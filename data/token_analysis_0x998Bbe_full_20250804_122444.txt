Token Analysis Report
==================================================
Token: Onion (0x998BbeaAd654824D74CC34eCd47ab6d015C42Fd0)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function setmintokensbeforeswap(uint256 amount) external onlyowner {
        mintokensbeforeswap = amount;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
      address token,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function reflectionfromtoken(uint256 tokenamount, bool deducttransferfee)
        public

  Code Snippet:
    function excludeaccount(address account) external onlyowner() {
        require(
            account != address(uniswapv2router),
            "erc20: we can not exclude uniswap router."
        );
        require(!_isexcluded[account], "erc20: account is already excluded");
        if (_reflectionbalance[account] > 0) {
            _tokenbalance[account] = tokenfromreflection(
                _reflectionbalance[account]
            );
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function collectfee(address account, uint256 amount, uint256 rate) private returns (uint256) {
        uint256 transferamount = amount;
        
        //@dev tax fee
        if(_taxfee != 0){
            uint256 taxfee = amount.mul(_taxfee).div(10**(_feedecimal + 2));
            transferamount = transferamount.sub(taxfee);
            _reflectiontotal = _reflectiontotal.sub(taxfee.mul(rate));
            _taxfeetotal = _taxfeetotal.add(taxfee);
        }

        //@dev liquidity fee
        if(_liquidityfee != 0){
            uint256 liquidityfee = amount.mul(_liquidityfee).div(10**(_feedecimal + 2));
            transferamount = transferamount.sub(liquidityfee);
            _reflectionbalance[address(this)] = _reflectionbalance[address(this)].add(liquidityfee.mul(rate));
            if(_isexcluded[address(this)]){
                _tokenbalance[address(this)] = _tokenbalance[address(this)].add(liquidityfee);
            }
            _liquidityfeetotal = _liquidityfeetotal.add(liquidityfee);
            emit transfer(account,address(this),liquidityfee);
        }
      
        //@dev burn fee
        if(_burnfee != 0){
            uint256 burnfee = amount.mul(_burnfee).div(10**(_feedecimal + 2));
            transferamount = transferamount.sub(burnfee);
            _tokentotal = _tokentotal.sub(burnfee);
            _reflectiontotal = _reflectiontotal.sub(burnfee.mul(rate));
            _burnfeetotal = _burnfeetotal.add(burnfee);
            emit transfer(account,address(0),burnfee);
        }
        
        return transferamount;
    }

  Code Snippet:
     function swapandliquify(uint256 contracttokenbalance) private locktheswap {
         if(contracttokenbalance > maxtxamount){
             contracttokenbalance = maxtxamount;
         }
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function setpair(address pair) external onlyowner {
        uniswapv2pair = pair;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool enabled) external onlyowner {
        swapandliquifyenabled = enabled;
        swapandliquifyenabledupdated(enabled);
    }

  Code Snippet:
    function setfeeactive(bool value) external onlyowner {
        isfeeactive = value;
    }

  Code Snippet:
    function settaxfee(uint256 fee) external onlyowner {
        _taxfee = fee;
    }

  Code Snippet:
    function setburnfee(uint256 fee) external onlyowner {
        _burnfee = fee;
    }

  Code Snippet:
    function setliquidityfee(uint256 fee) external onlyowner {
        _liquidityfee = fee;
    }

  Code Snippet:
    function setmintokensbeforeswap(uint256 amount) external onlyowner {
        mintokensbeforeswap = amount;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x0418295fdc842ecd78dece392330087366149684 — 23,136,460,101,817,439,617,024 tokens (37.27% of circulating supply)
  2. 0xf3279512f55c53c6c04b2c5d4bf2c05dedf7140c — 1,427,359,314,905,939,050,496 tokens (2.30% of circulating supply)
  3. 0x44409c851e7694c65ffd45423f80dc297fa32414 — 1,205,601,169,760,214,319,104 tokens (1.94% of circulating supply)
  4. 0x2035bdeb62a901b99373776f44b0bd4223250b2f — 668,742,420,653,080,969,216 tokens (1.08% of circulating supply)
  5. 0xf2ed6e5ceeb62f5bc3548df23c72a86268ddb653 — 302,306,800,104,251,129,856 tokens (0.49% of circulating supply)
  6. 0xfc99997ed7a40a08884bca6c1bbfcf9f5d0e85a0 — 143,291,578,961,428,332,544 tokens (0.23% of circulating supply)
  7. 0x1d531a7748d2bf228635e999807f95a69390f5e1 — 135,415,925,108,892,090,368 tokens (0.22% of circulating supply)
  8. 0x3711887c674370089744e52df72fedccad67114d — 126,822,791,747,269,541,888 tokens (0.20% of circulating supply)
  9. 0x5cf71dfd2ed51748d28ff20fa99b8b83eea6abf7 — 122,628,670,796,070,993,920 tokens (0.20% of circulating supply)
  10. 0x033101a64edfc96addf19de410a5d0c35ecf56e5 — 100,019,343,793,372,463,104 tokens (0.16% of circulating supply)

Top 10 Total Balance: 27,368,648,117,647,958,507,520 tokens
Top 10 Share of Circulating Supply: 44.09%
Top 10 Share of Total Supply: 29.47%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $46,646,058,885,824,400.00
Liquidity: $0.03
Liquidity/MCap Ratio: 0.0000
Token Volume: 4835898153.4340
USD Volume: 3634.0540
24h Volume/Liquidity Ratio: 104454.1724
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 530.2172442626214
LP holders count: 3

Liquidity holders for 0x998BbeaAd654824D74CC34eCd47ab6d015C42Fd0, (Onion)

0x998bbeaad654824d74cc34ecd47ab6d015c42fd0 holds 530.2148458578936 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.002398404727824777 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1544.84 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-12T16:10:57
Last Active: 2025-07-19T06:24:00
Days Since Last Activity: 16.25051028267361 days
Last Transaction Hash: 0x0e4b22dc70f9a31e5e7b7ac353bc4b5086ca01ad7ecd9c03233a12f8f923a5da
