Token Analysis Report
==================================================
Token: Dough (0xEDE5020492Be8E265dB6141CB0a1D2dF9dBAE9BB)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function mint(address to) external returns (uint256 liquidity);


  Code Snippet:
    function _mint (address account, uint256 amount) internal virtual {
        require (account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer (address(0), account, amount);

        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer (address(0), account, amount);
    }

  Code Snippet:
    function getrewardtoken() public view returns (address) {
        return rewardtoken;
    }

  Code Snippet:
    function _withdrawdividendofuser (address user) internal returns (uint256) {
        uint256 _withdrawabledividend = withdrawabledividendof (user);
        
        if (_withdrawabledividend > 0) {
            withdrawndividends[user] += _withdrawabledividend;
            emit dividendwithdrawn (user, _withdrawabledividend);
            bool success = ierc20(rewardtoken).transfer (user, _withdrawabledividend);
        
            if (!success) {
                withdrawndividends[user] -= _withdrawabledividend;
                return 0;
            }
            
            return _withdrawabledividend;
        }

        return 0;
    }

  Code Snippet:
    function _mint (address account, uint256 value) internal override {
        super._mint (account, value);

        magnifieddividendcorrections[account] -= (magnifieddividendpershare * value).toint256safe();
    }

  Code Snippet:
    function _setbalance (address account, uint256 newbalance) internal {
        uint256 currentbalance = balanceof (account);

        if (newbalance > currentbalance) {
            uint256 mintamount = newbalance - currentbalance;
            _mint (account, mintamount);
        } else if (newbalance < currentbalance) {
            uint256 burnamount = currentbalance - newbalance;
            _burn (account, burnamount);
        }
    }

  Code Snippet:
    function setbuyfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalbuyfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalbuyfees += _rewardsfee[i];
        
        totalbuyfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalbuyfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("buy", dividendmanager.getfees(buy), _rewardsfee, liquidityfee[buy], _liquidityfee, marketingfee[buy], _marketingfee, burnfee[buy], _burnfee);
        
        liquidityfee[buy] = _liquidityfee;
        marketingfee[buy] = _marketingfee;
        burnfee[buy] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, buy);
    }

  Code Snippet:
    function setsellfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalsellfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalsellfees += _rewardsfee[i];
        
        totalsellfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalsellfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("sell", dividendmanager.getfees(sell), _rewardsfee, liquidityfee[sell], _liquidityfee, marketingfee[sell], _marketingfee, burnfee[sell], _burnfee);
        
        liquidityfee[sell] = _liquidityfee;
        marketingfee[sell] = _marketingfee;
        burnfee[sell] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, sell);
    }

  Code Snippet:
    function updateclaimwaits (uint256[] memory claimwait) external onlyowner {
        dividendmanager.updateclaimwaits (claimwait);
    }

  Code Snippet:
    function getclaimwaits() external view returns (uint256[] memory) {
        return dividendmanager.claimwaits();
    }

  Code Snippet:
    function processdividendtrackers (uint256 gas) external {
        (uint256[] memory iterations, uint256[] memory claims, uint256[] memory lastprocessedindex) = dividendmanager.process (gas);
        
        for (uint256 i = 0; i < iterations.length; i++)
            emit processeddividendtracker(iterations[i], claims[i], lastprocessedindex[i], false, (gas / iterations.length), tx.origin);
    }

  Code Snippet:
    function claim (address account) external onlyowner {
        dividendmanager.processaccount (account);
    }

  Code Snippet:
    function getrewardtokenpercentages (uint8 feetype) public view returns (uint256 doughfeepercentage, uint256 cakefeepercentage) {
        uint8 cakefee = dividendmanager.getfee (feetype, cake); 
        uint8 doughfee = dividendmanager.getfee (feetype, address(this));
        uint256 sumsells = transactionbuffer.sumperkey[sell];
        uint256 sumbuys = transactionbuffer.sumperkey[buy];
        
        // dough fee in percent  = sum sells * original dough fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase dough fee on sells, decrease on buys
        doughfeepercentage = sumsells * doughfee * dividendmanager.getsummedfees (feetype) / (sumsells * doughfee + sumbuys * cakefee);
            
        // cake fee in percent = sum buys * original cake fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase cake fee on buys, decrease on sells
        cakefeepercentage = dividendmanager.getsummedfees (feetype) - doughfeepercentage;
    }

  Code Snippet:
    function gettransferamounts (uint256 amount, uint8 feetype) private returns (uint256, uint256, uint256) {
        uint256 _marketingtokens = amount * marketingfee[feetype] / 100;
        uint256 _liquiditytokens = amount * liquidityfee[feetype] / 100;
        uint256 _burntokens = amount * burnfee[feetype] / 100;
        (uint256 doughfeepercentage, uint256 cakefeepercentage) = getrewardtokenpercentages (feetype);
        uint256 doughtokens = amount * doughfeepercentage / 100;
        uint256 caketokens = amount * cakefeepercentage / 100;
            
        // keep track of balances so we can split the address balance
        dividendmanager.incrementfeetokens (doughtokens, address(this));
        dividendmanager.incrementfeetokens (caketokens, cake);
        marketingtokens += _marketingtokens;
        liquiditytokens += _liquiditytokens;
        uint256 fees = _marketingtokens + _liquiditytokens + doughtokens + caketokens;
        return (amount - fees - _burntokens, fees, _burntokens);
    }

  Code Snippet:
    function _transfer (address from, address to, uint256 amount) internal override {
        require (from != address(0), "erc20: transfer from the zero address");
        require (to != address(0), "erc20: transfer to the zero address");
        require (!isblacklisted[from] && !isblacklisted[to], "blacklisted address");
        
        // need to allow owner to add liquidity, otherwise prevent any snipers from buying for the first few blocks
        if (from != owner() && to != owner() && (block.timestamp <= antibotendtime || antibotendtime == 0)) {
            require (to == canstopantibotmeasures, "dough: bots can't stop antibot measures");
            
            if (antibotendtime == 0)
                antibotendtime = block.timestamp + 4;
        }

        if (amount == 0) {
            super._transfer (from, to, 0);
            return;
        } else if (from == doughdt) { // don't get caught in circular payout events
            super._transfer (from, to, amount);
            return;
        }
        
        // check max wallet
        if (from != owner() && !isexcludedfromfees[to] && to != uniswapv2pair)
            require (balanceof(to) + amount <= maxwalletamount, "dough: receiver's wallet balance exceeds the max wallet amount");
        
        uint8 feetype = sell;
        
        if (automatedmarketmakerpairs[to] && from != owner()) {
            if (from != address(this))
                transactionbuffer.append (amount, sell);
            
            if (!isexcludedfromfees[from])
                dividendmanager.excludefromdividendsuntiltimeout (from); // miss one payout as you sold
        } else if (automatedmarketmakerpairs[from]) {
            feetype = buy;
            transactionbuffer.append (amount, buy);
        }

        if (balanceof (address(this)) >= swaptokensatamount && !swapping && !automatedmarketmakerpairs[from] && !isexcludedfromfees[from] && to != owner()) {
            swapping = true;
            selltokensforbnbandtakefees(swaptokensatamount);
            swapping = false;
        }

        bool takefee = !swapping;

        // if any account belongs to _isexcludedfromfee account then remove the fee
        if (isexcludedfromfees[from] || isexcludedfromfees[to])
            takefee = false;

        if (takefee) {
            (uint256 transferamount, uint256 tokensforfees, uint256 tokenstoburn) = gettransferamounts (amount, feetype);
            amount = transferamount;
            
            if (tokensforfees > 0)
                super._transfer (from, address(this), tokensforfees);
            
            if (tokenstoburn > 0)
                super._transfer (from, burn_address, tokenstoburn);
        }

        super._transfer (from, to, amount);

        try dividendmanager.setbalance (from, balanceof(from)) {} catch {}
        try dividendmanager.setbalance (to, balanceof(to)) {} catch {}

        if (!swapping) {
            uint256 gas = gasforprocessing;

            try dividendmanager.process(gas) returns (uint256[] memory iterations, uint256[] memory claims, uint256[] memory lastprocessedindex) {
                for (uint256 i = 0; i < iterations.length; i++)
                    emit processeddividendtracker(iterations[i], claims[i], lastprocessedindex[i], true, (gas / iterations.length), tx.origin);
            } catch {}
        }
    }

  Code Snippet:
    function selltokensforbnbandtakefees (uint256 swapamount) private {
        (uint256 bnbformarketingandrewards, uint256 contracttokenbalance, uint256 scaledrewardtokens, uint256 scaledmarketingtokens) = swapliquifyandselltobnb (swapamount);
        // split returned bnb into marketing and dividend amounts
        uint256 bnbforcake = bnbformarketingandrewards * scaledrewardtokens / (scaledmarketingtokens + scaledrewardtokens);
        // swap bnb to cake and send dividends to cake dividend tracker and distribute
        swapandsenddividends (bnbforcake, scaledrewardtokens);
        // send bnb to marketing wallet
        uint256 bnbformarketing = address(this).balance;
        marketingwalletaddress.sendvalue (bnbformarketing);
        // send native dividends to dough dividend tracker and distribute
        uint256 doughdividends = dividendmanager.getfeetokensfromrewardaddress (address(this)) * swapamount / contracttokenbalance;
        super._transfer (address(this), dividendmanager.gettrackeraddress (address(this)), doughdividends);
        
        try dividendmanager.distributedividends (doughdividends, address(this)) {
            emit senddividends (address(this), doughdividends, doughdividends);
            // make sure we zero the count of tokens set aside for dough dividends
            dividendmanager.decrementfeetokens (doughdividends, address(this));
        } catch {
            // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
        } 
    }

  Code Snippet:
    function swapliquifyandselltobnb (uint256 swapamount) private returns (uint256, uint256, uint256, uint256) {
        uint256 bnbforfees;
        uint256 contracttokenbalance = balanceof (address(this));
        uint256 scaledliquiditytokens = liquiditytokens * swapamount / contracttokenbalance;
        uint256 scaledmarketingtokens = marketingtokens * swapamount / contracttokenbalance;
        uint256 scaledrewardtokens = dividendmanager.getfeetokensfromrewardaddress (cake) * swapamount / contracttokenbalance;
        // split tokens for lp into halves
        uint256 half = scaledliquiditytokens / 2;
        uint256 otherhalf = scaledliquiditytokens - half;
        // swap half lp tokens + marketing + cake reward tokens at once to avoid multiple contract sells
        uint256 tokenstoswap = half + scaledmarketingtokens + scaledrewardtokens;
        bnbforfees = swaptokensforbnb (tokenstoswap);

        if (bnbforfees > 0) {
            liquiditytokens -= scaledliquiditytokens;
            marketingtokens -= scaledmarketingtokens;
            uint256 bnbtoliquidity;
            // send all bnb to addliquidity as additional will be returned
            (bnbforfees, bnbtoliquidity) = addliquidity (otherhalf, bnbforfees);
            emit swapandliquify (half, bnbtoliquidity, otherhalf);
        }
        
        return (bnbforfees, contracttokenbalance, scaledrewardtokens, scaledmarketingtokens);
    }

  Code Snippet:
    function swapandsenddividends (uint256 bnbfordividend, uint256 tokensswapped) private {
        swapbnbforcake (bnbfordividend);
        uint256 dividends = ierc20(cake).balanceof (address(this));
        
        if (dividends > 0) {
            bool success = ierc20(cake).transfer (dividendmanager.gettrackeraddress (cake), dividends);
        
            if (success) {
                try dividendmanager.distributedividends (dividends, cake) {
                    emit senddividends (cake, dividendmanager.getfeetokensfromrewardaddress (cake), dividends);
                } catch {
                    // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
                }
            }
            
            dividendmanager.decrementfeetokens (tokensswapped, cake); // even if we don't distribute dividends to the tracker, we need to decrement the tokens as they've been converted to cake
        }
    }

  Code Snippet:
    function adddividendtracker (string memory name, string memory ticker, address rewardtoken, uint256 claimwait, uint256 minbalancefordividends, uint8 buyfeetotake, uint8 sellfeetotake) 
        external 

  Code Snippet:
    function incrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] += tokens;
    }

  Code Snippet:
    function decrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] -= tokens;
    }

  Code Snippet:
    function resetfeetokens (address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] = 0;
    }

  Code Snippet:
    function updateclaimwaits (uint256[] memory newclaimwaits) external onlyowner {
        require (newclaimwaits.length == dtarray.length, "dividendmanager: must provide newclaimwwait for each tracker (array wrong length)");
        
        for (uint256 i = 0; i < dtarray.length; i++)
            dtarray[i].updateclaimwait (newclaimwaits[i]);
    }

  Code Snippet:
    function distributedividends (uint256 amount, address rewardtoken) external onlyowner {
        dtarray[getidfromrewardaddress (rewardtoken)].distributedividends (amount);
    }

  Code Snippet:
    function process (uint256 gas) external onlyowner returns (uint256[] memory, uint256[] memory, uint256[] memory) {
        uint256 gaspertracker = gas / dtarray.length; //split the available gas between the trackers
        uint256[] memory iterations = new uint256[](dtarray.length);
        uint256[] memory claims = new uint256[](dtarray.length);
        uint256[] memory lastprocessedindex = new uint256[](dtarray.length);
        
        for (uint256 i = 0; i < dtarray.length; i++) {
            (uint256 _iterations, uint256 _claims, uint256 _lastprocessedindex) = dtarray[i].process (gaspertracker);
            iterations[i] = _iterations;
            claims[i] = _claims;
            lastprocessedindex[i] = _lastprocessedindex;
        }
        
        return (iterations, claims, lastprocessedindex);
    }

  Code Snippet:
    function getidfromrewardaddress (address reward) public view returns (uint256) {
        for (uint256 i = 0; i < dtarray.length; i++) {
            if (reward == dtarray[i].getrewardtoken())
                return i;
        }
        
        revert ("dividendmanager: reward address not found in dividendtracker rewards");
    }

  Code Snippet:
    function getfeetokensfromrewardaddress (address reward) public view returns (uint256) {
        return trackerfeetokenstoswap[getidfromrewardaddress (reward)];
    }

  Code Snippet:
    function getrewardtoken (uint256 dividendtrackerid) public view returns (address) {
        return dtarray[dividendtrackerid].getrewardtoken();
    }

  Code Snippet:
    function gettrackeraddress (address rewardtoken) public view returns (address) {
        return address(dtarray[getidfromrewardaddress (rewardtoken)]);
    }

  Code Snippet:
    function getfee (uint8 feetype, address rewardtoken) public view returns (uint8) {
        return dtarray[getidfromrewardaddress (rewardtoken)].fee(feetype);
    }

  Code Snippet:
    function claimwaits() public view returns (uint256[] memory) {
        uint256[] memory claimwait = new uint256[](dtarray.length);
        
        for (uint256 i = 0; i < dtarray.length; i++)
            claimwait[i] = dtarray[i].claimwait();
        
        return claimwait;
    }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "dividendtracker: withdrawdividend disabled. use the 'claim' function on the main contract.");
    }

  Code Snippet:
    function excludefromdividendsuntiltimeout (address account) external onlyowner {
        excludedfromdividends[account] = true;
        excludedtimeout[account] = block.timestamp + claimwait;
        excludedbalance[account] = balanceof (account);
        _setbalance(account, 0); //set balance to zero but don't remove from map so it still gets processed
        emit excludefromdividends(account);
    }

  Code Snippet:
    function updateclaimwait(uint256 newclaimwait) external onlyowner {
        require(newclaimwait >= 900 && newclaimwait <= 86400, "dividendtracker: claimwait must be updated to between 15 mins and 24 hours");
        require(newclaimwait != claimwait, "dividendtracker: cannot update claimwait to same value");
        emit claimwaitupdated(newclaimwait, claimwait);
        claimwait = newclaimwait;
    }

  Code Snippet:
    function canautoclaim (uint256 lastclaimtime) private view returns (bool) {
        if (lastclaimtime > block.timestamp)
            return false;

        return block.timestamp - lastclaimtime >= claimwait;
    }

  Code Snippet:
    function setbalance (address account, uint256 newbalance) public onlyowner {
        if (excludedfromdividends[account]) {
            if (excludedtimeout[account] > 0 && excludedtimeout[account] < block.timestamp) { // were temporarily excluded, now can be included again
                excludedfromdividends[account] = false; // don't need to update balance as function will set new balance below
            } else if (excludedtimeout[account] > block.timestamp) { // are still temporarily excluded
                if (newbalance >= minimumtokenbalancefordividends) // update excluded balance if they still qualify for rewards else remove them
                    excludedbalance[account] = newbalance;
                else
                    tokenholdersmap.remove (account);
                
                return;
            } else { // permanently excluded
                return;
            }
        }

        if (newbalance >= minimumtokenbalancefordividends) {
            _setbalance (account, newbalance);
            tokenholdersmap.set (account, newbalance);
        } else {
            _setbalance (account, 0);
            tokenholdersmap.remove (account);
        }

        processaccount (account, true);
    }

  Code Snippet:
    function process (uint256 gas) public returns (uint256, uint256, uint256) {
        uint256 numberoftokenholders = tokenholdersmap.keys.length;

        if (numberoftokenholders == 0)
            return (0, 0, lastprocessedindex);

        uint256 _lastprocessedindex = lastprocessedindex;
        uint256 gasused = 0;
        uint256 gasleft = gasleft();
        uint256 iterations = 0;
        uint256 claims = 0;

        while (gasused < gas && iterations < numberoftokenholders) {
            _lastprocessedindex++;

            if (_lastprocessedindex >= tokenholdersmap.keys.length)
                _lastprocessedindex = 0;

            address account = tokenholdersmap.keys[_lastprocessedindex];
            
            if (excludedfromdividends[account] && excludedtimeout[account] < block.timestamp) { // was temporarily excluded but can now be included again
                excludedfromdividends[account] = false;
                excludedtimeout[account] = 0;
                // we can validly assume the balance is > minimumtokenbalancefordividends as any changes in balance since exclusion will have been checked, and the balance was valid when excluded
                // this assumption would need to be checked if the value of minimumtokenbalancefordividends could be changed after creation
                _setbalance(account, excludedbalance[account]); 
            }

            if (canautoclaim (lastclaimtimes[account])) {
                if (processaccount (account, true)) {
                    claims++;
                }
            }

            iterations++;
            uint256 newgasleft = gasleft();

            if (gasleft > newgasleft)
                gasused += (gasleft - newgasleft);

            gasleft = newgasleft;
        }

        lastprocessedindex = _lastprocessedindex;
        return (iterations, claims, lastprocessedindex);
    }

  Code Snippet:
    function processaccount (address account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser (account);

        if (amount > 0) {
            lastclaimtimes[account] = block.timestamp;
            emit claim (account, amount, automatic);
            return true;
        }

        return false;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function getrewardtoken() public view returns (address) {
        return rewardtoken;
    }

  Code Snippet:
    function _withdrawdividendofuser (address user) internal returns (uint256) {
        uint256 _withdrawabledividend = withdrawabledividendof (user);
        
        if (_withdrawabledividend > 0) {
            withdrawndividends[user] += _withdrawabledividend;
            emit dividendwithdrawn (user, _withdrawabledividend);
            bool success = ierc20(rewardtoken).transfer (user, _withdrawabledividend);
        
            if (!success) {
                withdrawndividends[user] -= _withdrawabledividend;
                return 0;
            }
            
            return _withdrawabledividend;
        }

        return 0;
    }

  Code Snippet:
    function setbuyfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalbuyfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalbuyfees += _rewardsfee[i];
        
        totalbuyfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalbuyfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("buy", dividendmanager.getfees(buy), _rewardsfee, liquidityfee[buy], _liquidityfee, marketingfee[buy], _marketingfee, burnfee[buy], _burnfee);
        
        liquidityfee[buy] = _liquidityfee;
        marketingfee[buy] = _marketingfee;
        burnfee[buy] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, buy);
    }

  Code Snippet:
    function setsellfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalsellfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalsellfees += _rewardsfee[i];
        
        totalsellfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalsellfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("sell", dividendmanager.getfees(sell), _rewardsfee, liquidityfee[sell], _liquidityfee, marketingfee[sell], _marketingfee, burnfee[sell], _burnfee);
        
        liquidityfee[sell] = _liquidityfee;
        marketingfee[sell] = _marketingfee;
        burnfee[sell] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, sell);
    }

  Code Snippet:
    function getrewardtokenpercentages (uint8 feetype) public view returns (uint256 doughfeepercentage, uint256 cakefeepercentage) {
        uint8 cakefee = dividendmanager.getfee (feetype, cake); 
        uint8 doughfee = dividendmanager.getfee (feetype, address(this));
        uint256 sumsells = transactionbuffer.sumperkey[sell];
        uint256 sumbuys = transactionbuffer.sumperkey[buy];
        
        // dough fee in percent  = sum sells * original dough fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase dough fee on sells, decrease on buys
        doughfeepercentage = sumsells * doughfee * dividendmanager.getsummedfees (feetype) / (sumsells * doughfee + sumbuys * cakefee);
            
        // cake fee in percent = sum buys * original cake fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase cake fee on buys, decrease on sells
        cakefeepercentage = dividendmanager.getsummedfees (feetype) - doughfeepercentage;
    }

  Code Snippet:
    function gettransferamounts (uint256 amount, uint8 feetype) private returns (uint256, uint256, uint256) {
        uint256 _marketingtokens = amount * marketingfee[feetype] / 100;
        uint256 _liquiditytokens = amount * liquidityfee[feetype] / 100;
        uint256 _burntokens = amount * burnfee[feetype] / 100;
        (uint256 doughfeepercentage, uint256 cakefeepercentage) = getrewardtokenpercentages (feetype);
        uint256 doughtokens = amount * doughfeepercentage / 100;
        uint256 caketokens = amount * cakefeepercentage / 100;
            
        // keep track of balances so we can split the address balance
        dividendmanager.incrementfeetokens (doughtokens, address(this));
        dividendmanager.incrementfeetokens (caketokens, cake);
        marketingtokens += _marketingtokens;
        liquiditytokens += _liquiditytokens;
        uint256 fees = _marketingtokens + _liquiditytokens + doughtokens + caketokens;
        return (amount - fees - _burntokens, fees, _burntokens);
    }

  Code Snippet:
    function selltokensforbnbandtakefees (uint256 swapamount) private {
        (uint256 bnbformarketingandrewards, uint256 contracttokenbalance, uint256 scaledrewardtokens, uint256 scaledmarketingtokens) = swapliquifyandselltobnb (swapamount);
        // split returned bnb into marketing and dividend amounts
        uint256 bnbforcake = bnbformarketingandrewards * scaledrewardtokens / (scaledmarketingtokens + scaledrewardtokens);
        // swap bnb to cake and send dividends to cake dividend tracker and distribute
        swapandsenddividends (bnbforcake, scaledrewardtokens);
        // send bnb to marketing wallet
        uint256 bnbformarketing = address(this).balance;
        marketingwalletaddress.sendvalue (bnbformarketing);
        // send native dividends to dough dividend tracker and distribute
        uint256 doughdividends = dividendmanager.getfeetokensfromrewardaddress (address(this)) * swapamount / contracttokenbalance;
        super._transfer (address(this), dividendmanager.gettrackeraddress (address(this)), doughdividends);
        
        try dividendmanager.distributedividends (doughdividends, address(this)) {
            emit senddividends (address(this), doughdividends, doughdividends);
            // make sure we zero the count of tokens set aside for dough dividends
            dividendmanager.decrementfeetokens (doughdividends, address(this));
        } catch {
            // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
        } 
    }

  Code Snippet:
    function swapliquifyandselltobnb (uint256 swapamount) private returns (uint256, uint256, uint256, uint256) {
        uint256 bnbforfees;
        uint256 contracttokenbalance = balanceof (address(this));
        uint256 scaledliquiditytokens = liquiditytokens * swapamount / contracttokenbalance;
        uint256 scaledmarketingtokens = marketingtokens * swapamount / contracttokenbalance;
        uint256 scaledrewardtokens = dividendmanager.getfeetokensfromrewardaddress (cake) * swapamount / contracttokenbalance;
        // split tokens for lp into halves
        uint256 half = scaledliquiditytokens / 2;
        uint256 otherhalf = scaledliquiditytokens - half;
        // swap half lp tokens + marketing + cake reward tokens at once to avoid multiple contract sells
        uint256 tokenstoswap = half + scaledmarketingtokens + scaledrewardtokens;
        bnbforfees = swaptokensforbnb (tokenstoswap);

        if (bnbforfees > 0) {
            liquiditytokens -= scaledliquiditytokens;
            marketingtokens -= scaledmarketingtokens;
            uint256 bnbtoliquidity;
            // send all bnb to addliquidity as additional will be returned
            (bnbforfees, bnbtoliquidity) = addliquidity (otherhalf, bnbforfees);
            emit swapandliquify (half, bnbtoliquidity, otherhalf);
        }
        
        return (bnbforfees, contracttokenbalance, scaledrewardtokens, scaledmarketingtokens);
    }

  Code Snippet:
    function swapandsenddividends (uint256 bnbfordividend, uint256 tokensswapped) private {
        swapbnbforcake (bnbfordividend);
        uint256 dividends = ierc20(cake).balanceof (address(this));
        
        if (dividends > 0) {
            bool success = ierc20(cake).transfer (dividendmanager.gettrackeraddress (cake), dividends);
        
            if (success) {
                try dividendmanager.distributedividends (dividends, cake) {
                    emit senddividends (cake, dividendmanager.getfeetokensfromrewardaddress (cake), dividends);
                } catch {
                    // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
                }
            }
            
            dividendmanager.decrementfeetokens (tokensswapped, cake); // even if we don't distribute dividends to the tracker, we need to decrement the tokens as they've been converted to cake
        }
    }

  Code Snippet:
    function adddividendtracker (string memory name, string memory ticker, address rewardtoken, uint256 claimwait, uint256 minbalancefordividends, uint8 buyfeetotake, uint8 sellfeetotake) 
        external 

  Code Snippet:
    function incrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] += tokens;
    }

  Code Snippet:
    function decrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] -= tokens;
    }

  Code Snippet:
    function resetfeetokens (address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] = 0;
    }

  Code Snippet:
    function distributedividends (uint256 amount, address rewardtoken) external onlyowner {
        dtarray[getidfromrewardaddress (rewardtoken)].distributedividends (amount);
    }

  Code Snippet:
    function getidfromrewardaddress (address reward) public view returns (uint256) {
        for (uint256 i = 0; i < dtarray.length; i++) {
            if (reward == dtarray[i].getrewardtoken())
                return i;
        }
        
        revert ("dividendmanager: reward address not found in dividendtracker rewards");
    }

  Code Snippet:
    function getfeetokensfromrewardaddress (address reward) public view returns (uint256) {
        return trackerfeetokenstoswap[getidfromrewardaddress (reward)];
    }

  Code Snippet:
    function getrewardtoken (uint256 dividendtrackerid) public view returns (address) {
        return dtarray[dividendtrackerid].getrewardtoken();
    }

  Code Snippet:
    function gettrackeraddress (address rewardtoken) public view returns (address) {
        return address(dtarray[getidfromrewardaddress (rewardtoken)]);
    }

  Code Snippet:
    function getfee (uint8 feetype, address rewardtoken) public view returns (uint8) {
        return dtarray[getidfromrewardaddress (rewardtoken)].fee(feetype);
    }

  Code Snippet:
    function setbalance (address account, uint256 newbalance) public onlyowner {
        if (excludedfromdividends[account]) {
            if (excludedtimeout[account] > 0 && excludedtimeout[account] < block.timestamp) { // were temporarily excluded, now can be included again
                excludedfromdividends[account] = false; // don't need to update balance as function will set new balance below
            } else if (excludedtimeout[account] > block.timestamp) { // are still temporarily excluded
                if (newbalance >= minimumtokenbalancefordividends) // update excluded balance if they still qualify for rewards else remove them
                    excludedbalance[account] = newbalance;
                else
                    tokenholdersmap.remove (account);
                
                return;
            } else { // permanently excluded
                return;
            }
        }

        if (newbalance >= minimumtokenbalancefordividends) {
            _setbalance (account, newbalance);
            tokenholdersmap.set (account, newbalance);
        } else {
            _setbalance (account, 0);
            tokenholdersmap.remove (account);
        }

        processaccount (account, true);
    }

WARNING: High Tax Detected
  Code Snippet:
    function withdrawabledividendof(address _owner)
        external

  Code Snippet:
    function withdrawndividendof(address _owner)
        external

  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swap(
        uint256 amount0out,

  Code Snippet:
    function withdrawdividend() external;


  Code Snippet:
    function withdrawdividend() public virtual override {
        _withdrawdividendofuser (msg.sender);
    }

  Code Snippet:
    function _withdrawdividendofuser (address user) internal returns (uint256) {
        uint256 _withdrawabledividend = withdrawabledividendof (user);
        
        if (_withdrawabledividend > 0) {
            withdrawndividends[user] += _withdrawabledividend;
            emit dividendwithdrawn (user, _withdrawabledividend);
            bool success = ierc20(rewardtoken).transfer (user, _withdrawabledividend);
        
            if (!success) {
                withdrawndividends[user] -= _withdrawabledividend;
                return 0;
            }
            
            return _withdrawabledividend;
        }

        return 0;
    }

  Code Snippet:
    function dividendof (address _owner) public view override returns (uint256) {
        return withdrawabledividendof (_owner);
    }

  Code Snippet:
    function withdrawabledividendof (address _owner) public view override returns (uint256) {
        return (accumulativedividendof(_owner) - withdrawndividends[_owner]);
    }

  Code Snippet:
    function withdrawndividendof (address _owner) public view override returns (uint256) {
        return withdrawndividends[_owner];
    }

  Code Snippet:
    function safeapprove(ierc20 token, address spender, uint256 value) internal {
        // safeapprove should only be called when setting an initial allowance,
        // or when resetting it to zero. to increase and decrease it, use
        // 'safeincreaseallowance' and 'safedecreaseallowance'
        // solhint-disable-next-line max-line-length
        require ((value == 0) || (token.allowance (address(this), spender) == 0), "safeerc20: approve from non-zero to non-zero allowance");
        _calloptionalreturn (token, abi.encodewithselector (token.approve.selector, spender, value));
    }

  Code Snippet:
    function _calloptionalreturn(ierc20 token, bytes memory data) private {
        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since
        // we're implementing it ourselves. we use {address.functioncall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functioncall (data, "safeerc20: low-level call failed");
        
        if (returndata.length > 0) {
            // return data is optional
            // solhint-disable-next-line max-line-length
            require (abi.decode (returndata, (bool)), "safeerc20: erc20 operation did not succeed");
        }
    }

  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function updatedividendmanager (address newaddress) external onlyowner {
        require (newaddress != address(dividendmanager), "dough: the dividend manager already exists");
        dividendmanager newdividendmanager = dividendmanager(newaddress);
        
        require (newdividendmanager.owner() == address(this), "dough: the new dividend manager must be owned by the token contract");
        newdividendmanager.excludefromalldividends (address(newdividendmanager));
        newdividendmanager.excludefromalldividends (address(this));
        newdividendmanager.excludefromalldividends (address(uniswapv2router));
        newdividendmanager.excludefromalldividends(burn_address);
        newdividendmanager.excludefromalldividends(doughdt);
        emit updatedividendmanager (newaddress, address(dividendmanager));
        dividendmanager = newdividendmanager;
    }

  Code Snippet:
    function updateuniswapv2router (address newaddress) external onlyowner {
        require(newaddress != address(uniswapv2router), "dough: the router already has that address");
        emit updateuniswapv2router (newaddress, address(uniswapv2router));
        uniswapv2router = iuniswapv2router02 (newaddress);
        address _uniswapv2pair = iuniswapv2factory (uniswapv2router.factory()).createpair (address(this), uniswapv2router.weth());
        uniswapv2pair = _uniswapv2pair;
    }

  Code Snippet:
    function excludefromfees (address account, bool excluded) external onlyowner {
        require (isexcludedfromfees[account] != excluded, "dough: account is already the value of 'excluded'");
        isexcludedfromfees[account] = excluded;
        emit excludefromfees (account, excluded);
    }

  Code Snippet:
    function excludemultipleaccountsfromfees (address[] memory accounts, bool excluded) external onlyowner {
        for (uint256 i = 0; i < accounts.length; i++)
            isexcludedfromfees[accounts[i]] = excluded;

        emit excludemultipleaccountsfromfees (accounts, excluded);
    }

  Code Snippet:
    function setbuyfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalbuyfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalbuyfees += _rewardsfee[i];
        
        totalbuyfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalbuyfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("buy", dividendmanager.getfees(buy), _rewardsfee, liquidityfee[buy], _liquidityfee, marketingfee[buy], _marketingfee, burnfee[buy], _burnfee);
        
        liquidityfee[buy] = _liquidityfee;
        marketingfee[buy] = _marketingfee;
        burnfee[buy] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, buy);
    }

  Code Snippet:
    function setsellfees (uint8[] memory _rewardsfee, uint8 _liquidityfee, uint8 _marketingfee, uint8 _burnfee) external onlyowner {
        require (_rewardsfee.length == dividendmanager.dividendtrackers(), "dough: must provide a fee per dividend tracker (array wrong length)");
        uint256 totalsellfees;
        
        for (uint256 i = 0; i < _rewardsfee.length; i++)
            totalsellfees += _rewardsfee[i];
        
        totalsellfees += _liquidityfee + _marketingfee + _burnfee;
        require (totalsellfees <= 35, "dough: fees can't be > 35%");
        emit feeschanged ("sell", dividendmanager.getfees(sell), _rewardsfee, liquidityfee[sell], _liquidityfee, marketingfee[sell], _marketingfee, burnfee[sell], _burnfee);
        
        liquidityfee[sell] = _liquidityfee;
        marketingfee[sell] = _marketingfee;
        burnfee[sell] = _burnfee;
        dividendmanager.updatefees (_rewardsfee, sell);
    }

  Code Snippet:
    function setautomatedmarketmakerpair (address pair, bool value) external onlyowner {
        require (pair != uniswapv2pair, "dough: the pancakeswap pair cannot be removed from automatedmarketmakerpairs");
        _setautomatedmarketmakerpair (pair, value);
    }

  Code Snippet:
    function blacklistaddress (address account, bool blacklist) external onlyowner {
        require (isblacklisted[account] != blacklist, "dough: the account is already set to that value");
        require (account != uniswapv2pair && blacklist, "dough: the pancakeswap pair cannot be blacklisted");
        isblacklisted[account] = blacklist;
    }

  Code Snippet:
    function setswapamount (uint256 _swaptokensatamount) external onlyowner {
        require (_swaptokensatamount >= totalsupply() / 1_000_000 && _swaptokensatamount <= totalsupply() / 100, "dough: swap amount must be between 0.00001% and 1% of total supply");
        emit swapamountchanged (swaptokensatamount, _swaptokensatamount);
        swaptokensatamount = _swaptokensatamount;
    }

  Code Snippet:
    function checkifexcludedfromfees (address account) external view returns (bool) {
        return isexcludedfromfees[account];
    }

  Code Snippet:
    function withdrawabledividendsof (address account) external view returns (uint256[] memory) {
        return dividendmanager.withdrawabledividendsof (account);
    }

  Code Snippet:
    function getrewardtokenpercentages (uint8 feetype) public view returns (uint256 doughfeepercentage, uint256 cakefeepercentage) {
        uint8 cakefee = dividendmanager.getfee (feetype, cake); 
        uint8 doughfee = dividendmanager.getfee (feetype, address(this));
        uint256 sumsells = transactionbuffer.sumperkey[sell];
        uint256 sumbuys = transactionbuffer.sumperkey[buy];
        
        // dough fee in percent  = sum sells * original dough fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase dough fee on sells, decrease on buys
        doughfeepercentage = sumsells * doughfee * dividendmanager.getsummedfees (feetype) / (sumsells * doughfee + sumbuys * cakefee);
            
        // cake fee in percent = sum buys * original cake fee * total dividend fees / (sum buys * original cake fee + sum sells * original dough fee)
        // increase cake fee on buys, decrease on sells
        cakefeepercentage = dividendmanager.getsummedfees (feetype) - doughfeepercentage;
    }

  Code Snippet:
    function gettransferamounts (uint256 amount, uint8 feetype) private returns (uint256, uint256, uint256) {
        uint256 _marketingtokens = amount * marketingfee[feetype] / 100;
        uint256 _liquiditytokens = amount * liquidityfee[feetype] / 100;
        uint256 _burntokens = amount * burnfee[feetype] / 100;
        (uint256 doughfeepercentage, uint256 cakefeepercentage) = getrewardtokenpercentages (feetype);
        uint256 doughtokens = amount * doughfeepercentage / 100;
        uint256 caketokens = amount * cakefeepercentage / 100;
            
        // keep track of balances so we can split the address balance
        dividendmanager.incrementfeetokens (doughtokens, address(this));
        dividendmanager.incrementfeetokens (caketokens, cake);
        marketingtokens += _marketingtokens;
        liquiditytokens += _liquiditytokens;
        uint256 fees = _marketingtokens + _liquiditytokens + doughtokens + caketokens;
        return (amount - fees - _burntokens, fees, _burntokens);
    }

  Code Snippet:
    function _transfer (address from, address to, uint256 amount) internal override {
        require (from != address(0), "erc20: transfer from the zero address");
        require (to != address(0), "erc20: transfer to the zero address");
        require (!isblacklisted[from] && !isblacklisted[to], "blacklisted address");
        
        // need to allow owner to add liquidity, otherwise prevent any snipers from buying for the first few blocks
        if (from != owner() && to != owner() && (block.timestamp <= antibotendtime || antibotendtime == 0)) {
            require (to == canstopantibotmeasures, "dough: bots can't stop antibot measures");
            
            if (antibotendtime == 0)
                antibotendtime = block.timestamp + 4;
        }

        if (amount == 0) {
            super._transfer (from, to, 0);
            return;
        } else if (from == doughdt) { // don't get caught in circular payout events
            super._transfer (from, to, amount);
            return;
        }
        
        // check max wallet
        if (from != owner() && !isexcludedfromfees[to] && to != uniswapv2pair)
            require (balanceof(to) + amount <= maxwalletamount, "dough: receiver's wallet balance exceeds the max wallet amount");
        
        uint8 feetype = sell;
        
        if (automatedmarketmakerpairs[to] && from != owner()) {
            if (from != address(this))
                transactionbuffer.append (amount, sell);
            
            if (!isexcludedfromfees[from])
                dividendmanager.excludefromdividendsuntiltimeout (from); // miss one payout as you sold
        } else if (automatedmarketmakerpairs[from]) {
            feetype = buy;
            transactionbuffer.append (amount, buy);
        }

        if (balanceof (address(this)) >= swaptokensatamount && !swapping && !automatedmarketmakerpairs[from] && !isexcludedfromfees[from] && to != owner()) {
            swapping = true;
            selltokensforbnbandtakefees(swaptokensatamount);
            swapping = false;
        }

        bool takefee = !swapping;

        // if any account belongs to _isexcludedfromfee account then remove the fee
        if (isexcludedfromfees[from] || isexcludedfromfees[to])
            takefee = false;

        if (takefee) {
            (uint256 transferamount, uint256 tokensforfees, uint256 tokenstoburn) = gettransferamounts (amount, feetype);
            amount = transferamount;
            
            if (tokensforfees > 0)
                super._transfer (from, address(this), tokensforfees);
            
            if (tokenstoburn > 0)
                super._transfer (from, burn_address, tokenstoburn);
        }

        super._transfer (from, to, amount);

        try dividendmanager.setbalance (from, balanceof(from)) {} catch {}
        try dividendmanager.setbalance (to, balanceof(to)) {} catch {}

        if (!swapping) {
            uint256 gas = gasforprocessing;

            try dividendmanager.process(gas) returns (uint256[] memory iterations, uint256[] memory claims, uint256[] memory lastprocessedindex) {
                for (uint256 i = 0; i < iterations.length; i++)
                    emit processeddividendtracker(iterations[i], claims[i], lastprocessedindex[i], true, (gas / iterations.length), tx.origin);
            } catch {}
        }
    }

  Code Snippet:
    function selltokensforbnbandtakefees (uint256 swapamount) private {
        (uint256 bnbformarketingandrewards, uint256 contracttokenbalance, uint256 scaledrewardtokens, uint256 scaledmarketingtokens) = swapliquifyandselltobnb (swapamount);
        // split returned bnb into marketing and dividend amounts
        uint256 bnbforcake = bnbformarketingandrewards * scaledrewardtokens / (scaledmarketingtokens + scaledrewardtokens);
        // swap bnb to cake and send dividends to cake dividend tracker and distribute
        swapandsenddividends (bnbforcake, scaledrewardtokens);
        // send bnb to marketing wallet
        uint256 bnbformarketing = address(this).balance;
        marketingwalletaddress.sendvalue (bnbformarketing);
        // send native dividends to dough dividend tracker and distribute
        uint256 doughdividends = dividendmanager.getfeetokensfromrewardaddress (address(this)) * swapamount / contracttokenbalance;
        super._transfer (address(this), dividendmanager.gettrackeraddress (address(this)), doughdividends);
        
        try dividendmanager.distributedividends (doughdividends, address(this)) {
            emit senddividends (address(this), doughdividends, doughdividends);
            // make sure we zero the count of tokens set aside for dough dividends
            dividendmanager.decrementfeetokens (doughdividends, address(this));
        } catch {
            // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
        } 
    }

  Code Snippet:
    function swapliquifyandselltobnb (uint256 swapamount) private returns (uint256, uint256, uint256, uint256) {
        uint256 bnbforfees;
        uint256 contracttokenbalance = balanceof (address(this));
        uint256 scaledliquiditytokens = liquiditytokens * swapamount / contracttokenbalance;
        uint256 scaledmarketingtokens = marketingtokens * swapamount / contracttokenbalance;
        uint256 scaledrewardtokens = dividendmanager.getfeetokensfromrewardaddress (cake) * swapamount / contracttokenbalance;
        // split tokens for lp into halves
        uint256 half = scaledliquiditytokens / 2;
        uint256 otherhalf = scaledliquiditytokens - half;
        // swap half lp tokens + marketing + cake reward tokens at once to avoid multiple contract sells
        uint256 tokenstoswap = half + scaledmarketingtokens + scaledrewardtokens;
        bnbforfees = swaptokensforbnb (tokenstoswap);

        if (bnbforfees > 0) {
            liquiditytokens -= scaledliquiditytokens;
            marketingtokens -= scaledmarketingtokens;
            uint256 bnbtoliquidity;
            // send all bnb to addliquidity as additional will be returned
            (bnbforfees, bnbtoliquidity) = addliquidity (otherhalf, bnbforfees);
            emit swapandliquify (half, bnbtoliquidity, otherhalf);
        }
        
        return (bnbforfees, contracttokenbalance, scaledrewardtokens, scaledmarketingtokens);
    }

  Code Snippet:
    function swaptokensforbnb (uint256 tokenamount) private returns (uint256) {
        uint256 initialbalance = address(this).balance;
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve (address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens (
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
        
        return (address(this).balance - initialbalance);
    }

  Code Snippet:
    function swapbnbforcake (uint256 bnbamount) private {
        address[] memory path = new address[](2);
        path[0] = uniswapv2router.weth();
        path[1] = cake;

        // make the swap
        uniswapv2router.swapexactethfortokens {value: bnbamount} (
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity (uint256 tokenamount, uint256 bnbamount) private returns (uint256, uint256) {
        // approve token transfer to cover all possible scenarios
        _approve (address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        (,uint256 bnbtoliquidity,) = uniswapv2router.addliquidityeth {value: bnbamount} (
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
        
        return (bnbamount - bnbtoliquidity, bnbtoliquidity);
    }

  Code Snippet:
    function swapandsenddividends (uint256 bnbfordividend, uint256 tokensswapped) private {
        swapbnbforcake (bnbfordividend);
        uint256 dividends = ierc20(cake).balanceof (address(this));
        
        if (dividends > 0) {
            bool success = ierc20(cake).transfer (dividendmanager.gettrackeraddress (cake), dividends);
        
            if (success) {
                try dividendmanager.distributedividends (dividends, cake) {
                    emit senddividends (cake, dividendmanager.getfeetokensfromrewardaddress (cake), dividends);
                } catch {
                    // if the final holder is selling there will be no holders to payout, as they will be banned for 24 hours, so hold the dividends back for later
                }
            }
            
            dividendmanager.decrementfeetokens (tokensswapped, cake); // even if we don't distribute dividends to the tracker, we need to decrement the tokens as they've been converted to cake
        }
    }

  Code Snippet:
    function manuallytriggerswap (uint256 tokenamount) external onlyowner {
        if (tokenamount == 0)
            tokenamount = swaptokensatamount;
            
        swapping = true;
        selltokensforbnbandtakefees (tokenamount);
        swapping = false;
    }

  Code Snippet:
    function withdrawothertokens (address _token, address _account) external onlyowner {
        ierc20 token = ierc20(_token);
        uint tokenbalance = token.balanceof (address(this));
        token.transfer (_account, tokenbalance);
        emit accidentallysenttokenwithdrawn (_token, _account, tokenbalance);
    }

  Code Snippet:
    function withdrawexcessbnb (address _account) external onlyowner {
        uint256 contractbnbbalance = address(this).balance;
        
        if (contractbnbbalance > 0)
            payable(_account).sendvalue(contractbnbbalance);
        
        emit accidentallysentbnbwithdrawn (_account, contractbnbbalance);
    }

  Code Snippet:
    function adddividendtracker (string memory name, string memory ticker, address rewardtoken, uint256 claimwait, uint256 minbalancefordividends, uint8 buyfeetotake, uint8 sellfeetotake) 
        external 

  Code Snippet:
    function incrementfeetokens (uint256 tokens, uint256 dividendtrackerid) external onlyowner {
        trackerfeetokenstoswap[dividendtrackerid] += tokens;
    }

  Code Snippet:
    function incrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] += tokens;
    }

  Code Snippet:
    function decrementfeetokens (uint256 tokens, uint256 dividendtrackerid) external onlyowner {
        trackerfeetokenstoswap[dividendtrackerid] -= tokens;
    }

  Code Snippet:
    function decrementfeetokens (uint256 tokens, address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] -= tokens;
    }

  Code Snippet:
    function incrementfeetokens (uint256[] memory tokens) external onlyowner {
        require (tokens.length == dtarray.length, "dividendmanager: must provide fee tokens value for each tracker (array wrong length)");
        
        
        for (uint256 i = 0; i < dtarray.length; i++)
            trackerfeetokenstoswap[i] += tokens[i];
    }

  Code Snippet:
    function resetfeetokens (uint256 dividendtrackerid) external onlyowner {
        trackerfeetokenstoswap[dividendtrackerid] = 0;
    }

  Code Snippet:
    function resetfeetokens (address rewardtoken) external onlyowner {
        trackerfeetokenstoswap[getidfromrewardaddress (rewardtoken)] = 0;
    }

  Code Snippet:
    function updatefees (uint8[] memory newfees, uint8 feetype) external onlyowner {
        require (newfees.length == dtarray.length, "dividendmanager: must provide new fees for each tracker (array wrong length)");
        
        for (uint256 i = 0; i < dtarray.length; i++)
            dtarray[i].updatefee (newfees[i], feetype);
    }

  Code Snippet:
    function getfeetokensfromrewardaddress (address reward) public view returns (uint256) {
        return trackerfeetokenstoswap[getidfromrewardaddress (reward)];
    }

  Code Snippet:
    function getsummedfeetokens() public view returns (uint256) {
        uint256 summedfeetokens;
        
        for (uint256 i = 0; i < trackerfeetokenstoswap.length; i++) {
            summedfeetokens += trackerfeetokenstoswap[i];
        }
        
        return summedfeetokens;
    }

  Code Snippet:
    function withdrawabledividendsof (address account) public view returns (uint256[] memory) {
        uint256[] memory withdrawabledividendpertracker = new uint256[](dtarray.length);
        
        for (uint256 i = 0; i < dtarray.length; i++)
            withdrawabledividendpertracker[i] = dtarray[i].withdrawabledividendof (account);
        
        return withdrawabledividendpertracker;
    }

  Code Snippet:
    function getfees (uint8 feetype) public view returns (uint8[] memory) {
        uint8[] memory fees = new uint8[](dtarray.length + 1);
        uint8 summedfees;
        
        for (uint256 i = 0; i < dtarray.length; i++) {
            fees[i] = dtarray[i].fee (feetype);
            summedfees += fees[i];
        }
        
        fees[dtarray.length] = summedfees;
        return fees;
    }

  Code Snippet:
    function getsummedfees (uint8 feetype) public view returns (uint8) {
        uint8 summedfees;
        
        for (uint256 i = 0; i < dtarray.length; i++) {
            summedfees += dtarray[i].fee (feetype);
        }
        
        return summedfees;
    }

  Code Snippet:
    function getfee (uint8 feetype, address rewardtoken) public view returns (uint8) {
        return dtarray[getidfromrewardaddress (rewardtoken)].fee(feetype);
    }

  Code Snippet:
    function updatefee (uint8 newfee, uint8 feetype) external onlyowner {
        fee[feetype] = newfee;
    }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "dividendtracker: withdrawdividend disabled. use the 'claim' function on the main contract.");
    }

  Code Snippet:
    function processaccount (address account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser (account);

        if (amount > 0) {
            lastclaimtimes[account] = block.timestamp;
            emit claim (account, amount, automatic);
            return true;
        }

        return false;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function blacklistaddress (address account, bool blacklist) external onlyowner {
        require (isblacklisted[account] != blacklist, "dough: the account is already set to that value");
        require (account != uniswapv2pair && blacklist, "dough: the pancakeswap pair cannot be blacklisted");
        isblacklisted[account] = blacklist;
    }

  Code Snippet:
    function _transfer (address from, address to, uint256 amount) internal override {
        require (from != address(0), "erc20: transfer from the zero address");
        require (to != address(0), "erc20: transfer to the zero address");
        require (!isblacklisted[from] && !isblacklisted[to], "blacklisted address");
        
        // need to allow owner to add liquidity, otherwise prevent any snipers from buying for the first few blocks
        if (from != owner() && to != owner() && (block.timestamp <= antibotendtime || antibotendtime == 0)) {
            require (to == canstopantibotmeasures, "dough: bots can't stop antibot measures");
            
            if (antibotendtime == 0)
                antibotendtime = block.timestamp + 4;
        }

        if (amount == 0) {
            super._transfer (from, to, 0);
            return;
        } else if (from == doughdt) { // don't get caught in circular payout events
            super._transfer (from, to, amount);
            return;
        }
        
        // check max wallet
        if (from != owner() && !isexcludedfromfees[to] && to != uniswapv2pair)
            require (balanceof(to) + amount <= maxwalletamount, "dough: receiver's wallet balance exceeds the max wallet amount");
        
        uint8 feetype = sell;
        
        if (automatedmarketmakerpairs[to] && from != owner()) {
            if (from != address(this))
                transactionbuffer.append (amount, sell);
            
            if (!isexcludedfromfees[from])
                dividendmanager.excludefromdividendsuntiltimeout (from); // miss one payout as you sold
        } else if (automatedmarketmakerpairs[from]) {
            feetype = buy;
            transactionbuffer.append (amount, buy);
        }

        if (balanceof (address(this)) >= swaptokensatamount && !swapping && !automatedmarketmakerpairs[from] && !isexcludedfromfees[from] && to != owner()) {
            swapping = true;
            selltokensforbnbandtakefees(swaptokensatamount);
            swapping = false;
        }

        bool takefee = !swapping;

        // if any account belongs to _isexcludedfromfee account then remove the fee
        if (isexcludedfromfees[from] || isexcludedfromfees[to])
            takefee = false;

        if (takefee) {
            (uint256 transferamount, uint256 tokensforfees, uint256 tokenstoburn) = gettransferamounts (amount, feetype);
            amount = transferamount;
            
            if (tokensforfees > 0)
                super._transfer (from, address(this), tokensforfees);
            
            if (tokenstoburn > 0)
                super._transfer (from, burn_address, tokenstoburn);
        }

        super._transfer (from, to, amount);

        try dividendmanager.setbalance (from, balanceof(from)) {} catch {}
        try dividendmanager.setbalance (to, balanceof(to)) {} catch {}

        if (!swapping) {
            uint256 gas = gasforprocessing;

            try dividendmanager.process(gas) returns (uint256[] memory iterations, uint256[] memory claims, uint256[] memory lastprocessedindex) {
                for (uint256 i = 0; i < iterations.length; i++)
                    emit processeddividendtracker(iterations[i], claims[i], lastprocessedindex[i], true, (gas / iterations.length), tx.origin);
            } catch {}
        }
    }


Holder Analysis
--------------
Total Unique Holders: 200
 Owner information is not available (possibly hidden or unverified)
 Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
 Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xf92d36072d4bbe0cd1b7e282217380751b869652  699,959,226,152,693,245,562,322,944 tokens (73.62% of circulating supply)
  2. 0x915bf467c560da80b7ce9605add9b85967d1c397  21,175,704,873,223,017,782,575,104 tokens (2.23% of circulating supply)
  3. 0x67f340464c6b4ff4c8ca7a85fc516a7d989c505a  11,396,955,168,749,760,112,754,688 tokens (1.20% of circulating supply)
  4. 0xf539703922bed86100a13022728da1fd3cbd80e9  10,344,641,020,550,610,748,964,864 tokens (1.09% of circulating supply)
  5. 0xa7a666b95c477aba9caff5509fc769fb2fd0fe6f  9,493,728,156,178,413,739,048,960 tokens (1.00% of circulating supply)
  6. 0x692e3f6c576e9c7c829e5fc1155b83d5f873a6e7  9,242,753,788,397,759,397,625,856 tokens (0.97% of circulating supply)
  7. 0x988a6e0513e21e0b2c33bd8feb02d836810768c5  6,726,493,885,450,503,992,639,488 tokens (0.71% of circulating supply)
  8. 0x0920725eb581023d55d07ab8dbbe5c050d28e99f  6,089,507,428,784,979,721,584,640 tokens (0.64% of circulating supply)
  9. 0x0fcd98c626f14a7965b24cc9ad452bfa922d40bc  3,703,803,323,829,389,566,672,896 tokens (0.39% of circulating supply)
  10. 0x9430b4dc4224f7e0e195fa5d1e6028875a8d6e77  3,301,675,367,712,643,616,866,304 tokens (0.35% of circulating supply)

Top 10 Total Balance: 781,434,489,165,570,324,241,055,744 tokens
Top 10 Share of Circulating Supply: 82.19%
Top 10 Share of Total Supply: 78.14%
 Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $133,809,291,866,193,952.00
Liquidity: $0.20
Liquidity/MCap Ratio: 0.0000
Token Volume: 323490.5636
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0002
Percentage of liquidity locked: 66.3500
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 217628.68645984295
LP holders count: 8

Liquidity holders for 0xEDE5020492Be8E265dB6141CB0a1D2dF9dBAE9BB, (Dough)

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 144399.2639631379 LP tokens

0xa770a5616d4fab2082649d0fae4d8917cbdcc26d holds 62066.656301323215 LP tokens

0xd44207fc38c6b82846a3ce2cedb80e0a05952df1 holds 8963.282432981234 LP tokens

0xb4d55e2c36d1171bad81d90f7300dc74e1be9677 holds 1488.475411719284 LP tokens

Owner 0x418c0618b3ebd1532e7dac82ad282db9198bd68a holds 659.9142426383048 LP tokens

0xa4927d0ab0b2f3dd8922d5254ee8dc7ca0797416 holds 50.198506953002024 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.8956010900129501 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
 Suspicious URL(s) found in the contract.
  URL: https://doughbsc.com/, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/Doughbsc, Reason: metamask recovery phrase phishing
  URL: https://t.me/doughbsc, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/roger-wu), Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How, Reason: metamask recovery phrase phishing
  URL: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1417.49 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-09-15T21:11:23
Last Active: 2025-07-19T10:55:08
Days Since Last Activity: 14.922350618460648 days
Last Transaction Hash: 0x67c63fff3a97deaed5c4ae20b0c39129575832982a680ee5ae7085a797aa5cf7
