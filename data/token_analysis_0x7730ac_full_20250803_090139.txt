Token Analysis Report
==================================================
Token: ElonHype (0x7730ac665114c0e343B141dAaaeB097197191F8a)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function claimdividend(address holder) external;
}

  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }

    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function claimdividend(address holder) external override {
        distributedividend(holder);
    }

  Code Snippet:
    function claim() public {
        dividenddistributor.claimdividend(msg.sender);
        
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;
        
        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
        require(totalfee <= 25, "must keep fees at 25% or less");
    }

  Code Snippet:
    function swapback() internal locktheswap {
        
        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}
        
        uint256 marketingshare = amountbnbmarketing.mul(7).div(10);
        uint256 anothermarketingshare = amountbnbmarketing.sub(marketingshare);
        
        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");
        (bool tmpsuccess1,) = payable(anothermarketingwallet).call{value: anothermarketingshare, gas: 30000}("");
        
        // only to supress warning msg
        tmpsuccess = false;
        tmpsuccess1 = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function changetxlimit(uint256 newlimit) external authorized {
        _maxtxamount = newlimit;
    }

  Code Snippet:
    function changewalletlimit(uint256 newlimit) external authorized {
        _walletmax  = newlimit;
    }

  Code Snippet:
    function changerestrictwhales(bool newvalue) external authorized {
       restrictwhales = newvalue;
    }

  Code Snippet:
    function changeisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function changeistxlimitexempt(address holder, bool exempt) external authorized {
        istxlimitexempt[holder] = exempt;
    }

  Code Snippet:
    function changeisdividendexempt(address holder, bool exempt) external authorized {
        require(holder != address(this) && holder != pair);
        isdividendexempt[holder] = exempt;
        
        if(exempt){
            dividenddistributor.setshare(holder, 0);
        }else{
            dividenddistributor.setshare(holder, _balances[holder]);
        }
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;
        
        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
        require(totalfee <= 25, "must keep fees at 25% or less");
    }

  Code Snippet:
    function changefeereceivers(address newliquidityreceiver, address newmarketingwallet, address newanothermarketingwallet) external authorized {
        autoliquidityreceiver = newliquidityreceiver;
        marketingwallet = newmarketingwallet;
        anothermarketingwallet = newanothermarketingwallet;
    }

  Code Snippet:
    function changeswapbacksettings(bool enableswapback, uint256 newswapbacklimit, bool swapbylimitonly) external authorized {
        swapandliquifyenabled  = enableswapback;
        swapthreshold = newswapbacklimit;
        swapandliquifybylimitonly = swapbylimitonly;
    }

  Code Snippet:
    function changedistributioncriteria(uint256 newinperiod, uint256 newmindistribution) external authorized {
        dividenddistributor.setdistributioncriteria(newinperiod, newmindistribution);
    }

  Code Snippet:
    function changedistributorsettings(uint256 gas) external authorized {
        require(gas < 750000);
        distributorgas = gas;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        
        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");
        
        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }

    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;
        
        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
        require(totalfee <= 25, "must keep fees at 25% or less");
    }

  Code Snippet:
    function swapback() internal locktheswap {
        
        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}
        
        uint256 marketingshare = amountbnbmarketing.mul(7).div(10);
        uint256 anothermarketingshare = amountbnbmarketing.sub(marketingshare);
        
        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");
        (bool tmpsuccess1,) = payable(anothermarketingwallet).call{value: anothermarketingshare, gas: 30000}("");
        
        // only to supress warning msg
        tmpsuccess = false;
        tmpsuccess1 = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function launch() internal {
        launchedat = block.number;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }

    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function changeisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;
        
        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
        require(totalfee <= 25, "must keep fees at 25% or less");
    }

  Code Snippet:
    function changefeereceivers(address newliquidityreceiver, address newmarketingwallet, address newanothermarketingwallet) external authorized {
        autoliquidityreceiver = newliquidityreceiver;
        marketingwallet = newmarketingwallet;
        anothermarketingwallet = newanothermarketingwallet;
    }

  Code Snippet:
    function changeswapbacksettings(bool enableswapback, uint256 newswapbacklimit, bool swapbylimitonly) external authorized {
        swapandliquifyenabled  = enableswapback;
        swapthreshold = newswapbacklimit;
        swapandliquifybylimitonly = swapbylimitonly;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        
        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");
        
        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

  Code Snippet:
    function takefee(address sender, address recipient, uint256 amount) internal returns (uint256) {
        
        uint256 feeapplicable = pair == recipient ? totalfeeifselling : totalfee;
        uint256 feeamount = amount.mul(feeapplicable).div(100);

        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function tradingstatus(bool newstatus) public onlyowner {
        tradingopen = newstatus;
    }

  Code Snippet:
    function swapback() internal locktheswap {
        
        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}
        
        uint256 marketingshare = amountbnbmarketing.mul(7).div(10);
        uint256 anothermarketingshare = amountbnbmarketing.sub(marketingshare);
        
        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");
        (bool tmpsuccess1,) = payable(anothermarketingwallet).call{value: anothermarketingshare, gas: 30000}("");
        
        // only to supress warning msg
        tmpsuccess = false;
        tmpsuccess1 = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        
        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");
        
        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

  Code Snippet:
    function tradingstatus(bool newstatus) public onlyowner {
        tradingopen = newstatus;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xa8a0cc8c7bf1494c554ca7448884c7d862c95f2a
Owner Balance: 106,184,260,320,276,524,377,833,472 tokens
Owner Share: 10.94% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe — 498,448,791,211,001,972,202,143,744 tokens (51.36% of circulating supply)
  2. 0xa8a0cc8c7bf1494c554ca7448884c7d862c95f2a — 106,184,260,320,276,524,377,833,472 tokens (10.94% of circulating supply)
  3. 0x559d816b3e938a73f5c6dba2f69e7ef3e1ee67f4 — 40,438,017,086,871,760,147,578,880 tokens (4.17% of circulating supply)
  4. 0xd14a8e60567075ea2439b7e7e02b362e6f0befde — 36,000,000,000,000,001,543,503,872 tokens (3.71% of circulating supply)
  5. 0x1af810b49f90a87d6eaf5b520bf40e20777a26cd — 29,680,379,398,378,354,076,811,264 tokens (3.06% of circulating supply)
  6. 0xf5a868e846e262013258cfde2e89289d34ebd707 — 17,589,958,799,372,311,003,660,288 tokens (1.81% of circulating supply)
  7. 0x3b7fb0dc871f48ad451da5a595de58a51780485d — 14,407,209,640,000,000,683,409,408 tokens (1.48% of circulating supply)
  8. 0xc9cd111b0e1fc14bce79a5f39a5995012c5477fc — 9,250,146,558,291,653,227,970,560 tokens (0.95% of circulating supply)
  9. 0xb3ae1846dd2f4d25a747db7e013f12066f643142 — 7,992,417,048,258,887,171,440,640 tokens (0.82% of circulating supply)
  10. 0x68ef4d2d000b77cac61d91c33a315ac635a0a93d — 7,953,903,341,265,392,089,694,208 tokens (0.82% of circulating supply)

Top 10 Total Balance: 767,945,083,403,716,856,524,046,336 tokens
Top 10 Share of Circulating Supply: 79.13%
Top 10 Share of Total Supply: 76.79%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $31,253,925,249,259,684.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 4952478.3613
USD Volume: 0.0002
24h Volume/Liquidity Ratio: 0.0612
Percentage of liquidity locked: 99.7400
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (10.6184)
Total supply of LP tokens: 5013.135469322885
LP holders count: 6

Liquidity holders for 0x7730ac665114c0e343B141dAaaeB097197191F8a, (ElonHype)

Owner 0x000000000000000000000000000000000000dead holds 5000.0 LP tokens
WARNING: Owner holds over 5% of the liquidity
0x89d91027bc355cd4bb713205f7bcb6e4d358c548 holds 10.707240700383759 LP tokens

0x58ccff5c68619d6e6ac0fd25ec61a7fc8d633440 holds 0.867473529685902 LP tokens

0x2868973ea46938721cabd10cbcecefb7704a418d holds 0.7999138263614864 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.7608412664536135 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://elonhype.space/, Reason: metamask recovery phrase phishing
  URL: https://t.me/ElonHypeOfficial, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1275.37 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-02-05T00:05:00
Last Active: 2025-07-29T10:37:57
Days Since Last Activity: 4.933131462465278 days
Last Transaction Hash: 0x6764e9a7ed6ea033d3e836a871d19b1cde585786cc3ccd22fc382cc053bc04d9
