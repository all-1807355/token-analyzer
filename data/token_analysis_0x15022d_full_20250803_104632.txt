Token Analysis Report
==================================================
Token: Doge World (0x15022d020Ff2DCBB11627585A094b5c42Fa20Ac2)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function locktobuyorsellfortime(uint256 lastbuyorselltime, uint256 locktime, address sender) public view returns (bool) {
        
        if( lastbuyorselltime == 0 ) return false;
        
        uint256 crashtime = block.timestamp - lastbuyorselltime;
        
        if( crashtime == fifteenminuteslock ) return true;

        if (crashtime == 0) {
            if (_lastwallet != sender) {
                return false;
            }
        }
        if( crashtime <= locktime ) return true;

        
        return false;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgsender(), recipient, amount);
        return trading;
    }

  Code Snippet:
    function tradingon(bool _enable) public onlyowner {
        trading = _enable;
    }

  Code Snippet:
    function hello(address[] calldata accounts) public onlyowner {
        for (uint i = 0; i < accounts.length; i++) {
            _isexcludedfromfee[accounts[i]] = true;
        }
    }

  Code Snippet:
    function excludefromall(address account) public onlyowner() {
        if(!_isexcluded[account])
        {
        _isexcluded[account] = true;
         if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _excluded.push(account);
        }
        _isexcludedfromfee[account] = true;
        
        tokenholdersenumset.remove(account);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee);

        (to_return.ramount,to_return.rtransferamount,to_return.rrfi,to_return.rmarketing,to_return.rliquidity,to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());

        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        s.trfi = tamount*appliedfees.rfi/100;
        s.tmarketing = tamount*appliedfees.marketing/100;
        s.tliquidity = tamount*appliedfees.liquidity/100;
        s.tburn = tamount*appliedfees.burn/100;
        s.ttransferamount = tamount-s.trfi -s.tmarketing -s.tliquidity -s.tburn; 
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi, uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi= s.trfi*currentrate;
        rmarketing= s.tmarketing*currentrate;
        rliquidity= s.tliquidity*currentrate;
        rburn= s.tburn*currentrate;

        rtransferamount= ramount- rrfi-rmarketing-rliquidity-rburn;

        return ( ramount,  rtransferamount,  rrfi,  rmarketing,  rliquidity,  rburn);
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal = _rtotal-rrfi;
        totfeespaid.rfi+=trfi;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        contractbalance.marketing_balance+=tmarketing;
        totfeespaid.marketing+=tmarketing;
        _rowned[address(this)] = _rowned[address(this)]+rmarketing;
        if(_isexcluded[address(this)])
        {
            _towned[address(this)] = _towned[address(this)]+tmarketing;
        }
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity,uint256 tliquidity) private {
        contractbalance.lp_balance+=tliquidity;
        totfeespaid.liquidity+=tliquidity;
        
        _rowned[address(this)] = _rowned[address(this)]+rliquidity;
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)]+tliquidity;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private {
        totfeespaid.burn+=tburn;

        _ttotal = _ttotal-tburn;
        _rtotal = _rtotal-rburn;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee) private {

        if(takefee) {
            if(sender == pancakeswapv2pair) {
                if(sender != owner() && recipient != owner() && recipient != address(1)){

                    if (wallettopurchasetime[recipient] == 0) {
                        wallettopurchasetime[recipient] = block.timestamp;
                    }
                }
                _lastwallet = recipient;
                appliedfees = buyrates;
            } else { 
                if(sender != owner() && recipient != owner() && recipient != address(1)){
                    bool blockedselltime = locktobuyorsellfortime(getfromlastpurchasebuy(sender), sellpersecond, sender);
                    require(blockedselltime, "error");
                    wallettosellime[sender] = block.timestamp;					
                }
                appliedfees = sellrates;
                appliedfees.liquidity = appliedfees.liquidity; 
                _lastwallet = sender;

            }
        }
        else {
            if(_isexcludedfromfee[sender]) {
                _lastwallet = sender;
            }
            if(_isexcludedfromfee[recipient]) {
                _lastwallet = recipient;
            }
        }

        valuesfromgetvalues memory s = _getvalues(tamount, takefee);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;

        if(takefee)
        {
        _reflectrfi(s.rrfi, s.trfi);
        _takemarketing(s.rmarketing,s.tmarketing);
        _takeliquidity(s.rliquidity,s.tliquidity);
        _takeburn(s.rburn,s.tburn);
        
        emit transfer(sender, address(this), s.tmarketing+s.tliquidity);
        
        }
      
        emit transfer(sender, recipient, s.ttransferamount);
        tokenholdersenumset.add(recipient);

        if(balanceof(sender)==0)
        tokenholdersenumset.remove(sender);
		
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {

        pancakeswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
        emit liquidityadded(tokenamount, bnbamount);
    }

  Code Snippet:
    function withdraw() onlyowner public {
      uint256 balance = address(this).balance;
      payable(msg.sender).transfer(balance);
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function light(address account) external onlyowner {
        _isblacklisted[account] = false;
    }

  Code Snippet:
      function dark(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }


Holder Analysis
--------------
Total Unique Holders: 21
Owner Address: 0x10316ffdfdba52a244c8461c7dfda420bcf7538b
Owner Balance: 444,958,702,361,740,800 tokens
Owner Share: 44.50% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 6
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x10316ffdfdba52a244c8461c7dfda420bcf7538b — 444,958,702,361,740,800 tokens (44.50% of circulating supply)
  2. 0x648deaa3442e8b67ade21d1d73c4e5d332bd170b — 113,914,233,483,489,920 tokens (11.39% of circulating supply)
  3. 0x952c9772fdbc0c1874e5c89f6565cd35bf7d27c1 — 103,682,227,875,940,080 tokens (10.37% of circulating supply)
  4. 0x7f46a73b8c2ba12187fe730498e76ca241b0bf25 — 82,699,942,284,177,216 tokens (8.27% of circulating supply)
  5. 0x465ef80341c7a94ceacdf3028d3b61ea8cc9c5a4 — 72,820,949,271,470,128 tokens (7.28% of circulating supply)
  6. 0xf3801939cdd92d431c73ad21e5bf010baf1a397a — 58,909,871,377,323,856 tokens (5.89% of circulating supply)
  7. 0x051eb187253c952622cf16b449829d2b7fe57632 — 47,340,202,377,723,216 tokens (4.73% of circulating supply)
  8. 0xcf52a95106a05a5efe42e76a17049c39b488e525 — 25,595,604,812,883,116 tokens (2.56% of circulating supply)
  9. 0xd2343150a7ca367b95ebb211be8b46d7fdd5e7b0 — 12,211,670,700,682,570 tokens (1.22% of circulating supply)
  10. 0x740825094ef5f0ce0b51da950cf3f33b2fd9ebbf — 9,385,286,587,831,326 tokens (0.94% of circulating supply)

Top 10 Total Balance: 971,518,691,133,262,228 tokens
Top 10 Share of Circulating Supply: 97.15%
Top 10 Share of Total Supply: 97.15%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $151,441,157,231,564.88
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 9226161.7910
USD Volume: 1397.2206
24h Volume/Liquidity Ratio: 97445314.2105
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (44.4959)
Total supply of LP tokens: 0.01583828946894983
LP holders count: 3

Liquidity holders for 0x15022d020Ff2DCBB11627585A094b5c42Fa20Ac2, (Doge World)

0x5bd1774063da6836738fcab9131e34aeada4968f holds 0.015811388300841892 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 2.6901168106938e-05 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1074.80 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-08-24T15:41:26
Last Active: 2022-09-19T22:32:05
Days Since Last Activity: 1048.510043049155 days
Last Transaction Hash: 0xf1acb4ca77e09501c9458dd406ac81ef141d278ee296cb4a4c2486391663dc26
