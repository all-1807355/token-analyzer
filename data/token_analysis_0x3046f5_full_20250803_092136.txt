Token Analysis Report
==================================================
Token: RoArts Token (0x3046f5cD17Cb6A7f5BBcc3A23309dD32106C9116)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
        function _transfer(address sender, address recipient, uint256 amount) internal {
            require(sender != address(0), "erc20: transfer from the zero address");
            require(recipient != address(0), "erc20: transfer to the zero address");
            require(amount > 0, "transfer amount must be greater than zero");
            require(balanceof(recipient) + amount <= _maxwalletamount, "recipent is exceeding the wallet limit");
            
            if(sender != owner() && recipient != owner())
                require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");

            // is the token balance of this contract address over the min number of
            // tokens that we need to initiate a swap?
            // also, don't get caught in a circular charity event.
            // also, don't swap if sender is uniswap pair.
            uint256 contracttokenbalance = balanceof(address(this));
            
            if(contracttokenbalance >= _maxtxamount)
            {
                contracttokenbalance = _maxtxamount;
            }
            
            bool overmintokenbalance = contracttokenbalance >= _numoftokenstoexchangeforbnb;
            if (!inswap && swapenabled && overmintokenbalance && sender != uniswapv2pair) {
                // we need to swap the current tokens to eth and send to the charity wallet
             
            swapback(contracttokenbalance);
                }
            
            
            //indicates if fee should be deducted from transfer
            bool takefee = true;
            
               
            //if any account belongs to _isexcludedfromfee account then remove the fee
            if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
                takefee = false;
            }
            
            
            if(takefee)
            {
            uint256 buyfeeamount = amount.mul(buytotalfees).div(100);
            uint256 sellfeeamount = (amount.mul(selltotalfees)).div(100);
    
             if(recipient == address(uniswapv2pair))
            {
              require(amount <= _maxsellamount, "not allowed");
              amount = amount.sub(sellfeeamount);
              _takefee(sellfeeamount);
            }
            else 
           {
              amount = amount.sub(buyfeeamount);
              _takefee(buyfeeamount);
            }
            
           
        }  
         
            //transfer amount, it will take tax and charity fee
            _tokentransfer(sender,recipient,amount,takefee);
        }

WARNING: Ownership Renounced
  Code Snippet:
        function renounceownership() public virtual onlyowner {
            emit ownershiptransferred(_owner, address(0));
            _owner = address(0);
        }

WARNING: High Tax Detected
  Code Snippet:
        function feetosetter() external view returns (address);


  Code Snippet:
        function setfeetosetter(address) external;
    } 

  Code Snippet:
        function swapexacttokensfortokens(
            uint amountin,

  Code Snippet:
        function swaptokensforexacttokens(
            uint amountout,

  Code Snippet:
        function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function removeliquidityethsupportingfeeontransfertokens(
            address token,

  Code Snippet:
        function removeliquidityethwithpermitsupportingfeeontransfertokens(
            address token,

  Code Snippet:
        function swapexacttokensfortokenssupportingfeeontransfertokens(
            uint amountin,

  Code Snippet:
        function swapexactethfortokenssupportingfeeontransfertokens(
            uint amountoutmin,

  Code Snippet:
        function swapexacttokensforethsupportingfeeontransfertokens(
            uint amountin,

  Code Snippet:
        function setexcludefromfee(address account, bool excluded) external onlyowner() {
            _isexcludedfromfee[account] = excluded;
        }

  Code Snippet:
        function totalfees() public view returns (uint256) {
            return _tfeetotal;
        }

  Code Snippet:
        function deliver(uint256 tamount) public {
            address sender = _msgsender();
            require(!_isexcluded[sender], "excluded addresses cannot call this function");
            (uint256 ramount,,,,) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rtotal = _rtotal.sub(ramount);
            _tfeetotal = _tfeetotal.add(tamount);
        }

  Code Snippet:
        function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
            require(tamount <= _ttotal, "amount must be less than supply");
            if (!deducttransferfee) {
                (uint256 ramount,,,,) = _getvalues(tamount);
                return ramount;
            } else {
                (,uint256 rtransferamount,,,) = _getvalues(tamount);
                return rtransferamount;
            }
        }

  Code Snippet:
        function excludeaccount(address account) external onlyowner() {
            require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
            require(!_isexcluded[account], "account is already excluded");
            if(_rowned[account] > 0) {
                _towned[account] = tokenfromreflection(_rowned[account]);
            }
            _isexcluded[account] = true;
            _excluded.push(account);
        }

  Code Snippet:
        function updaterouter(address _router) public onlyowner {
            uniswapv2router = iuniswapv2router02(_router);
            uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).getpair(address(this), uniswapv2router.weth());
            if (uniswapv2pair == address(0)) {
                uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
            }
            require(uniswapv2pair != address(0), "invalid pair address");
        }

  Code Snippet:
        function removeallfee() private {
            if(_taxfee == 0 && _liquidityfee == 0 && _marketingfee == 0 && _communityfee == 0 && _gamefee == 0) return;
            
            _previoustaxfee = _taxfee;
            _previousliquidityfee = _liquidityfee;
            _previouscommunityfee = _communityfee;
            _previousmarketingfee = _marketingfee;
            _previousgamefee = _gamefee;
            
            _taxfee = 0;
            _liquidityfee = 0;
            _marketingfee = 0;
            _communityfee = 0;
            _gamefee = 0;
            
        }

  Code Snippet:
        function restoreallfee() private {
            _taxfee = _previoustaxfee;
            _liquidityfee = _previousliquidityfee;
            _marketingfee = _previousmarketingfee;
            _communityfee = _previouscommunityfee;
            _gamefee = _previousgamefee;
        }

  Code Snippet:
        function isexcludedfromfee(address account) public view returns(bool) {
            return _isexcludedfromfee[account];
        }

  Code Snippet:
        function _transfer(address sender, address recipient, uint256 amount) internal {
            require(sender != address(0), "erc20: transfer from the zero address");
            require(recipient != address(0), "erc20: transfer to the zero address");
            require(amount > 0, "transfer amount must be greater than zero");
            require(balanceof(recipient) + amount <= _maxwalletamount, "recipent is exceeding the wallet limit");
            
            if(sender != owner() && recipient != owner())
                require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");

            // is the token balance of this contract address over the min number of
            // tokens that we need to initiate a swap?
            // also, don't get caught in a circular charity event.
            // also, don't swap if sender is uniswap pair.
            uint256 contracttokenbalance = balanceof(address(this));
            
            if(contracttokenbalance >= _maxtxamount)
            {
                contracttokenbalance = _maxtxamount;
            }
            
            bool overmintokenbalance = contracttokenbalance >= _numoftokenstoexchangeforbnb;
            if (!inswap && swapenabled && overmintokenbalance && sender != uniswapv2pair) {
                // we need to swap the current tokens to eth and send to the charity wallet
             
            swapback(contracttokenbalance);
                }
            
            
            //indicates if fee should be deducted from transfer
            bool takefee = true;
            
               
            //if any account belongs to _isexcludedfromfee account then remove the fee
            if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
                takefee = false;
            }
            
            
            if(takefee)
            {
            uint256 buyfeeamount = amount.mul(buytotalfees).div(100);
            uint256 sellfeeamount = (amount.mul(selltotalfees)).div(100);
    
             if(recipient == address(uniswapv2pair))
            {
              require(amount <= _maxsellamount, "not allowed");
              amount = amount.sub(sellfeeamount);
              _takefee(sellfeeamount);
            }
            else 
           {
              amount = amount.sub(buyfeeamount);
              _takefee(buyfeeamount);
            }
            
           
        }  
         
            //transfer amount, it will take tax and charity fee
            _tokentransfer(sender,recipient,amount,takefee);
        }

  Code Snippet:
        function _takefee(uint256 tfee) private {
            uint256 currentrate =  _getrate();
            uint256 rfee = tfee.mul(currentrate);
            _rowned[address(this)] = _rowned[address(this)].add(rfee);
            if(_isexcluded[address(this)])
                _towned[address(this)] = _towned[address(this)].add(tfee);
        }

  Code Snippet:
    function swapback(uint256 tokenstoliquify) internal locktheswap {

        uint256 tokenstolp = tokenstoliquify.mul(_liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(tokenstolp);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenstoliquify);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 bnbbalance = address(this).balance;
        uint256 bnbfeefactor = totalfee.sub((_liquidityfee).div(2));

        uint256 bnbforliquidity = bnbbalance.mul(_liquidityfee).div(bnbfeefactor).div(2);
        uint256 bnbformarketing = bnbbalance.mul(_marketingfee).div(bnbfeefactor);
        uint256 bnbforcommunity = bnbbalance.mul(_communityfee).div(bnbfeefactor);
        uint256 bnbforgame = bnbbalance.mul(_gamefee).div(bnbfeefactor);
      

        addliquidity(tokenstolp, bnbforliquidity);

        payable(marketingwallet).transfer(bnbformarketing);
        payable(communitywallet).transfer(bnbforcommunity);
        payable(gamewallet).transfer(bnbforgame);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
        function setswapenabled(bool enabled) external onlyowner(){
            swapenabled = enabled;
        }

  Code Snippet:
        function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
            if(!takefee)
                removeallfee();

            if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _transferfromexcluded(sender, recipient, amount);
            } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _transfertoexcluded(sender, recipient, amount);
            } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
                _transferstandard(sender, recipient, amount);
            } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _transferbothexcluded(sender, recipient, amount);
            } else {
                _transferstandard(sender, recipient, amount);
            }

            if(!takefee)
                restoreallfee();
        }

  Code Snippet:
        function _transferstandard(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount); 
          
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _towned[recipient] = _towned[recipient].add(ttransferamount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount);    
                     
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee) = _getvalues(tamount);
            _towned[sender] = _towned[sender].sub(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount); 
           
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee) = _getvalues(tamount);
            _towned[sender] = _towned[sender].sub(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _towned[recipient] = _towned[recipient].add(ttransferamount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
                  
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _reflectfee(uint256 rfee, uint256 tfee) private {
            _rtotal = _rtotal.sub(rfee);
            _tfeetotal = _tfeetotal.add(tfee);
        }

  Code Snippet:
        function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256) {
            (uint256 ttransferamount, uint256 tfee) = _gettvalues(tamount, _taxfee);
            uint256 currentrate =  _getrate();
            (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, currentrate);
            return (ramount, rtransferamount, rfee, ttransferamount, tfee);
        }

  Code Snippet:
        function _gettvalues(uint256 tamount, uint256 taxfee) private pure returns (uint256, uint256) {
            uint256 tfee = tamount.mul(taxfee).div(100);
            uint256 ttransferamount = tamount.sub(tfee);
            return (ttransferamount, tfee);
        }

  Code Snippet:
        function _getrvalues(uint256 tamount, uint256 tfee, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
            uint256 ramount = tamount.mul(currentrate);
            uint256 rfee = tfee.mul(currentrate);
            uint256 rtransferamount = ramount.sub(rfee);
            return (ramount, rtransferamount, rfee);
        }

  Code Snippet:
        function _gettaxfee() private view returns(uint256) {
            return _taxfee;
        }

  Code Snippet:
        function changebuyfee(uint256 taxfee, uint256 buyliquidity, uint256 buygame) public onlyowner
        {
        _buytaxfee = taxfee;
        _buyliquidityfee = buyliquidity; 
        _buygamefee = buygame;
        buytotalfees = _buytaxfee.add(_buyliquidityfee).add(_buygamefee);
        
        }

  Code Snippet:
         function changesellfee(uint256 taxfee, uint256 sellliquidity, uint256 sellmarketing, uint256 sellcommunity, uint256 sellgame) public onlyowner
        {
        _selltaxfee = taxfee;
        _sellliquidityfee = sellliquidity; 
        _sellmarketingfee = sellmarketing; 
        _sellcommunityfee = sellcommunity; 
        _sellgamefee = sellgame;
        selltotalfees = _selltaxfee.add(_sellliquidityfee).add(_sellcommunityfee).add(_sellmarketingfee).add(_sellgamefee);
        
         }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x7cced166fbf722e15852699cfeb32cc1adc6205c
Owner Balance: 3,098,684,978,824,216 tokens
Owner Share: 2.63% of circulating supply
✅ Owner holds LESS than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x7f31b9dff52b180b0bd5453311ac41eef097210c — 87,420,854,900,085,952 tokens (74.26% of circulating supply)
  2. 0x898fce2414a1347c0e12bde6b28b75843fd9bbad — 19,240,811,898,826,380 tokens (16.34% of circulating supply)
  3. 0x95180577a93be22f50915557afe928a156339b5b — 3,967,623,382,121,514 tokens (3.37% of circulating supply)
  4. 0x7cced166fbf722e15852699cfeb32cc1adc6205c — 3,098,684,978,824,216 tokens (2.63% of circulating supply)
  5. 0x0ed943ce24baebf257488771759f9bf482c39706 — 2,556,289,887,201,223 tokens (2.17% of circulating supply)
  6. 0x63a0cc7b4661783159dd30d8d7640324778b4201 — 1,107,840,070,835,951 tokens (0.94% of circulating supply)
  7. 0xb4d499e9b894e10fa3e53cd037c70bd8a55650d2 — 950,055,995,986,910 tokens (0.81% of circulating supply)
  8. 0x52ba9d0b0ff6fc41c98b704a58067e8c6cffeae2 — 857,299,787,500,077 tokens (0.73% of circulating supply)
  9. 0xf9e1bc154b418775bbe5fe61365d74d4479430b3 — 763,949,968,990,583 tokens (0.65% of circulating supply)
  10. 0xa7d96d95aeb38ddf4d13db6bf6dbd59615a0a502 — 719,073,164,215,365 tokens (0.61% of circulating supply)

Top 10 Total Balance: 120,682,484,034,588,171 tokens
Top 10 Share of Circulating Supply: 102.52%
Top 10 Share of Total Supply: 120.68%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $3,107,674,527,008,006.50
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 11626.2030
USD Volume: 306.9214
24h Volume/Liquidity Ratio: 14685966.5169
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0001)
Total supply of LP tokens: 0.000167786123770206
LP holders count: 4

Liquidity holders for 0x3046f5cD17Cb6A7f5BBcc3A23309dD32106C9116, (RoArts Token)

0x93e80813c2e9c0df2e708773909e532c82618279 holds 0.000120325975616847 LP tokens

Owner 0x7cced166fbf722e15852699cfeb32cc1adc6205c holds 3.9432915629846e-05 LP tokens
WARNING: Owner holds over 5% of the liquidity
0x0ed943ce24baebf257488771759f9bf482c39706 holds 8.027232522513e-06 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1356.47 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-15T22:00:51
Last Active: 2025-07-19T00:30:03
Days Since Last Activity: 15.369135856967594 days
Last Transaction Hash: 0x222cf84e82df813449b8e456ad27c70e5b95a9bfdc9a476b551fbd970caf06b1
