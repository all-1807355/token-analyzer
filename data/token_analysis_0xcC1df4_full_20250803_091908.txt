Token Analysis Report
==================================================
Token: FlappyShibaInu (0xcC1df4Cff1E9186ecE7B71367749e8E749c82A85)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rwrd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function claimdividend() external {
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
function multitransfer(address from, address[] calldata addresses, uint256[] calldata tokens) external onlyowner {

    require(addresses.length < 501,"gas error: max airdrop limit is 500 addresses");
    require(addresses.length == tokens.length,"mismatch between address and token count");

    uint256 sccc = 0;

    for(uint i=0; i < addresses.length; i++){
        sccc = sccc + tokens[i];
    }

    require(balanceof(from) >= sccc, "not enough tokens in wallet");

    for(uint i=0; i < addresses.length; i++){
        _basictransfer(from,addresses[i],tokens[i]);
        if(!isdividendexempt[addresses[i]]) {
            try distributor.setshare(addresses[i], _balances[addresses[i]]) {} catch {} 
        }
    }

    // dividend tracker
    if(!isdividendexempt[from]) {
        try distributor.setshare(from, _balances[from]) {} catch {}
    }
}

  Code Snippet:
function multitransfer_fixed(address from, address[] calldata addresses, uint256 tokens) external onlyowner {

    require(addresses.length < 801,"gas error: max airdrop limit is 800 addresses");

    uint256 sccc = tokens * addresses.length;

    require(balanceof(from) >= sccc, "not enough tokens in wallet");

    for(uint i=0; i < addresses.length; i++){
        _basictransfer(from,addresses[i],tokens);
        if(!isdividendexempt[addresses[i]]) {
            try distributor.setshare(addresses[i], _balances[addresses[i]]) {} catch {} 
        }
    }

    // dividend tracker
    if(!isdividendexempt[from]) {
        try distributor.setshare(from, _balances[from]) {} catch {}
    }
}

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function settxlimit(uint256 amount) external authorized {
        _maxtxamount = amount;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingdevfeereceiver && recipient != prizefeereceiver  && recipient != autoliquidityreceiver && recipient != burnfeereceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = (!shouldtakefee(sender) || !shouldtakefee(recipient)) ? amount : takefee(sender, amount,(recipient == pair));
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function clearstuckbalance(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(marketingdevfeereceiver).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function clearstuckbalance_sender(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(msg.sender).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function setisdividendexempt(address holder, bool exempt) external authorized {
        require(holder != address(this) && holder != pair);
        isdividendexempt[holder] = exempt;
        if(exempt){
            distributor.setshare(holder, 0);
        }else{
            distributor.setshare(holder, _balances[holder]);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setistxlimitexempt(address holder, bool exempt) external authorized {
        istxlimitexempt[holder] = exempt;
    }

  Code Snippet:
    function setistimelockexempt(address holder, bool exempt) external authorized {
        istimelockexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingdevfee, uint256 _prizefee, uint256 _burnfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingdevfee = _marketingdevfee;
        prizefee = _prizefee;
        burnfee = _burnfee;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingdevfee).add(_prizefee).add(_burnfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/2, "fees cannot be more than 50%");
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingdevfeereceiver, address _prizefeereceiver, address _burnfeereceiver ) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingdevfeereceiver = _marketingdevfeereceiver;
        prizefeereceiver = _prizefeereceiver;
        burnfeereceiver = _burnfeereceiver;
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

  Code Snippet:
    function settargetliquidity(uint256 _target, uint256 _denominator) external authorized {
        targetliquidity = _target;
        targetliquiditydenominator = _denominator;
    }

  Code Snippet:
    function setdistributioncriteria(uint256 _minperiod, uint256 _mindistribution) external authorized {
        distributor.setdistributioncriteria(_minperiod, _mindistribution);
    }

  Code Snippet:
    function setdistributorsettings(uint256 gas) external authorized {
        require(gas < 750000);
        distributorgas = gas;
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingdevfeereceiver && recipient != prizefeereceiver  && recipient != autoliquidityreceiver && recipient != burnfeereceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = (!shouldtakefee(sender) || !shouldtakefee(recipient)) ? amount : takefee(sender, amount,(recipient == pair));
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function cooldownenabled(bool _status, uint8 _interval) public onlyowner {
        buycooldownenabled = _status;
        cooldowntimerinterval = _interval;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = rwrd.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = wbnb;
        path[1] = address(rwrd);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rwrd.balanceof(address(this)).sub(balancebefore);

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rwrd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingdevfeereceiver && recipient != prizefeereceiver  && recipient != autoliquidityreceiver && recipient != burnfeereceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = (!shouldtakefee(sender) || !shouldtakefee(recipient)) ? amount : takefee(sender, amount,(recipient == pair));
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function shouldtakefee(address sender) internal view returns (bool) {
        return !isfeeexempt[sender];
    }

  Code Snippet:
    function takefee(address sender, uint256 amount, bool issell) internal returns (uint256) {
        
        uint256 multiplier = issell ? sellmultiplier : 100;
        uint256 feeamount = amount.mul(totalfee).mul(multiplier).div(feedenominator * 100);

        uint256 burntokens = feeamount.mul(burnfee).div(totalfee);
        uint256 contracttokens = feeamount.sub(burntokens);

        _balances[address(this)] = _balances[address(this)].add(contracttokens);
        _balances[burnfeereceiver] = _balances[burnfeereceiver].add(burntokens);
        emit transfer(sender, address(this), contracttokens);
        
        if(burntokens > 0){
            emit transfer(sender, burnfeereceiver, burntokens);    
        }

        return amount.sub(feeamount);
    }

  Code Snippet:
    function shouldswapback() internal view returns (bool) {
        return msg.sender != pair
        && !inswap
        && swapenabled
        && _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function clearstuckbalance(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(marketingdevfeereceiver).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }

  Code Snippet:
    function swapback() internal swapping {
        uint256 dynamicliquidityfee = isoverliquified(targetliquidity, targetliquiditydenominator) ? 0 : liquidityfee;
        uint256 amounttoliquify = swapthreshold.mul(dynamicliquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = swapthreshold.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = wbnb;

        uint256 balancebefore = address(this).balance;

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance.sub(balancebefore);

        uint256 totalbnbfee = totalfee.sub(dynamicliquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(dynamicliquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(reflectionfee).div(totalbnbfee);
        uint256 amountbnbmarketingdev = amountbnb.mul(marketingdevfee).div(totalbnbfee);
        uint256 amountbnbprize = amountbnb.mul(prizefee).div(totalbnbfee);

        try distributor.deposit{value: amountbnbreflection}() {} catch {}
        (bool tmpsuccess,) = payable(marketingdevfeereceiver).call{value: amountbnbmarketingdev, gas: 30000}("");
        (tmpsuccess,) = payable(prizefeereceiver).call{value: amountbnbprize, gas: 30000}("");
        
        // only to supress warning msg
        tmpsuccess = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingdevfee, uint256 _prizefee, uint256 _burnfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingdevfee = _marketingdevfee;
        prizefee = _prizefee;
        burnfee = _burnfee;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingdevfee).add(_prizefee).add(_burnfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/2, "fees cannot be more than 50%");
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingdevfeereceiver, address _prizefeereceiver, address _burnfeereceiver ) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingdevfeereceiver = _marketingdevfeereceiver;
        prizefeereceiver = _prizefeereceiver;
        burnfeereceiver = _burnfeereceiver;
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingdevfeereceiver && recipient != prizefeereceiver  && recipient != autoliquidityreceiver && recipient != burnfeereceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = (!shouldtakefee(sender) || !shouldtakefee(recipient)) ? amount : takefee(sender, amount,(recipient == pair));
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function enable_blacklist(bool _status) public onlyowner {
        blacklistmode = _status;
    }

  Code Snippet:
    function manage_blacklist(address[] calldata addresses, bool status) public onlyowner {
        for (uint256 i; i < addresses.length; ++i) {
            isblacklisted[addresses[i]] = status;
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingdevfeereceiver && recipient != prizefeereceiver  && recipient != autoliquidityreceiver && recipient != burnfeereceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = (!shouldtakefee(sender) || !shouldtakefee(recipient)) ? amount : takefee(sender, amount,(recipient == pair));
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x968d2f75cf8cb5170f3dbd16204c98389d863066
Owner Balance: 45,134,431,309,591,724,032 tokens
Owner Share: 54.75% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x968d2f75cf8cb5170f3dbd16204c98389d863066 — 45,134,431,309,591,724,032 tokens (54.75% of circulating supply)
  2. 0x7ee058420e5937496f5a2096f04caa7721cf70cc — 8,000,000,000,000,000,000 tokens (9.70% of circulating supply)
  3. 0xa950deba6b63772fa51536b50731f3ae007e7b60 — 1,030,333,674,321,070,720 tokens (1.25% of circulating supply)
  4. 0x3802a54520e31a34f1a08167a1e5c1f74f23abeb — 564,696,430,233,444,800 tokens (0.68% of circulating supply)
  5. 0x4125db3300840a53e3b18cd0b74620e8898b4374 — 507,708,010,047,371,072 tokens (0.62% of circulating supply)
  6. 0x0e79ef3ba850fc2950d2d98ecf6df2a1f967ab5b — 499,267,400,861,264,768 tokens (0.61% of circulating supply)
  7. 0xd5561ebf772fbe42cb6140d245115ca0ebd0bda5 — 423,000,000,000,000,000 tokens (0.51% of circulating supply)
  8. 0x945b285fca0ecb8f0d717b7e8da50f5e50cc17e6 — 409,122,326,921,256,128 tokens (0.50% of circulating supply)
  9. 0x17b1e57a4e909472aa89c8cbd1085568aba8a4ac — 362,956,361,936,476,864 tokens (0.44% of circulating supply)
  10. 0x076f8cd29e75f8345cc918f8e4e86fc8d7223a92 — 289,704,487,677,976,640 tokens (0.35% of circulating supply)

Top 10 Total Balance: 57,221,220,001,590,585,024 tokens
Top 10 Share of Circulating Supply: 69.41%
Top 10 Share of Total Supply: 57.22%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $852,273,687,039,545,856.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 23183280.1207
USD Volume: 239663.9878
24h Volume/Liquidity Ratio: 996800851964.6240
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (45.1344)
Total supply of LP tokens: 3.1626498552078e-05
LP holders count: 2

Liquidity holders for 0xcC1df4Cff1E9186ecE7B71367749e8E749c82A85, (FlappyShibaInu)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 3.1626498551078e-05 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1358.98 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-13T09:42:01
Last Active: 2025-01-14T14:29:09
Days Since Last Activity: 200.78471251842592 days
Last Transaction Hash: 0xa873e870c9305f1f9fe55b80af3f87bad93b3a39b1e2281bf666901422833bb4
