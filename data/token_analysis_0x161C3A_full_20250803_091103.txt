Token Analysis Report
==================================================
Token: BNBGlobal V2 (0x161C3A337019920c3F29e20627A32e958D8a6856)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");

        bool takefee = true;
        
        dynamictax memory currenttax;

        if (from != owner() && to != owner() && !presale && from != address(this) && to != address(this) && !_iscontract[from] && !_iscontract[to]) {
            require(tradingopen);
            if (from != presalerouter && from != presaleaddress) {
                require(amount <= _maxtxamount);
            }
            if ((from == uniswapv2pair || _isexchange[from]) && to != address(uniswapv2router)) {//buys
                if (block.timestamp - previoustransactionblock[to] <= _botblocks) {
                    bots[to] = true;
                } else {
                    previoustransactionblock[to] = block.timestamp;
                }

                if (block.timestamp <= _firstblock.add(_botblocks) && from != presalerouter && from != presaleaddress) {
                    bots[to] = true;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                
                require(bnbamount >= _minbuybnb, "you must buy at least min bnb worth of token");
                require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                
                currenttax = getfee();
                
            }
            
            if (!inswap && from != uniswapv2pair && !_isexchange[from]) { //sells, transfers
                require(!bots[from] && !bots[to]);
                
                if (block.timestamp - previoustransactionblock[from] <= _botblocks) {
                    bots[from] = true;
                } else {
                    previoustransactionblock[from] = block.timestamp;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                require(bnbamount >= _minsellbnb, "you must buy at least the min bnb worth of token");
                
                if (_priceimpactselllimitenabled) {
                    
                    require(amount <= balanceof(uniswapv2pair).mul(_priceimpact).div(100)); // price impact limit

                }
                
                if(to != uniswapv2pair) {
                    require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                }

                currenttax = getfee();
                
                uint256 contracttokenbalance = balanceof(address(this));
                if (contracttokenbalance > mintokenstoswap) {
                    contracttokenbalance = mintokenstoswap;
                }
                if (contracttokenbalance >= mintokenstoswap) {

                    swapandliquify(contracttokenbalance);
                
                }
                uint256 contractethbalance = address(this).balance;
                if (contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
                    
            }
        }

        if (_isexcludedfromfee[from] || _isexcludedfromfee[to] || presale || _iscontract[from] || _iscontract[to]) {
            restoreallfee();
            takefee = false;
        }

        else if (bots[from] || bots[to]) {
            restoreallfee();
            setbotfee();
            takefee = true;
        }

        if (presale) {
            require(from == owner() || from == presalerouter || from == presaleaddress || _iscontract[from] || _iscontract[to] || to == owner());
        }
        
        _tokentransfer(from, to, amount, takefee, currenttax);
        restoreallfee();
    }

  Code Snippet:
    function updatemintokenstoswap(uint256 _mintokentoswap) external onlyowner() {
        mintokenstoswap = _mintokentoswap;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function removeallfee() private {
        if (_buymarketingfee == 0 && _buyreflectionfee == 0 && _buyliquidityfee == 0 && _sellmarketingfee == 0 && _sellreflectionfee == 0 && _sellliquidityfee == 0) return;
        _previousbuymarketingfee = _buymarketingfee;
        _previousbuyreflectionfee = _buyreflectionfee;
        _previousbuyliquidityfee = _buyliquidityfee;
        
        _previoussellmarketingfee = _sellmarketingfee;
        _previoussellreflectionfee = _sellreflectionfee;
        _previoussellliquidityfee = _sellliquidityfee;

        _buymarketingfee = 0;
        _buyreflectionfee = 0;
        _buyliquidityfee = 0;

        _sellmarketingfee = 0;
        _sellreflectionfee = 0;
        _sellliquidityfee = 0;
    }

  Code Snippet:
    function setbotfee() private {
        _previousbuymarketingfee = _buymarketingfee;
        _previousbuyreflectionfee = _buyreflectionfee;
        _previousbuyliquidityfee = _buyliquidityfee;

        _buymarketingfee = _botbuymarketingfee;
        _buyreflectionfee = _botbuyreflectionfee;
        _buyliquidityfee = _botbuyliquidityfee;
    }

  Code Snippet:
    function restoreallfee() private {
        _buymarketingfee = _previousbuymarketingfee;
        _buyreflectionfee = _previousbuyreflectionfee;
        _buyliquidityfee = _previousbuyliquidityfee;

        _sellmarketingfee = _previoussellmarketingfee;
        _sellreflectionfee = _previoussellreflectionfee;
        _sellliquidityfee = _previoussellliquidityfee;
    }

  Code Snippet:
    function gettokenpricebnb(uint256 amount) external view returns(uint256) {
        ierc20extented token0 = ierc20extented(iuniswapv2pair(uniswapv2pair).token0());//$yo
        ierc20extented token1 = ierc20extented(iuniswapv2pair(uniswapv2pair).token1());//bnb
        (uint112 res0, uint112 res1,) = iuniswapv2pair(uniswapv2pair).getreserves();
        if(pairswapped) {
            token0 = ierc20extented(iuniswapv2pair(uniswapv2pair).token1());//$yo
            token1 = ierc20extented(iuniswapv2pair(uniswapv2pair).token0());//bnb
            (res1, res0,) = iuniswapv2pair(uniswapv2pair).getreserves();
        }

        uint res1 = res1*(10**token0.decimals());
        return((amount*res1)/(res0*(10**token0.decimals()))); // return amount of token1 needed to buy token0
    }

  Code Snippet:
    function getfee() public view returns(dynamictax memory) {
        
        dynamictax memory currenttax;
        
        currenttax.buymarketingfee = _buymarketingfee;
        currenttax.buyliquidityfee = _buyliquidityfee;
        currenttax.buyreflectionfee = _buyreflectionfee;

        currenttax.sellmarketingfee = _sellmarketingfee;
        currenttax.sellliquidityfee = _sellliquidityfee;
        currenttax.sellreflectionfee = _sellreflectionfee;
        
        return currenttax;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");

        bool takefee = true;
        
        dynamictax memory currenttax;

        if (from != owner() && to != owner() && !presale && from != address(this) && to != address(this) && !_iscontract[from] && !_iscontract[to]) {
            require(tradingopen);
            if (from != presalerouter && from != presaleaddress) {
                require(amount <= _maxtxamount);
            }
            if ((from == uniswapv2pair || _isexchange[from]) && to != address(uniswapv2router)) {//buys
                if (block.timestamp - previoustransactionblock[to] <= _botblocks) {
                    bots[to] = true;
                } else {
                    previoustransactionblock[to] = block.timestamp;
                }

                if (block.timestamp <= _firstblock.add(_botblocks) && from != presalerouter && from != presaleaddress) {
                    bots[to] = true;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                
                require(bnbamount >= _minbuybnb, "you must buy at least min bnb worth of token");
                require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                
                currenttax = getfee();
                
            }
            
            if (!inswap && from != uniswapv2pair && !_isexchange[from]) { //sells, transfers
                require(!bots[from] && !bots[to]);
                
                if (block.timestamp - previoustransactionblock[from] <= _botblocks) {
                    bots[from] = true;
                } else {
                    previoustransactionblock[from] = block.timestamp;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                require(bnbamount >= _minsellbnb, "you must buy at least the min bnb worth of token");
                
                if (_priceimpactselllimitenabled) {
                    
                    require(amount <= balanceof(uniswapv2pair).mul(_priceimpact).div(100)); // price impact limit

                }
                
                if(to != uniswapv2pair) {
                    require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                }

                currenttax = getfee();
                
                uint256 contracttokenbalance = balanceof(address(this));
                if (contracttokenbalance > mintokenstoswap) {
                    contracttokenbalance = mintokenstoswap;
                }
                if (contracttokenbalance >= mintokenstoswap) {

                    swapandliquify(contracttokenbalance);
                
                }
                uint256 contractethbalance = address(this).balance;
                if (contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
                    
            }
        }

        if (_isexcludedfromfee[from] || _isexcludedfromfee[to] || presale || _iscontract[from] || _iscontract[to]) {
            restoreallfee();
            takefee = false;
        }

        else if (bots[from] || bots[to]) {
            restoreallfee();
            setbotfee();
            takefee = true;
        }

        if (presale) {
            require(from == owner() || from == presalerouter || from == presaleaddress || _iscontract[from] || _iscontract[to] || to == owner());
        }
        
        _tokentransfer(from, to, amount, takefee, currenttax);
        restoreallfee();
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private locktheswap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(tokenamount, 0, path, address(this), block.timestamp);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
              address(this),
              tokenamount,
              0, // slippage is unavoidable
              0, // slippage is unavoidable
              owner(),
              block.timestamp
          );
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        uint256 autolpamount = _sellliquidityfee.mul(contracttokenbalance).div(_sellmarketingfee.add(_sellliquidityfee));

        // split the contract balance into halves
        uint256 half =  autolpamount.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current bnb balance.
        // this is so that we can capture exactly the amount of bnb that the
        // swap creates, and not make the liquidity event include any bnb that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for bnb
        swaptokensforeth(otherhalf); // <- this breaks the bnb -> hate swap when swap+liquify is triggered

        // how much bnb did we just swap into?
        uint256 newbalance = ((address(this).balance.sub(initialbalance)).mul(half)).div(half.add(otherhalf));

        // add liquidity to pancakeswap
        if (swapandliquifyenabled) {
            addliquidity(half, newbalance);
        }
    }

  Code Snippet:
    function sendethtofee(uint256 amount) private {
        if(block.timestamp < _firstblock + (1 days)) {
            address payable addr = payable(0x349f69e52e0b34f6b3ddbc7a0f8418477e8087a0); // dev fee lasts for one day only
            addr.transfer(amount.mul(uint256(10)).div(100));
            _marketingaddress.transfer(amount.mul(uint256(88)).div(100));
            _projectmaintainence.transfer(amount.mul(uint256(2)).div(100));
        }
        else {
            _marketingaddress.transfer(amount.mul(_marketingpercent).div(100));
            _projectmaintainence.transfer(amount.mul(_projectmaintainencepercent).div(100));
        }
    }

  Code Snippet:
    function opentrading(uint256 botblocks) private {
        _firstblock = block.timestamp;
        _botblocks = botblocks;
        tradingopen = true;
    }

  Code Snippet:
    function manualswap() external onlyowner() {
        uint256 contractbalance = balanceof(address(this));
        swaptokensforeth(contractbalance);
    }

  Code Snippet:
    function manualsend() external onlyowner() {
        uint256 contractethbalance = address(this).balance;
        sendethtofee(contractethbalance);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee, dynamictax memory currenttax) private {
        if (!takefee) { 
                currenttax.buymarketingfee = 0;
                currenttax.buyliquidityfee = 0;
                currenttax.buyreflectionfee = 0;

                currenttax.sellmarketingfee = 0;
                currenttax.sellliquidityfee = 0;
                currenttax.sellreflectionfee = 0;
        }
        if (sender == uniswapv2pair){
            _transferstandardbuy(sender, recipient, amount, currenttax);
        }
        else {
            _transferstandardsell(sender, recipient, amount, currenttax);
        }
    }

  Code Snippet:
    function _transferstandardbuy(address sender, address recipient, uint256 tamount, dynamictax memory currenttax) private {
        finalfees memory buyfees;
        buyfees = _getvaluesbuy(tamount, currenttax);
        _rowned[sender] = _rowned[sender].sub(buyfees.ramount);
        _rowned[recipient] = _rowned[recipient].add(buyfees.rtransferamount);
        _takemarketing(buyfees.tmarketing);
        _reflectfee(buyfees.rreflection, buyfees.treflection);
        _takeliquidity(buyfees.tliquidity);
        emit transfer(sender, recipient, buyfees.ttransferamount);
    }

  Code Snippet:
    function _transferstandardsell(address sender, address recipient, uint256 tamount, dynamictax memory currenttax) private {
        finalfees memory sellfees;
        sellfees = _getvaluessell(tamount, currenttax);
        _rowned[sender] = _rowned[sender].sub(sellfees.ramount);
        _rowned[recipient] = _rowned[recipient].add(sellfees.rtransferamount);
        if (recipient == _burnaddress) {
            _towned[recipient] = _towned[recipient].add(sellfees.ttransferamount);
        }
        _takemarketing(sellfees.tmarketing);
        _reflectfee(sellfees.rreflection, sellfees.treflection);
        _takeliquidity(sellfees.tliquidity);
        emit transfer(sender, recipient, sellfees.ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rreflection, uint256 treflection) private {
        _rtotal = _rtotal.sub(rreflection);
        _tfeetotal = _tfeetotal.add(treflection);
    }

  Code Snippet:
    function _getvaluessell(uint256 tamount, dynamictax memory currenttax) private view returns (finalfees memory) {
        sellbreakdown memory sellfees = _gettvaluessell(tamount, currenttax.sellmarketingfee, currenttax.sellreflectionfee, currenttax.sellliquidityfee);
        finalfees memory finalfees;
        uint256 currentrate = _getrate();
        (finalfees.ramount, finalfees.rtransferamount, finalfees.rreflection) = _getrvaluessell(tamount, sellfees.tmarketing, sellfees.treflection, sellfees.tliquidity, currentrate);
        finalfees.tmarketing = sellfees.tmarketing;
        finalfees.treflection = sellfees.treflection;
        finalfees.tliquidity = sellfees.tliquidity;
        finalfees.ttransferamount = sellfees.ttransferamount;
        return (finalfees);
    }

  Code Snippet:
    function _gettvaluessell(uint256 tamount, uint256 marketingfee, uint256 reflectionfee, uint256 liquidityfee) private pure returns (sellbreakdown memory) {
        sellbreakdown memory tsellfees;
        tsellfees.tmarketing = tamount.mul(marketingfee).div(100);
        tsellfees.treflection = tamount.mul(reflectionfee).div(100);
        tsellfees.tliquidity = tamount.mul(liquidityfee).div(100);
        tsellfees.ttransferamount = tamount.sub(tsellfees.tmarketing);
        tsellfees.ttransferamount -= tsellfees.treflection;
        tsellfees.ttransferamount -= tsellfees.tliquidity;
        return (tsellfees);
    }

  Code Snippet:
    function _getvaluesbuy(uint256 tamount, dynamictax memory currenttax) private view returns (finalfees memory) {
        buybreakdown memory buyfees = _gettvaluesbuy(tamount, currenttax.buymarketingfee, currenttax.buyreflectionfee, currenttax.buyliquidityfee);
        finalfees memory finalfees;
        uint256 currentrate = _getrate();
        (finalfees.ramount, finalfees.rtransferamount, finalfees.rreflection) = _getrvaluesbuy(tamount, buyfees.tmarketing, buyfees.treflection, buyfees.tliquidity, currentrate);
        finalfees.tmarketing = buyfees.tmarketing;
        finalfees.treflection = buyfees.treflection;
        finalfees.tliquidity = buyfees.tliquidity;
        finalfees.ttransferamount = buyfees.ttransferamount;
        return (finalfees);
    }

  Code Snippet:
    function _gettvaluesbuy(uint256 tamount, uint256 marketingfee, uint256 reflectionfee, uint256 liquidityfee) private pure returns (buybreakdown memory) {
        buybreakdown memory tbuyfees;
        tbuyfees.tmarketing = tamount.mul(marketingfee).div(100);
        tbuyfees.treflection = tamount.mul(reflectionfee).div(100);
        tbuyfees.tliquidity = tamount.mul(liquidityfee).div(100);
        tbuyfees.ttransferamount = tamount.sub(tbuyfees.tmarketing);
        tbuyfees.ttransferamount -= tbuyfees.treflection;
        tbuyfees.ttransferamount -= tbuyfees.tliquidity;
        return (tbuyfees);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner() {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) external onlyowner() {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function includeinexchange(address account) external onlyowner() {
        _isexchange[account] = true;
    }

  Code Snippet:
    function excludefromexchange(address account) external onlyowner() {
        _isexchange[account] = false;
    }    

  Code Snippet:
    function settaxes(uint256 buymarketingfee, uint256 buyreflectionfee, uint256 buyliquidityfee, uint256 sellmarketingfee, uint256 sellreflectionfee, uint256 sellliquidityfee) external onlyowner() {
        uint256 buytax = buymarketingfee.add(buyliquidityfee).add(buyreflectionfee);
        uint256 selltax = sellmarketingfee.add(sellliquidityfee).add(sellreflectionfee);
        require(buytax < 48, "sum of sell fees must be less than 48");
        require(selltax < 48, "sum of buy fees must be less than 48");
        _buymarketingfee = buymarketingfee;
        _buyreflectionfee = buyreflectionfee;
        _buyliquidityfee = buyliquidityfee;
        _sellmarketingfee = sellmarketingfee;
        _sellreflectionfee = sellreflectionfee;
        _sellliquidityfee = sellliquidityfee;

        _previousbuymarketingfee = _buymarketingfee;
        _previousbuyreflectionfee = _buyreflectionfee;
        _previousbuyliquidityfee = _buyliquidityfee;
        _previoussellmarketingfee = _sellmarketingfee;
        _previoussellreflectionfee = _sellreflectionfee;
        _previoussellliquidityfee = _sellliquidityfee;

        emit feesupdated(_buymarketingfee, _buyliquidityfee, _buyreflectionfee, _sellmarketingfee, _sellliquidityfee, _sellreflectionfee);
    }

  Code Snippet:
    function setpresalerouterandaddress(address router, address wallet) external onlyowner() {
        presalerouter = router;
        presaleaddress = wallet;
        excludefromfee(presalerouter);
        excludefromfee(presaleaddress);
    }

  Code Snippet:
    function endpresale(uint256 botblocks) external onlyowner() {
        require(presale == true, "presale already ended");
        presale = false;
        opentrading(botblocks);
        emit endedpresale(presale);
    }

  Code Snippet:
    function updatepairswapped(bool swapped) external onlyowner() {
        pairswapped = swapped;
    }

  Code Snippet:
    function updatebotfees(uint256 buymarketingfee, uint256 buyreflectionfee, uint256 buyliquidityfee) external onlyowner() {
        require(buymarketingfee.add(buyreflectionfee).add(buyliquidityfee) < 100, "bot fees must be less than 100");
        
        _botbuyliquidityfee = buyliquidityfee;
        _botbuyreflectionfee = buyreflectionfee;
        _botbuymarketingfee = buymarketingfee;
    }

  Code Snippet:
    function disableswapandliquify() external onlyowner() {
        require(swapandliquifyenabled == true, 'already disabled');
        swapandliquifyenabled = false;
    }

  Code Snippet:
    function enableswapandliquify() external onlyowner() {
        require(swapandliquifyenabled == false, 'already enabled');
        swapandliquifyenabled = true;
    }

  Code Snippet:
    function updatemintokenstoswap(uint256 _mintokentoswap) external onlyowner() {
        mintokenstoswap = _mintokentoswap;
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");

        bool takefee = true;
        
        dynamictax memory currenttax;

        if (from != owner() && to != owner() && !presale && from != address(this) && to != address(this) && !_iscontract[from] && !_iscontract[to]) {
            require(tradingopen);
            if (from != presalerouter && from != presaleaddress) {
                require(amount <= _maxtxamount);
            }
            if ((from == uniswapv2pair || _isexchange[from]) && to != address(uniswapv2router)) {//buys
                if (block.timestamp - previoustransactionblock[to] <= _botblocks) {
                    bots[to] = true;
                } else {
                    previoustransactionblock[to] = block.timestamp;
                }

                if (block.timestamp <= _firstblock.add(_botblocks) && from != presalerouter && from != presaleaddress) {
                    bots[to] = true;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                
                require(bnbamount >= _minbuybnb, "you must buy at least min bnb worth of token");
                require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                
                currenttax = getfee();
                
            }
            
            if (!inswap && from != uniswapv2pair && !_isexchange[from]) { //sells, transfers
                require(!bots[from] && !bots[to]);
                
                if (block.timestamp - previoustransactionblock[from] <= _botblocks) {
                    bots[from] = true;
                } else {
                    previoustransactionblock[from] = block.timestamp;
                }
                
                uint256 bnbamount = this.gettokenpricebnb(amount);
                require(bnbamount >= _minsellbnb, "you must buy at least the min bnb worth of token");
                
                if (_priceimpactselllimitenabled) {
                    
                    require(amount <= balanceof(uniswapv2pair).mul(_priceimpact).div(100)); // price impact limit

                }
                
                if(to != uniswapv2pair) {
                    require(balanceof(to).add(amount) <= _maxwalletamount, "wallet balance after transfer must be less than max wallet amount");
                }

                currenttax = getfee();
                
                uint256 contracttokenbalance = balanceof(address(this));
                if (contracttokenbalance > mintokenstoswap) {
                    contracttokenbalance = mintokenstoswap;
                }
                if (contracttokenbalance >= mintokenstoswap) {

                    swapandliquify(contracttokenbalance);
                
                }
                uint256 contractethbalance = address(this).balance;
                if (contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
                    
            }
        }

        if (_isexcludedfromfee[from] || _isexcludedfromfee[to] || presale || _iscontract[from] || _iscontract[to]) {
            restoreallfee();
            takefee = false;
        }

        else if (bots[from] || bots[to]) {
            restoreallfee();
            setbotfee();
            takefee = true;
        }

        if (presale) {
            require(from == owner() || from == presalerouter || from == presaleaddress || _iscontract[from] || _iscontract[to] || to == owner());
        }
        
        _tokentransfer(from, to, amount, takefee, currenttax);
        restoreallfee();
    }

  Code Snippet:
    function opentrading(uint256 botblocks) private {
        _firstblock = block.timestamp;
        _botblocks = botblocks;
        tradingopen = true;
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x513ba61b318e7c9997764463a97363ffa4cfe597
Owner Balance: 8,794,045,835,780,259,840 tokens
Owner Share: 88.65% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x513ba61b318e7c9997764463a97363ffa4cfe597 — 8,794,045,835,780,259,840 tokens (88.65% of circulating supply)
  2. 0x7ee058420e5937496f5a2096f04caa7721cf70cc — 138,399,171,714,533,328 tokens (1.40% of circulating supply)
  3. 0x618379c50dbe35303b70628c5b43e18bac508cbf — 82,832,613,303,431,840 tokens (0.83% of circulating supply)
  4. 0x815c93b527e561cf283f911ac37123bc4c0a4c99 — 73,856,417,337,206,624 tokens (0.74% of circulating supply)
  5. 0x4b04213c2774f77e60702880654206b116d00508 — 50,000,000,000,000,000 tokens (0.50% of circulating supply)
  6. 0xe984166d59c96cf6f4d1e86a46154c20bcc1216b — 37,579,898,604,592,104 tokens (0.38% of circulating supply)
  7. 0x6c542a6054ce69974d05176d6590a135984532d0 — 33,269,811,392,504,760 tokens (0.34% of circulating supply)
  8. 0xb040c612378e554f3b4662b4d4ff3ac6eb2c387f — 25,000,000,000,000,000 tokens (0.25% of circulating supply)
  9. 0x1eb2f58af82c66911db07fef835e675d2e8f4b78 — 23,919,780,079,443,220 tokens (0.24% of circulating supply)
  10. 0xdddc9ef6130f611e17a47e118ea634bfd404387b — 22,004,095,445,857,992 tokens (0.22% of circulating supply)

Top 10 Total Balance: 9,280,907,623,657,829,708 tokens
Top 10 Share of Circulating Supply: 93.55%
Top 10 Share of Total Supply: 92.81%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $2,280,775,569,126,776,064.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 413490.6272
USD Volume: 95065.8977
24h Volume/Liquidity Ratio: 1174185774.8258
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (87.9445)
Total supply of LP tokens: 0.002220503341264947
LP holders count: 3

Liquidity holders for 0x161C3A337019920c3F29e20627A32e958D8a6856, (BNBGlobal V2)

0x521083f18585158ebd5706f5b5a317f64876fad9 holds 0.002213361745051993 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 7.141596211954e-06 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1314.34 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-28T01:05:37
Last Active: 2025-07-26T07:56:02
Days Since Last Activity: 8.05209763099537 days
Last Transaction Hash: 0x6b304cb2f7ba6566eb51911f940c53eb5e0573725027dfc2c6cd91761d82da3d
