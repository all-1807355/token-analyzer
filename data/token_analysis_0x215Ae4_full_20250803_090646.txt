Token Analysis Report
==================================================
Token: BABY SANTA TOKEN v2 (0x215Ae47ecC7A297d3E20126c3e05E735F548f1d3)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
	function _mint(address account, uint256 amount) internal virtual {
		require(account != address(0), "erc20: mint to the zero address");
		_beforetokentransfer(address(0), account, amount);
		_totalsupply = _totalsupply.add(amount);
		_balances[account] = _balances[account].add(amount);
		emit transfer(address(0), account, amount);
	}

  Code Snippet:
	function _withdrawdividendofuser(address payable user) internal returns (uint256) {
		uint256 _withdrawabledividend = withdrawabledividendof(user);
		if (_withdrawabledividend > 0) {
			withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
			emit dividendwithdrawn(user, _withdrawabledividend);
			if (rewardtoken == address(0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c)) {
			(bool success,) = user.call{value: _withdrawabledividend, gas: 3000}("");
				if(!success) {
					withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
					return 0;
				}
				return _withdrawabledividend;
			} else {
				return swapbnbfortokensandwithdrawdividend(user, _withdrawabledividend);
			}
		}
		return 0;
	}

  Code Snippet:
	function swapbnbfortokensandwithdrawdividend(address holder, uint256 bnbamount) private returns(uint256) {
		address[] memory path = new address[](2);
		path[0] = uniswapv2router.weth();
		path[1] = address(rewardtoken);

		try uniswapv2router.swapexactethfortokenssupportingfeeontransfertokens{value : bnbamount}(
			0, // accept any amount of tokens
			path,
			address(holder),
			block.timestamp
		) {
			return bnbamount;
		} catch {
			withdrawndividends[holder] = withdrawndividends[holder].sub(bnbamount);
			return 0;
		}
	}

  Code Snippet:
	function _mint(address account, uint256 value) internal override {
		super._mint(account, value);
		magnifieddividendcorrections[account] = magnifieddividendcorrections[account]
		.sub( (magnifieddividendpershare.mul(value)).toint256safe() );
	}

  Code Snippet:
	function _setbalance(address account, uint256 newbalance) internal {
		uint256 currentbalance = balanceof(account);
		if(newbalance > currentbalance) {
			uint256 mintamount = newbalance.sub(currentbalance);
			_mint(account, mintamount);
		} else if(newbalance < currentbalance) {
			uint256 burnamount = currentbalance.sub(newbalance);
			_burn(account, burnamount);
		}
	}

  Code Snippet:
	function _setrewardtoken(address token) internal onlyowner {
		rewardtoken = token;
	}

  Code Snippet:
	function setminimumtokensbeforeswap(uint256 newvalue) public onlyowner {
		require(newvalue != minimumtokensbeforeswap, "babysanta: cannot update minimumtokensbeforeswap to same value");
		emit mintokenamountbeforeswapchange(newvalue, minimumtokensbeforeswap);
		minimumtokensbeforeswap = newvalue;
	}

  Code Snippet:
	function updateclaimwait(uint256 claimwait) external onlyowner {
		dividendtracker.updateclaimwait(claimwait);
	}

  Code Snippet:
	function processdividendtracker(uint256 gas) external {
		(uint256 iterations, uint256 claims, uint256 lastprocessedindex) = dividendtracker.process(gas);
		emit processeddividendtracker(iterations, claims, lastprocessedindex, false, gas, tx.origin);
	}

  Code Snippet:
	function claim() external {
		dividendtracker.processaccount(payable(msg.sender), false);
	}

  Code Snippet:
	function setdividendtoken(address newdividendtoken) external onlyowner {
		require(newdividendtoken != dividendtoken, "babysanta: cannot update dividend token to same value");
		require(newdividendtoken != address(0), "babysanta: the dividend token cannot be 0");
		require(newdividendtoken != address(this), "babysanta: the dividend token cannot be set to the current contract");
		emit dividendtokenchange(newdividendtoken, dividendtoken);
		dividendtoken = newdividendtoken;
		dividendtracker.setrewardtoken(dividendtoken);
	}

  Code Snippet:
	function claimbnboverflow(uint256 amount) external onlyowner {
		require(amount < address(this).balance, "babysanta: cannot send more than contract balance");
		(bool success,) = address(owner()).call{value : amount}("");
		if (success){
			emit claimbnboverflow(amount);
		}
	}

  Code Snippet:
	function getclaimwait() external view returns(uint256) {
		return dividendtracker.claimwait();
	}

  Code Snippet:
	function setrewardtoken(address token) external onlyowner {
		_setrewardtoken(token);
	}

  Code Snippet:
	function updateclaimwait(uint256 newclaimwait) external onlyowner {
		require(newclaimwait >= 3600 && newclaimwait <= 86400, "babysanta_dividend_tracker: claimwait must be updated to between 1 and 24 hours");
		require(newclaimwait != claimwait, "babysanta_dividend_tracker: cannot update claimwait to same value");
		emit claimwaitupdated(newclaimwait, claimwait);
		claimwait = newclaimwait;
	}

  Code Snippet:
	function canautoclaim(uint256 lastclaimtime) private view returns (bool) {
		if(lastclaimtime > block.timestamp)  {
			return false;
		}
		return block.timestamp.sub(lastclaimtime) >= claimwait;
	}

  Code Snippet:
	function process(uint256 gas) public returns (uint256, uint256, uint256) {
		uint256 numberoftokenholders = tokenholdersmap.keys.length;
		if(numberoftokenholders == 0) {
			return (0, 0, lastprocessedindex);
		}

		uint256 _lastprocessedindex = lastprocessedindex;
		uint256 gasused = 0;
		uint256 gasleft = gasleft();
		uint256 iterations = 0;
		uint256 claims = 0;

		while(gasused < gas && iterations < numberoftokenholders) {
			_lastprocessedindex++;
			if(_lastprocessedindex >= tokenholdersmap.keys.length) {
				_lastprocessedindex = 0;
			}
			address account = tokenholdersmap.keys[_lastprocessedindex];
			if(canautoclaim(lastclaimtimes[account])) {
				if(processaccount(payable(account), true)) {
					claims++;
				}
			}

			iterations++;
			uint256 newgasleft = gasleft();
			if(gasleft > newgasleft) {
				gasused = gasused.add(gasleft.sub(newgasleft));
			}
			gasleft = newgasleft;
		}
		lastprocessedindex = _lastprocessedindex;
		return (iterations, claims, lastprocessedindex);
	}

  Code Snippet:
	function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
		uint256 amount = _withdrawdividendofuser(account);
		if(amount > 0) {
			lastclaimtimes[account] = block.timestamp;
			emit claim(account, amount, automatic);
			return true;
		}
		return false;
	}

WARNING: Ownership Renounced
  Code Snippet:
	function renounceownership() public virtual onlyowner {
		emit ownershiptransferred(_owner, address(0));
		_owner = address(0);
	}

WARNING: Is Honeypot Suspected
  Code Snippet:
	function _withdrawdividendofuser(address payable user) internal returns (uint256) {
		uint256 _withdrawabledividend = withdrawabledividendof(user);
		if (_withdrawabledividend > 0) {
			withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
			emit dividendwithdrawn(user, _withdrawabledividend);
			if (rewardtoken == address(0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c)) {
			(bool success,) = user.call{value: _withdrawabledividend, gas: 3000}("");
				if(!success) {
					withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
					return 0;
				}
				return _withdrawabledividend;
			} else {
				return swapbnbfortokensandwithdrawdividend(user, _withdrawabledividend);
			}
		}
		return 0;
	}

  Code Snippet:
	function swapbnbfortokensandwithdrawdividend(address holder, uint256 bnbamount) private returns(uint256) {
		address[] memory path = new address[](2);
		path[0] = uniswapv2router.weth();
		path[1] = address(rewardtoken);

		try uniswapv2router.swapexactethfortokenssupportingfeeontransfertokens{value : bnbamount}(
			0, // accept any amount of tokens
			path,
			address(holder),
			block.timestamp
		) {
			return bnbamount;
		} catch {
			withdrawndividends[holder] = withdrawndividends[holder].sub(bnbamount);
			return 0;
		}
	}

  Code Snippet:
	function _setrewardtoken(address token) internal onlyowner {
		rewardtoken = token;
	}

  Code Snippet:
	function setdividendtoken(address newdividendtoken) external onlyowner {
		require(newdividendtoken != dividendtoken, "babysanta: cannot update dividend token to same value");
		require(newdividendtoken != address(0), "babysanta: the dividend token cannot be 0");
		require(newdividendtoken != address(this), "babysanta: the dividend token cannot be set to the current contract");
		emit dividendtokenchange(newdividendtoken, dividendtoken);
		dividendtoken = newdividendtoken;
		dividendtracker.setrewardtoken(dividendtoken);
	}

  Code Snippet:
	function setrewardtoken(address token) external onlyowner {
		_setrewardtoken(token);
	}

WARNING: Delayed Trading Detected
  Code Snippet:
	function launch() public onlyowner {
		_launchstarttimestamp = _getnow();
		_launchblocknumber = block.number;
		istradingenabled = true;
		_islanched = true;
	}

  Code Snippet:
	function isinlaunch() external view returns (bool) {
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 totallaunchtime =  _launch1.timeinperiod.add(_launch2.timeinperiod).add(_launch3.timeinperiod);

		if(_islanched && (timesincelaunch < totallaunchtime || blockssincelaunch < _launch1.blocksinperiod )) {
			return true;
		} else {
			return false;
		}
	}

  Code Snippet:
	function _adjusttaxes(bool isbuyfromlp, bool isselltolp) private {
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 timeinlaunch = _launch3.timeinperiod.add(_launch2.timeinperiod);
		uint256 timesincecharity = currenttimestamp.sub(_charityhourstarttimestamp);
		_liquidityfee = 0;
		_marketingfee = 0;
		_buybackfee = 0;
		_stakingfee = 0;
		_holdersfee = 0;

		if (isbuyfromlp) {
			_liquidityfee = _base.liquidityfeeonbuy;
			_marketingfee = _base.marketingfeeonbuy;
			_buybackfee = _base.buybackfeeonbuy;
			_stakingfee = _base.stakingfeeonbuy;
			_holdersfee = _base.holdersfeeonbuy;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonbuy;
				_marketingfee = _launch1.marketingfeeonbuy;
				_buybackfee = _launch1.buybackfeeonbuy;
				_stakingfee = _launch1.stakingfeeonbuy;
				_holdersfee = _launch1.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonbuy;
				_marketingfee = _launch2.marketingfeeonbuy;
				_buybackfee = _launch2.buybackfeeonbuy;
				_stakingfee = _launch2.stakingfeeonbuy;
				_holdersfee = _launch2.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonbuy;
				_marketingfee = _launch3.marketingfeeonbuy;
				_buybackfee = _launch3.buybackfeeonbuy;
				_stakingfee = _launch3.stakingfeeonbuy;
				_holdersfee = _launch3.holdersfeeonbuy;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonbuy;
				_marketingfee = _charity1.marketingfeeonbuy;
				_buybackfee = _charity1.buybackfeeonbuy;
				_stakingfee = _charity1.stakingfeeonbuy;
				_holdersfee = _charity1.holdersfeeonbuy;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonbuy;
				_marketingfee = _charity2.marketingfeeonbuy;
				_buybackfee = _charity2.buybackfeeonbuy;
				_stakingfee = _charity2.stakingfeeonbuy;
				_holdersfee = _charity2.holdersfeeonbuy;
			}
		}
		if (isselltolp) {
			_liquidityfee = _base.liquidityfeeonsell;
			_marketingfee = _base.marketingfeeonsell;
			_buybackfee = _base.buybackfeeonsell;
			_stakingfee = _base.stakingfeeonsell;
			_holdersfee = _base.holdersfeeonsell;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonsell;
				_marketingfee = _launch1.marketingfeeonsell;
				_buybackfee = _launch1.buybackfeeonsell;
				_stakingfee = _launch1.stakingfeeonsell;
				_holdersfee = _launch1.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonsell;
				_marketingfee = _launch2.marketingfeeonsell;
				_buybackfee = _launch2.buybackfeeonsell;
				_stakingfee = _launch2.stakingfeeonsell;
				_holdersfee = _launch2.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonsell;
				_marketingfee = _launch3.marketingfeeonsell;
				_buybackfee = _launch3.buybackfeeonsell;
				_stakingfee = _launch3.stakingfeeonsell;
				_holdersfee = _launch3.holdersfeeonsell;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonsell;
				_marketingfee = _charity1.marketingfeeonsell;
				_buybackfee = _charity1.buybackfeeonsell;
				_stakingfee = _charity1.stakingfeeonsell;
				_holdersfee = _charity1.holdersfeeonsell;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonsell;
				_marketingfee = _charity2.marketingfeeonsell;
				_buybackfee = _charity2.buybackfeeonsell;
				_stakingfee = _charity2.stakingfeeonsell;
				_holdersfee = _charity2.holdersfeeonsell;
			}
		}
		_totalfee = _liquidityfee.add(_marketingfee).add(_buybackfee).add(_stakingfee).add(_holdersfee);
	}

WARNING: High Tax Detected
  Code Snippet:
	function feetosetter() external view returns (address);


  Code Snippet:
	function setfeetosetter(address) external;
}

  Code Snippet:
	function swapexacttokensfortokens(
		uint amountin,

  Code Snippet:
	function swaptokensforexacttokens(
		uint amountout,

  Code Snippet:
	function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
	external

  Code Snippet:
	function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
	external

  Code Snippet:
	function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
	external

  Code Snippet:
	function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
	external

  Code Snippet:
	function removeliquidityethsupportingfeeontransfertokens(
		address token,

  Code Snippet:
	function removeliquidityethwithpermitsupportingfeeontransfertokens(
		address token,

  Code Snippet:
	function swapexacttokensfortokenssupportingfeeontransfertokens(
		uint amountin,

  Code Snippet:
	function swapexactethfortokenssupportingfeeontransfertokens(
		uint amountoutmin,

  Code Snippet:
	function swapexacttokensforethsupportingfeeontransfertokens(
		uint amountin,

  Code Snippet:
	function withdrawdividend() external;
	event dividendsdistributed(

  Code Snippet:
	function withdrawdividend() public virtual override onlyowner {
		_withdrawdividendofuser(payable(msg.sender));
	}

  Code Snippet:
	function _withdrawdividendofuser(address payable user) internal returns (uint256) {
		uint256 _withdrawabledividend = withdrawabledividendof(user);
		if (_withdrawabledividend > 0) {
			withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
			emit dividendwithdrawn(user, _withdrawabledividend);
			if (rewardtoken == address(0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c)) {
			(bool success,) = user.call{value: _withdrawabledividend, gas: 3000}("");
				if(!success) {
					withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
					return 0;
				}
				return _withdrawabledividend;
			} else {
				return swapbnbfortokensandwithdrawdividend(user, _withdrawabledividend);
			}
		}
		return 0;
	}

  Code Snippet:
	function swapbnbfortokensandwithdrawdividend(address holder, uint256 bnbamount) private returns(uint256) {
		address[] memory path = new address[](2);
		path[0] = uniswapv2router.weth();
		path[1] = address(rewardtoken);

		try uniswapv2router.swapexactethfortokenssupportingfeeontransfertokens{value : bnbamount}(
			0, // accept any amount of tokens
			path,
			address(holder),
			block.timestamp
		) {
			return bnbamount;
		} catch {
			withdrawndividends[holder] = withdrawndividends[holder].sub(bnbamount);
			return 0;
		}
	}

  Code Snippet:
	function dividendof(address _owner) public view override returns(uint256) {
		return withdrawabledividendof(_owner);
	}

  Code Snippet:
	function withdrawabledividendof(address _owner) public view override returns(uint256) {
		return accumulativedividendof(_owner).sub(withdrawndividends[_owner]);
	}

  Code Snippet:
	function withdrawndividendof(address _owner) public view override returns(uint256) {
		return withdrawndividends[_owner];
	}

  Code Snippet:
	function _setuniswaprouter(address router) internal onlyowner {
		uniswapv2router = iuniswapv2router02(router);
	}

  Code Snippet:
	function launch() public onlyowner {
		_launchstarttimestamp = _getnow();
		_launchblocknumber = block.number;
		istradingenabled = true;
		_islanched = true;
	}

  Code Snippet:
	function activatetrading() public onlyowner {
		istradingenabled = true;
	}

  Code Snippet:
	function deactivatetrading() public onlyowner {
		istradingenabled = false;
		_tradingpausedtimestamp = _getnow();
	}

  Code Snippet:
	function setcharityhour() public onlyowner {
		require(!this.isincharityhour(), "babysanta: charity hour is already set");
		require(istradingenabled, "babysanta: trading must be enabled first");
		require(!this.isinlaunch(), "babysanta: must not be in launch period");
		emit charityhourchange(true, false);
		_charityhourstarttimestamp = _getnow();
	}

  Code Snippet:
	function updatedividendtracker(address newaddress) public onlyowner {
		require(newaddress != address(dividendtracker), "babysanta: the dividend tracker already has that address");
		babysantadividendtracker newdividendtracker = babysantadividendtracker(payable(newaddress));
		require(newdividendtracker.owner() == address(this), "babysanta: the new dividend tracker must be owned by the babysanta token contract");
		newdividendtracker.excludefromdividends(address(newdividendtracker));
		newdividendtracker.excludefromdividends(address(this));
		newdividendtracker.excludefromdividends(owner());
		newdividendtracker.excludefromdividends(address(uniswapv2router));
		newdividendtracker.excludefromdividends(address(uniswapv2pair));
		emit dividendtrackerchange(newaddress, address(dividendtracker));

		dividendtracker = newdividendtracker;
	}

  Code Snippet:
	function excludefromfees(address account, bool excluded) public onlyowner {
		require(_isexcludedfromfee[account] != excluded, "babysanta: account is already the value of 'excluded'");
		_isexcludedfromfee[account] = excluded;
		emit excludefromfeeschange(account, excluded);
	}

  Code Snippet:
	function setallfeestozero() public onlyowner {
		_setcustombuytaxperiod(_base, 0, 0, 0, 0, 0);
		emit feechange('basefees-buy', 0, 0, 0, 0, 0);
		_setcustomselltaxperiod(_base, 0, 0, 0, 0, 0);
		emit feechange('basefees-sell', 0, 0, 0, 0, 0);
	}

  Code Snippet:
	function resetallfees() public onlyowner {
		_setcustombuytaxperiod(_base, _default.liquidityfeeonbuy, _default.marketingfeeonbuy, _default.buybackfeeonbuy, _default.stakingfeeonbuy, _default.holdersfeeonbuy);
		emit feechange('basefees-buy', _default.liquidityfeeonbuy, _default.marketingfeeonbuy, _default.buybackfeeonbuy, _default.stakingfeeonbuy,  _default.holdersfeeonbuy);
		_setcustomselltaxperiod(_base, _default.liquidityfeeonsell, _default.marketingfeeonsell, _default.buybackfeeonsell, _default.stakingfeeonsell,  _default.holdersfeeonsell);
		emit feechange('basefees-sell', _default.liquidityfeeonsell, _default.marketingfeeonsell, _default.buybackfeeonsell, _default.stakingfeeonsell, _default.holdersfeeonsell);
	}

  Code Snippet:
	function setbasefeesonbuy(uint256 _liquidityfeeonbuy, uint256 _marketingfeeonbuy, uint256 _buybackfeeonbuy, uint256 _stakingfeeonbuy, uint256 _holdersfeeonbuy) public onlyowner {
		_setcustombuytaxperiod(_base, _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
		emit feechange('basefees-buy', _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
	}

  Code Snippet:
	function setbasefeesonsell(uint256 _liquidityfeeonsell,uint256 _marketingfeeonsell, uint256 _buybackfeeonsell, uint256 _stakingfeeonsell, uint256 _holdersfeeonsell) public onlyowner {
		_setcustomselltaxperiod(_base, _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
		emit feechange('basefees-sell', _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
	}

  Code Snippet:
	function setlaunch2feesonbuy(uint256 _liquidityfeeonbuy, uint256 _marketingfeeonbuy, uint256 _buybackfeeonbuy, uint256 _stakingfeeonbuy, uint256 _holdersfeeonbuy) public onlyowner {
		_setcustombuytaxperiod(_launch2, _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
		emit feechange('launch2fees-buy', _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
	}

  Code Snippet:
	function setlaunch2feesonsell(uint256 _liquidityfeeonsell,uint256 _marketingfeeonsell, uint256 _buybackfeeonsell, uint256 _stakingfeeonsell, uint256 _holdersfeeonsell) public onlyowner {
		_setcustomselltaxperiod(_launch2, _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
		emit feechange('launch2fees-sell', _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
	}

  Code Snippet:
	function setlaunch3feesonbuy(uint256 _liquidityfeeonbuy, uint256 _marketingfeeonbuy, uint256 _buybackfeeonbuy, uint256 _stakingfeeonbuy, uint256 _holdersfeeonbuy) public onlyowner {
		_setcustombuytaxperiod(_launch3, _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
		emit feechange('launch3fees-buy', _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
	}

  Code Snippet:
	function setlaunch3feesonsell(uint256 _liquidityfeeonsell,uint256 _marketingfeeonsell, uint256 _buybackfeeonsell, uint256 _stakingfeeonsell, uint256 _holdersfeeonsell) public onlyowner {
		_setcustomselltaxperiod(_launch3, _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
		emit feechange('launch3fees-sell', _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
	}

  Code Snippet:
	function setcharityhour1buyfees(uint256 _liquidityfeeonbuy,uint256 _marketingfeeonbuy, uint256 _buybackfeeonbuy, uint256 _stakingfeeonbuy, uint256 _holdersfeeonbuy) public onlyowner {
		_setcustombuytaxperiod(_charity1, _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
		emit feechange('charity1fees-buy', _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
	}

  Code Snippet:
	function setcharityhour1sellfees(uint256 _liquidityfeeonsell,uint256 _marketingfeeonsell, uint256 _buybackfeeonsell, uint256 _stakingfeeonsell, uint256 _holdersfeeonsell) public onlyowner {
		_setcustomselltaxperiod(_charity1, _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
		emit feechange('charity1fees-sell', _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
	}

  Code Snippet:
	function setcharityhour2buyfees(uint256 _liquidityfeeonbuy,uint256 _marketingfeeonbuy, uint256 _buybackfeeonbuy, uint256 _stakingfeeonbuy, uint256 _holdersfeeonbuy) public onlyowner {
		_setcustombuytaxperiod(_charity2, _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
		emit feechange('charity2fees-buy', _liquidityfeeonbuy, _marketingfeeonbuy, _buybackfeeonbuy, _stakingfeeonbuy, _holdersfeeonbuy);
	}

  Code Snippet:
	function setcharityhour2sellfees(uint256 _liquidityfeeonsell,uint256 _marketingfeeonsell, uint256 _buybackfeeonsell, uint256 _stakingfeeonsell, uint256 _holdersfeeonsell) public onlyowner {
		_setcustomselltaxperiod(_charity2, _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
		emit feechange('charity2fees-sell', _liquidityfeeonsell, _marketingfeeonsell, _buybackfeeonsell, _stakingfeeonsell, _holdersfeeonsell);
	}

  Code Snippet:
	function setuniswaprouter(address newaddress) public onlyowner {
		require(newaddress != address(uniswapv2router), "babysanta: the router already has that address");
		emit uniswapv2routerchange(newaddress, address(uniswapv2router));
		uniswapv2router = iuniswapv2router02(newaddress);
		dividendtracker.setuniswaprouter(newaddress);
	}

  Code Snippet:
	function setminimumtokensbeforeswap(uint256 newvalue) public onlyowner {
		require(newvalue != minimumtokensbeforeswap, "babysanta: cannot update minimumtokensbeforeswap to same value");
		emit mintokenamountbeforeswapchange(newvalue, minimumtokensbeforeswap);
		minimumtokensbeforeswap = newvalue;
	}

  Code Snippet:
	function timesincelastcharityhour() external view returns(uint256){
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _charityhourstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		return currenttimestamp.sub(_charityhourstarttimestamp);
	}

  Code Snippet:
	function isincharityhour() external view returns (bool) {
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _charityhourstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 totalcharitytime = _charity1.timeinperiod.add(_charity2.timeinperiod);
		uint256 timesincecharity = currenttimestamp.sub(_charityhourstarttimestamp);
		if(timesincecharity < totalcharitytime) {
			return true;
		} else {
			return false;
		}
	}

  Code Snippet:
	function isinlaunch() external view returns (bool) {
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 totallaunchtime =  _launch1.timeinperiod.add(_launch2.timeinperiod).add(_launch3.timeinperiod);

		if(_islanched && (timesincelaunch < totallaunchtime || blockssincelaunch < _launch1.blocksinperiod )) {
			return true;
		} else {
			return false;
		}
	}

  Code Snippet:
	function withdrawabledividendof(address account) public view returns(uint256) {
		return dividendtracker.withdrawabledividendof(account);
	}

  Code Snippet:
	function getbasebuyfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_base.liquidityfeeonbuy, _base.marketingfeeonbuy, _base.buybackfeeonbuy, _base.stakingfeeonbuy, _base.holdersfeeonbuy);
	}

  Code Snippet:
	function getbasesellfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_base.liquidityfeeonsell, _base.marketingfeeonsell, _base.buybackfeeonsell, _base.stakingfeeonsell, _base.holdersfeeonsell);
	}

  Code Snippet:
	function getcharity1buyfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_charity1.liquidityfeeonbuy, _charity1.marketingfeeonbuy, _charity1.buybackfeeonbuy, _charity1.stakingfeeonbuy, _charity1.holdersfeeonbuy);
	}

  Code Snippet:
	function getcharity1sellfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_charity1.liquidityfeeonsell, _charity1.marketingfeeonsell, _charity1.buybackfeeonsell, _charity1.stakingfeeonsell, _charity1.holdersfeeonsell);
	}

  Code Snippet:
	function getcharity2buyfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_charity2.liquidityfeeonbuy, _charity2.marketingfeeonbuy, _charity2.buybackfeeonbuy, _charity2.stakingfeeonbuy, _charity2.holdersfeeonbuy);
	}

  Code Snippet:
	function getcharity2sellfees() external view returns (uint256, uint256, uint256, uint256, uint256){
		return (_charity2.liquidityfeeonsell, _charity2.marketingfeeonsell, _charity2.buybackfeeonsell, _charity2.stakingfeeonsell, _charity2.holdersfeeonsell);
	}

  Code Snippet:
	function _adjusttaxes(bool isbuyfromlp, bool isselltolp) private {
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 timeinlaunch = _launch3.timeinperiod.add(_launch2.timeinperiod);
		uint256 timesincecharity = currenttimestamp.sub(_charityhourstarttimestamp);
		_liquidityfee = 0;
		_marketingfee = 0;
		_buybackfee = 0;
		_stakingfee = 0;
		_holdersfee = 0;

		if (isbuyfromlp) {
			_liquidityfee = _base.liquidityfeeonbuy;
			_marketingfee = _base.marketingfeeonbuy;
			_buybackfee = _base.buybackfeeonbuy;
			_stakingfee = _base.stakingfeeonbuy;
			_holdersfee = _base.holdersfeeonbuy;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonbuy;
				_marketingfee = _launch1.marketingfeeonbuy;
				_buybackfee = _launch1.buybackfeeonbuy;
				_stakingfee = _launch1.stakingfeeonbuy;
				_holdersfee = _launch1.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonbuy;
				_marketingfee = _launch2.marketingfeeonbuy;
				_buybackfee = _launch2.buybackfeeonbuy;
				_stakingfee = _launch2.stakingfeeonbuy;
				_holdersfee = _launch2.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonbuy;
				_marketingfee = _launch3.marketingfeeonbuy;
				_buybackfee = _launch3.buybackfeeonbuy;
				_stakingfee = _launch3.stakingfeeonbuy;
				_holdersfee = _launch3.holdersfeeonbuy;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonbuy;
				_marketingfee = _charity1.marketingfeeonbuy;
				_buybackfee = _charity1.buybackfeeonbuy;
				_stakingfee = _charity1.stakingfeeonbuy;
				_holdersfee = _charity1.holdersfeeonbuy;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonbuy;
				_marketingfee = _charity2.marketingfeeonbuy;
				_buybackfee = _charity2.buybackfeeonbuy;
				_stakingfee = _charity2.stakingfeeonbuy;
				_holdersfee = _charity2.holdersfeeonbuy;
			}
		}
		if (isselltolp) {
			_liquidityfee = _base.liquidityfeeonsell;
			_marketingfee = _base.marketingfeeonsell;
			_buybackfee = _base.buybackfeeonsell;
			_stakingfee = _base.stakingfeeonsell;
			_holdersfee = _base.holdersfeeonsell;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonsell;
				_marketingfee = _launch1.marketingfeeonsell;
				_buybackfee = _launch1.buybackfeeonsell;
				_stakingfee = _launch1.stakingfeeonsell;
				_holdersfee = _launch1.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonsell;
				_marketingfee = _launch2.marketingfeeonsell;
				_buybackfee = _launch2.buybackfeeonsell;
				_stakingfee = _launch2.stakingfeeonsell;
				_holdersfee = _launch2.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonsell;
				_marketingfee = _launch3.marketingfeeonsell;
				_buybackfee = _launch3.buybackfeeonsell;
				_stakingfee = _launch3.stakingfeeonsell;
				_holdersfee = _launch3.holdersfeeonsell;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonsell;
				_marketingfee = _charity1.marketingfeeonsell;
				_buybackfee = _charity1.buybackfeeonsell;
				_stakingfee = _charity1.stakingfeeonsell;
				_holdersfee = _charity1.holdersfeeonsell;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonsell;
				_marketingfee = _charity2.marketingfeeonsell;
				_buybackfee = _charity2.buybackfeeonsell;
				_stakingfee = _charity2.stakingfeeonsell;
				_holdersfee = _charity2.holdersfeeonsell;
			}
		}
		_totalfee = _liquidityfee.add(_marketingfee).add(_buybackfee).add(_stakingfee).add(_holdersfee);
	}

  Code Snippet:
	function _setcustomselltaxperiod(customtaxperiod storage map,
		uint256 _liquidityfeeonsell,

  Code Snippet:
	function _setcustombuytaxperiod(customtaxperiod storage map,
		uint256 _liquidityfeeonbuy,

  Code Snippet:
	function _swapandliquify() private {
		uint256 contractbalance = balanceof(address(this));
		uint256 initialbnbbalance = address(this).balance;

		uint256 amounttoliquify = contractbalance.mul(_liquidityfee).div(_totalfee).div(2);
		uint256 amountforstaking = contractbalance.mul(_stakingfee).div(_totalfee);
		uint256 amounttoswap = contractbalance.sub((amounttoliquify.add(amountforstaking)));

		_swaptokensforbnb(amounttoswap);

		uint256 bnbbalanceafterswap = address(this).balance.sub(initialbnbbalance);
		uint256 totalbnbfee = _totalfee.sub(_liquidityfee.div(2));

		uint256 amountbnbliquidity = bnbbalanceafterswap.mul(_liquidityfee).div(totalbnbfee).div(2);
		uint256 amountbnbmarketing = bnbbalanceafterswap.mul(_marketingfee).div(totalbnbfee);
		uint256 amountbnbbuyback= bnbbalanceafterswap.mul(_buybackfee).div(totalbnbfee);
		uint256 amountbnbholders = bnbbalanceafterswap.sub((amountbnbliquidity.add(amountbnbmarketing).add(amountbnbbuyback)));

		payable(marketingwallet).transfer(amountbnbmarketing);
		payable(buybackwallet).transfer(amountbnbbuyback);

		if (amounttoliquify > 0) {
			_addliquidity(amounttoliquify, amountbnbliquidity);
			emit swapandliquify(amounttoswap, amountbnbliquidity, amounttoliquify);
		}

		(bool stakingsuccess) = ierc20(address(this)).transfer(address(stakingaddress), amountforstaking);
		if(stakingsuccess) {
			emit stakingtokenssent(amountforstaking);
		}

		(bool dividendsuccess,) = address(dividendtracker).call{value: amountbnbholders}("");
		if(dividendsuccess) {
			emit dividendssent(amountbnbholders);
		}
	}

  Code Snippet:
	function _swaptokensforbnb(uint256 tokenamount) private {
		address[] memory path = new address[](2);
		path[0] = address(this);
		path[1] = uniswapv2router.weth();
		_approve(address(this), address(uniswapv2router), tokenamount);
		uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
			tokenamount,
			0, // accept any amount of eth
			path,
			address(this),
			block.timestamp
		);
	}

  Code Snippet:
	function _addliquidity(uint256 tokenamount, uint256 ethamount) private {
		_approve(address(this), address(uniswapv2router), tokenamount);
		uniswapv2router.addliquidityeth{value: ethamount}(
			address(this),
			tokenamount,
			0, // slippage is unavoidable
			0, // slippage is unavoidable
			liquiditywallet,
			block.timestamp
		);
	}

  Code Snippet:
	function setuniswaprouter(address router) external onlyowner {
		_setuniswaprouter(router);
	}

  Code Snippet:
	function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
		uint256 amount = _withdrawdividendofuser(account);
		if(amount > 0) {
			lastclaimtimes[account] = block.timestamp;
			emit claim(account, amount, automatic);
			return true;
		}
		return false;
	}

WARNING: Trading Disabled Possible
  Code Snippet:
	function launch() public onlyowner {
		_launchstarttimestamp = _getnow();
		_launchblocknumber = block.number;
		istradingenabled = true;
		_islanched = true;
	}

  Code Snippet:
	function activatetrading() public onlyowner {
		istradingenabled = true;
	}

  Code Snippet:
	function deactivatetrading() public onlyowner {
		istradingenabled = false;
		_tradingpausedtimestamp = _getnow();
	}

  Code Snippet:
	function setcharityhour() public onlyowner {
		require(!this.isincharityhour(), "babysanta: charity hour is already set");
		require(istradingenabled, "babysanta: trading must be enabled first");
		require(!this.isinlaunch(), "babysanta: must not be in launch period");
		emit charityhourchange(true, false);
		_charityhourstarttimestamp = _getnow();
	}

  Code Snippet:
	function timesincelastcharityhour() external view returns(uint256){
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _charityhourstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		return currenttimestamp.sub(_charityhourstarttimestamp);
	}

  Code Snippet:
	function isincharityhour() external view returns (bool) {
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _charityhourstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 totalcharitytime = _charity1.timeinperiod.add(_charity2.timeinperiod);
		uint256 timesincecharity = currenttimestamp.sub(_charityhourstarttimestamp);
		if(timesincecharity < totalcharitytime) {
			return true;
		} else {
			return false;
		}
	}

  Code Snippet:
	function isinlaunch() external view returns (bool) {
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 totallaunchtime =  _launch1.timeinperiod.add(_launch2.timeinperiod).add(_launch3.timeinperiod);

		if(_islanched && (timesincelaunch < totallaunchtime || blockssincelaunch < _launch1.blocksinperiod )) {
			return true;
		} else {
			return false;
		}
	}

  Code Snippet:
	function _adjusttaxes(bool isbuyfromlp, bool isselltolp) private {
		uint256 blockssincelaunch = block.number.sub(_launchblocknumber);
		uint256 currenttimestamp = !istradingenabled && _tradingpausedtimestamp > _launchstarttimestamp  ? _tradingpausedtimestamp : _getnow();
		uint256 timesincelaunch = currenttimestamp.sub(_launchstarttimestamp);
		uint256 timeinlaunch = _launch3.timeinperiod.add(_launch2.timeinperiod);
		uint256 timesincecharity = currenttimestamp.sub(_charityhourstarttimestamp);
		_liquidityfee = 0;
		_marketingfee = 0;
		_buybackfee = 0;
		_stakingfee = 0;
		_holdersfee = 0;

		if (isbuyfromlp) {
			_liquidityfee = _base.liquidityfeeonbuy;
			_marketingfee = _base.marketingfeeonbuy;
			_buybackfee = _base.buybackfeeonbuy;
			_stakingfee = _base.stakingfeeonbuy;
			_holdersfee = _base.holdersfeeonbuy;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonbuy;
				_marketingfee = _launch1.marketingfeeonbuy;
				_buybackfee = _launch1.buybackfeeonbuy;
				_stakingfee = _launch1.stakingfeeonbuy;
				_holdersfee = _launch1.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonbuy;
				_marketingfee = _launch2.marketingfeeonbuy;
				_buybackfee = _launch2.buybackfeeonbuy;
				_stakingfee = _launch2.stakingfeeonbuy;
				_holdersfee = _launch2.holdersfeeonbuy;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonbuy;
				_marketingfee = _launch3.marketingfeeonbuy;
				_buybackfee = _launch3.buybackfeeonbuy;
				_stakingfee = _launch3.stakingfeeonbuy;
				_holdersfee = _launch3.holdersfeeonbuy;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonbuy;
				_marketingfee = _charity1.marketingfeeonbuy;
				_buybackfee = _charity1.buybackfeeonbuy;
				_stakingfee = _charity1.stakingfeeonbuy;
				_holdersfee = _charity1.holdersfeeonbuy;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonbuy;
				_marketingfee = _charity2.marketingfeeonbuy;
				_buybackfee = _charity2.buybackfeeonbuy;
				_stakingfee = _charity2.stakingfeeonbuy;
				_holdersfee = _charity2.holdersfeeonbuy;
			}
		}
		if (isselltolp) {
			_liquidityfee = _base.liquidityfeeonsell;
			_marketingfee = _base.marketingfeeonsell;
			_buybackfee = _base.buybackfeeonsell;
			_stakingfee = _base.stakingfeeonsell;
			_holdersfee = _base.holdersfeeonsell;

			if (_islanched && blockssincelaunch < _launch1.blocksinperiod) {
				_liquidityfee = _launch1.liquidityfeeonsell;
				_marketingfee = _launch1.marketingfeeonsell;
				_buybackfee = _launch1.buybackfeeonsell;
				_stakingfee = _launch1.stakingfeeonsell;
				_holdersfee = _launch1.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch <= _launch2.timeinperiod && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch2.liquidityfeeonsell;
				_marketingfee = _launch2.marketingfeeonsell;
				_buybackfee = _launch2.buybackfeeonsell;
				_stakingfee = _launch2.stakingfeeonsell;
				_holdersfee = _launch2.holdersfeeonsell;
			}
			if (_islanched && timesincelaunch > _launch2.timeinperiod && timesincelaunch <= timeinlaunch && blockssincelaunch > _launch1.blocksinperiod) {
				_liquidityfee = _launch3.liquidityfeeonsell;
				_marketingfee = _launch3.marketingfeeonsell;
				_buybackfee = _launch3.buybackfeeonsell;
				_stakingfee = _launch3.stakingfeeonsell;
				_holdersfee = _launch3.holdersfeeonsell;
			}
			if (timesincecharity <= _charity1.timeinperiod) {
				_liquidityfee = _charity1.liquidityfeeonsell;
				_marketingfee = _charity1.marketingfeeonsell;
				_buybackfee = _charity1.buybackfeeonsell;
				_stakingfee = _charity1.stakingfeeonsell;
				_holdersfee = _charity1.holdersfeeonsell;
			}
			if (timesincecharity > _charity1.timeinperiod && timesincecharity <= _charity1.timeinperiod.add(_charity2.timeinperiod)) {
				_liquidityfee = _charity2.liquidityfeeonsell;
				_marketingfee = _charity2.marketingfeeonsell;
				_buybackfee = _charity2.buybackfeeonsell;
				_stakingfee = _charity2.stakingfeeonsell;
				_holdersfee = _charity2.holdersfeeonsell;
			}
		}
		_totalfee = _liquidityfee.add(_marketingfee).add(_buybackfee).add(_stakingfee).add(_holdersfee);
	}


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x586e3b22789d8f9cbd934a86b3b81695100a1a4f
Owner Balance: 636,592,112,049,471,852,396,189,623,255,040 tokens
Owner Share: 73.07% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x586e3b22789d8f9cbd934a86b3b81695100a1a4f — 636,592,112,049,471,852,396,189,623,255,040 tokens (73.07% of circulating supply)
  2. 0x30501c5788c1895a2acfd766e93cd0d56613ae3c — 29,212,226,906,854,834,140,820,795,293,696 tokens (3.35% of circulating supply)
  3. 0x4398682fe3bfa7b9b23b85a2e78a37abb2f2a0c2 — 7,093,545,852,764,851,474,877,290,381,312 tokens (0.81% of circulating supply)
  4. 0xa01233a0bf24a6303e2ffd9deebe64dcb362cf98 — 6,948,998,323,525,234,105,265,095,180,288 tokens (0.80% of circulating supply)
  5. 0xd9fa327e473f1ccb27eacdfd74aa2192af144422 — 6,244,556,946,513,270,456,945,060,347,904 tokens (0.72% of circulating supply)
  6. 0xa40e58ceeaa4540d5dd2234054e80ea398393272 — 4,812,283,333,841,763,850,392,984,092,672 tokens (0.55% of circulating supply)
  7. 0x67dea1c6a27bffd57641bec12765c1dc329ab41f — 4,599,876,997,246,890,490,560,472,154,112 tokens (0.53% of circulating supply)
  8. 0x5ec1e1ab7a3a9f63ea785c655a20a62867389140 — 2,870,489,078,435,304,412,675,886,284,800 tokens (0.33% of circulating supply)
  9. 0x9d166b273f423206a402532ba82522381dac67d3 — 2,308,704,029,909,631,878,432,020,234,240 tokens (0.27% of circulating supply)
  10. 0xf2da7f3cd4c57c9da50c7f3b1e3e84439fc74878 — 1,792,984,500,000,000,067,956,440,563,712 tokens (0.21% of circulating supply)

Top 10 Total Balance: 702,475,778,018,563,633,274,115,667,787,776 tokens
Top 10 Share of Circulating Supply: 80.63%
Top 10 Share of Total Supply: 70.25%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $8,278,270,113,300,655.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 1559645639998.1313
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.1695
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (63.6592)
Total supply of LP tokens: 15145884.740004523
LP holders count: 2

Liquidity holders for 0x215Ae47ecC7A297d3E20126c3e05E735F548f1d3, (BABY SANTA TOKEN v2)

0x586e3b22789d8f9cbd934a86b3b81695100a1a4f holds 15145884.740004523 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/babysantatoken, Reason: metamask recovery phrase phishing
  URL: https://www.facebook.com/Baby-Santa-101677595665401/, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/babysantabsc, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/roger-wu), Reason: metamask recovery phrase phishing
  URL: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1343.64 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-28T17:48:41
Last Active: 2025-07-22T19:48:43
Days Since Last Activity: 11.55420314755787 days
Last Transaction Hash: 0x972a1799e79dd89f43d67b4a5c20118a8724fb7886e29fdac7fe70a91d18f8cb
