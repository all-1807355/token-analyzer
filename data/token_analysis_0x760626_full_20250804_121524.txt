Token Analysis Report
==================================================
Token: Talkado (0x7606267A4bfff2c5010c92924348C3e4221955f2)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        _taxfee = 0;
        _liquidityfee = 0;
        _burnfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = 3;
        _liquidityfee = 4;
        _burnfee = 1;
        _marketingfee = 2;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount) private {
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            removeallfee();
        }
        else{
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }
        
        //calculate burn amount and marketing amount
        uint256 burnamt = amount.mul(_burnfee).div(100);
        uint256 marketingamt = amount.mul(_marketingfee).div(100);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        }
        
        //temporarily remove fees to transfer to burn address and marketing wallet
        _taxfee = 0;
        _liquidityfee = 0;

        //send transfers to burn and marketing wallet
        _transferstandard(sender, address(0), burnamt);
        _transferstandard(sender, marketingwallet, marketingamt);

        //restore tax and liquidity fees
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;


        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient])
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function enableallfees() external onlyowner() {
        _taxfee = 3;
        _previoustaxfee = _taxfee;
        _liquidityfee = 4;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 1;
        _previousburnfee = _taxfee;
        _marketingfee = 2;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = true;
        emit swapandliquifyenabledupdated(true);
    }

  Code Snippet:
    function disableallfees() external onlyowner() {
        _taxfee = 0;
        _previoustaxfee = _taxfee;
        _liquidityfee = 0;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketingfee = 0;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = false;
        emit swapandliquifyenabledupdated(false);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xfd6dbb2b1c09ae45d4dd25957e91237edf837dd1
Owner Balance: 395,867,638,352,042,979,753,984 tokens
Owner Share: 0.62% of circulating supply
✅ Creator holds LESS than 5% of circulating supply
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xd8b6a853095c334ad26621a301379cc3614f9663 — 14,004,583,475,403,912,791,457,792 tokens (21.96% of circulating supply)
  2. 0xc7029e939075f48fa2d5953381660c7d01570171 — 7,722,053,248,187,850,893,033,472 tokens (12.11% of circulating supply)
  3. 0xba6c98f1cc6869eccbeb892b7a603f8f02db3b29 — 999,999,999,999,999,983,222,784 tokens (1.57% of circulating supply)
  4. 0x6f99a036a97bcc64bb64bae2a5603afa22e863d7 — 509,226,611,101,827,027,959,808 tokens (0.80% of circulating supply)
  5. 0xfd6dbb2b1c09ae45d4dd25957e91237edf837dd1 — 395,867,638,352,042,979,753,984 tokens (0.62% of circulating supply)
  6. 0xcffa79b98a9a6c03da6ea1842924201878ffbcd9 — 325,037,827,149,615,188,672,512 tokens (0.51% of circulating supply)
  7. 0x6e4f21142cceb4ac5681379ab4f422903c90bf21 — 219,246,527,812,927,659,966,464 tokens (0.34% of circulating supply)
  8. 0xa3507be08bc722b1115f04d6bd23ab01e79e87c0 — 199,999,999,999,999,983,222,784 tokens (0.31% of circulating supply)
  9. 0xfc21809fa21b99516e9f75b39eb6168b16adae7c — 174,661,898,360,373,286,797,312 tokens (0.27% of circulating supply)
  10. 0xeda1f6c6b6a356944decc456c4e6eac6dbbcd2f5 — 143,854,159,867,831,088,316,416 tokens (0.23% of circulating supply)

Top 10 Total Balance: 24,694,531,386,236,380,882,403,328 tokens
Top 10 Share of Circulating Supply: 38.72%
Top 10 Share of Total Supply: 24.69%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $41,271,180,651,718,384.00
Liquidity: $0.02
Liquidity/MCap Ratio: 0.0000
Token Volume: 11745226362785.8203
USD Volume: 7600.6987
24h Volume/Liquidity Ratio: 419335.0835
Percentage of liquidity locked: 98.9100
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.396)
Total supply of LP tokens: 9509.13963684028
LP holders count: 10

Liquidity holders for 0x7606267A4bfff2c5010c92924348C3e4221955f2, (Talkado)

0x7ee058420e5937496f5a2096f04caa7721cf70cc holds 9405.958111750233 LP tokens

0x098532743ee48dce25faf0acce7ec4a4a61fcaec holds 72.0 LP tokens

0xfd6dbb2b1c09ae45d4dd25957e91237edf837dd1 holds 25.408223511546236 LP tokens

0xf650f5d8cb5375f94332e9eddfd6ac0bb9a479df holds 2.2897488814309166 LP tokens

0x3e02282f37892dec5dcd01a4b3963ffe88392b0b holds 1.339126092352335 LP tokens

0x57bf8f65400248932ba610e6b6b7789acdb91e96 holds 0.7262615451083871 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.6642355114709898 LP tokens

0xeeaec964fc3aaf3212bf78fb11457de9c288a17d holds 0.4931828014194655 LP tokens

0x25224f5356f809a555b6ac26e821e7e9dc00dd36 holds 0.23524209188892245 LP tokens

0x3db97775bfed0731eddcade71ce0377ea772a7cc holds 0.022872567663448348 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1503.37 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-06-23T03:25:07
Last Active: 2025-07-30T12:08:52
Days Since Last Activity: 5.0045446825810185 days
Last Transaction Hash: 0xf924c1421f23af788f0da7424af56cded70674f1071031dc4d1f589056a2a3c7
