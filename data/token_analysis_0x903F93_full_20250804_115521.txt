Token Analysis Report
==================================================
Token: Guan Yu (0x903F9381BC949e911cBe10E7Ad05E5E04824d073)
Chain: ETH
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() external onlyowner { 
        _owner = address(0); 
        emit ownershiptransferred(address(0)); 
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _opentrading() internal {
        _maxtxamount     = _totalsupply * 2 / 100; 
        _maxwalletamount = _totalsupply * 2 / 100;
        _tradingopen = true;
        _launchblock = block.number;
        _antimevblock = _antimevblock + _launchblock + antisnipeblocks1 + antisnipeblocks2;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        require(sender != address(0), "no transfers from zero wallet");
        if (!_tradingopen) { require(_nofees[sender] && _nolimits[sender], "trading not open"); }
        if ( !_intaxswap && _islp[recipient] ) { _swaptaxandliquify(); }
        if ( block.number < _antimevblock && block.number >= _launchblock && _islp[sender] ) {
            require(recipient == tx.origin, "mev blocked");
        }
        if ( sender != address(this) && recipient != address(this) && sender != _owner ) { 
            require(_checklimits(sender, recipient, amount), "tx exceeds limits"); 
        }
        uint256 _taxamount = _calculatetax(sender, recipient, amount);
        uint256 _transferamount = amount - _taxamount;
        _balances[sender] = _balances[sender] - amount;
        _swaplimit += _taxamount;
        _balances[recipient] = _balances[recipient] + _transferamount;
        emit transfer(sender, recipient, amount);
        return true;
    }

  Code Snippet:
    function _calculatetax(address sender, address recipient, uint256 amount) internal view returns (uint256) {
        uint256 taxamount;
        
        if ( !_tradingopen || _nofees[sender] || _nofees[recipient] ) { 
            taxamount = 0; 
        } else if ( _islp[sender] ) { 
            if ( block.number >= _launchblock + antisnipeblocks1 + antisnipeblocks2 ) {
                taxamount = amount * _buytaxrate / 100; 
            } else if ( block.number >= _launchblock + antisnipeblocks1 ) {
                taxamount = amount * antisnipetax2 / 100;
            } else if ( block.number >= _launchblock) {
                taxamount = amount * antisnipetax1 / 100;
            }
        } else if ( _islp[recipient] ) { 
            taxamount = amount * _selltaxrate / 100; 
        }

        return taxamount;
    }

WARNING: High Tax Detected
  Code Snippet:
    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_checktradingopen(msg.sender), "trading not open");
        return _transferfrom(msg.sender, recipient, amount);
    }

  Code Snippet:
    function transferfrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_checktradingopen(sender), "trading not open");
        if(_allowances[sender][msg.sender] != type(uint256).max){
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
        }
        return _transferfrom(sender, recipient, amount);
    }

  Code Snippet:
    function _approverouter(uint256 _tokenamount) internal {
        if ( _allowances[address(this)][_swaprouteraddress] < _tokenamount ) {
            _allowances[address(this)][_swaprouteraddress] = type(uint256).max;
            emit approval(address(this), _swaprouteraddress, type(uint256).max);
        }
    }

  Code Snippet:
    function addliquidity() external payable onlyowner locktaxswap {
        require(_primarylp == address(0), "lp exists");
        require(!_tradingopen, "trading is open");
        require(msg.value > 0 || address(this).balance>0, "no eth in contract or message");
        require(_balances[address(this)]>0, "no tokens in contract");
        _primarylp = iuniswapv2factory(_primaryswaprouter.factory()).createpair(address(this), _primaryswaprouter.weth());
        _addliquidity(_balances[address(this)], address(this).balance, false);
        _balances[_primarylp] -= _swaplimit;
        (bool lpaddsuccess,) = _primarylp.call(abi.encodewithsignature("sync()"));
        require(lpaddsuccess, "failed adding liquidity");
        _islp[_primarylp] = lpaddsuccess;
        _opentrading();
    }

  Code Snippet:
    function _addliquidity(uint256 _tokenamount, uint256 _ethamountwei, bool autoburn) internal {
        address lptokenrecipient = _lpowner;
        if ( autoburn ) { lptokenrecipient = address(0); }
        _approverouter(_tokenamount);
        _primaryswaprouter.addliquidityeth{value: _ethamountwei} ( address(this), _tokenamount, 0, 0, lptokenrecipient, block.timestamp );
    }

  Code Snippet:
    function _opentrading() internal {
        _maxtxamount     = _totalsupply * 2 / 100; 
        _maxwalletamount = _totalsupply * 2 / 100;
        _tradingopen = true;
        _launchblock = block.number;
        _antimevblock = _antimevblock + _launchblock + antisnipeblocks1 + antisnipeblocks2;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        require(sender != address(0), "no transfers from zero wallet");
        if (!_tradingopen) { require(_nofees[sender] && _nolimits[sender], "trading not open"); }
        if ( !_intaxswap && _islp[recipient] ) { _swaptaxandliquify(); }
        if ( block.number < _antimevblock && block.number >= _launchblock && _islp[sender] ) {
            require(recipient == tx.origin, "mev blocked");
        }
        if ( sender != address(this) && recipient != address(this) && sender != _owner ) { 
            require(_checklimits(sender, recipient, amount), "tx exceeds limits"); 
        }
        uint256 _taxamount = _calculatetax(sender, recipient, amount);
        uint256 _transferamount = amount - _taxamount;
        _balances[sender] = _balances[sender] - amount;
        _swaplimit += _taxamount;
        _balances[recipient] = _balances[recipient] + _transferamount;
        emit transfer(sender, recipient, amount);
        return true;
    }

  Code Snippet:
    function _checklimits(address sender, address recipient, uint256 transferamount) internal view returns (bool) {
        bool limitcheckpassed = true;
        if ( _tradingopen && !_nolimits[sender] && !_nolimits[recipient] ) {
            if ( transferamount > _maxtxamount ) { limitcheckpassed = false; }
            else if ( !_islp[recipient] && (_balances[recipient] + transferamount > _maxwalletamount) ) { limitcheckpassed = false; }
        }
        return limitcheckpassed;
    }

  Code Snippet:
    function _checktradingopen(address sender) private view returns (bool){
        bool checkresult = false;
        if ( _tradingopen ) { checkresult = true; } 
        else if (_nofees[sender] && _nolimits[sender]) { checkresult = true; } 

        return checkresult;
    }

  Code Snippet:
    function _calculatetax(address sender, address recipient, uint256 amount) internal view returns (uint256) {
        uint256 taxamount;
        
        if ( !_tradingopen || _nofees[sender] || _nofees[recipient] ) { 
            taxamount = 0; 
        } else if ( _islp[sender] ) { 
            if ( block.number >= _launchblock + antisnipeblocks1 + antisnipeblocks2 ) {
                taxamount = amount * _buytaxrate / 100; 
            } else if ( block.number >= _launchblock + antisnipeblocks1 ) {
                taxamount = amount * antisnipetax2 / 100;
            } else if ( block.number >= _launchblock) {
                taxamount = amount * antisnipetax1 / 100;
            }
        } else if ( _islp[recipient] ) { 
            taxamount = amount * _selltaxrate / 100; 
        }

        return taxamount;
    }

  Code Snippet:
    function exemptfromfees(address wallet) external view returns (bool) {
        return _nofees[wallet];
    } 

  Code Snippet:
    function setexempt(address wallet, bool nofees, bool nolimits) external onlyowner {
        if (nolimits || nofees) { require(!_islp[wallet], "cannot exempt lp"); }
        _nofees[ wallet ] = nofees;
        _nolimits[ wallet ] = nolimits;
    }

  Code Snippet:
    function buyfee() external view returns(uint8) {
        return _buytaxrate;
    }

  Code Snippet:
    function sellfee() external view returns(uint8) {
        return _selltaxrate;
    }

  Code Snippet:
    function feesplit() external view returns (uint16 marketing, uint16 development, uint16 lp ) {
        return ( _taxsharesmarketing, _taxsharesdevelopment, _taxshareslp);
    }

  Code Snippet:
    function setfees(uint8 buy, uint8 sell) external onlyowner {
        require(buy + sell <= 15, "roundtrip too high");
        _buytaxrate = buy;
        _selltaxrate = sell;
    }  

  Code Snippet:
    function setfeesplit(uint16 sharesautolp, uint16 sharesmarketing, uint16 sharesdevelopment) external onlyowner {
        uint16 totalshares = sharesautolp + sharesmarketing + sharesdevelopment;
        require( totalshares > 0, "all cannot be 0");
        _taxshareslp = sharesautolp;
        _taxsharesmarketing = sharesmarketing;
        _taxsharesdevelopment = sharesdevelopment;
        _totaltaxshares = totalshares;
    }

  Code Snippet:
    function updatewallets(address marketing, address development, address lptokens) external onlyowner {
        require(!_islp[marketing] && !_islp[development] && !_islp[lptokens], "lp cannot be tax wallet");
        
        _walletmarketing = payable(marketing);
        _walletdevelopment = payable(development);
        _lpowner = lptokens;
        
        _nofees[marketing] = true;
        _nolimits[marketing] = true;
        
        _nofees[development] = true;        
        _nolimits[development] = true;
    }

  Code Snippet:
    function swapatmin() external view returns (uint256) {
        return _taxswapmin;
    }

  Code Snippet:
    function swapatmax() external view returns (uint256) {
        return _taxswapmax;
    }

  Code Snippet:
    function settaxswap(uint32 minvalue, uint32 mindivider, uint32 maxvalue, uint32 maxdivider) external onlyowner {
        _taxswapmin = _totalsupply * minvalue / mindivider;
        _taxswapmax = _totalsupply * maxvalue / maxdivider;
        require(_taxswapmax>=_taxswapmin, "min/max error");
        require(_taxswapmax>_totalsupply / 100000, "max too low");
        require(_taxswapmax<_totalsupply / 100, "max too high");
    }

  Code Snippet:
    function _swaptaxandliquify() private locktaxswap {
        uint256 _taxtokensavailable = _swaplimit;
        if ( _taxtokensavailable >= _taxswapmin && _tradingopen ) {
            if ( _taxtokensavailable >= _taxswapmax ) { _taxtokensavailable = _taxswapmax; }
            uint256 _tokensforlp = _taxtokensavailable * _taxshareslp / _totaltaxshares / 2;
            
            uint256 _tokenstoswap = _taxtokensavailable - _tokensforlp;
            if( _tokenstoswap > 10**_decimals ) {
                uint256 _ethpreswap = address(this).balance;
                _balances[address(this)] += _taxtokensavailable;
                _swaptaxtokensforeth(_tokenstoswap);
                _swaplimit -= _taxtokensavailable;
                uint256 _ethswapped = address(this).balance - _ethpreswap;
                if ( _taxshareslp > 0 ) {
                    uint256 _ethweiamount = _ethswapped * _taxshareslp / _totaltaxshares ;
                    _approverouter(_tokensforlp);
                    _addliquidity(_tokensforlp, _ethweiamount, false);
                }
            }
            uint256 _contractethbalance = address(this).balance;
            if(_contractethbalance > 0) { _distributetaxeth(_contractethbalance); }
        }
    }

  Code Snippet:
    function _swaptaxtokensforeth(uint256 tokenamount) private {
        _approverouter(tokenamount);
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _primaryswaprouter.weth();
        _primaryswaprouter.swapexacttokensforethsupportingfeeontransfertokens(tokenamount,0,path,address(this),block.timestamp);
    }

  Code Snippet:
    function manualtaxswapandsend(uint8 swaptokenpercent, bool sendeth) external onlyowner locktaxswap {
        require(swaptokenpercent <= 100, "cannot swap more than 100%");
        uint256 tokenstoswap = _balances[address(this)] * swaptokenpercent / 100;
        if (tokenstoswap > 10 ** _decimals) {
            _swaptaxtokensforeth(tokenstoswap);
        }
        if (sendeth) { 
            uint256 ethbalance = address(this).balance;
            require(ethbalance > 0, "no eth");
            _distributetaxeth(address(this).balance); 
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function transfer(address recipient, uint256 amount) external override returns (bool) {
        require(_checktradingopen(msg.sender), "trading not open");
        return _transferfrom(msg.sender, recipient, amount);
    }

  Code Snippet:
    function transferfrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        require(_checktradingopen(sender), "trading not open");
        if(_allowances[sender][msg.sender] != type(uint256).max){
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
        }
        return _transferfrom(sender, recipient, amount);
    }

  Code Snippet:
    function addliquidity() external payable onlyowner locktaxswap {
        require(_primarylp == address(0), "lp exists");
        require(!_tradingopen, "trading is open");
        require(msg.value > 0 || address(this).balance>0, "no eth in contract or message");
        require(_balances[address(this)]>0, "no tokens in contract");
        _primarylp = iuniswapv2factory(_primaryswaprouter.factory()).createpair(address(this), _primaryswaprouter.weth());
        _addliquidity(_balances[address(this)], address(this).balance, false);
        _balances[_primarylp] -= _swaplimit;
        (bool lpaddsuccess,) = _primarylp.call(abi.encodewithsignature("sync()"));
        require(lpaddsuccess, "failed adding liquidity");
        _islp[_primarylp] = lpaddsuccess;
        _opentrading();
    }

  Code Snippet:
    function _opentrading() internal {
        _maxtxamount     = _totalsupply * 2 / 100; 
        _maxwalletamount = _totalsupply * 2 / 100;
        _tradingopen = true;
        _launchblock = block.number;
        _antimevblock = _antimevblock + _launchblock + antisnipeblocks1 + antisnipeblocks2;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        require(sender != address(0), "no transfers from zero wallet");
        if (!_tradingopen) { require(_nofees[sender] && _nolimits[sender], "trading not open"); }
        if ( !_intaxswap && _islp[recipient] ) { _swaptaxandliquify(); }
        if ( block.number < _antimevblock && block.number >= _launchblock && _islp[sender] ) {
            require(recipient == tx.origin, "mev blocked");
        }
        if ( sender != address(this) && recipient != address(this) && sender != _owner ) { 
            require(_checklimits(sender, recipient, amount), "tx exceeds limits"); 
        }
        uint256 _taxamount = _calculatetax(sender, recipient, amount);
        uint256 _transferamount = amount - _taxamount;
        _balances[sender] = _balances[sender] - amount;
        _swaplimit += _taxamount;
        _balances[recipient] = _balances[recipient] + _transferamount;
        emit transfer(sender, recipient, amount);
        return true;
    }

  Code Snippet:
    function _checklimits(address sender, address recipient, uint256 transferamount) internal view returns (bool) {
        bool limitcheckpassed = true;
        if ( _tradingopen && !_nolimits[sender] && !_nolimits[recipient] ) {
            if ( transferamount > _maxtxamount ) { limitcheckpassed = false; }
            else if ( !_islp[recipient] && (_balances[recipient] + transferamount > _maxwalletamount) ) { limitcheckpassed = false; }
        }
        return limitcheckpassed;
    }

  Code Snippet:
    function _checktradingopen(address sender) private view returns (bool){
        bool checkresult = false;
        if ( _tradingopen ) { checkresult = true; } 
        else if (_nofees[sender] && _nolimits[sender]) { checkresult = true; } 

        return checkresult;
    }

  Code Snippet:
    function _calculatetax(address sender, address recipient, uint256 amount) internal view returns (uint256) {
        uint256 taxamount;
        
        if ( !_tradingopen || _nofees[sender] || _nofees[recipient] ) { 
            taxamount = 0; 
        } else if ( _islp[sender] ) { 
            if ( block.number >= _launchblock + antisnipeblocks1 + antisnipeblocks2 ) {
                taxamount = amount * _buytaxrate / 100; 
            } else if ( block.number >= _launchblock + antisnipeblocks1 ) {
                taxamount = amount * antisnipetax2 / 100;
            } else if ( block.number >= _launchblock) {
                taxamount = amount * antisnipetax1 / 100;
            }
        } else if ( _islp[recipient] ) { 
            taxamount = amount * _selltaxrate / 100; 
        }

        return taxamount;
    }

  Code Snippet:
    function _swaptaxandliquify() private locktaxswap {
        uint256 _taxtokensavailable = _swaplimit;
        if ( _taxtokensavailable >= _taxswapmin && _tradingopen ) {
            if ( _taxtokensavailable >= _taxswapmax ) { _taxtokensavailable = _taxswapmax; }
            uint256 _tokensforlp = _taxtokensavailable * _taxshareslp / _totaltaxshares / 2;
            
            uint256 _tokenstoswap = _taxtokensavailable - _tokensforlp;
            if( _tokenstoswap > 10**_decimals ) {
                uint256 _ethpreswap = address(this).balance;
                _balances[address(this)] += _taxtokensavailable;
                _swaptaxtokensforeth(_tokenstoswap);
                _swaplimit -= _taxtokensavailable;
                uint256 _ethswapped = address(this).balance - _ethpreswap;
                if ( _taxshareslp > 0 ) {
                    uint256 _ethweiamount = _ethswapped * _taxshareslp / _totaltaxshares ;
                    _approverouter(_tokensforlp);
                    _addliquidity(_tokensforlp, _ethweiamount, false);
                }
            }
            uint256 _contractethbalance = address(this).balance;
            if(_contractethbalance > 0) { _distributetaxeth(_contractethbalance); }
        }
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x000000000000000000000000000000000000dead — 576,896,018,501,223,972,864 tokens (74.35% of circulating supply)
  2. 0x3bd94d1490d33e19a1d32edf8f21120d102a0f45 — 12,491,134,974,141,313,024 tokens (1.61% of circulating supply)
  3. 0xfeaab330292e5f828677710c1a4ec0c470127df1 — 11,769,015,394,274,355,200 tokens (1.52% of circulating supply)
  4. 0x69204ff96d42de77a64c6abc2a3ba8b1beb84051 — 7,911,599,533,870,470,144 tokens (1.02% of circulating supply)
  5. 0x190417184a9a19386c29022399d6b291fac6c92d — 7,772,785,302,518,332,416 tokens (1.00% of circulating supply)
  6. 0x368f6527fc8ee22f4ad4691419f56e5cc307afc6 — 5,630,473,060,774,121,472 tokens (0.73% of circulating supply)
  7. 0x5edd9d44439bf2cc88408806f8308baf7f0a7c7d — 5,458,100,793,823,978,496 tokens (0.70% of circulating supply)
  8. 0xaf21926b47d8630ca0626b1b949584b45c35904b — 4,693,124,851,563,643,904 tokens (0.60% of circulating supply)
  9. 0x0f3269580356242c4198b1ca41d854ae75c35c0d — 4,306,994,074,708,960,256 tokens (0.56% of circulating supply)
  10. 0x41e18bd510ec543ae5dc6d1f28b5a0b81235b141 — 4,173,988,042,302,355,456 tokens (0.54% of circulating supply)

Top 10 Total Balance: 641,103,234,529,201,503,232 tokens
Top 10 Share of Circulating Supply: 82.62%
Top 10 Share of Total Supply: 82.43%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,813,741,545,477,647,106,048.00
Liquidity: $58.40
Liquidity/MCap Ratio: 0.0000
Token Volume: 3326123392.4291
USD Volume: 7774726247.9749
24h Volume/Liquidity Ratio: 133139358.4056
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.3868591474940862
LP holders count: 2

Liquidity holders for 0x903F9381BC949e911cBe10E7Ad05E5E04824d073, (Guan Yu)

0x04bda42de3bc32abb00df46004204424d4cf8287 holds 0.3868591474940852 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/GuanYuToken, Reason: metamask recovery phrase phishing
  URL: https://guanyutoken.com, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 784.79 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2023-06-11T16:55:23
Last Active: 2025-07-03T11:28:11
Days Since Last Activity: 32.018868616064815 days
Last Transaction Hash: 0x09fdc6daa9ecfebdbad23d35e2c6a1225ac3fcd6e2da6d806c0a84394dd7dfe2
