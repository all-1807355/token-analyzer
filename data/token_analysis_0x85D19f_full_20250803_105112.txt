Token Analysis Report
==================================================
Token: Conan (0x85D19fb57CA7DA715695FCf347CA2169144523a7)
Chain: ETH
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 taxamount=0;
        if (from != owner() && to != owner()) {
            require(!bots[from] && !bots[to]);
            taxamount = amount.mul((_buycount>_reducebuytaxat)?_finalbuytax:_initialbuytax).div(100);

            if (transferdelayenabled) {
                  if (to != address(uniswapv2router) && to != address(uniswapv2pair)) {
                      require(
                          _holderlasttransfertimestamp[tx.origin] <
                              block.number,
                          "_transfer:: transfer delay enabled.  only one purchase per block allowed."
                      );
                      _holderlasttransfertimestamp[tx.origin] = block.number;
                  }
              }

            if (from == uniswapv2pair && to != address(uniswapv2router) && ! _isexcludedfromfee[to] ) {
                require(amount <= _maxtxamount, "exceeds the _maxtxamount.");
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");
                _buycount++;
            }

            if(to == uniswapv2pair && from!= address(this) ){
                taxamount = amount.mul((_buycount>_reduceselltaxat)?_finalselltax:_initialselltax).div(100);
            }

            uint256 contracttokenbalance = balanceof(address(this));
            if (!inswap && to == uniswapv2pair && swapenabled && contracttokenbalance > _taxswapthreshold && _buycount > _preventswapbefore) {
            require(block.number > lastexecutedblocknumber, "exceeds the maxwalletsize.");
            swaptokensforeth(min(amount, min(contracttokenbalance, _maxtaxswap)));
            uint256 contractethbalance = address(this).balance;
            if (contractethbalance > 0) {
                sendethtofee(address(this).balance);
            }
                lastexecutedblocknumber = block.number;
            }
        }

        if(taxamount>0){
          _balances[address(this)]=_balances[address(this)].add(taxamount);
          emit transfer(from, address(this),taxamount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxamount));
        emit transfer(from, to, amount.sub(taxamount));
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 taxamount=0;
        if (from != owner() && to != owner()) {
            require(!bots[from] && !bots[to]);
            taxamount = amount.mul((_buycount>_reducebuytaxat)?_finalbuytax:_initialbuytax).div(100);

            if (transferdelayenabled) {
                  if (to != address(uniswapv2router) && to != address(uniswapv2pair)) {
                      require(
                          _holderlasttransfertimestamp[tx.origin] <
                              block.number,
                          "_transfer:: transfer delay enabled.  only one purchase per block allowed."
                      );
                      _holderlasttransfertimestamp[tx.origin] = block.number;
                  }
              }

            if (from == uniswapv2pair && to != address(uniswapv2router) && ! _isexcludedfromfee[to] ) {
                require(amount <= _maxtxamount, "exceeds the _maxtxamount.");
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");
                _buycount++;
            }

            if(to == uniswapv2pair && from!= address(this) ){
                taxamount = amount.mul((_buycount>_reduceselltaxat)?_finalselltax:_initialselltax).div(100);
            }

            uint256 contracttokenbalance = balanceof(address(this));
            if (!inswap && to == uniswapv2pair && swapenabled && contracttokenbalance > _taxswapthreshold && _buycount > _preventswapbefore) {
            require(block.number > lastexecutedblocknumber, "exceeds the maxwalletsize.");
            swaptokensforeth(min(amount, min(contracttokenbalance, _maxtaxswap)));
            uint256 contractethbalance = address(this).balance;
            if (contractethbalance > 0) {
                sendethtofee(address(this).balance);
            }
                lastexecutedblocknumber = block.number;
            }
        }

        if(taxamount>0){
          _balances[address(this)]=_balances[address(this)].add(taxamount);
          emit transfer(from, address(this),taxamount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxamount));
        emit transfer(from, to, amount.sub(taxamount));
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private locktheswap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function sendethtofee(uint256 amount) private {
        _taxwallet.transfer(amount);
    }

  Code Snippet:
    function opentrading() external onlyowner() {
        require(!tradingopen,"trading is already open");
        uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
        uniswapv2router.addliquidityeth{value: address(this).balance}(address(this),balanceof(address(this)),0,0,owner(),block.timestamp);
        ierc20(uniswapv2pair).approve(address(uniswapv2router), type(uint).max);
        swapenabled = true;
        tradingopen = true;
    }

  Code Snippet:
    function reducefee(uint256 _newfee) external{
      require(_msgsender()==_taxwallet);
      require(_newfee<=_finalbuytax && _newfee<=_finalselltax);
      _finalbuytax=_newfee;
      _finalselltax=_newfee;
    }

  Code Snippet:
    function manualswap() external {
        require(_msgsender()==_taxwallet);
        uint256 tokenbalance=balanceof(address(this));
        if(tokenbalance>0){
          swaptokensforeth(tokenbalance);
        }
        uint256 ethbalance=address(this).balance;
        if(ethbalance>0){
          sendethtofee(ethbalance);
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function opentrading() external onlyowner() {
        require(!tradingopen,"trading is already open");
        uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
        uniswapv2router.addliquidityeth{value: address(this).balance}(address(this),balanceof(address(this)),0,0,owner(),block.timestamp);
        ierc20(uniswapv2pair).approve(address(uniswapv2router), type(uint).max);
        swapenabled = true;
        tradingopen = true;
    }


Holder Analysis
--------------
⚠️ Holder analysis exception in owner_circulating_supply_analysis: Exception during holder analysis in owner_circulating_supply_analysis: float division by zero

Liquidity Analysis
-----------------
Market Cap: $0.00
Liquidity: $128,863.09
Liquidity/MCap Ratio: 0.0000
Token Volume: 10685089621.0851
USD Volume: 2491.7629
24h Volume/Liquidity Ratio: 0.0193
Percentage of liquidity locked: 99.6200
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 28.391316824538592
LP holders count: 3

Liquidity holders for 0x85D19fb57CA7DA715695FCf347CA2169144523a7, (Conan)

0x000000000000000000000000000000000000dead holds 28.2842712474619 LP tokens

0x17662641b6a6662518e85f40abc14b0c7cb512be holds 0.10704557707668946 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/conanerc20, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/Conan_erc, Reason: metamask recovery phrase phishing
  URL: https://conan-erc20.com/, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 593.07 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2023-12-19T09:12:35
Last Active: 2025-08-03T00:35:35
Days Since Last Activity: 0.4275231002893518 days
Last Transaction Hash: 0x4f88cb2a5f7732e52e0f9747321bba004befbdbcda30cbb4a27c53c026321219
