Token Analysis Report
==================================================
Token: SpartanCoin (0x9A0D5797732d9C7EB67b550b0B00D47c2A913918)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event mint(address indexed sender, uint amount0, uint amount1);  //for minting lp tokens, standard for add to liquidity funcion

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function minimumtokensbeforeswapamount() public view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        uint256 sumoftokenparts = _marketingteamfee.add(_liquidityfee); //6
        uint256 partsoftokenbalance = contracttokenbalance.div(sumoftokenparts); //1
        
        uint256 tokenpart = (partsoftokenbalance.mul(_liquidityfee)).div(2); //tokens for liquidity, half of liquidity fee
        uint256 swappart = contracttokenbalance.sub(tokenpart); //tokens swapped for bnb liquidity + marketingteam bnb
        
        uint256 initialbalance = address(this).balance;
        
        swaptokensforeth(swappart);
        
        uint256 newbalance = address(this).balance.sub(initialbalance);
        
        uint256 sumofparts = _marketingteamfee.add((_liquidityfee).div(2));
        uint256 partsofbalance = newbalance.div(sumofparts);
        uint256 liquiditypart = partsofbalance.mul((_liquidityfee).div(2));
        
        addliquidity(tokenpart, liquiditypart);
        
        emit swapandliquify(swappart, newbalance, tokenpart);

        uint256 marketingteambalance = address(this).balance;

        uint256 marketingbnb = (marketingteambalance.div(10)).mul(5);
        transfermarketingbnb(marketingaddress, marketingbnb);
        
        uint256 teambnb = (marketingteambalance.div(10)).mul(5);
        transferteambnb(teamaddress, teambnb);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this), // the contract
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquidity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquidity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquidity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquidity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _ttotal = _ttotal.sub(tburn);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tburn, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tburn, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tburn = calculateburnfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tburn).sub(tliquidity);
        return (ttransferamount, tfee, tburn, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tburn, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rburn = tburn.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rburn).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateburnfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_burnfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee.add(_marketingteamfee)).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _burnfee == 0 && _liquidityfee == 0 && _marketingteamfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousburnfee = _burnfee;
        _previousliquidityfee = _liquidityfee;
        _previousmarketingteamfee = _marketingteamfee;
        
        _taxfee = 0;
        _burnfee = 0;
        _liquidityfee = 0;
        _marketingteamfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _burnfee = _previousburnfee;
        _liquidityfee = _previousliquidityfee;
        _marketingteamfee = _previousmarketingteamfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setburnfeepercent(uint256 burnfee) external onlyowner() {
        _burnfee = burnfee;
    }

  Code Snippet:
    function setnumtokensselltoaddtoliquidity(uint256 _minimumtokensbeforeswap) external onlyowner() {
        minimumtokensbeforeswap = _minimumtokensbeforeswap;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x0f541357e4d032fee00a7b042c3ac9ceaf4b3668 — 730,244,931,140,305,158,144 tokens (82.80% of circulating supply)
  2. 0xd7a98d34cd49dd203cac9752ea400ee309a5f602 — 16,460,841,443,029,385,216 tokens (1.87% of circulating supply)
  3. 0x2f42bdde6802f176d4142bcfd45d71aba65d6786 — 14,504,337,236,504,332,288 tokens (1.64% of circulating supply)
  4. 0x0f40b1246aa00386ce13fcd721a392ea46e300b2 — 9,451,360,313,552,482,304 tokens (1.07% of circulating supply)
  5. 0x548e03c19a175a66912685f71e157706fee6a04d — 8,000,373,565,482,653,696 tokens (0.91% of circulating supply)
  6. 0xd7ce3b62feac28dae97e21eb6c3d75b084bb4d0e — 4,906,196,938,865,685,504 tokens (0.56% of circulating supply)
  7. 0x052e80ddcd21334ea058c61d7a28924f45f69b76 — 4,655,504,603,311,039,488 tokens (0.53% of circulating supply)
  8. 0x069cfa0db1910ec02b32ed80fdb8d705b485a2c1 — 4,377,044,499,732,828,672 tokens (0.50% of circulating supply)
  9. 0x052eef0ed909eea131e5535d11d49ab0902fa3a6 — 3,750,001,749,639,496,704 tokens (0.43% of circulating supply)
  10. 0xa6864e154b64a8ce94020a8c1b43f191d3523c47 — 3,688,781,738,081,581,056 tokens (0.42% of circulating supply)

Top 10 Total Balance: 800,039,373,228,504,643,072 tokens
Top 10 Share of Circulating Supply: 90.72%
Top 10 Share of Total Supply: 87.74%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $9,469,520,579,096,588.00
Liquidity: $0.02
Liquidity/MCap Ratio: 0.0000
Token Volume: 489984746.9872
USD Volume: 5261.1860
24h Volume/Liquidity Ratio: 335493.3888
Percentage of liquidity locked: 99.9900
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0002)
Total supply of LP tokens: 63.53292794215797
LP holders count: 4

Liquidity holders for 0x9A0D5797732d9C7EB67b550b0B00D47c2A913918, (SpartanCoin)

0x0000000000000000000000000000000000000000 holds 63.52928675956378 LP tokens

0x8cc7bc33f5188b1fb683bedc4dbffa77b136833b holds 0.002106591901178682 LP tokens

0x07d80ae6f36a5e08dca74ce884a24d39db9934ed holds 0.000905329850561491 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000629260842452263 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/spartancoinchat, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://bscscan.com/address/0xd152f549545093347a162dce210e7293f1452150, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1525.97 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-31T13:57:58
Last Active: 2025-07-19T10:30:15
Days Since Last Activity: 16.118212525775462 days
Last Transaction Hash: 0x87225a0c0bdc3c75a2558c6c0c0c95016543c898f5a8689a872685fb2ccbf91f
