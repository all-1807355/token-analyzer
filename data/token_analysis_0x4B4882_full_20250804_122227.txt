Token Analysis Report
==================================================
Token: ElonMoney (0x4B48821B9Bf2621e4cD4c3255083f04083c3B37e)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "erc20: transfer from the zero address");
        require(recipient != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if(sender != owner() && recipient != owner() && recipient != address(1) && recipient != pcsv2pair){
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
            uint256 contractbalancerecepient = balanceof(recipient);
            require(contractbalancerecepient + amount <= _maxwallettoken, "exceeds maximum wallet token amount (100,000,000)"); 
        }

        

        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is uniswap pair.
        uint256 contracttokenbalance = balanceof(address(this));
        
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        
        bool overmintokenbalance = contracttokenbalance >= _numtokensselltoaddtoliquidity;
        if (
            overmintokenbalance &&
            !inswapandliquify &&
            sender != pcsv2pair
        ) {
            contracttokenbalance = _numtokensselltoaddtoliquidity;
            swapandliquify(contracttokenbalance);
        }
        
        bool takefee = true;
        
        //if any account belongs to _isexcludedfromfee account then remove the fee
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            takefee = false;
        }
        
        if(!takefee)
            removeallfee();
        
        _transferstandard(sender, recipient, amount);
        
        if(!takefee)
            restoreallfee();
    }

WARNING: Ownership Renounced
  Code Snippet:
  function renounceownership() public onlyowner {
    emit ownershiptransferred(_owner, address(0));
    _owner = address(0);
  }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;


  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function reflect(uint256 tamount) public {
        address sender = _msgsender();
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "erc20: transfer from the zero address");
        require(recipient != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if(sender != owner() && recipient != owner() && recipient != address(1) && recipient != pcsv2pair){
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
            uint256 contractbalancerecepient = balanceof(recipient);
            require(contractbalancerecepient + amount <= _maxwallettoken, "exceeds maximum wallet token amount (100,000,000)"); 
        }

        

        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is uniswap pair.
        uint256 contracttokenbalance = balanceof(address(this));
        
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        
        bool overmintokenbalance = contracttokenbalance >= _numtokensselltoaddtoliquidity;
        if (
            overmintokenbalance &&
            !inswapandliquify &&
            sender != pcsv2pair
        ) {
            contracttokenbalance = _numtokensselltoaddtoliquidity;
            swapandliquify(contracttokenbalance);
        }
        
        bool takefee = true;
        
        //if any account belongs to _isexcludedfromfee account then remove the fee
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            takefee = false;
        }
        
        if(!takefee)
            removeallfee();
        
        _transferstandard(sender, recipient, amount);
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = tamount.div(10 ** 2).mul(_taxfee);
        uint256 tliquidity = tamount.div(10 ** 2).mul(_liquidityfee);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current bnb balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for bnb
        swaptokensforbnb(half);

        // how much bnb did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf, contracttokenbalance);
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsv2router.weth();

        _approve(address(this), address(pcsv2router), tokenamount);

        // make the swap
        pcsv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x0e7316b54c6f0b03bfb5177935d0efe7eb5bc888
Owner Balance: 28,990,274,696,359,720,805,310,922,752 tokens
Owner Share: 0.00% of circulating supply
✅ Creator holds LESS than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x4d94e0e021357586e87f1195bea832604667a5a4 — 655,139,354,027,775,655,227,830,088,761,344 tokens (75.85% of circulating supply)
  2. 0x94e5a2a91e86108035f3c263a0e9a374170e334b — 7,958,200,344,405,590,803,792,632,217,600 tokens (0.92% of circulating supply)
  3. 0x96c9523810ee4d80ffab2586012101308d59a45e — 5,123,636,349,658,331,329,344,537,886,720 tokens (0.59% of circulating supply)
  4. 0x22e88adc159dc58642c5da8d240bc536d6ae5cec — 3,823,284,694,251,973,167,047,933,689,856 tokens (0.44% of circulating supply)
  5. 0x56b2a275bf05536fd16f76fb2fb622553b130672 — 3,725,835,935,135,129,927,376,533,716,992 tokens (0.43% of circulating supply)
  6. 0xf448b9bce6a9ae0e711715e62dc5dcb7eeffe2ce — 3,520,408,329,058,395,305,020,548,448,256 tokens (0.41% of circulating supply)
  7. 0x230eb2850a609891534bb675f7855624166b535e — 2,743,239,317,736,740,049,420,571,115,520 tokens (0.32% of circulating supply)
  8. 0x7f9ab3f05d3a9a34569e9adfd92d01d271d62897 — 2,317,057,404,772,292,599,625,996,566,528 tokens (0.27% of circulating supply)
  9. 0x98ca22b0d59b77970aec9fe1dd0af522fc4a8f43 — 2,023,104,736,069,969,548,103,907,278,848 tokens (0.23% of circulating supply)
  10. 0x021f9fd872a6ef5214a7e36410de7e8a03778d7f — 1,988,580,414,588,368,787,208,419,672,064 tokens (0.23% of circulating supply)

Top 10 Total Balance: 688,362,701,553,452,446,744,771,169,353,728 tokens
Top 10 Share of Circulating Supply: 79.70%
Top 10 Share of Total Supply: 68.84%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $27,951,913,179,171,384.00
Liquidity: $0.04
Liquidity/MCap Ratio: 0.0000
Token Volume: 51655644601.0910
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0000
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0032)
Total supply of LP tokens: 96945392.82287985
LP holders count: 1

Liquidity holders for 0x4B48821B9Bf2621e4cD4c3255083f04083c3B37e, (ElonMoney)

0x0000000000000000000000000000000000000000 holds 96945392.82287985 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/ElonMoneyBSC, Reason: metamask recovery phrase phishing
  URL: https://elonmoney.finance/, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1536.10 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-21T10:05:34
Last Active: 2025-07-31T15:28:56
Days Since Last Activity: 3.8705068192592593 days
Last Transaction Hash: 0xb1400c69cf91646dea49ef81a9d697b885a5ef17e7af988c06a9889359ce6617
