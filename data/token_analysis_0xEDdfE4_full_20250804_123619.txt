Token Analysis Report
==================================================
Token: Reaper Coin (0xEDdfE469b89375daCb5b05b9F4BB89334236E337)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function setascharityaccount(address account) external onlyowner() {
		feeaddress = account;
    }

  Code Snippet:
	function updatefee(uint256 _txfee,uint256 _burnfee,uint256 _charityfee) onlyowner() public{
		require(_txfee < 100 && _burnfee < 100 && _charityfee < 100);
        _tax_fee = _txfee* 100; 
        _burn_fee = _burnfee * 100;
		_charity_fee = _charityfee* 100;
		orig_tax_fee = _tax_fee;
		orig_burn_fee = _burn_fee;
		orig_charity_fee = _charity_fee;
	}

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "token20: transfer from the zero address");
        require(recipient != address(0), "token20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if(sender != owner() && recipient != owner())
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");

        uint256 contracttokenbalance = balanceof(address(this));
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        // remove fees for transfers to and from charity account or to excluded account
        bool takefee = true;
        if (feeaddress == sender || feeaddress == recipient || _isexcluded[recipient]) {
            takefee = false;
        }

        if (!takefee) removeallfee();
        
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }

        if (!takefee) restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tcharity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _standardtransfercontent(sender, recipient, ramount, rtransferamount);
        _sendtocharity(tcharity, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tcharity);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tcharity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _excludedfromtransfercontent(sender, recipient, ttransferamount, ramount, rtransferamount);        
        _sendtocharity(tcharity, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tcharity);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tcharity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _excludedtotransfercontent(sender, recipient, tamount, ramount, rtransferamount);
        _sendtocharity(tcharity, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tcharity);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tcharity) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _bothtransfercontent(sender, recipient, tamount, ramount, ttransferamount, rtransferamount);  
        _sendtocharity(tcharity, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tcharity);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn, uint256 tcharity) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _tcharitytotal = _tcharitytotal.add(tcharity);
        _ttotal = _ttotal.sub(tburn);
		emit transfer(address(this), address(0), tburn);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tfee, uint256 tburn, uint256 tcharity) = _gettbasics(tamount, _tax_fee, _burn_fee, _charity_fee);
        uint256 ttransferamount = getttransferamount(tamount, tfee, tburn, tcharity);
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rfee) = _getrbasics(tamount, tfee, currentrate);
        uint256 rtransferamount = _getrtransferamount(ramount, rfee, tburn, tcharity, currentrate);
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tburn, tcharity);
    }

  Code Snippet:
    function _gettbasics(uint256 tamount, uint256 taxfee, uint256 burnfee, uint256 charityfee) private view returns (uint256, uint256, uint256) {
        uint256 tfee = ((tamount.mul(taxfee)).div(_granularity)).div(100);
        uint256 tburn = ((tamount.mul(burnfee)).div(_granularity)).div(100);
        uint256 tcharity = ((tamount.mul(charityfee)).div(_granularity)).div(100);
        return (tfee, tburn, tcharity);
    }

  Code Snippet:
    function getttransferamount(uint256 tamount, uint256 tfee, uint256 tburn, uint256 tcharity) private pure returns (uint256) {
        return tamount.sub(tfee).sub(tburn).sub(tcharity);
    }

  Code Snippet:
    function _getrbasics(uint256 tamount, uint256 tfee, uint256 currentrate) private pure returns (uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        return (ramount, rfee);
    }

  Code Snippet:
    function _getrtransferamount(uint256 ramount, uint256 rfee, uint256 tburn, uint256 tcharity, uint256 currentrate) private pure returns (uint256) {
        uint256 rburn = tburn.mul(currentrate);
        uint256 rcharity = tcharity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rburn).sub(rcharity);
        return rtransferamount;
    }

  Code Snippet:
    function _sendtocharity(uint256 tcharity, address sender) private {
        uint256 currentrate = _getrate();
        uint256 rcharity = tcharity.mul(currentrate);
        _rowned[0x2840371e0fba5e21352ca7e026d546b127e4dba3] = _rowned[0x2840371e0fba5e21352ca7e026d546b127e4dba3].add(rcharity);
        _towned[0x2840371e0fba5e21352ca7e026d546b127e4dba3] = _towned[0x2840371e0fba5e21352ca7e026d546b127e4dba3].add(tcharity);
        emit transfer(sender, feeaddress, tcharity);
    }

  Code Snippet:
    function removeallfee() private {
        if(_tax_fee == 0 && _burn_fee == 0 && _charity_fee == 0) return;
        
        orig_tax_fee = _tax_fee;
        orig_burn_fee = _burn_fee;
        orig_charity_fee = _charity_fee;
        
        _tax_fee = 0;
        _burn_fee = 0;
        _charity_fee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _tax_fee = orig_tax_fee;
        _burn_fee = orig_burn_fee;
        _charity_fee = orig_charity_fee;
    }

  Code Snippet:
    function _gettaxfee() private view returns(uint256) {
        return _tax_fee;
    }


Holder Analysis
--------------
Total Unique Holders: 25
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x2dc317b6adc76bca8a5b03f37b6142b445543488 — 346,483,503,319,587,175,268,352 tokens (50.02% of circulating supply)
  2. 0xeb795f9f7ccb217fffb657e9af4e90b2587e1c72 — 15,724,126,332,226,499,510,272 tokens (2.27% of circulating supply)
  3. 0x47982c5c82d64eede999d94f8123bfdb0d18921e — 11,183,945,154,598,105,251,840 tokens (1.61% of circulating supply)
  4. 0x6ca83bf6a466bd6608963a1218a38558b9e305aa — 4,486,927,236,186,918,354,944 tokens (0.65% of circulating supply)
  5. 0x2840371e0fba5e21352ca7e026d546b127e4dba3 — 4,342,807,565,954,931,752,960 tokens (0.63% of circulating supply)
  6. 0x5e3773713f0a20806168d633652b905ee7253f83 — 4,103,071,419,235,718,135,808 tokens (0.59% of circulating supply)
  7. 0x4c9840b9c1f85906b5ec9bb9d87cf123330198d7 — 3,159,979,066,915,556,950,016 tokens (0.46% of circulating supply)
  8. 0xcb692809bf98a8201648b3c81f7231230f5cdfb1 — 3,028,669,257,514,129,817,600 tokens (0.44% of circulating supply)
  9. 0x456a4bdf83e236f5fadf5e031b2256b1cb0b1f75 — 2,971,638,588,993,721,335,808 tokens (0.43% of circulating supply)
  10. 0x3c65fde1a51f279c4ed3743479784bd126894e09 — 2,970,590,371,378,601,918,464 tokens (0.43% of circulating supply)

Top 10 Total Balance: 398,455,258,312,591,358,296,064 tokens
Top 10 Share of Circulating Supply: 57.52%
Top 10 Share of Total Supply: 40.65%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,129,931,137,823,211.75
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 1188665129442.7932
USD Volume: 1939.0240
24h Volume/Liquidity Ratio: 1715327.1628
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 379.4733192202055
LP holders count: 2

Liquidity holders for 0xEDdfE469b89375daCb5b05b9F4BB89334236E337, (Reaper Coin)

0x000000000000000000000000000000000000dead holds 379.4733192202055 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1490.71 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-07-05T19:28:25
Last Active: 2022-03-23T15:10:12
Days Since Last Activity: 1229.8931448042363 days
Last Transaction Hash: 0xa8e2e1d8fc6c63441111750b7968a4ea791e68803a238ec7e09bc091b3b98e3f
