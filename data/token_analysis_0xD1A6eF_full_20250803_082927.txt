Token Analysis Report
==================================================
Token: MetaMatrix (0xD1A6eFF20958403F9fa137760e62dfDE4516a0b1)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");
 
        _beforetokentransfer(address(0), account, amount);
 
        _totalsupply = _totalsupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit transfer(address(0), account, amount);
    }

  Code Snippet:
  function _mint(address account, uint256 value) internal override {
    super._mint(account, value);
 
    magnifieddividendcorrections[account] = magnifieddividendcorrections[account]
      .sub( (magnifieddividendpershare.mul(value)).toint256safe() );
  }

  Code Snippet:
  function _setbalance(address account, uint256 newbalance) internal {
    uint256 currentbalance = balanceof(account);
 
    if(newbalance > currentbalance) {
      uint256 mintamount = newbalance.sub(currentbalance);
      _mint(account, mintamount);
    } else if(newbalance < currentbalance) {
      uint256 burnamount = currentbalance.sub(newbalance);
      _burn(account, burnamount);
    }
  }

  Code Snippet:
    function withdrawdividend() pure public override {
        require(false, "metamatrix_busd_dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main metamatrix contract.");
    }

  Code Snippet:
    function updateclaimwait(uint256 newclaimwait) external onlyowner {
        require(newclaimwait >= 3600 && newclaimwait <= 86400, "metamatrix_busd_dividend_tracker: claimwait must be updated to between 1 and 24 hours");
        require(newclaimwait != claimwait, "metamatrix_busd_dividend_tracker: cannot update claimwait to same value");
        emit claimwaitupdated(newclaimwait, claimwait);
        claimwait = newclaimwait;
    }

  Code Snippet:
    function canautoclaim(uint256 lastclaimtime) private view returns (bool) {
    	if(lastclaimtime > block.timestamp)  {
    		return false;
    	}
 
    	return block.timestamp.sub(lastclaimtime) >= claimwait;
    }

  Code Snippet:
    function process(uint256 gas) public returns (uint256, uint256, uint256) {
    	uint256 numberoftokenholders = tokenholdersmap.keys.length;
 
    	if(numberoftokenholders == 0) {
    		return (0, 0, lastprocessedindex);
    	}
 
    	uint256 _lastprocessedindex = lastprocessedindex;
 
    	uint256 gasused = 0;
 
    	uint256 gasleft = gasleft();
 
    	uint256 iterations = 0;
    	uint256 claims = 0;
 
    	while(gasused < gas && iterations < numberoftokenholders) {
    		_lastprocessedindex++;
 
    		if(_lastprocessedindex >= tokenholdersmap.keys.length) {
    			_lastprocessedindex = 0;
    		}
 
    		address account = tokenholdersmap.keys[_lastprocessedindex];
 
    		if(canautoclaim(lastclaimtimes[account])) {
    			if(processaccount(payable(account), true)) {
    				claims++;
    			}
    		}
 
    		iterations++;
 
    		uint256 newgasleft = gasleft();
 
    		if(gasleft > newgasleft) {
    			gasused = gasused.add(gasleft.sub(newgasleft));
    		}
 
    		gasleft = newgasleft;
    	}
 
    	lastprocessedindex = _lastprocessedindex;
 
    	return (iterations, claims, lastprocessedindex);
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);
 
    	if(amount > 0) {
    		lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
    		return true;
    	}
 
    	return false;
    }

  Code Snippet:
    function setbusddividendenabled(bool _enabled) external onlyowner {
        require(busddividendenabled != _enabled, "can't set flag to same status");
        if (_enabled == false) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 0;
            busddividendenabled = _enabled;
        } else if (_enabled == true) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 4;
            busddividendenabled = _enabled;
        }
 
        emit busddividendenabledupdated(_enabled);
    }

  Code Snippet:
    function updateclaimwait(uint256 claimwait) external onlyowner {
        busddividendtracker.updateclaimwait(claimwait);

    }

  Code Snippet:
    function getbusdclaimwait() external view returns(uint256) {
        return busddividendtracker.claimwait();
    }

  Code Snippet:
	function processdividendtracker(uint256 gas) external onlyowner {
		(uint256 busditerations, uint256 busdclaims, uint256 busdlastprocessedindex) = busddividendtracker.process(gas);
		emit processedbusddividendtracker(busditerations, busdclaims, busdlastprocessedindex, false, gas, tx.origin);
 
		
    }

  Code Snippet:
    function claim() external {
		busddividendtracker.processaccount(payable(msg.sender), false);
		
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
  function setauth(address account) external onlyowner{
      _isauth[account] = true;
  }

  Code Snippet:
    function setauthondividends(address account) public onlyowner {
        busddividendtracker.setauth(account);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function setbusddividendenabled(bool _enabled) external onlyowner {
        require(busddividendenabled != _enabled, "can't set flag to same status");
        if (_enabled == false) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 0;
            busddividendenabled = _enabled;
        } else if (_enabled == true) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 4;
            busddividendenabled = _enabled;
        }
 
        emit busddividendenabledupdated(_enabled);
    }

WARNING: High Tax Detected
  Code Snippet:
  function withdrawdividend() external;
 

  Code Snippet:
  function withdrawabledividendof(address _owner) external view returns(uint256);
 

  Code Snippet:
  function withdrawndividendof(address _owner) external view returns(uint256);
 

  Code Snippet:
  function withdrawdividend() public virtual override {
    _withdrawdividendofuser(payable(msg.sender));
  }

  Code Snippet:
  function _withdrawdividendofuser(address payable user) internal returns (uint256) {
    uint256 _withdrawabledividend = withdrawabledividendof(user);
    if (_withdrawabledividend > 0) {
      withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
      emit dividendwithdrawn(user, _withdrawabledividend);
      bool success = ierc20(dividendtoken).transfer(user, _withdrawabledividend);
 
      if(!success) {
        withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
        return 0;
      }
 
      return _withdrawabledividend;
    }
 
    return 0;
  }

  Code Snippet:
  function dividendof(address _owner) public view override returns(uint256) {
    return withdrawabledividendof(_owner);
  }

  Code Snippet:
  function withdrawabledividendof(address _owner) public view override returns(uint256) {
    return accumulativedividendof(_owner).sub(withdrawndividends[_owner]);
  }

  Code Snippet:
  function withdrawndividendof(address _owner) public view override returns(uint256) {
    return withdrawndividends[_owner];
  }

  Code Snippet:
    function feetosetter() external view returns (address);
 

  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts); 
 

  Code Snippet:
function removeliquidityethwithpermitsupportingfeeontransfertokens( address token, uint liquidity, uint amounttokenmin, uint amountethmin, address to, uint deadline, bool approvemax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amounteth); 
 

  Code Snippet:
function swapexacttokensforethsupportingfeeontransfertokens( uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline ) external; 
 

  Code Snippet:
    function withdrawdividend() pure public override {
        require(false, "metamatrix_busd_dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main metamatrix contract.");
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);
 
    	if(amount > 0) {
    		lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
    		return true;
    	}
 
    	return false;
    }

  Code Snippet:
  	function prepareforpartherorexchangelisting(address _partnerorexchangeaddress) external onlyowner {
  	    busddividendtracker.excludefromdividends(_partnerorexchangeaddress);
        excludefromfees(_partnerorexchangeaddress, true);
  	}

  Code Snippet:
  	function updatemarketingwallet(address _newwallet) external onlyowner {
  	    require(_newwallet != marketingwallet, "metamatrix: the marketing wallet is already this address");
        excludefromfees(_newwallet, true);
        emit marketingwalletupdated(marketingwallet, _newwallet);
  	    marketingwallet = _newwallet;
  	}

  Code Snippet:
  	function setswaptokensatamount(uint256 _swapamount) external onlyowner {
  	    swaptokensatamount = _swapamount * (10**18);
  	}

  Code Snippet:
  	function setselltransactionmultiplier(uint256 _multiplier) external onlyowner {
  	    sellfeeincreasefactor = _multiplier;
  	}

  Code Snippet:
    function settradingisenabled(bool _enabled) external onlyowner {
        tradingisenabled = _enabled;
    }

  Code Snippet:
    function setbusddividendenabled(bool _enabled) external onlyowner {
        require(busddividendenabled != _enabled, "can't set flag to same status");
        if (_enabled == false) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 0;
            busddividendenabled = _enabled;
        } else if (_enabled == true) {
            previousbusddividendrewardsfee = busddividendrewardsfee;
            busddividendrewardsfee = 4;
            busddividendenabled = _enabled;
        }
 
        emit busddividendenabledupdated(_enabled);
    }

  Code Snippet:
    function setmarketingenabled(bool _enabled) external onlyowner {
        require(marketingenabled != _enabled, "can't set flag to same status");
        if (_enabled == false) {
            previousmarketingfee = marketingfee;
            marketingfee = 0;
            marketingenabled = _enabled;
        } else if (_enabled == true) {
            previousmarketingfee = marketingfee;
            marketingfee = 4;
            marketingenabled = _enabled;
        }
 
        emit marketingenabledupdated(_enabled);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) external onlyowner {
        require(swapandliquifyenabled != _enabled, "can't set flag to same status");
        if (_enabled == false) {
            previousliquidityfee = liquidityfee;
            liquidityfee = 0;
            swapandliquifyenabled = _enabled;
        } else if (_enabled == true) {
            previousliquidityfee = liquidityfee;
            liquidityfee = 4;
            swapandliquifyenabled = _enabled;
        }
 
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function updatebusddividendtracker(address newaddress) external onlyowner {
        require(newaddress != address(busddividendtracker), "metamatrix: the dividend tracker already has that address");
 
        busddividendtracker newbusddividendtracker = busddividendtracker(payable(newaddress));
 
        require(newbusddividendtracker.owner() == address(this), "metamatrix: the new dividend tracker must be owned by the metamatrix token contract");
 
        newbusddividendtracker.excludefromdividends(address(newbusddividendtracker));
        newbusddividendtracker.excludefromdividends(address(this));
        newbusddividendtracker.excludefromdividends(address(uniswapv2router));
        newbusddividendtracker.excludefromdividends(address(deadaddress));
 
        emit updatebusddividendtracker(newaddress, address(busddividendtracker));
 
        busddividendtracker = newbusddividendtracker;
    }

  Code Snippet:
    function updateuniswapv2router(address newaddress) external onlyowner {
        require(newaddress != address(uniswapv2router), "metamatrix: the router already has that address");
        emit updateuniswapv2router(newaddress, address(uniswapv2router));
        uniswapv2router = iuniswapv2router02(newaddress);
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        require(isexcludedfromfees[account] != excluded, "metamatrix: account is already exluded from fees");
        isexcludedfromfees[account] = excluded;
 
        emit excludefromfees(account, excluded);
    }

  Code Snippet:
    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {
        require(pair != uniswapv2pair, "metamatrix: the pancakeswap pair cannot be removed from automatedmarketmakerpairs");
 
        _setautomatedmarketmakerpair(pair, value);
    }

  Code Snippet:
    function getisexcludedfromfees(address account) public view returns(bool) {
        return isexcludedfromfees[account];
    }

  Code Snippet:
    function withdrawablebusddividendof(address account) external view returns(uint256) {
    	return busddividendtracker.withdrawabledividendof(account);
  	}

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
 
        uint256 initialbalance = address(this).balance;
 
        swaptokensforbnb(half);
 
        uint256 newbalance = address(this).balance.sub(initialbalance);
 
        addliquidity(otherhalf, newbalance);
 
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {
 
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);
 
        // add the liquidity
        uniswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            marketingwallet,
            block.timestamp
        );
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
 
        _approve(address(this), address(uniswapv2router), tokenamount);
 
        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
 
    }

  Code Snippet:
    function swaptokensfordividendtoken(uint256 _tokenamount, address _recipient, address _dividendaddress) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = _dividendaddress;
 
        _approve(address(this), address(uniswapv2router), _tokenamount);
 
        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            _tokenamount,
            0, // accept any amount of dividend token
            path,
            _recipient,
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsendbusddividends(uint256 tokens) private {
        swaptokensfordividendtoken(tokens, address(this), busddividendtoken);
        uint256 busddividends = ierc20(busddividendtoken).balanceof(address(this));
        transferdividends(busddividendtoken, address(busddividendtracker), busddividendtracker, busddividends);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x6cfff14d6f9b6359d669c2f51a0666252471996f
Owner Balance: 487,167,010,832,374,123,867,486,195,548,160 tokens
Owner Share: 51.00% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x6cfff14d6f9b6359d669c2f51a0666252471996f — 487,167,010,832,374,123,867,486,195,548,160 tokens (51.00% of circulating supply)
  2. 0x8ac859b8e542dd0f170fc716f02ae80ce9e4471c — 184,138,324,249,248,178,312,806,351,765,504 tokens (19.28% of circulating supply)
  3. 0xd1a6eff20958403f9fa137760e62dfde4516a0b1 — 60,328,367,761,963,092,129,610,349,936,640 tokens (6.32% of circulating supply)
  4. 0x1c4251d3437905036d181c42c99828eb52467d00 — 23,812,250,000,000,001,054,110,166,024,192 tokens (2.49% of circulating supply)
  5. 0x76c49be4eba18e73a723639835021d3f414e7bf8 — 20,550,026,639,999,042,606,888,623,538,176 tokens (2.15% of circulating supply)
  6. 0xce1395eace0bc906c1da4ecaac4f49b0190db363 — 12,630,856,949,659,703,838,717,142,630,400 tokens (1.32% of circulating supply)
  7. 0x71fbc2a205ef61b14d03a6f7c2da0e70f762c431 — 6,029,130,825,568,250,358,430,936,596,480 tokens (0.63% of circulating supply)
  8. 0x8f6512b144f7ba617e894ac6d7dda537f437beb2 — 5,601,636,208,167,350,380,395,596,087,296 tokens (0.59% of circulating supply)
  9. 0x4b04213c2774f77e60702880654206b116d00508 — 3,727,289,673,645,606,729,434,018,086,912 tokens (0.39% of circulating supply)
  10. 0x204c5a0f5c468b24d6a0abdc01e2cfcecfc6f0a8 — 3,409,496,105,753,835,307,723,799,920,640 tokens (0.36% of circulating supply)

Top 10 Total Balance: 807,394,389,246,379,184,585,603,180,134,400 tokens
Top 10 Share of Circulating Supply: 84.53%
Top 10 Share of Total Supply: 80.74%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,450,161,724,223,050.75
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 61952000000.0000
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0276
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (48.7167)
Total supply of LP tokens: 34819.78526272469
LP holders count: 8

Liquidity holders for 0xD1A6eFF20958403F9fa137760e62dfDE4516a0b1, (MetaMatrix)

0x252caae7a2cf2cb13c8503af1b79f60a29eeb085 holds 21578.091503463078 LP tokens

0x527e5d132847885ae2be0392ade818ad6c5bbac3 holds 11576.254885049535 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 647.972546069603 LP tokens

0x3a717e09704feefeb982dbc7e411714d474c9654 holds 495.6094667005561 LP tokens

0x02ca1bace1638a45408917c6f320debf7a19ca65 holds 466.43901240293434 LP tokens

0xe4a5d813f3fae74ae07897097f2f8a8bd3bee491 holds 55.417316059565586 LP tokens

0x6a3acaae514da7d943dba72f8627c79ded0b2db1 holds 0.00053297941455317 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/MetaverseMatrix, Reason: metamask recovery phrase phishing
  URL: https://www.metamatrix.network/, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/MetaMatrixBSC, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/RequestNetwork/requestNetwork/issues/43, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1339.56 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-02T19:03:37
Last Active: 2025-08-02T20:13:36
Days Since Last Activity: 0.5110142415046297 days
Last Transaction Hash: 0xfd4234a2bcd798bb11c9359b497a7a3ec75429aaa7bb0abdaa023e2d7e4b73db
