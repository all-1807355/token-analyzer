{
    "token_address": "0x271C48bb9b0dF4b604184Ce22D436E271d42fa61",
    "chain": "bsc",
    "token_name": "SpaceXliFe",
    "analyses": {
        "contract": {
            "contract_name": "SpaceXliFe",
            "compiler_version": "v0.8.7+commit.e28d00a7",
            "license_type": "MIT",
            "implementation": "",
            "source_code": "{\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IBEP20 {\\n  function totalSupply() external view returns (uint256);\\n  function decimals() external view returns (uint8);\\n  function symbol() external view returns (string memory);\\n  function name() external view returns (string memory);\\n  function getOwner() external view returns (address);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IPancakeFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IPancakeRouter {\\n   \\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n}\\n\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\\n\"},\"SpaceXliFe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\nimport \\\"./Libraries.sol\\\";\\ncontract SpaceXliFe is IBEP20, Ownable\\n{\\n  \\n    mapping (address =\\u003e uint) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\n    mapping(address =\\u003e bool) public excludedFromFees;\\n    mapping(address =\\u003e bool) public excludedFromLimit;\\n    mapping(address=\\u003ebool) public isAMM;\\n    //Token Info\\n    string private constant _name = \\u0027SpaceXliFe\\u0027;\\n    string private constant _symbol = \\u0027SAFE\\u0027;\\n    uint8 private constant _decimals = 18;\\n    uint public constant InitialSupply= 8*10**9 * 10**_decimals;//equals 8.000.000.000 Token\\n\\n    uint private constant DefaultLiquidityLockTime=7 days;\\n    //0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 testnet router\\n    //0x10ED43C718714eb63d5aA57B78B54704E256024E mainnet router\\n\\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n\\n    //variables that track balanceLimit and sellLimit,\\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\\n    uint private _circulatingSupply =InitialSupply;\\n    \\n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\\n    uint public buyTax = 100;\\n    uint public sellTax = 200;\\n    uint public transferTax = 0;\\n    uint public burnTax=0;\\n    uint public liquidityTax=100;\\n    uint public marketingTax=900;\\n    uint constant TAX_DENOMINATOR=1000;\\n    uint constant MAXTAXDENOMINATOR=10;\\n    \\n\\n    address private _pancakePairAddress; \\n    IPancakeRouter private  _pancakeRouter;\\n    \\n    \\n    //TODO: marketingWallet\\n    address public marketingWallet;\\n    //Only marketingWallet can change marketingWallet\\n    function ChangeMarketingWallet(address newWallet) public{\\n        require(msg.sender==marketingWallet);\\n        marketingWallet=newWallet;\\n    }\\n    //modifier for functions only the team can call\\n    modifier onlyTeam() {\\n        require(_isTeam(msg.sender), \\\"Caller not Team or Owner\\\");\\n        _;\\n    }\\n    //Checks if address is in Team, is needed to give Team access even if contract is renounced\\n    //Team doesn\\u0027t have access to critical Functions that could turn this into a Rugpull(Exept liquidity unlocks)\\n    function _isTeam(address addr) private view returns (bool){\\n        return addr==owner()||addr==marketingWallet;\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    constructor () {\\n        uint deployerBalance=_circulatingSupply;\\n        _balances[msg.sender] = deployerBalance;\\n        emit Transfer(address(0), msg.sender, deployerBalance);\\n\\n        // Pancake Router\\n        _pancakeRouter = IPancakeRouter(PancakeRouter);\\n        //Creates a Pancake Pair\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\n        isAMM[_pancakePairAddress]=true;\\n        \\n        //contract creator is by default marketing wallet\\n        marketingWallet=msg.sender;\\n        //owner pancake router and contract is excluded from Taxes\\n        excludedFromFees[msg.sender]=true;\\n        excludedFromFees[PancakeRouter]=true;\\n        excludedFromFees[address(this)]=true;\\n    }\\n    \\n\\n\\n\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    //transfer function, every transfer runs through this function\\n    function _transfer(address sender, address recipient, uint amount) private{\\n        require(sender != address(0), \\\"Transfer from zero\\\");\\n        require(recipient != address(0), \\\"Transfer to zero\\\");\\n\\n\\n        //Pick transfer\\n        if(excludedFromFees[sender] || excludedFromFees[recipient])\\n            _feelessTransfer(sender, recipient, amount);\\n        else if(excludedFromLimit[recipient]){ \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _LimitlessFonctionTransfer(sender,recipient,amount);                  \\n        }\\n        else { \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _taxedTransfer(sender,recipient,amount);                  \\n        }\\n    }\\n    \\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\\n    function _taxedTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        uint recipientBalance = _balances[recipient];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        require((recipientBalance + amount ) \\u003c= InitialSupply/200, \\\"Wallet contain more than 0.5% Total Supply\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    //Start tax drops depending on the time since launch, enables bot protection and Dump protection\\n    function _getStartTax(uint duration, uint maxTax) private view returns (uint){\\n        uint timeSinceLaunch=block.timestamp-LaunchTimestamp;\\n        return maxTax-((maxTax-50)*timeSinceLaunch/duration);\\n    }\\n    //Calculates the token that should be taxed\\n    function _calculateFee(uint amount, uint tax, uint taxPercent) private pure returns (uint) {\\n        return (amount*tax*taxPercent) / (TAX_DENOMINATOR*TAX_DENOMINATOR);\\n    }\\n\\n\\n    //Feeless transfer only transfers and autostakes\\n    function _feelessTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        _balances[sender]-=amount;\\n        _balances[recipient]+=amount;      \\n        emit Transfer(sender,recipient,amount);\\n    }\\n///////////////////////////////Yeaaaah//////////addd\\n    function _LimitlessFonctionTransfer (address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    \\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    \\n    //Locks the swap if already swapping\\n    bool private _isSwappingContractModifier;\\n    modifier lockTheSwap {\\n        _isSwappingContractModifier = true;\\n        _;\\n        _isSwappingContractModifier = false;\\n    }\\n\\n    //Sets the permille of pancake pair to trigger liquifying taxed token\\n    uint public swapTreshold=2;\\n    function setSwapTreshold(uint newSwapTresholdPermille) public onlyTeam{\\n        require(newSwapTresholdPermille\\u003c=15);//MaxTreshold= 1.5%\\n        swapTreshold=newSwapTresholdPermille;\\n    }\\n    //Sets the max Liquidity where swaps for Liquidity still happen\\n    uint public overLiquifyTreshold=150;\\n    function SetOverLiquifiedTreshold(uint newOverLiquifyTresholdPermille) public onlyTeam{\\n        require(newOverLiquifyTresholdPermille\\u003c=1000);\\n        overLiquifyTreshold=newOverLiquifyTresholdPermille;\\n    }\\n    //Sets the taxes Burn+marketing+liquidity tax needs to equal the TAX_DENOMINATOR (1000)\\n    //buy, sell and transfer tax are limited by the MAXTAXDENOMINATOR\\n    event OnSetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity);\\n    function SetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity) public onlyTeam{\\n        uint maxTax=3*(TAX_DENOMINATOR/MAXTAXDENOMINATOR);\\n        require(buy\\u003c=maxTax\\u0026\\u0026sell\\u003c=maxTax\\u0026\\u0026transfer_\\u003c=maxTax,\\\"Tax exceeds maxTax\\\");\\n        require(burn+marketing+liquidity==TAX_DENOMINATOR,\\\"Taxes don\\u0027t add up to denominator\\\");\\n        \\n        buyTax=buy;\\n        sellTax=sell;\\n        transferTax=transfer_;\\n        marketingTax=marketing;\\n        liquidityTax=liquidity;\\n        burnTax=burn;\\n        emit OnSetTaxes(buy, sell, transfer_, burn, marketing,liquidity);\\n    }\\n    \\n    //If liquidity is over the treshold, convert 100% of Token to Marketing BNB to avoid overliquifying\\n    function isOverLiquified() public view returns(bool){\\n        return _balances[_pancakePairAddress]\\u003e_circulatingSupply*overLiquifyTreshold/1000;\\n    }\\n\\n\\n    //swaps the token on the contract for Marketing BNB and LP Token.\\n    //always swaps a percentage of the LP pair balance to avoid price impact\\n    function _swapContractToken(bool ignoreLimits) private lockTheSwap{\\n        uint contractBalance=_balances[address(this)];\\n        uint totalTax=liquidityTax+marketingTax;\\n        //swaps each time it reaches swapTreshold of pancake pair to avoid large prize impact\\n        uint tokenToSwap=_balances[_pancakePairAddress]*swapTreshold/1000;\\n\\n        //nothing to swap at no tax\\n        if(totalTax==0)return;\\n        //only swap if contractBalance is larger than tokenToSwap, and totalTax is unequal to 0\\n        //Ignore limits swaps 100% of the contractBalance\\n        if(ignoreLimits)\\n            tokenToSwap=_balances[address(this)];\\n        else if(contractBalance\\u003ctokenToSwap)\\n            return;\\n\\n        //splits the token in TokenForLiquidity and tokenForMarketing\\n        //if over liquified, 0 tokenForLiquidity\\n        uint tokenForLiquidity=\\n        isOverLiquified()?0\\n        :(tokenToSwap*liquidityTax)/totalTax;\\n\\n        uint tokenForMarketing= tokenToSwap-tokenForLiquidity;\\n\\n        uint LiqHalf=tokenForLiquidity/2;\\n        //swaps marktetingToken and the liquidity token half for BNB\\n        uint swapToken=LiqHalf+tokenForMarketing;\\n        //Gets the initial BNB balance, so swap won\\u0027t touch any contract BNB\\n        uint initialBNBBalance = address(this).balance;\\n        _swapTokenForBNB(swapToken);\\n        uint newBNB=(address(this).balance - initialBNBBalance);\\n\\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\\n        if(tokenForLiquidity\\u003e0){\\n            uint liqBNB = (newBNB*LiqHalf)/swapToken;\\n            _addLiquidity(LiqHalf, liqBNB);\\n        }\\n        //Sends all the marketing BNB to the marketingWallet\\n        (bool sent,)=marketingWallet.call{value:address(this).balance}(\\\"\\\");\\n        sent=true;\\n    }\\n    //swaps tokens on the contract for BNB\\n    function _swapTokenForBNB(uint amount) private {\\n        _approve(address(this), address(_pancakeRouter), amount);\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _pancakeRouter.WETH();\\n\\n        try _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        ){}\\n        catch{}\\n    }\\n    //Adds Liquidity directly to the contract where LP are locked\\n    function _addLiquidity(uint tokenamount, uint bnbamount) private {\\n        _approve(address(this), address(_pancakeRouter), tokenamount);\\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\\n            address(this),\\n            tokenamount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \\n    function getLiquidityReleaseTimeInSeconds() public view returns (uint){\\n        if(block.timestamp\\u003c_liquidityUnlockTime)\\n            return _liquidityUnlockTime-block.timestamp;\\n        return 0;\\n    }\\n    function getBurnedTokens() public view returns(uint){\\n        return (InitialSupply-_circulatingSupply)+_balances[address(0xdead)];\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //For AMM addresses buy and sell taxes apply\\n    function SetAMM(address AMM, bool Add) public onlyTeam{\\n        require(AMM!=_pancakePairAddress,\\\"can\\u0027t change pancake\\\");\\n        isAMM[AMM]=Add;\\n    }\\n    \\n    bool public manualSwap;\\n    //switches autoLiquidity and marketing BNB generation during transfers\\n    function SwitchManualSwap(bool manual) public onlyTeam{\\n        manualSwap=manual;\\n    }\\n    //manually converts contract token to LP and staking BNB\\n    function SwapContractToken() public onlyTeam{\\n    _swapContractToken(true);\\n    }\\n    event ExcludeAccount(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludeAccountFromFees(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromFees[account]=exclude;\\n        emit ExcludeAccount(account,exclude);\\n    }\\n\\n    /////////////moussss///////////\\n     event ExcludeAccountLimit(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludedFromLimit(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromLimit[account]=exclude;\\n        emit ExcludeAccountLimit(account,exclude);\\n    }\\n\\n\\n\\n    //Enables trading. Sets the launch timestamp to the given Value\\n    event OnEnableTrading();\\n    uint public LaunchTimestamp;\\n    function SetupEnableTrading() public onlyTeam{\\n        require(LaunchTimestamp==0,\\\"AlreadyLaunched\\\");\\n        LaunchTimestamp=block.timestamp;\\n        emit OnEnableTrading();\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //the timestamp when Liquidity unlocks\\n    uint _liquidityUnlockTime;\\n    bool public LPReleaseLimitedTo20Percent;\\n    //Sets Liquidity Release to 20% at a time and prolongs liquidity Lock for a Week after Release. \\n    //That way autoLiquidity can be slowly released \\n    function limitLiquidityReleaseTo20Percent() public onlyTeam{\\n        LPReleaseLimitedTo20Percent=true;\\n    }\\n    //Locks Liquidity for seconds. can only be prolonged\\n    function LockLiquidityForSeconds(uint secondsUntilUnlock) public onlyTeam{\\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\\n    }\\n    event OnProlongLPLock(uint UnlockTimestamp);\\n    function _prolongLiquidityLock(uint newUnlockTime) private{\\n        // require new unlock time to be longer than old one\\n        require(newUnlockTime\\u003e_liquidityUnlockTime);\\n        _liquidityUnlockTime=newUnlockTime;\\n        emit OnProlongLPLock(_liquidityUnlockTime);\\n    }\\n    event OnReleaseLP();\\n    //Release Liquidity Tokens once unlock time is over\\n    function LiquidityRelease() public onlyTeam {\\n        //Only callable if liquidity Unlock time is over\\n        require(block.timestamp \\u003e= _liquidityUnlockTime, \\\"Not yet unlocked\\\");\\n\\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\\n        uint amount = liquidityToken.balanceOf(address(this));\\n        if(LPReleaseLimitedTo20Percent)\\n        {\\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\n            //regular liquidity release, only releases 50% at a time and locks liquidity for another week\\n            amount=amount*2/10;\\n        }\\n        liquidityToken.transfer(msg.sender, amount);\\n        emit OnReleaseLP();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    receive() external payable {}\\n\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return _circulatingSupply;\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) external view override returns (uint) {\\n        return _allowances[_owner][spender];\\n    }\\n\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n    function _approve(address owner, address spender, uint amount) private {\\n        require(owner != address(0), \\\"Approve from zero\\\");\\n        require(spender != address(0), \\\"Approve to zero\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"Transfer \\u003e allowance\\\");\\n\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    // IBEP20 - Helpers\\n\\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\\n        uint currentAllowance = _allowances[msg.sender][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"\\u003c0 allowance\\\");\\n\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n        return true;\\n    }\\n\\n}\"}}",
            "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UnlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"OnProlongLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"OnSetTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludedFromLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPReleaseLimitedTo20Percent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"LockLiquidityForSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"SetAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newOverLiquifyTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"SetOverLiquifiedTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SwapContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"SwitchManualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityReleaseTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAMM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitLiquidityReleaseTo20Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overLiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"setSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
            "verified": true,
            "owner": "0x294d213bbf2c9f87af68008d08f2be79f4774ceb",
            "creator": "0x294d213bbf2c9f87af68008d08f2be79f4774ceb",
            "is_hidden_owner": false,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "total_matches": 1,
                "patterns_found": {
                    "router_manipulation": {
                        "count": 1,
                        "snippets": [
                            {
                                "matched_code": "modifier locktheswap",
                                "function_context": "{\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IBEP20 {\\n  function totalSupply() external view returns (uint256);\\n  function decimals() external view returns (uint8);\\n  function symbol() external view returns (string memory);\\n  function name() external view returns (string memory);\\n  function getOwner() external view returns (address);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IPancakeFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IPancakeRouter {\\n   \\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n}\\n\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\n\\n\\n\"},\"SpaceXliFe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\nimport \\\"./Libraries.sol\\\";\\ncontract SpaceXliFe is IBEP20, Ownable\\n{\\n  \\n    mapping (address =\\u003e uint) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\n    mapping(address =\\u003e bool) public excludedFromFees;\\n    mapping(address =\\u003e bool) public excludedFromLimit;\\n    mapping(address=\\u003ebool) public isAMM;\\n    //Token Info\\n    string private constant _name = \\u0027SpaceXliFe\\u0027;\\n    string private constant _symbol = \\u0027SAFE\\u0027;\\n    uint8 private constant _decimals = 18;\\n    uint public constant InitialSupply= 8*10**9 * 10**_decimals;//equals 8.000.000.000 Token\\n\\n    uint private constant DefaultLiquidityLockTime=7 days;\\n    //0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 testnet router\\n    //0x10ED43C718714eb63d5aA57B78B54704E256024E mainnet router\\n\\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n\\n    //variables that track balanceLimit and sellLimit,\\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\\n    uint private _circulatingSupply =InitialSupply;\\n    \\n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\\n    uint public buyTax = 100;\\n    uint public sellTax = 200;\\n    uint public transferTax = 0;\\n    uint public burnTax=0;\\n    uint public liquidityTax=100;\\n    uint public marketingTax=900;\\n    uint constant TAX_DENOMINATOR=1000;\\n    uint constant MAXTAXDENOMINATOR=10;\\n    \\n\\n    address private _pancakePairAddress; \\n    IPancakeRouter private  _pancakeRouter;\\n    \\n    \\n    //TODO: marketingWallet\\n    address public marketingWallet;\\n    //Only marketingWallet can change marketingWallet\\n    function ChangeMarketingWallet(address newWallet) public{\\n        require(msg.sender==marketingWallet);\\n        marketingWallet=newWallet;\\n    }\\n    //modifier for functions only the team can call\\n    modifier onlyTeam() {\\n        require(_isTeam(msg.sender), \\\"Caller not Team or Owner\\\");\\n        _;\\n    }\\n    //Checks if address is in Team, is needed to give Team access even if contract is renounced\\n    //Team doesn\\u0027t have access to critical Functions that could turn this into a Rugpull(Exept liquidity unlocks)\\n    function _isTeam(address addr) private view returns (bool){\\n        return addr==owner()||addr==marketingWallet;\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    constructor () {\\n        uint deployerBalance=_circulatingSupply;\\n        _balances[msg.sender] = deployerBalance;\\n        emit Transfer(address(0), msg.sender, deployerBalance);\\n\\n        // Pancake Router\\n        _pancakeRouter = IPancakeRouter(PancakeRouter);\\n        //Creates a Pancake Pair\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\n        isAMM[_pancakePairAddress]=true;\\n        \\n        //contract creator is by default marketing wallet\\n        marketingWallet=msg.sender;\\n        //owner pancake router and contract is excluded from Taxes\\n        excludedFromFees[msg.sender]=true;\\n        excludedFromFees[PancakeRouter]=true;\\n        excludedFromFees[address(this)]=true;\\n    }\\n    \\n\\n\\n\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    //transfer function, every transfer runs through this function\\n    function _transfer(address sender, address recipient, uint amount) private{\\n        require(sender != address(0), \\\"Transfer from zero\\\");\\n        require(recipient != address(0), \\\"Transfer to zero\\\");\\n\\n\\n        //Pick transfer\\n        if(excludedFromFees[sender] || excludedFromFees[recipient])\\n            _feelessTransfer(sender, recipient, amount);\\n        else if(excludedFromLimit[recipient]){ \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _LimitlessFonctionTransfer(sender,recipient,amount);                  \\n        }\\n        else { \\n            //once trading is enabled, it can\\u0027t be turned off again\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\n            _taxedTransfer(sender,recipient,amount);                  \\n        }\\n    }\\n    \\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\\n    function _taxedTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        uint recipientBalance = _balances[recipient];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        require((recipientBalance + amount ) \\u003c= InitialSupply/200, \\\"Wallet contain more than 0.5% Total Supply\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    //Start tax drops depending on the time since launch, enables bot protection and Dump protection\\n    function _getStartTax(uint duration, uint maxTax) private view returns (uint){\\n        uint timeSinceLaunch=block.timestamp-LaunchTimestamp;\\n        return maxTax-((maxTax-50)*timeSinceLaunch/duration);\\n    }\\n    //Calculates the token that should be taxed\\n    function _calculateFee(uint amount, uint tax, uint taxPercent) private pure returns (uint) {\\n        return (amount*tax*taxPercent) / (TAX_DENOMINATOR*TAX_DENOMINATOR);\\n    }\\n\\n\\n    //Feeless transfer only transfers and autostakes\\n    function _feelessTransfer(address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n        _balances[sender]-=amount;\\n        _balances[recipient]+=amount;      \\n        emit Transfer(sender,recipient,amount);\\n    }\\n///////////////////////////////Yeaaaah//////////addd\\n    function _LimitlessFonctionTransfer (address sender, address recipient, uint amount) private{\\n        uint senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\n\\n        bool isBuy=isAMM[sender];\\n        bool isSell=isAMM[recipient];\\n\\n        uint tax;\\n        if(isSell){  \\n            uint SellTaxDuration=180 seconds;          \\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\n                tax=_getStartTax(SellTaxDuration,999);\\n                }else tax=sellTax;\\n            }\\n        else if(isBuy){\\n            uint BuyTaxDuration=20 seconds;\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\n                tax=_getStartTax(BuyTaxDuration,999);\\n            }else tax=buyTax;\\n        } else tax=transferTax;\\n\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\n            _swapContractToken(false);\\n\\n        //Calculates the exact token amount for each tax\\n        uint tokensToBeBurnt=_calculateFee(amount, tax, burnTax);\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax);\\n        //Subtract the Taxed Tokens from the amount\\n        uint taxedAmount=amount-(tokensToBeBurnt + contractToken);\\n\\n        _balances[sender]-=amount;\\n        //Adds the taxed tokens to the contract wallet\\n        _balances[address(this)] += contractToken;\\n        //Burns tokens\\n        _circulatingSupply-=tokensToBeBurnt;\\n        _balances[recipient]+=taxedAmount;\\n        \\n        emit Transfer(sender,recipient,taxedAmount);\\n    }\\n    \\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    \\n    //Locks the swap if already swapping\\n    bool private _isSwappingContractModifier;\\n    modifier lockTheSwap {\\n        _isSwappingContractModifier = true;\\n        _;\\n        _isSwappingContractModifier = false;\\n    }\\n\\n    //Sets the permille of pancake pair to trigger liquifying taxed token\\n    uint public swapTreshold=2;\\n    function setSwapTreshold(uint newSwapTresholdPermille) public onlyTeam{\\n        require(newSwapTresholdPermille\\u003c=15);//MaxTreshold= 1.5%\\n        swapTreshold=newSwapTresholdPermille;\\n    }\\n    //Sets the max Liquidity where swaps for Liquidity still happen\\n    uint public overLiquifyTreshold=150;\\n    function SetOverLiquifiedTreshold(uint newOverLiquifyTresholdPermille) public onlyTeam{\\n        require(newOverLiquifyTresholdPermille\\u003c=1000);\\n        overLiquifyTreshold=newOverLiquifyTresholdPermille;\\n    }\\n    //Sets the taxes Burn+marketing+liquidity tax needs to equal the TAX_DENOMINATOR (1000)\\n    //buy, sell and transfer tax are limited by the MAXTAXDENOMINATOR\\n    event OnSetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity);\\n    function SetTaxes(uint buy, uint sell, uint transfer_, uint burn, uint marketing,uint liquidity) public onlyTeam{\\n        uint maxTax=3*(TAX_DENOMINATOR/MAXTAXDENOMINATOR);\\n        require(buy\\u003c=maxTax\\u0026\\u0026sell\\u003c=maxTax\\u0026\\u0026transfer_\\u003c=maxTax,\\\"Tax exceeds maxTax\\\");\\n        require(burn+marketing+liquidity==TAX_DENOMINATOR,\\\"Taxes don\\u0027t add up to denominator\\\");\\n        \\n        buyTax=buy;\\n        sellTax=sell;\\n        transferTax=transfer_;\\n        marketingTax=marketing;\\n        liquidityTax=liquidity;\\n        burnTax=burn;\\n        emit OnSetTaxes(buy, sell, transfer_, burn, marketing,liquidity);\\n    }\\n    \\n    //If liquidity is over the treshold, convert 100% of Token to Marketing BNB to avoid overliquifying\\n    function isOverLiquified() public view returns(bool){\\n        return _balances[_pancakePairAddress]\\u003e_circulatingSupply*overLiquifyTreshold/1000;\\n    }\\n\\n\\n    //swaps the token on the contract for Marketing BNB and LP Token.\\n    //always swaps a percentage of the LP pair balance to avoid price impact\\n    function _swapContractToken(bool ignoreLimits) private lockTheSwap{\\n        uint contractBalance=_balances[address(this)];\\n        uint totalTax=liquidityTax+marketingTax;\\n        //swaps each time it reaches swapTreshold of pancake pair to avoid large prize impact\\n        uint tokenToSwap=_balances[_pancakePairAddress]*swapTreshold/1000;\\n\\n        //nothing to swap at no tax\\n        if(totalTax==0)return;\\n        //only swap if contractBalance is larger than tokenToSwap, and totalTax is unequal to 0\\n        //Ignore limits swaps 100% of the contractBalance\\n        if(ignoreLimits)\\n            tokenToSwap=_balances[address(this)];\\n        else if(contractBalance\\u003ctokenToSwap)\\n            return;\\n\\n        //splits the token in TokenForLiquidity and tokenForMarketing\\n        //if over liquified, 0 tokenForLiquidity\\n        uint tokenForLiquidity=\\n        isOverLiquified()?0\\n        :(tokenToSwap*liquidityTax)/totalTax;\\n\\n        uint tokenForMarketing= tokenToSwap-tokenForLiquidity;\\n\\n        uint LiqHalf=tokenForLiquidity/2;\\n        //swaps marktetingToken and the liquidity token half for BNB\\n        uint swapToken=LiqHalf+tokenForMarketing;\\n        //Gets the initial BNB balance, so swap won\\u0027t touch any contract BNB\\n        uint initialBNBBalance = address(this).balance;\\n        _swapTokenForBNB(swapToken);\\n        uint newBNB=(address(this).balance - initialBNBBalance);\\n\\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\\n        if(tokenForLiquidity\\u003e0){\\n            uint liqBNB = (newBNB*LiqHalf)/swapToken;\\n            _addLiquidity(LiqHalf, liqBNB);\\n        }\\n        //Sends all the marketing BNB to the marketingWallet\\n        (bool sent,)=marketingWallet.call{value:address(this).balance}(\\\"\\\");\\n        sent=true;\\n    }\\n    //swaps tokens on the contract for BNB\\n    function _swapTokenForBNB(uint amount) private {\\n        _approve(address(this), address(_pancakeRouter), amount);\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _pancakeRouter.WETH();\\n\\n        try _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        ){}\\n        catch{}\\n    }\\n    //Adds Liquidity directly to the contract where LP are locked\\n    function _addLiquidity(uint tokenamount, uint bnbamount) private {\\n        _approve(address(this), address(_pancakeRouter), tokenamount);\\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\\n            address(this),\\n            tokenamount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \\n    function getLiquidityReleaseTimeInSeconds() public view returns (uint){\\n        if(block.timestamp\\u003c_liquidityUnlockTime)\\n            return _liquidityUnlockTime-block.timestamp;\\n        return 0;\\n    }\\n    function getBurnedTokens() public view returns(uint){\\n        return (InitialSupply-_circulatingSupply)+_balances[address(0xdead)];\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //For AMM addresses buy and sell taxes apply\\n    function SetAMM(address AMM, bool Add) public onlyTeam{\\n        require(AMM!=_pancakePairAddress,\\\"can\\u0027t change pancake\\\");\\n        isAMM[AMM]=Add;\\n    }\\n    \\n    bool public manualSwap;\\n    //switches autoLiquidity and marketing BNB generation during transfers\\n    function SwitchManualSwap(bool manual) public onlyTeam{\\n        manualSwap=manual;\\n    }\\n    //manually converts contract token to LP and staking BNB\\n    function SwapContractToken() public onlyTeam{\\n    _swapContractToken(true);\\n    }\\n    event ExcludeAccount(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludeAccountFromFees(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromFees[account]=exclude;\\n        emit ExcludeAccount(account,exclude);\\n    }\\n\\n    /////////////moussss///////////\\n     event ExcludeAccountLimit(address account, bool exclude);\\n    //Exclude/Include account from fees (eg. CEX)\\n    function ExcludedFromLimit(address account, bool exclude) public onlyTeam{\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\n        excludedFromLimit[account]=exclude;\\n        emit ExcludeAccountLimit(account,exclude);\\n    }\\n\\n\\n\\n    //Enables trading. Sets the launch timestamp to the given Value\\n    event OnEnableTrading();\\n    uint public LaunchTimestamp;\\n    function SetupEnableTrading() public onlyTeam{\\n        require(LaunchTimestamp==0,\\\"AlreadyLaunched\\\");\\n        LaunchTimestamp=block.timestamp;\\n        emit OnEnableTrading();\\n    }\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //the timestamp when Liquidity unlocks\\n    uint _liquidityUnlockTime;\\n    bool public LPReleaseLimitedTo20Percent;\\n    //Sets Liquidity Release to 20% at a time and prolongs liquidity Lock for a Week after Release. \\n    //That way autoLiquidity can be slowly released \\n    function limitLiquidityReleaseTo20Percent() public onlyTeam{\\n        LPReleaseLimitedTo20Percent=true;\\n    }\\n    //Locks Liquidity for seconds. can only be prolonged\\n    function LockLiquidityForSeconds(uint secondsUntilUnlock) public onlyTeam{\\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\\n    }\\n    event OnProlongLPLock(uint UnlockTimestamp);\\n    function _prolongLiquidityLock(uint newUnlockTime) private{\\n        // require new unlock time to be longer than old one\\n        require(newUnlockTime\\u003e_liquidityUnlockTime);\\n        _liquidityUnlockTime=newUnlockTime;\\n        emit OnProlongLPLock(_liquidityUnlockTime);\\n    }\\n    event OnReleaseLP();\\n    //Release Liquidity Tokens once unlock time is over\\n    function LiquidityRelease() public onlyTeam {\\n        //Only callable if liquidity Unlock time is over\\n        require(block.timestamp \\u003e= _liquidityUnlockTime, \\\"Not yet unlocked\\\");\\n\\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\\n        uint amount = liquidityToken.balanceOf(address(this));\\n        if(LPReleaseLimitedTo20Percent)\\n        {\\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\n            //regular liquidity release, only releases 50% at a time and locks liquidity for another week\\n            amount=amount*2/10;\\n        }\\n        liquidityToken.transfer(msg.sender, amount);\\n        emit OnReleaseLP();\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    receive() external payable {}\\n\\n    function getOwner() external view override returns (address) {\\n        return owner();\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint) {\\n        return _circulatingSupply;\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) external view override returns (uint) {\\n        return _allowances[_owner][spender];\\n    }\\n\\n    function approve(address spender, uint amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n    function _approve(address owner, address spender, uint amount) private {\\n        require(owner != address(0), \\\"Approve from zero\\\");\\n        require(spender != address(0), \\\"Approve to zero\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint currentAllowance = _allowances[sender][msg.sender];\\n        require(currentAllowance \\u003e= amount, \\\"Transfer \\u003e allowance\\\");\\n\\n        _approve(sender, msg.sender, currentAllowance - amount);\\n        return true;\\n    }\\n\\n    // IBEP20 - Helpers\\n\\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\\n        uint currentAllowance = _allowances[msg.sender][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"\\u003c0 allowance\\\");\\n\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n        return true;\\n    }\\n\\n}\"}}",
                                "pattern": "modifier\\s+lockTheSwap"
                            }
                        ]
                    }
                }
            }
        },
        "holder": {
            "total_holders": 25,
            "holders_list": {
                "0x3ea2519bccf085ee9e9c3a570e6450bdbf17f754": {
                    "balance": 248516.52604279618,
                    "percentage_of_total_supply": 0.0031064565755349522,
                    "percentage_of_circulating_supply": 0.003452991172591272
                },
                "0xff930dc59a7ad4d2777e58e2212ed37e80e5f149": {
                    "balance": 0.5,
                    "percentage_of_total_supply": 6.2500000000000005e-09,
                    "percentage_of_circulating_supply": 6.947206343928701e-09
                },
                "0x3eef9881fee59d5407b53399cec74c59ac5181c9": {
                    "balance": 199999.99999999997,
                    "percentage_of_total_supply": 0.0024999999999999996,
                    "percentage_of_circulating_supply": 0.0027788825375714803
                },
                "0x6fb1fe9b7db91bba0591b46d38a761a2b0460163": {
                    "balance": 441044.84667528723,
                    "percentage_of_total_supply": 0.005513060583441091,
                    "percentage_of_circulating_supply": 0.006128059113559233
                },
                "0x6149cd56fdc7100d54b6bbbbfd13919df72f4061": {
                    "balance": 1838923.861611796,
                    "percentage_of_total_supply": 0.02298654827014745,
                    "percentage_of_circulating_supply": 0.025550767034782665
                },
                "0xfc85d60430c61a53b14db1c2e241769ba675c960": {
                    "balance": 2.3459836523959003,
                    "percentage_of_total_supply": 2.9324795654948752e-08,
                    "percentage_of_circulating_supply": 3.259606502535565e-08
                },
                "0x4121fbcb813c4544c74610b081ee0676b128b94d": {
                    "balance": 17500000.0,
                    "percentage_of_total_supply": 0.21874999999999997,
                    "percentage_of_circulating_supply": 0.24315222203750453
                },
                "0xb63f9f8321d41019594ec63408987f37a6ad6c7b": {
                    "balance": 877.842211189766,
                    "percentage_of_total_supply": 1.0973027639872075e-05,
                    "percentage_of_circulating_supply": 1.219710195709188e-05
                },
                "0x4dea352ffeb7e74aed060b47b15c1a2f76c5bc97": {
                    "balance": 2.5165824e-11,
                    "percentage_of_total_supply": 3.1457280000000002e-19,
                    "percentage_of_circulating_supply": 3.4966434428598633e-19
                },
                "0x5d429d4ce47a67e754964cf8f61d333811fbb4ea": {
                    "balance": 6078946.1371657895,
                    "percentage_of_total_supply": 0.07598682671457237,
                    "percentage_of_circulating_supply": 0.08446338633703808
                },
                "0x7b1c4d9769713b5d03c242ae343281e84b9c6a5e": {
                    "balance": 5651921.458403028,
                    "percentage_of_total_supply": 0.07064901823003786,
                    "percentage_of_circulating_supply": 0.07853012922240854
                },
                "0x950ca29f9568e2ec45419f800c32a9cc4a5787fc": {
                    "balance": 698.1078851805169,
                    "percentage_of_total_supply": 8.72634856475646e-06,
                    "percentage_of_circulating_supply": 9.699799057345471e-06
                },
                "0x0bed529a06332a6c359d8d605dec71fee567ba2c": {
                    "balance": 9011.087697526375,
                    "percentage_of_total_supply": 0.0001126385962190797,
                    "percentage_of_circulating_supply": 0.0001252037712359062
                },
                "0x599aff84ec11417c68226db632182336019d9699": {
                    "balance": 1.4958471002019438,
                    "percentage_of_total_supply": 1.8698088752524298e-08,
                    "percentage_of_circulating_supply": 2.078391692814059e-08
                },
                "0xfeed0388462f8b6cfab0915bd7aa0028643aaa38": {
                    "balance": 4.426434489496938,
                    "percentage_of_total_supply": 5.533043111871172e-08,
                    "percentage_of_circulating_supply": 6.150270753283586e-08
                },
                "0xeca2ad07cdcefb7445d648fd3730bd07f9b9e4ff": {
                    "balance": 318.50534877381244,
                    "percentage_of_total_supply": 3.981316859672656e-06,
                    "percentage_of_circulating_supply": 4.4254447591533065e-06
                },
                "0x5b8aad9e258b730ee8d081a0eba259a6a2127642": {
                    "balance": 16194.993033531297,
                    "percentage_of_total_supply": 0.0002024374129191412,
                    "percentage_of_circulating_supply": 0.00022501991668485947
                },
                "0xf1c57974d9f403121a1467abbbc974cc77ed4bc1": {
                    "balance": 1715.518086462103,
                    "percentage_of_total_supply": 2.1443976080776285e-05,
                    "percentage_of_circulating_supply": 2.383611626678789e-05
                },
                "0x183061a1fedd0a1fa70f2584723677bc3aed5077": {
                    "balance": 8867.730509792942,
                    "percentage_of_total_supply": 0.00011084663137241178,
                    "percentage_of_circulating_supply": 0.00012321190730776724
                },
                "0x294d213bbf2c9f87af68008d08f2be79f4774ceb": {
                    "balance": 6362260364.893862,
                    "percentage_of_total_supply": 79.52825456117326,
                    "percentage_of_circulating_supply": 88.39987113743352
                },
                "0x538dc2a990b1f910715f37205a311132ec283e5a": {
                    "balance": 2.5165824e-11,
                    "percentage_of_total_supply": 3.1457280000000002e-19,
                    "percentage_of_circulating_supply": 3.4966434428598633e-19
                },
                "0x3899454ed2e73c12f9094852c19e827f6eb6a6b7": {
                    "balance": 63.987681724712274,
                    "percentage_of_total_supply": 7.998460215589034e-07,
                    "percentage_of_circulating_supply": 8.890712568224234e-07
                },
                "0x48bfe0436ba880c7139e796eed64c4f06a55dde4": {
                    "balance": 8953.661862721374,
                    "percentage_of_total_supply": 0.0001119207732840172,
                    "percentage_of_circulating_supply": 0.0001244058729881808
                },
                "0xcc52d3e578499a1e20ae6faca03461ab435b27e3": {
                    "balance": 8774.132674706501,
                    "percentage_of_total_supply": 0.00010967665843383125,
                    "percentage_of_circulating_supply": 0.00012191142036038621
                },
                "0xd72430cb2f24992329396abba7a50cda0e185813": {
                    "balance": 9.48321636e-10,
                    "percentage_of_total_supply": 1.185402045e-17,
                    "percentage_of_circulating_supply": 1.3176372171408087e-17
                }
            },
            "total_supply": 8000000000.0,
            "total_circulating_supply": 7197137601.02951,
            "owner": {
                "address": "0x294d213bbf2c9f87af68008d08f2be79f4774ceb",
                "balance": 6362260364.893862,
                "percentage_of_circulating_supply": 88.39987113743352,
                "exceeds_5_percent": true
            },
            "creator": {
                "address": "0x294d213bbf2c9f87af68008d08f2be79f4774ceb",
                "balance": 6362260364.893862,
                "percentage_of_circulating_supply": 88.39987113743352,
                "exceeds_5_percent": true
            },
            "holders_exceeding_5_percent_circulating": [],
            "howmany_holders_exceeding_5_percent_circulating": 0,
            "top_10_holders": [
                {
                    "address": "0x294d213bbf2c9f87af68008d08f2be79f4774ceb",
                    "balance": 6362260364.893862,
                    "percentage_of_total_supply": 79.52825456117326,
                    "percentage_of_circulating_supply": 88.39987113743352
                },
                {
                    "address": "0x4121fbcb813c4544c74610b081ee0676b128b94d",
                    "balance": 17500000.0,
                    "percentage_of_total_supply": 0.21874999999999997,
                    "percentage_of_circulating_supply": 0.24315222203750453
                },
                {
                    "address": "0x5d429d4ce47a67e754964cf8f61d333811fbb4ea",
                    "balance": 6078946.1371657895,
                    "percentage_of_total_supply": 0.07598682671457237,
                    "percentage_of_circulating_supply": 0.08446338633703808
                },
                {
                    "address": "0x7b1c4d9769713b5d03c242ae343281e84b9c6a5e",
                    "balance": 5651921.458403028,
                    "percentage_of_total_supply": 0.07064901823003786,
                    "percentage_of_circulating_supply": 0.07853012922240854
                },
                {
                    "address": "0x6149cd56fdc7100d54b6bbbbfd13919df72f4061",
                    "balance": 1838923.861611796,
                    "percentage_of_total_supply": 0.02298654827014745,
                    "percentage_of_circulating_supply": 0.025550767034782665
                },
                {
                    "address": "0x6fb1fe9b7db91bba0591b46d38a761a2b0460163",
                    "balance": 441044.84667528723,
                    "percentage_of_total_supply": 0.005513060583441091,
                    "percentage_of_circulating_supply": 0.006128059113559233
                },
                {
                    "address": "0x3ea2519bccf085ee9e9c3a570e6450bdbf17f754",
                    "balance": 248516.52604279618,
                    "percentage_of_total_supply": 0.0031064565755349522,
                    "percentage_of_circulating_supply": 0.003452991172591272
                },
                {
                    "address": "0x3eef9881fee59d5407b53399cec74c59ac5181c9",
                    "balance": 199999.99999999997,
                    "percentage_of_total_supply": 0.0024999999999999996,
                    "percentage_of_circulating_supply": 0.0027788825375714803
                },
                {
                    "address": "0x5b8aad9e258b730ee8d081a0eba259a6a2127642",
                    "balance": 16194.993033531297,
                    "percentage_of_total_supply": 0.0002024374129191412,
                    "percentage_of_circulating_supply": 0.00022501991668485947
                },
                {
                    "address": "0x0bed529a06332a6c359d8d605dec71fee567ba2c",
                    "balance": 9011.087697526375,
                    "percentage_of_total_supply": 0.0001126385962190797,
                    "percentage_of_circulating_supply": 0.0001252037712359062
                }
            ],
            "total_top_10_balance": 6394244923.80449,
            "top10_percentage_of_total_supply": 79.92806154755613,
            "top10_percentage_of_circulating_supply": 88.84427779857688,
            "top_10_less_than_70_percent_of_total": false,
            "top_10_less_than_70_percent_of_circulating": false
        },
        "liquidity": {
            "price_usd": 2.211859917639144e-13,
            "liquidity_usd": 2.5002517062972463e-06,
            "market_cap_usd": 0.0015919060181450717,
            "liquidity_to_market_cap_ratio": 0.0015706025844481708,
            "token_volume": 646200.1757133144,
            "volume_usd": 1.4293042674316522e-07,
            "volume_to_liquidity_ratio": 0.057166415038603605,
            "locked_liquidity_percent": 0.0,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": false,
            "creator_percent_of_lp": 79.5283,
            "owner_under_5_percent": false,
            "owner_percent_of_lp": 79.5283,
            "total_lp_supply": 75.1878460866665,
            "lp_holders_count": 4,
            "lp_holders": [
                {
                    "address": "0x5c7210ce1c7d016897bca87afbec3f25cf251bdc",
                    "balance": 73.86929108410088,
                    "is_locked": false,
                    "percent": 98.24631895819203,
                    "tag": ""
                },
                {
                    "address": "0x271c48bb9b0df4b604184ce22d436e271d42fa61",
                    "balance": 1.2774025260138464,
                    "is_locked": false,
                    "percent": 1.6989481578464523,
                    "tag": ""
                },
                {
                    "address": "0x0ed943ce24baebf257488771759f9bf482c39706",
                    "balance": 0.04115247655177649,
                    "is_locked": false,
                    "percent": 0.05473288396151339,
                    "tag": ""
                },
                {
                    "address": "0x0000000000000000000000000000000000000000",
                    "balance": 1e-15,
                    "is_locked": true,
                    "percent": 1.3e-15,
                    "tag": "Null Address"
                }
            ]
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {},
            "howmany_suspicious_urls": 0,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 117012406.632078,
            "token_creation_date": "2021-12-10T23:59:59",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x4eb5c2cccca081f7ca8ebf06efc30d6e1590bf3c4b438c6ae2d7bd01e20bb983",
            "last_active_age": "2025-08-06T05:52:37",
            "inactive_days": 20.06540970065972
        }
    },
    "errors": []
}