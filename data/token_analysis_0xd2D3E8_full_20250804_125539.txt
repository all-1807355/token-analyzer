Token Analysis Report
==================================================
Token: BuyTheDip (0xd2D3E898E164f1BfDcC59524F32b63698769a8bf)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x05ff2b0db69458a0750badebc4f9e13add608c7f, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x05ff2b0db69458a0750badebc4f9e13add608c7f, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
         (,rvalues memory values) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(values.ramount);
        _rtotal = _rtotal.sub(values.ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        (,rvalues memory values) = _getvalues(tamount);
        if (!deducttransferfee) {
            return values.ramount;
        } else {
            return values.rtransferamount;
        }
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x05ff2b0db69458a0750badebc4f9e13add608c7f, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (tvalues memory tvalues, rvalues memory rvalues) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(rvalues.ramount);
        _rowned[recipient] = _rowned[recipient].add(rvalues.rtransferamount);
        _reflectfee(rvalues.rfee, rvalues.rburn, tvalues.tfee, tvalues.tburn);
        emit transfer(sender, recipient, tvalues.ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (tvalues memory tvalues, rvalues memory rvalues) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(rvalues.ramount);
        _towned[recipient] = _towned[recipient].add(tvalues.ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rvalues.rtransferamount);           
        _reflectfee(rvalues.rfee, rvalues.rburn, tvalues.tfee, tvalues.tburn);
        emit transfer(sender, recipient, tvalues.ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (tvalues memory tvalues, rvalues memory rvalues) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(rvalues.ramount);
        _rowned[recipient] = _rowned[recipient].add(rvalues.rtransferamount);   
        _reflectfee(rvalues.rfee, rvalues.rburn, tvalues.tfee, tvalues.tburn);
        emit transfer(sender, recipient, tvalues.ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (tvalues memory tvalues, rvalues memory rvalues) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(rvalues.ramount);
        _towned[recipient] = _towned[recipient].add(tvalues.ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rvalues.rtransferamount);        
        _reflectfee(rvalues.rfee, rvalues.rburn, tvalues.tfee, tvalues.tburn);
        emit transfer(sender, recipient, tvalues.ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _ttotal = _ttotal.sub(tburn);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (tvalues memory values) {
        values.tfee = calculatetaxfee(tamount);
        values.tburn = calculateburnfee(tamount);
        values.ttransferamount = tamount.sub(values.tfee).sub(values.tburn);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, tvalues memory tvalues) private view returns (rvalues memory values) {
        values.rate = _getrate();
        values.ramount = tamount.mul(values.rate);
        values.rfee = tvalues.tfee.mul(values.rate);
        values.rburn = tvalues.tburn.mul(values.rate);
        values.rtransferamount = values.ramount.sub(values.rfee).sub(values.rburn);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateburnfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_burnfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _burnfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousburnfee = _burnfee;
        
        _taxfee = 0;
        _burnfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _burnfee = _previousburnfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setburnfeepercent(uint256 burnfee) external onlyowner() {
        _burnfee = burnfee;
    }


Holder Analysis
--------------
Total Unique Holders: 171
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xec973d9be1192207317930c3aff9c395a6843477
Owner Balance: 7,262,595,768,472,515,664,412,672 tokens
Owner Share: 86.40% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xec973d9be1192207317930c3aff9c395a6843477 — 7,262,595,768,472,515,664,412,672 tokens (86.07% of circulating supply)
  2. 0x550694addf0b0e8c502b47ff35ee5de05ea06b4c — 322,439,750,929,538,510,487,552 tokens (3.82% of circulating supply)
  3. 0x4a3e2bab0d613d1ef8312ac861e2a90ec92b8e52 — 264,908,158,863,629,973,716,992 tokens (3.14% of circulating supply)
  4. 0x5432b7d72431c665ca7b4c09d7889a9ea0757e77 — 94,454,913,497,434,186,317,824 tokens (1.12% of circulating supply)
  5. 0x56b2a275bf05536fd16f76fb2fb622553b130672 — 52,616,722,169,042,833,506,304 tokens (0.62% of circulating supply)
  6. 0x6210f5992ba106f138581e885f3523df75d623b1 — 31,529,174,308,208,821,403,648 tokens (0.37% of circulating supply)
  7. 0x02608d7e2be8e1e8b3b52807dbdc317e64de5e72 — 29,506,370,378,309,306,417,152 tokens (0.35% of circulating supply)
  8. 0x3dce2c6e46feceaa9636b86c2180c2d190b3f05f — 24,863,369,889,800,718,909,440 tokens (0.29% of circulating supply)
  9. 0x7176a1fb83a0831fbf7d889943a81753eaf2c239 — 20,332,161,682,843,805,679,616 tokens (0.24% of circulating supply)
  10. 0x102acc77c464e08b7e7de8f3619d6a15caf1eac6 — 12,526,212,268,455,083,638,784 tokens (0.15% of circulating supply)

Top 10 Total Balance: 8,115,772,602,459,778,904,489,984 tokens
Top 10 Share of Circulating Supply: 96.18%
Top 10 Share of Total Supply: 94.41%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $666,132,871,669,350.12
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (84.8151)
Total supply of LP tokens: 70.71067811865476
LP holders count: 2

Liquidity holders for 0xd2D3E898E164f1BfDcC59524F32b63698769a8bf, (BuyTheDip)

0xaa3d85ad9d128dfecb55424085754f6dfa643eb1 holds 70.71067811865476 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1540.21 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-17T07:54:04
Last Active: 2022-11-11T22:52:19
Days Since Last Activity: 996.5856554226505 days
Last Transaction Hash: 0xb0d64fbed2c8726ffdd063972c3c68c10f7ab8b93a0ada47eafe25cf1a514c53
