Token Analysis Report
==================================================
Token: Gouki-Inu (0x616e302F89d1b21a2e3EC2AB8DaC01E01CBBadfB)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function isexcludedfromreward(address account)
        external

  Code Snippet:
    function launch(address[] memory airdropwallets, uint256[] memory amounts) external onlyowner returns (bool){
        require(!tradingactive, "trading is already active, cannot relaunch.");
        require(airdropwallets.length < 200, "can only airdrop 200 wallets per txn due to gas limits"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.
        for(uint256 i = 0; i < airdropwallets.length; i++){
            address wallet = airdropwallets[i];
            uint256 amount = amounts[i];
            _transfer(msg.sender, wallet, amount);
        }
        enabletrading();
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x10ed43c718714eb63d5aa57b78b54704e256024e);
        excludefrommaxtransaction(address(_uniswapv2router), true);
        uniswapv2router = _uniswapv2router;
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());
        excludefrommaxtransaction(address(uniswapv2pair), true);
        _setautomatedmarketmakerpair(address(uniswapv2pair), true);
        require(address(this).balance > 0, "must have eth on contract to launch");
        addliquidity(balanceof(address(this)), address(this).balance);
        setliquidityaddress(address(0xdead));
        return true;
    }

  Code Snippet:
    function _setautomatedmarketmakerpair(address pair, bool value) private {
        automatedmarketmakerpairs[pair] = value;
        _isexcludedmaxtransactionamount[pair] = value;
        if(value){excludefromreward(pair);}
        if(!value){includeinreward(pair);}
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcluded[account], "account is already excluded");
        require(_excluded.length + 1 <= 50, "cannot exclude more than 50 accounts.  include a previously excluded address.");
        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) public onlyowner {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account)
        external

  Code Snippet:
    function _setautomatedmarketmakerpair(address pair, bool value) private {
        automatedmarketmakerpairs[pair] = value;
        _isexcludedmaxtransactionamount[pair] = value;
        if(value){excludefromreward(pair);}
        if(!value){includeinreward(pair);}
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcluded[account], "account is already excluded");
        require(_excluded.length + 1 <= 50, "cannot exclude more than 50 accounts.  include a previously excluded address.");
        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) public onlyowner {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function enabletrading() internal onlyowner {
        tradingactive = true;
        swapandliquifyenabled = true;
        tradingactiveblock = block.number;
        earlybuypenaltyend = block.timestamp + 72 hours;
    }

  Code Snippet:
    function launch(address[] memory airdropwallets, uint256[] memory amounts) external onlyowner returns (bool){
        require(!tradingactive, "trading is already active, cannot relaunch.");
        require(airdropwallets.length < 200, "can only airdrop 200 wallets per txn due to gas limits"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.
        for(uint256 i = 0; i < airdropwallets.length; i++){
            address wallet = airdropwallets[i];
            uint256 amount = amounts[i];
            _transfer(msg.sender, wallet, amount);
        }
        enabletrading();
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x10ed43c718714eb63d5aa57b78b54704e256024e);
        excludefrommaxtransaction(address(_uniswapv2router), true);
        uniswapv2router = _uniswapv2router;
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());
        excludefrommaxtransaction(address(uniswapv2pair), true);
        _setautomatedmarketmakerpair(address(uniswapv2pair), true);
        require(address(this).balance > 0, "must have eth on contract to launch");
        addliquidity(balanceof(address(this)), address(this).balance);
        setliquidityaddress(address(0xdead));
        return true;
    }

WARNING: High Tax Detected
  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swap(
        uint256 amount0out,

  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function totalfees() external view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function enabletrading() internal onlyowner {
        tradingactive = true;
        swapandliquifyenabled = true;
        tradingactiveblock = block.number;
        earlybuypenaltyend = block.timestamp + 72 hours;
    }

  Code Snippet:
    function launch(address[] memory airdropwallets, uint256[] memory amounts) external onlyowner returns (bool){
        require(!tradingactive, "trading is already active, cannot relaunch.");
        require(airdropwallets.length < 200, "can only airdrop 200 wallets per txn due to gas limits"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.
        for(uint256 i = 0; i < airdropwallets.length; i++){
            address wallet = airdropwallets[i];
            uint256 amount = amounts[i];
            _transfer(msg.sender, wallet, amount);
        }
        enabletrading();
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x10ed43c718714eb63d5aa57b78b54704e256024e);
        excludefrommaxtransaction(address(_uniswapv2router), true);
        uniswapv2router = _uniswapv2router;
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());
        excludefrommaxtransaction(address(uniswapv2pair), true);
        _setautomatedmarketmakerpair(address(uniswapv2pair), true);
        require(address(this).balance > 0, "must have eth on contract to launch");
        addliquidity(balanceof(address(this)), address(this).balance);
        setliquidityaddress(address(0xdead));
        return true;
    }

  Code Snippet:
    function minimumtokensbeforeswapamount() external view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {
        require(pair != uniswapv2pair, "the pair cannot be removed from automatedmarketmakerpairs");

        _setautomatedmarketmakerpair(pair, value);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee)
        external

  Code Snippet:
    function swapback() private locktheswap {
        uint256 contractbalance = balanceof(address(this));
        uint256 totaltokenstoswap = _liquiditytokenstoswap + _marketingtokenstoswap;
        
        // halve the amount of liquidity tokens
        uint256 tokensforliquidity = _liquiditytokenstoswap.div(2);
        uint256 amounttoswapforeth = contractbalance.sub(tokensforliquidity);
        
        uint256 initialethbalance = address(this).balance;

        swaptokensforeth(amounttoswapforeth); 
        
        uint256 ethbalance = address(this).balance.sub(initialethbalance);
        
        uint256 ethformarketing = ethbalance.mul(_marketingtokenstoswap).div(totaltokenstoswap);
        
        uint256 ethforliquidity = ethbalance.sub(ethformarketing);
        
        uint256 ethforbuyback= ethformarketing * 2 / 7; // 2/7 gos to buyback
        ethformarketing -= ethforbuyback;
        
        _liquiditytokenstoswap = 0;
        _marketingtokenstoswap = 0;
        
        (bool success,) = address(marketingaddress).call{value: ethformarketing}("");
        (success,) = address(buybackaddress).call{value: ethforbuyback}("");
        
        addliquidity(tokensforliquidity, ethforliquidity);
        emit swapandliquify(amounttoswapforeth, ethforliquidity, tokensforliquidity);
        
        // send leftover bnb to the marketing wallet so it doesn't get stuck on the contract.
        if(address(this).balance > 1e17){
            (success,) = address(marketingaddress).call{value: address(this).balance}("");
        }
    }

  Code Snippet:
    function forceswapback() external onlyowner {
        uint256 contractbalance = balanceof(address(this));
        require(contractbalance >= _ttotal / 100, "can only swap back if more than 1% of tokens stuck on contract");
        swapback();
        emit ownerforcedswapback(block.timestamp);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            liquidityaddress,
            block.timestamp
        );
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _takeliquidity(uint256 tliquidity) private {
        if(buyorsellswitch == buy){
            _liquiditytokenstoswap += tliquidity * _buyliquidityfee / _liquidityfee;
            _marketingtokenstoswap += tliquidity * _buymarketingfee / _liquidityfee;
        } else if(buyorsellswitch == sell){
            _liquiditytokenstoswap += tliquidity * _sellliquidityfee / _liquidityfee;
            _marketingtokenstoswap += tliquidity * _sellmarketingfee / _liquidityfee;
        }
        uint256 currentrate = _getrate();
        uint256 rliquidity = tliquidity.mul(currentrate);
        _rowned[address(this)] = _rowned[address(this)].add(rliquidity);
        if (_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)].add(tliquidity);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(10**2);
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount)
        private

  Code Snippet:
    function removeallfee() private {
        if (_taxfee == 0 && _liquidityfee == 0) return;

        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;

        _taxfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) external view returns (bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) external onlyowner {
        _isexcludedfromfee[account] = true;
        emit excludefromfee(account);
    }

  Code Snippet:
    function includeinfee(address account) external onlyowner {
        _isexcludedfromfee[account] = false;
        emit includeinfee(account);
    }

  Code Snippet:
    function setbuyfee(uint256 buytaxfee, uint256 buyliquidityfee, uint256 buymarketingfee)
        external

  Code Snippet:
    function setsellfee(uint256 selltaxfee, uint256 sellliquidityfee, uint256 sellmarketingfee)
        external

  Code Snippet:
    function setmarketingaddress(address _marketingaddress) external onlyowner {
        require(_marketingaddress != address(0), "_marketingaddress address cannot be 0");
        _isexcludedfromfee[marketingaddress] = false;
        marketingaddress = payable(_marketingaddress);
        _isexcludedfromfee[marketingaddress] = true;
        emit updatedmarketingaddress(_marketingaddress);
    }

  Code Snippet:
    function setliquidityaddress(address _liquidityaddress) public onlyowner {
        require(_liquidityaddress != address(0), "_liquidityaddress address cannot be 0");
        liquidityaddress = payable(_liquidityaddress);
        _isexcludedfromfee[liquidityaddress] = true;
        emit updatedliquidityaddress(_liquidityaddress);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function withdrawstucketh() external onlyowner {
        require(!tradingactive, "can only withdraw if trading hasn't started");
        bool success;
        (success,) = address(msg.sender).call{value: address(this).balance}("");
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 4
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x38261bccd37f338897fce7de03ab8c4bd913bff0 — 49,084,883,622,454,399,860,736 tokens (6.59% of circulating supply)
  2. 0x6d15daf62566d9fe57ae69e1178b4013e16be321 — 48,097,395,919,959,476,928,512 tokens (6.45% of circulating supply)
  3. 0x25adf743c0fa773b4a37535ee653092822d01d9a — 45,193,379,503,399,092,879,360 tokens (6.06% of circulating supply)
  4. 0xefafa7bbbb71bf0e0875a02940a91251bb54a2be — 45,142,394,148,403,919,454,208 tokens (6.06% of circulating supply)
  5. 0xde6219693005bc3bcd12db926b29c7b0d6f37f39 — 20,097,522,943,891,941,097,472 tokens (2.70% of circulating supply)
  6. 0x6c84e9ce6771e832ca3529762ea7bf9679499c58 — 18,993,673,804,055,857,594,368 tokens (2.55% of circulating supply)
  7. 0x48ae21cc292a8b3182bc7714fb8e5f125c464326 — 17,334,397,124,735,825,608,704 tokens (2.33% of circulating supply)
  8. 0xb8fbba7190f66db79df4a1acbaebb623091f3f19 — 15,522,780,397,537,956,200,448 tokens (2.08% of circulating supply)
  9. 0xb1ac84aebcf6ba9b4bb25c1656b3e32240e74312 — 14,271,032,747,363,766,632,448 tokens (1.91% of circulating supply)
  10. 0x8346334df47bb8de390700271cf19cabe78e62f5 — 14,200,194,066,592,089,243,648 tokens (1.91% of circulating supply)

Top 10 Total Balance: 287,937,654,278,394,325,499,904 tokens
Top 10 Share of Circulating Supply: 38.63%
Top 10 Share of Total Supply: 28.79%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $394,288,290,007,953.75
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 165347582283982.7188
USD Volume: 87475.1322
24h Volume/Liquidity Ratio: 1710609906.0871
Percentage of liquidity locked: 41.3700
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 28.931079221211828
LP holders count: 6

Liquidity holders for 0x616e302F89d1b21a2e3EC2AB8DaC01E01CBBadfB, (Gouki-Inu)

0x6c84e9ce6771e832ca3529762ea7bf9679499c58 holds 15.260184056027862 LP tokens

0x000000000000000000000000000000000000dead holds 11.969964958900716 LP tokens

0x5d6573e62e3688e40c1fc36e01b155fb0006f432 holds 1.4341913494892249 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.2664936771980819 LP tokens

0x5abf0c186fed031912756b62b896c16e1591fc16 holds 0.00024517959594381 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1348.69 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-24T19:44:40
Last Active: 2025-06-28T20:16:01
Days Since Last Activity: 36.66407714398148 days
Last Transaction Hash: 0xd05096dbdaac6e50dea5b0a423844a8cdef9adffbe60bfe7cfd483649a8cd523
