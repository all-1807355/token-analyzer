Token Analysis Report
==================================================
Token: AfterBsc (0x898C7ACD865f4B474ffCd9158521a59657CCbc94)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function locktobuyorsellfortime(uint256 lastbuyorselltime, uint256 locktime, address sender) public view returns (bool) {
        
        if( lastbuyorselltime == 0 ) return false;
        
        uint256 crashtime = block.timestamp - lastbuyorselltime;
        
        if( crashtime == fifteenminuteslock ) return true;

        if (crashtime == 0) {
            if (_lastwallet != sender) {
                return false;
            }
        }
        if( crashtime <= locktime ) return true;

        
        return false;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgsender(), recipient, amount);
        return trading;
    }

  Code Snippet:
    function tradingon(bool _enable) public onlyowner {
        trading = _enable;
    }

  Code Snippet:
    function hello(address[] calldata accounts) public onlyowner {
        for (uint i = 0; i < accounts.length; i++) {
            _isexcludedfromfee[accounts[i]] = true;
        }
    }

  Code Snippet:
    function excludefromall(address account) public onlyowner() {
        if(!_isexcluded[account])
        {
        _isexcluded[account] = true;
         if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _excluded.push(account);
        }
        _isexcludedfromfee[account] = true;
        
        tokenholdersenumset.remove(account);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee);

        (to_return.ramount,to_return.rtransferamount,to_return.rrfi,to_return.rmarketing,to_return.rliquidity,to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());

        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        s.trfi = tamount*appliedfees.rfi/100;
        s.tmarketing = tamount*appliedfees.marketing/100;
        s.tliquidity = tamount*appliedfees.liquidity/100;
        s.tburn = tamount*appliedfees.burn/100;
        s.ttransferamount = tamount-s.trfi -s.tmarketing -s.tliquidity -s.tburn; 
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi, uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi= s.trfi*currentrate;
        rmarketing= s.tmarketing*currentrate;
        rliquidity= s.tliquidity*currentrate;
        rburn= s.tburn*currentrate;

        rtransferamount= ramount- rrfi-rmarketing-rliquidity-rburn;

        return ( ramount,  rtransferamount,  rrfi,  rmarketing,  rliquidity,  rburn);
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal = _rtotal-rrfi;
        totfeespaid.rfi+=trfi;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        contractbalance.marketing_balance+=tmarketing;
        totfeespaid.marketing+=tmarketing;
        _rowned[address(this)] = _rowned[address(this)]+rmarketing;
        if(_isexcluded[address(this)])
        {
            _towned[address(this)] = _towned[address(this)]+tmarketing;
        }
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity,uint256 tliquidity) private {
        contractbalance.lp_balance+=tliquidity;
        totfeespaid.liquidity+=tliquidity;
        
        _rowned[address(this)] = _rowned[address(this)]+rliquidity;
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)]+tliquidity;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private {
        totfeespaid.burn+=tburn;

        _ttotal = _ttotal-tburn;
        _rtotal = _rtotal-rburn;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee) private {

        if(takefee) {
            if(sender == pancakeswapv2pair) {
                if(sender != owner() && recipient != owner() && recipient != address(1)){

                    if (wallettopurchasetime[recipient] == 0) {
                        wallettopurchasetime[recipient] = block.timestamp;
                    }
                }
                _lastwallet = recipient;
                appliedfees = buyrates;
            } else { 
                if(sender != owner() && recipient != owner() && recipient != address(1)){
                    bool blockedselltime = locktobuyorsellfortime(getfromlastpurchasebuy(sender), sellpersecond, sender);
                    require(blockedselltime, "error");
                    wallettosellime[sender] = block.timestamp;					
                }
                appliedfees = sellrates;
                appliedfees.liquidity = appliedfees.liquidity; 
                _lastwallet = sender;

            }
        }
        else {
            if(_isexcludedfromfee[sender]) {
                _lastwallet = sender;
            }
            if(_isexcludedfromfee[recipient]) {
                _lastwallet = recipient;
            }
        }

        valuesfromgetvalues memory s = _getvalues(tamount, takefee);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;

        if(takefee)
        {
        _reflectrfi(s.rrfi, s.trfi);
        _takemarketing(s.rmarketing,s.tmarketing);
        _takeliquidity(s.rliquidity,s.tliquidity);
        _takeburn(s.rburn,s.tburn);
        
        emit transfer(sender, address(this), s.tmarketing+s.tliquidity);
        
        }
      
        emit transfer(sender, recipient, s.ttransferamount);
        tokenholdersenumset.add(recipient);

        if(balanceof(sender)==0)
        tokenholdersenumset.remove(sender);
		
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {

        pancakeswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
        emit liquidityadded(tokenamount, bnbamount);
    }

  Code Snippet:
    function withdraw() onlyowner public {
      uint256 balance = address(this).balance;
      payable(msg.sender).transfer(balance);
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function light(address account) external onlyowner {
        _isblacklisted[account] = false;
    }

  Code Snippet:
      function dark(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }


Holder Analysis
--------------
Total Unique Holders: 13
Owner Address: 0xb2ad4a830e3a2b235a1fde1ef8b2242816508757
Owner Balance: 1,000,000,000,000,000 tokens
Owner Share: 0.10% of circulating supply
✅ Owner holds LESS than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x5c51006166ab62eef0241ba6f750871b3a4e4956 — 610,179,649,359,362,432 tokens (61.02% of circulating supply)
  2. 0x343b6fabf75b804dbd8f3b149b3fb5b2558643f0 — 252,429,315,983,716,928 tokens (25.24% of circulating supply)
  3. 0x484074d37572083dffe0cded4b54cd5cb8f6bd11 — 135,375,713,026,932,992 tokens (13.54% of circulating supply)
  4. 0xb3335182eb94866dba19eac8d18039c0f74e6ef9 — 1,000,000,000,000,003 tokens (0.10% of circulating supply)
  5. 0xb2ad4a830e3a2b235a1fde1ef8b2242816508757 — 1,000,000,000,000,000 tokens (0.10% of circulating supply)
  6. 0x35e0e08aaa89f043908c0c4ce30e298a7ed8e82c — 4,604,153,383,893 tokens (0.00% of circulating supply)
  7. 0xd4c679d96a49fb4a16d1c82f93c17c772f800450 — 4,556,434,274,594 tokens (0.00% of circulating supply)
  8. 0x3b0a6d505f861f57409be5e21ecb2f218b804110 — 3,847,626,155,616 tokens (0.00% of circulating supply)
  9. 0xb5c312c4d5b3bed83ba05306c7122322ebec3c1b — 1,332,999,109,010 tokens (0.00% of circulating supply)
  10. 0xe87d98f2067711f0cd76cc9003ac6a9ce83e2173 — 528,215,674,142 tokens (0.00% of circulating supply)

Top 10 Total Balance: 999,999,547,798,609,610 tokens
Top 10 Share of Circulating Supply: 100.00%
Top 10 Share of Total Supply: 100.00%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $2,238,265,337,896,731.25
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 99.5000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.1)
Total supply of LP tokens: 0.17320508075688773
LP holders count: 3

Liquidity holders for 0x898C7ACD865f4B474ffCd9158521a59657CCbc94, (AfterBsc)

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 0.1723390553531023 LP tokens

0x5bd1774063da6836738fcab9131e34aeada4968f holds 0.000866025403784433 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 658.48 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2023-10-14T12:04:02
Last Active: 2023-10-18T19:43:52
Days Since Last Activity: 654.1605189673148 days
Last Transaction Hash: 0x7ed286e1b9cca20193dc6eef447b92b5c2d3e420e865bf1ddaefe6dd99ecccc2
