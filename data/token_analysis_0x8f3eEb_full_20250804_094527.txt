Token Analysis Report
==================================================
Token: OctoDoge (0x8f3eEbfFa47e5E73Ca8Fa3d00A3DD8E66BCB837E)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x05ff2b0db69458a0750badebc4f9e13add608c7f, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x05ff2b0db69458a0750badebc4f9e13add608c7f, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        _taxfee = 0;
        _liquidityfee = 0;
        _burnfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = 5;
        _liquidityfee = 5;
        _burnfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount) private {
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            removeallfee();
        }
        else{
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }
        
        //calculate burn amount and marketing amount
        uint256 burnamt = amount.mul(_burnfee).div(100);
        uint256 marketingamt = amount.mul(_marketingfee).div(100);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        } else {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamt)));
        }
        
        //temporarily remove fees to transfer to burn address and marketing wallet
        _taxfee = 0;
        _liquidityfee = 0;

        //send transfers to burn and marketing wallet
        _transferstandard(sender, marketingwallet, marketingamt);

        //restore tax and liquidity fees
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;


        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient])
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function enableallfees() external onlyowner() {
        _taxfee = 5;
        _previoustaxfee = _taxfee;
        _liquidityfee = 5;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketingfee = 0;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = true;
        emit swapandliquifyenabledupdated(true);
    }

  Code Snippet:
    function disableallfees() external onlyowner() {
        _taxfee = 0;
        _previoustaxfee = _taxfee;
        _liquidityfee = 0;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketingfee = 0;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = false;
        emit swapandliquifyenabledupdated(false);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x550e6ae4e2119829acea22904faee9fc9ee231df
Owner Balance: 185,642,606,833,839,508,553,728 tokens
Owner Share: 29.81% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x550e6ae4e2119829acea22904faee9fc9ee231df — 185,642,606,833,839,508,553,728 tokens (29.81% of circulating supply)
  2. 0x7e8298788266fbbbd71023db300d813a32b5d25a — 12,235,625,036,449,409,138,688 tokens (1.96% of circulating supply)
  3. 0x7a1a7f0d1ac956e7cb9748a07907d1931f78d15e — 5,959,448,658,032,725,065,728 tokens (0.96% of circulating supply)
  4. 0x9c61124ba962d6cb7e29c3aa1c18bec0825bd206 — 3,511,289,597,321,889,185,792 tokens (0.56% of circulating supply)
  5. 0x9afbb7c6cd1177667ee60fe573d30614b521f290 — 2,708,348,384,879,860,776,960 tokens (0.43% of circulating supply)
  6. 0x780e9b374cdbf3165b05760ac1d56c03813ec3da — 2,251,547,970,150,232,489,984 tokens (0.36% of circulating supply)
  7. 0xf70ef0b78adda9555836c86915bbb7c69fa8c78a — 1,936,434,931,906,161,672,192 tokens (0.31% of circulating supply)
  8. 0x48e17949988b4355cf67d06a39cd0547f0d23770 — 1,853,889,724,136,782,561,280 tokens (0.30% of circulating supply)
  9. 0xdbe491b714efaf43bd21af82edffdb000586ce99 — 1,821,601,893,582,269,054,976 tokens (0.29% of circulating supply)
  10. 0x5f194e515d21740e488ad45b32702552b131719e — 1,383,706,142,012,771,663,872 tokens (0.22% of circulating supply)

Top 10 Total Balance: 219,304,499,172,311,610,163,200 tokens
Top 10 Share of Circulating Supply: 35.21%
Top 10 Share of Total Supply: 21.93%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $94,789,092.14
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (18.5643)
Total supply of LP tokens: 0.000858405332740247
LP holders count: 2

Liquidity holders for 0x8f3eEbfFa47e5E73Ca8Fa3d00A3DD8E66BCB837E, (OctoDoge)

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 0.000858405332739247 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1528.69 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-28T17:07:41
Last Active: 2021-11-30T15:13:23
Days Since Last Activity: 1342.7722760740974 days
Last Transaction Hash: 0x4d4e75e0925541a257fadde9b16bd332342b3cad90a59694a30aeabfac8fd46a
