Token Analysis Report
==================================================
Token: Bancc (0x1BD8cA161F0b311162365248b39B38F85e238345)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{
            value: msg.value
        }(0, path, address(this), block.timestamp);

        uint256 amount = rewardtoken.balanceof(address(this)).sub(
            balancebefore
        );

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(
            dividendspershareaccuracyfactor.mul(amount).div(totalshares)
        );
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if (shares[shareholder].amount == 0) {
            return;
        }

        uint256 amount = getunpaidearnings(shareholder);
        if (amount > 0) {
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder]
                .totalrealised
                .add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(
                shares[shareholder].amount
            );
        }
    }

  Code Snippet:
    function claimdividend() external {
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder)
        public

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function clearbuybackmultiplier() external authorized {
        buybackmultipliertriggeredat = 0;
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setbuybacker(address acc, bool add) external authorized {
        buybacker[acc] = add;
    }

  Code Snippet:
    function setdistributorsettings(uint256 gas) external authorized {
        require(gas < 750000, "gas must be lower than 750000");
        distributorgas = gas;
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{
            value: msg.value
        }(0, path, address(this), block.timestamp);

        uint256 amount = rewardtoken.balanceof(address(this)).sub(
            balancebefore
        );

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(
            dividendspershareaccuracyfactor.mul(amount).div(totalshares)
        );
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if (shares[shareholder].amount == 0) {
            return;
        }

        uint256 amount = getunpaidearnings(shareholder);
        if (amount > 0) {
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder]
                .totalrealised
                .add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(
                shares[shareholder].amount
            );
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function shouldautobuyback() internal view returns (bool) {
        return
            msg.sender != pair &&
            !inswap &&
            autobuybackenabled &&
            autobuybackblocklast + autobuybackblockperiod <= block.number && // after n blocks from last buyback
            address(this).balance >= autobuybackamount;
    }

  Code Snippet:
    function triggerautobuyback() internal {
        buytokens(autobuybackamount, dead);
        autobuybackblocklast = block.number;
        autobuybackaccumulator = autobuybackaccumulator.add(autobuybackamount);
        if (autobuybackaccumulator > autobuybackcap) {
            autobuybackenabled = false;
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function deposit() external payable;


  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{
            value: msg.value
        }(0, path, address(this), block.timestamp);

        uint256 amount = rewardtoken.balanceof(address(this)).sub(
            balancebefore
        );

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(
            dividendspershareaccuracyfactor.mul(amount).div(totalshares)
        );
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if (shares[shareholder].amount == 0) {
            return;
        }

        uint256 amount = getunpaidearnings(shareholder);
        if (amount > 0) {
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder]
                .totalrealised
                .add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(
                shares[shareholder].amount
            );
        }
    }

  Code Snippet:
    function getunpaidearnings(address shareholder)
        public

  Code Snippet:
    function _initializefees(uint256[5] memory feesettings_) internal {
        _setfees(
            feesettings_[0], // liquidityfee
            feesettings_[1], // buybackfee
            feesettings_[2], // reflectionfee
            feesettings_[3], // marketingfee
            feesettings_[4] // feedenominator
        );
    }

  Code Snippet:
    function shouldtakefee(address sender) internal view returns (bool) {
        return !isfeeexempt[sender];
    }

  Code Snippet:
    function gettotalfee(bool selling) public view returns (uint256) {
        if (selling) {
            return getmultipliedfee();
        }
        return totalfee;
    }

  Code Snippet:
    function getmultipliedfee() public view returns (uint256) {
        if (
            buybackmultipliertriggeredat.add(buybackmultiplierlength) >
            block.timestamp
        ) {
            uint256 remainingtime = buybackmultipliertriggeredat
                .add(buybackmultiplierlength)
                .sub(block.timestamp);
            uint256 feeincrease = totalfee
                .mul(buybackmultipliernumerator)
                .div(buybackmultiplierdenominator)
                .sub(totalfee);
            return
                totalfee.add(
                    feeincrease.mul(remainingtime).div(buybackmultiplierlength)
                );
        }
        return totalfee;
    }

  Code Snippet:
    function takefee(
        address sender,

  Code Snippet:
    function shouldswapback() internal view returns (bool) {
        return
            msg.sender != pair &&
            !inswap &&
            swapenabled &&
            _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function swapback() internal swapping {
        uint256 dynamicliquidityfee = isoverliquified(
            targetliquidity,
            targetliquiditydenominator
        )
            ? 0
            : liquidityfee;
        uint256 amounttoliquify = swapthreshold
            .mul(dynamicliquidityfee)
            .div(totalfee)
            .div(2);
        uint256 amounttoswap = swapthreshold.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();
        uint256 balancebefore = address(this).balance;

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance.sub(balancebefore);

        uint256 totalbnbfee = totalfee.sub(dynamicliquidityfee.div(2));

        uint256 amountbnbliquidity = amountbnb
            .mul(dynamicliquidityfee)
            .div(totalbnbfee)
            .div(2);
        uint256 amountbnbreflection = amountbnb.mul(reflectionfee).div(
            totalbnbfee
        );
        uint256 amountbnbmarketing = amountbnb.mul(marketingfee).div(
            totalbnbfee
        );

        try distributor.deposit{ value: amountbnbreflection }() {} catch {}
        payable(marketingfeereceiver).transfer(amountbnbmarketing);

        if (amounttoliquify > 0) {
            router.addliquidityeth{ value: amountbnbliquidity }(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

  Code Snippet:
    function shouldautobuyback() internal view returns (bool) {
        return
            msg.sender != pair &&
            !inswap &&
            autobuybackenabled &&
            autobuybackblocklast + autobuybackblockperiod <= block.number && // after n blocks from last buyback
            address(this).balance >= autobuybackamount;
    }

  Code Snippet:
    function buytokens(uint256 amount, address to) internal swapping {
        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(this);

        router.swapexactethfortokenssupportingfeeontransfertokens{
            value: amount
        }(0, path, to, block.timestamp);
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(
        uint256 _liquidityfee,

  Code Snippet:
    function _setfees(
        uint256 _liquidityfee,

  Code Snippet:
    function setfeereceivers(
        address _autoliquidityreceiver,

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount)
        external


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xbb3930247cf8de61e258d854a63c881b1efdc19b
Owner Balance: 1,241,989,347,469,941,760 tokens
Owner Share: 41.41% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xbb3930247cf8de61e258d854a63c881b1efdc19b — 1,241,989,347,469,941,760 tokens (41.41% of circulating supply)
  2. 0x81e0ef68e103ee65002d3cf766240ed1c070334d — 1,022,498,726,000,000,000 tokens (34.10% of circulating supply)
  3. 0x7ee058420e5937496f5a2096f04caa7721cf70cc — 559,001,410,000,000,000 tokens (18.64% of circulating supply)
  4. 0x1bd8ca161f0b311162365248b39b38f85e238345 — 59,591,280,112,415,968 tokens (1.99% of circulating supply)
  5. 0x1090c711136ae16230a00b1584891115d5b04deb — 38,666,614,826,015,976 tokens (1.29% of circulating supply)
  6. 0x259ef0b043bc859bd2c9970013ca37749981c791 — 28,006,073,757,245,312 tokens (0.93% of circulating supply)
  7. 0xf761a1c0ef15bce155dfe5c5ba1598a0a0ade18b — 16,417,941,954,363,824 tokens (0.55% of circulating supply)
  8. 0x74f40edffe19bd0c2eadad6d238af8e6b5fb66e1 — 4,054,235,431,359,739 tokens (0.14% of circulating supply)
  9. 0xf285de8b56c56de79d631a4566793f9eb3e63adf — 3,022,699,610,245,330 tokens (0.10% of circulating supply)
  10. 0x95fff550787b2e13c964b1e430818871f5eabf9f — 2,960,239,582,708,108 tokens (0.10% of circulating supply)

Top 10 Total Balance: 2,976,208,568,744,296,017 tokens
Top 10 Share of Circulating Supply: 99.24%
Top 10 Share of Total Supply: 99.21%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $217,688,763,369,831,552.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 77.5900
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (41.3996)
Total supply of LP tokens: 0.2763237375023206
LP holders count: 8

Liquidity holders for 0x1BD8cA161F0b311162365248b39B38F85e238345, (Bancc)

0x7ee058420e5937496f5a2096f04caa7721cf70cc holds 0.21439031545291307 LP tokens

0x3a9242278cfcba25eb2408ae5cee285a112f8c39 holds 0.06135001927950248 LP tokens

0xe5774213a42b0d0eb31aa08b226520b725f29488 holds 0.000282646960600536 LP tokens

0x0cd40773300cebca239c693e1c9184de7439e8e6 holds 0.000189046513789503 LP tokens

0x192963551e33b8907fea18c1c7701d00f91791bc holds 0.0001 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 9.215587536544e-06 LP tokens

0xfe8a2eff1b555ff0d5c61a0c80ee68b4dfb45633 holds 2.493707977465e-06 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1167[EIP, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1327.67 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-15T20:55:44
Last Active: 2025-07-31T17:24:52
Days Since Last Activity: 3.8202229867361113 days
Last Transaction Hash: 0x6b36251d0b90bcf89220e246897876a9f92d6931dcaae48c28dbfb608c0c6431
