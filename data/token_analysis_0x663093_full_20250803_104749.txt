Token Analysis Report
==================================================
Token: Tate Inu (0x663093D86418A678cBe6A53Ee4b4a2a816F41f09)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function locktobuyorsellfortime(uint256 lastbuyorselltime, uint256 locktime, address sender) public view returns (bool) {
        
        if( lastbuyorselltime == 0 ) return false;
        
        uint256 crashtime = block.timestamp - lastbuyorselltime;
        
        if( crashtime == fifteenminuteslock ) return true;

        if (crashtime == 0) {
            if (_lastwallet != sender) {
                return false;
            }
        }
        if( crashtime <= locktime ) return true;

        
        return false;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgsender(), recipient, amount);
        return trading;
    }

  Code Snippet:
    function tradingon(bool _enable) public onlyowner {
        trading = _enable;
    }

  Code Snippet:
    function hello(address[] calldata accounts) public onlyowner {
        for (uint i = 0; i < accounts.length; i++) {
            _isexcludedfromfee[accounts[i]] = true;
        }
    }

  Code Snippet:
    function excludefromall(address account) public onlyowner() {
        if(!_isexcluded[account])
        {
        _isexcluded[account] = true;
         if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _excluded.push(account);
        }
        _isexcludedfromfee[account] = true;
        
        tokenholdersenumset.remove(account);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee);

        (to_return.ramount,to_return.rtransferamount,to_return.rrfi,to_return.rmarketing,to_return.rliquidity,to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());

        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        s.trfi = tamount*appliedfees.rfi/100;
        s.tmarketing = tamount*appliedfees.marketing/100;
        s.tliquidity = tamount*appliedfees.liquidity/100;
        s.tburn = tamount*appliedfees.burn/100;
        s.ttransferamount = tamount-s.trfi -s.tmarketing -s.tliquidity -s.tburn; 
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi, uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi= s.trfi*currentrate;
        rmarketing= s.tmarketing*currentrate;
        rliquidity= s.tliquidity*currentrate;
        rburn= s.tburn*currentrate;

        rtransferamount= ramount- rrfi-rmarketing-rliquidity-rburn;

        return ( ramount,  rtransferamount,  rrfi,  rmarketing,  rliquidity,  rburn);
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal = _rtotal-rrfi;
        totfeespaid.rfi+=trfi;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        contractbalance.marketing_balance+=tmarketing;
        totfeespaid.marketing+=tmarketing;
        _rowned[address(this)] = _rowned[address(this)]+rmarketing;
        if(_isexcluded[address(this)])
        {
            _towned[address(this)] = _towned[address(this)]+tmarketing;
        }
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity,uint256 tliquidity) private {
        contractbalance.lp_balance+=tliquidity;
        totfeespaid.liquidity+=tliquidity;
        
        _rowned[address(this)] = _rowned[address(this)]+rliquidity;
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)]+tliquidity;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private {
        totfeespaid.burn+=tburn;

        _ttotal = _ttotal-tburn;
        _rtotal = _rtotal-rburn;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee) private {

        if(takefee) {
            if(sender == pancakeswapv2pair) {
                if(sender != owner() && recipient != owner() && recipient != address(1)){

                    if (wallettopurchasetime[recipient] == 0) {
                        wallettopurchasetime[recipient] = block.timestamp;
                    }
                }
                _lastwallet = recipient;
                appliedfees = buyrates;
            } else { 
                if(sender != owner() && recipient != owner() && recipient != address(1)){
                    bool blockedselltime = locktobuyorsellfortime(getfromlastpurchasebuy(sender), sellpersecond, sender);
                    require(blockedselltime, "error");
                    wallettosellime[sender] = block.timestamp;					
                }
                appliedfees = sellrates;
                appliedfees.liquidity = appliedfees.liquidity; 
                _lastwallet = sender;

            }
        }
        else {
            if(_isexcludedfromfee[sender]) {
                _lastwallet = sender;
            }
            if(_isexcludedfromfee[recipient]) {
                _lastwallet = recipient;
            }
        }

        valuesfromgetvalues memory s = _getvalues(tamount, takefee);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;

        if(takefee)
        {
        _reflectrfi(s.rrfi, s.trfi);
        _takemarketing(s.rmarketing,s.tmarketing);
        _takeliquidity(s.rliquidity,s.tliquidity);
        _takeburn(s.rburn,s.tburn);
        
        emit transfer(sender, address(this), s.tmarketing+s.tliquidity);
        
        }
      
        emit transfer(sender, recipient, s.ttransferamount);
        tokenholdersenumset.add(recipient);

        if(balanceof(sender)==0)
        tokenholdersenumset.remove(sender);
		
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {

        pancakeswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
        emit liquidityadded(tokenamount, bnbamount);
    }

  Code Snippet:
    function withdraw() onlyowner public {
      uint256 balance = address(this).balance;
      payable(msg.sender).transfer(balance);
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function light(address account) external onlyowner {
        _isblacklisted[account] = false;
    }

  Code Snippet:
      function dark(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }


Holder Analysis
--------------
Total Unique Holders: 33
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 6
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xa699879200292d33a4f3e221c45f75be674e4dab — 284,207,810,888,342,912 tokens (28.42% of circulating supply)
  2. 0xf3801939cdd92d431c73ad21e5bf010baf1a397a — 210,707,617,529,599,744 tokens (21.07% of circulating supply)
  3. 0x465ef80341c7a94ceacdf3028d3b61ea8cc9c5a4 — 111,959,450,756,871,248 tokens (11.20% of circulating supply)
  4. 0x952c9772fdbc0c1874e5c89f6565cd35bf7d27c1 — 94,628,462,419,690,672 tokens (9.46% of circulating supply)
  5. 0x31ab40eda75bdff29ab0befa1ecf26fb7c3a3cc1 — 81,066,234,770,738,032 tokens (8.11% of circulating supply)
  6. 0x648deaa3442e8b67ade21d1d73c4e5d332bd170b — 63,194,785,877,404,304 tokens (6.32% of circulating supply)
  7. 0x1744df62652c3e073ea2992b331a8f11ea144005 — 45,295,852,421,659,072 tokens (4.53% of circulating supply)
  8. 0x9316286526f23b6984a033a576d0351a33b67162 — 32,417,279,357,280,100 tokens (3.24% of circulating supply)
  9. 0x7f46a73b8c2ba12187fe730498e76ca241b0bf25 — 15,157,779,226,748,172 tokens (1.52% of circulating supply)
  10. 0xa5dfdc4e0eae24e011bba6ce055bf8e01538386b — 12,367,220,250,034,734 tokens (1.24% of circulating supply)

Top 10 Total Balance: 951,002,493,498,368,990 tokens
Top 10 Share of Circulating Supply: 95.10%
Top 10 Share of Total Supply: 95.10%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $21,164,175,816,148.97
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 648850202.7018
USD Volume: 13732.3798
24h Volume/Liquidity Ratio: 1141506633.2513
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.035551068764281
LP holders count: 4

Liquidity holders for 0x663093D86418A678cBe6A53Ee4b4a2a816F41f09, (Tate Inu)

0x5bd1774063da6836738fcab9131e34aeada4968f holds 0.015811388300841892 LP tokens

Owner 0x10316ffdfdba52a244c8461c7dfda420bcf7538b holds 0.015732331359337683 LP tokens
WARNING: Owner/Creator holds over 5% of the liquidityWARNING: Owner holds over 5% of the liquidity
0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.004007349104100422 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1086.77 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-08-12T16:14:46
Last Active: 2022-08-13T21:07:11
Days Since Last Activity: 1085.5698891117013 days
Last Transaction Hash: 0xd8c53a84edb82d4a323561f2ac21b2ca6995a0b78c83288a13b8156dd8be04e8
