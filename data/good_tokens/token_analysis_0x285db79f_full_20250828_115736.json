{
  "token_address": "0x285db79fa7e0e89e822786f48a7c98c6c1dc1c7d",
  "chain": "eth",
  "token_name": "Magic Internet Cash",
  "analyses": {
    "contract": {
      "contract_name": "MIC",
      "compiler_version": "v0.8.17+commit.8df45f5f",
      "license_type": "",
      "implementation": "",
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mic.sol\": {\r\n      \"content\": \"// https://t.me/micportal\\r\\n// https://magicinternetcash.wtf\\r\\n// SPDX-License-Identifier: Unlicensed                                                                         \\r\\n \\r\\npragma solidity 0.8.17;\\r\\n \\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n \\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n \\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n \\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n \\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n \\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n \\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n \\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n \\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n \\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n \\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n \\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n \\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n \\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n \\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n \\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n \\r\\n \\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    mapping(address => uint256) private _balances;\\r\\n \\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n \\r\\n    uint256 private _totalSupply;\\r\\n \\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n \\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n \\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n \\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n \\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n \\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n \\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n \\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n \\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n \\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n \\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n \\r\\n \\r\\n \\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n \\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n \\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n \\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n \\r\\n \\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n \\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n \\r\\n \\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n \\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n \\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n \\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\ncontract MIC is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0x000000000000000000000000000000000000dEaD);\\r\\n \\r\\n    bool private swapping;\\r\\n \\r\\n    address public marketingWallet;\\r\\n    address public devWallet;\\r\\n \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n \\r\\n    uint256 public percentForLPBurn = 25; // 25 = .25%\\r\\n    bool public lpBurnEnabled = true;\\r\\n    uint256 public lpBurnFrequency = 7200 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n \\r\\n    uint256 public manualBurnFrequency = 30 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n \\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    bool public enableEarlySellTax = true;\\r\\n \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n \\r\\n    // Seller Map\\r\\n    mapping (address => uint256) private _holderFirstBuyTimestamp;\\r\\n \\r\\n    // Blacklist Map\\r\\n    mapping (address => bool) private _blacklist;\\r\\n    bool public transferDelayEnabled = true;\\r\\n \\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyDevFee;\\r\\n \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellDevFee;\\r\\n \\r\\n    uint256 public earlySellLiquidityFee;\\r\\n    uint256 public earlySellMarketingFee;\\r\\n \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForDev;\\r\\n \\r\\n    // block number of opened trading\\r\\n    uint256 launchedAt;\\r\\n \\r\\n    /******************/\\r\\n \\r\\n    // exclude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n \\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n \\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n \\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n \\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n \\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event devWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n \\r\\n    event AutoNukeLP();\\r\\n \\r\\n    event ManualNukeLP();\\r\\n \\r\\n    constructor() ERC20(\\\"Magic Internet Cash\\\", \\\"MIC\\\") {\\r\\n \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n \\r\\n        uint256 _buyMarketingFee = 20;\\r\\n        uint256 _buyLiquidityFee = 5;\\r\\n        uint256 _buyDevFee = 0;\\r\\n \\r\\n        uint256 _sellMarketingFee = 20;\\r\\n        uint256 _sellLiquidityFee = 5;\\r\\n        uint256 _sellDevFee = 0;\\r\\n \\r\\n        uint256 _earlySellLiquidityFee = 0;\\r\\n        uint256 _earlySellMarketingFee = 0;\\r\\n \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n \\r\\n        maxTransactionAmount = totalSupply * 10 / 1000; // 1% maxtransaction\\r\\n        maxWallet = totalSupply * 20 / 1000; // 2% maxwallet\\r\\n        swapTokensAtAmount = totalSupply * 5 / 10000; // 0.05% swap wallet \\r\\n \\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyDevFee = _buyDevFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellDevFee = _sellDevFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n \\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n \\r\\n        marketingWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // marketingwallet\\r\\n        devWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // devwallet\\r\\n \\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n \\r\\n        /*\\r\\n            _mint is an internal function in ERC20.sol that is only called here,\\r\\n            and CANNOT be called ever again\\r\\n        */\\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n \\r\\n    receive() external payable {\\r\\n \\r\\n  \\t}\\r\\n \\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        launchedAt = block.number;\\r\\n    }\\r\\n \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function setEarlySellTax(bool onoff) external onlyOwner  {\\r\\n        enableEarlySellTax = onoff;\\r\\n    }\\r\\n \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n  \\t    require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n  \\t    require(newAmount <= totalSupply() * 5 / 1000, \\\"Swap amount cannot be higher than 0.5% total supply.\\\");\\r\\n  \\t    swapTokensAtAmount = newAmount;\\r\\n  \\t    return true;\\r\\n  \\t}\\r\\n \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.5%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 15 / 1000)/1e18, \\\"Cannot set maxWallet lower than 1.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyDevFee = _devFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellDevFee = _devFee;\\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n        require(sellTotalFees <= 99, \\\"Must keep fees at 99% or less\\\");\\r\\n    }\\r\\n \\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n \\r\\n    function blacklistAccount (address account, bool isBlacklisted) public onlyOwner {\\r\\n        _blacklist[account] = isBlacklisted;\\r\\n    }\\r\\n \\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n \\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n \\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n \\r\\n    function updateDevWallet(address newWallet) external onlyOwner {\\r\\n        emit devWalletUpdated(newWallet, devWallet);\\r\\n        devWallet = newWallet;\\r\\n    }\\r\\n \\r\\n \\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n \\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(!_blacklist[to] && !_blacklist[from], \\\"You have been blacklisted from transfering tokens\\\");\\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n \\r\\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n \\r\\n        // anti bot logic\\r\\n        if (block.number <= (launchedAt + 0) && \\r\\n                to != uniswapV2Pair && \\r\\n                to != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\r\\n            ) { \\r\\n            _blacklist[to] = false;\\r\\n        }\\r\\n \\r\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\r\\n \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n \\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n \\r\\n            swapBack();\\r\\n \\r\\n            swapping = false;\\r\\n        }\\r\\n \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n \\r\\n        bool takeFee = !swapping;\\r\\n \\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n \\r\\n        uint256 fees = 0;\\r\\n        // only take fees on buys/sells, do not take on wallet transfers\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForDev += fees * sellDevFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n        \\t    fees = amount.mul(buyTotalFees).div(100);\\r\\n        \\t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForDev += fees * buyDevFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n \\r\\n        \\tamount -= fees;\\r\\n        }\\r\\n \\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n \\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n \\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n \\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n \\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n \\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\\r\\n        bool success;\\r\\n \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n \\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n \\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n \\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\\r\\n \\r\\n \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\\r\\n \\r\\n \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForDev = 0;\\r\\n \\r\\n        (success,) = address(devWallet).call{value: ethForDev}(\\\"\\\");\\r\\n \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n \\r\\n \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AutoNukeLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"BoughtEarly\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManualNukeLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"devWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"marketingWalletUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blacklistAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDevFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlySellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlySellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableEarlySellTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLpBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastManualLpBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBurnEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBurnFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualBurnFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"manualBurnLiquidityPairTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentForLPBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDevFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_frequencyInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_Enabled\",\"type\":\"bool\"}],\"name\":\"setAutoLPBurnSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onoff\",\"type\":\"bool\"}],\"name\":\"setEarlySellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlySellLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlySellMarketingFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "verified": true,
      "owner": "0x0000000000000000000000000000000000000000",
      "creator": "0x7c0c91c1b2152e176bf6712a8ee32472383671b8",
      "is_hidden_owner": true,
      "is_proxy": false,
      "is_sellable": true,
      "is_hardcoded_owner": false,
      "code_analysis": {
        "total_matches": 2,
        "patterns_found": {
          "stealth_fee_mechanics": {
            "count": 1,
            "snippets": [
              {
                "matched_code": "mapping (address => bool) private _isexcludedfromfee",
                "function_context": "\"content\": \"// https://t.me/micportal\\r\\n// https://magicinternetcash.wtf\\r\\n// SPDX-License-Identifier: Unlicensed                                                                         \\r\\n \\r\\npragma solidity 0.8.17;\\r\\n \\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n \\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n \\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n \\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n \\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n \\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n \\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n \\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n \\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n \\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n \\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n \\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n \\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n \\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n \\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n \\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n \\r\\n \\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    mapping(address => uint256) private _balances;\\r\\n \\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n \\r\\n    uint256 private _totalSupply;\\r\\n \\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n \\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n \\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n \\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n \\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n \\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n \\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n \\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n \\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n \\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n \\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n \\r\\n \\r\\n \\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n \\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n \\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n \\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n \\r\\n \\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n \\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n \\r\\n \\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n \\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n \\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n \\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\ncontract MIC is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0x000000000000000000000000000000000000dEaD);\\r\\n \\r\\n    bool private swapping;\\r\\n \\r\\n    address public marketingWallet;\\r\\n    address public devWallet;\\r\\n \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n \\r\\n    uint256 public percentForLPBurn = 25; // 25 = .25%\\r\\n    bool public lpBurnEnabled = true;\\r\\n    uint256 public lpBurnFrequency = 7200 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n \\r\\n    uint256 public manualBurnFrequency = 30 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n \\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    bool public enableEarlySellTax = true;\\r\\n \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n \\r\\n    // Seller Map\\r\\n    mapping (address => uint256) private _holderFirstBuyTimestamp;\\r\\n \\r\\n    // Blacklist Map\\r\\n    mapping (address => bool) private _blacklist;\\r\\n    bool public transferDelayEnabled = true;\\r\\n \\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyDevFee;\\r\\n \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellDevFee;\\r\\n \\r\\n    uint256 public earlySellLiquidityFee;\\r\\n    uint256 public earlySellMarketingFee;\\r\\n \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForDev;\\r\\n \\r\\n    // block number of opened trading\\r\\n    uint256 launchedAt;\\r\\n \\r\\n    /******************/\\r\\n \\r\\n    // exclude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n \\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n \\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n \\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n \\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n \\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event devWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n \\r\\n    event AutoNukeLP();\\r\\n \\r\\n    event ManualNukeLP();\\r\\n \\r\\n    constructor() ERC20(\\\"Magic Internet Cash\\\", \\\"MIC\\\") {\\r\\n \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n \\r\\n        uint256 _buyMarketingFee = 20;\\r\\n        uint256 _buyLiquidityFee = 5;\\r\\n        uint256 _buyDevFee = 0;\\r\\n \\r\\n        uint256 _sellMarketingFee = 20;\\r\\n        uint256 _sellLiquidityFee = 5;\\r\\n        uint256 _sellDevFee = 0;\\r\\n \\r\\n        uint256 _earlySellLiquidityFee = 0;\\r\\n        uint256 _earlySellMarketingFee = 0;\\r\\n \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n \\r\\n        maxTransactionAmount = totalSupply * 10 / 1000; // 1% maxtransaction\\r\\n        maxWallet = totalSupply * 20 / 1000; // 2% maxwallet\\r\\n        swapTokensAtAmount = totalSupply * 5 / 10000; // 0.05% swap wallet \\r\\n \\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyDevFee = _buyDevFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellDevFee = _sellDevFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n \\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n \\r\\n        marketingWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // marketingwallet\\r\\n        devWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // devwallet\\r\\n \\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n \\r\\n        /*\\r\\n            _mint is an internal function in ERC20.sol that is only called here,\\r\\n            and CANNOT be called ever again\\r\\n        */\\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n \\r\\n    receive() external payable {\\r\\n \\r\\n  \\t}\\r\\n \\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        launchedAt = block.number;\\r\\n    }\\r\\n \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function setEarlySellTax(bool onoff) external onlyOwner  {\\r\\n        enableEarlySellTax = onoff;\\r\\n    }\\r\\n \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n  \\t    require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n  \\t    require(newAmount <= totalSupply() * 5 / 1000, \\\"Swap amount cannot be higher than 0.5% total supply.\\\");\\r\\n  \\t    swapTokensAtAmount = newAmount;\\r\\n  \\t    return true;\\r\\n  \\t}\\r\\n \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.5%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 15 / 1000)/1e18, \\\"Cannot set maxWallet lower than 1.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyDevFee = _devFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellDevFee = _devFee;\\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n        require(sellTotalFees <= 99, \\\"Must keep fees at 99% or less\\\");\\r\\n    }\\r\\n \\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n \\r\\n    function blacklistAccount (address account, bool isBlacklisted) public onlyOwner {\\r\\n        _blacklist[account] = isBlacklisted;\\r\\n    }\\r\\n \\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n \\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n \\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n \\r\\n    function updateDevWallet(address newWallet) external onlyOwner {\\r\\n        emit devWalletUpdated(newWallet, devWallet);\\r\\n        devWallet = newWallet;\\r\\n    }\\r\\n \\r\\n \\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n \\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(!_blacklist[to] && !_blacklist[from], \\\"You have been blacklisted from transfering tokens\\\");\\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n \\r\\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n \\r\\n        // anti bot logic\\r\\n        if (block.number <= (launchedAt + 0) && \\r\\n                to != uniswapV2Pair && \\r\\n                to != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\r\\n            ) { \\r\\n            _blacklist[to] = false;\\r\\n        }\\r\\n \\r\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\r\\n \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n \\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n \\r\\n            swapBack();\\r\\n \\r\\n            swapping = false;\\r\\n        }\\r\\n \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n \\r\\n        bool takeFee = !swapping;\\r\\n \\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n \\r\\n        uint256 fees = 0;\\r\\n        // only take fees on buys/sells, do not take on wallet transfers\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForDev += fees * sellDevFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n        \\t    fees = amount.mul(buyTotalFees).div(100);\\r\\n        \\t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForDev += fees * buyDevFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n \\r\\n        \\tamount -= fees;\\r\\n        }\\r\\n \\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n \\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n \\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n \\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n \\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n \\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\\r\\n        bool success;\\r\\n \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n \\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n \\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n \\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\\r\\n \\r\\n \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\\r\\n \\r\\n \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForDev = 0;\\r\\n \\r\\n        (success,) = address(devWallet).call{value: ethForDev}(\\\"\\\");\\r\\n \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n \\r\\n \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n}\"",
                "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
              }
            ]
          },
          "liquidity_manipulation": {
            "count": 1,
            "snippets": [
              {
                "matched_code": "function removeliquidity(\\r\\n        address tokena,\\r\\n        address tokenb,\\r\\n        uint liquidity,\\r\\n        uint amountamin,\\r\\n        uint amountbmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounta, uint amountb);\\r\\n    function removeliquidityeth(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounttoken, uint amounteth);\\r\\n    function removeliquiditywithpermit(\\r\\n        address tokena,\\r\\n        address tokenb,\\r\\n        uint liquidity,\\r\\n        uint amountamin,\\r\\n        uint amountbmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounta, uint amountb);\\r\\n    function removeliquidityethwithpermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounttoken, uint amounteth);\\r\\n    function swapexacttokensfortokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swaptokensforexacttokens(\\r\\n        uint amountout,\\r\\n        uint amountinmax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n \\r\\n    function quote(uint amounta, uint reservea, uint reserveb) external pure returns (uint amountb);\\r\\n    function getamountout(uint amountin, uint reservein, uint reserveout) external pure returns (uint amountout);\\r\\n    function getamountin(uint amountout, uint reservein, uint reserveout) external pure returns (uint amountin);\\r\\n    function getamountsout(uint amountin, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getamountsin(uint amountout, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n \\r\\ninterface iuniswapv2router02 is iuniswapv2router01 {\\r\\n    function removeliquidityethsupportingfeeontransfertokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounteth);\\r\\n    function removeliquidityethwithpermitsupportingfeeontransfertokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounteth);\\r\\n \\r\\n    function swapexacttokensfortokenssupportingfeeontransfertokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapexactethfortokenssupportingfeeontransfertokens(\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapexacttokensforethsupportingfeeontransfertokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\ncontract mic is erc20, ownable {\\r\\n    using safemath for uint256;\\r\\n \\r\\n    iuniswapv2router02 public immutable uniswapv2router;\\r\\n    address public immutable uniswapv2pair;\\r\\n    address public constant deadaddress = address(0x000000000000000000000000000000000000dead);\\r\\n \\r\\n    bool private swapping;\\r\\n \\r\\n    address public marketingwallet;\\r\\n    address public devwallet;\\r\\n \\r\\n    uint256 public maxtransactionamount;\\r\\n    uint256 public swaptokensatamount;\\r\\n    uint256 public maxwallet;\\r\\n \\r\\n    uint256 public percentforlpburn = 25; // 25 = .25%\\r\\n    bool public lpburnenabled = true;\\r\\n    uint256 public lpburnfrequency = 7200 seconds;\\r\\n    uint256 public lastlpburntime;\\r\\n \\r\\n    uint256 public manualburnfrequency = 30 minutes;\\r\\n    uint256 public lastmanuallpburntime;\\r\\n \\r\\n    bool public limitsineffect = true;\\r\\n    bool public tradingactive = false;\\r\\n    bool public swapenabled = false;\\r\\n    bool public enableearlyselltax = true;\\r\\n \\r\\n     // anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderlasttransfertimestamp; // to hold last transfers temporarily during launch\\r\\n \\r\\n    // seller map\\r\\n    mapping (address => uint256) private _holderfirstbuytimestamp;\\r\\n \\r\\n    // blacklist map\\r\\n    mapping (address => bool) private _blacklist;\\r\\n    bool public transferdelayenabled = true;\\r\\n \\r\\n    uint256 public buytotalfees;\\r\\n    uint256 public buymarketingfee;\\r\\n    uint256 public buyliquidityfee;\\r\\n    uint256 public buydevfee;\\r\\n \\r\\n    uint256 public selltotalfees;\\r\\n    uint256 public sellmarketingfee;\\r\\n    uint256 public sellliquidityfee;\\r\\n    uint256 public selldevfee;\\r\\n \\r\\n    uint256 public earlysellliquidityfee;\\r\\n    uint256 public earlysellmarketingfee;\\r\\n \\r\\n    uint256 public tokensformarketing;\\r\\n    uint256 public tokensforliquidity;\\r\\n    uint256 public tokensfordev;\\r\\n \\r\\n    // block number of opened trading\\r\\n    uint256 launchedat;\\r\\n \\r\\n    /******************/\\r\\n \\r\\n    // exclude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isexcludedfromfees;\\r\\n    mapping (address => bool) public _isexcludedmaxtransactionamount;\\r\\n \\r\\n    // store addresses that a automatic market maker pairs. any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedmarketmakerpairs;\\r\\n \\r\\n    event updateuniswapv2router(address indexed newaddress, address indexed oldaddress);\\r\\n \\r\\n    event excludefromfees(address indexed account, bool isexcluded);\\r\\n \\r\\n    event setautomatedmarketmakerpair(address indexed pair, bool indexed value);\\r\\n \\r\\n    event marketingwalletupdated(address indexed newwallet, address indexed oldwallet);\\r\\n \\r\\n    event devwalletupdated(address indexed newwallet, address indexed oldwallet);\\r\\n \\r\\n    event swapandliquify(\\r\\n        uint256 tokensswapped,\\r\\n        uint256 ethreceived,\\r\\n        uint256 tokensintoliquidity\\r\\n    );\\r\\n \\r\\n    event autonukelp();\\r\\n \\r\\n    event manualnukelp();\\r\\n \\r\\n    constructor() erc20(\\\"magic internet cash\\\", \\\"mic\\\") {\\r\\n \\r\\n        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\\r\\n \\r\\n        excludefrommaxtransaction(address(_uniswapv2router), true);\\r\\n        uniswapv2router = _uniswapv2router;\\r\\n \\r\\n        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());\\r\\n        excludefrommaxtransaction(address(uniswapv2pair), true);\\r\\n        _setautomatedmarketmakerpair(address(uniswapv2pair), true);\\r\\n \\r\\n        uint256 _buymarketingfee = 20;\\r\\n        uint256 _buyliquidityfee = 5;\\r\\n        uint256 _buydevfee = 0;\\r\\n \\r\\n        uint256 _sellmarketingfee = 20;\\r\\n        uint256 _sellliquidityfee = 5;\\r\\n        uint256 _selldevfee = 0;\\r\\n \\r\\n        uint256 _earlysellliquidityfee = 0;\\r\\n        uint256 _earlysellmarketingfee = 0;\\r\\n \\r\\n        uint256 totalsupply = 1 * 1e9 * 1e18;\\r\\n \\r\\n        maxtransactionamount = totalsupply * 10 / 1000; // 1% maxtransaction\\r\\n        maxwallet = totalsupply * 20 / 1000; // 2% maxwallet\\r\\n        swaptokensatamount = totalsupply * 5 / 10000; // 0.05% swap wallet \\r\\n \\r\\n        buymarketingfee = _buymarketingfee;\\r\\n        buyliquidityfee = _buyliquidityfee;\\r\\n        buydevfee = _buydevfee;\\r\\n        buytotalfees = buymarketingfee + buyliquidityfee + buydevfee;\\r\\n \\r\\n        sellmarketingfee = _sellmarketingfee;\\r\\n        sellliquidityfee = _sellliquidityfee;\\r\\n        selldevfee = _selldevfee;\\r\\n        selltotalfees = sellmarketingfee + sellliquidityfee + selldevfee;\\r\\n \\r\\n        earlysellliquidityfee = _earlysellliquidityfee;\\r\\n        earlysellmarketingfee = _earlysellmarketingfee;\\r\\n \\r\\n        marketingwallet = address(0x7c0c91c1b2152e176bf6712a8ee32472383671b8); // marketingwallet\\r\\n        devwallet = address(0x7c0c91c1b2152e176bf6712a8ee32472383671b8); // devwallet\\r\\n \\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludefromfees(owner(), true);\\r\\n        excludefromfees(address(this), true);\\r\\n        excludefromfees(address(0xdead), true);\\r\\n \\r\\n        excludefrommaxtransaction(owner(), true);\\r\\n        excludefrommaxtransaction(address(this), true);\\r\\n        excludefrommaxtransaction(address(0xdead), true);\\r\\n \\r\\n        /*\\r\\n            _mint is an internal function in erc20.sol that is only called here,\\r\\n            and cannot be called ever again\\r\\n        */\\r\\n        _mint(msg.sender, totalsupply);\\r\\n    }\\r\\n \\r\\n    receive() external payable {\\r\\n \\r\\n  \\t}\\r\\n \\r\\n    // once enabled, can never be turned off\\r\\n    function enabletrading() external onlyowner {\\r\\n        tradingactive = true;\\r\\n        swapenabled = true;\\r\\n        lastlpburntime = block.timestamp;\\r\\n        launchedat = block.number;\\r\\n    }\\r\\n \\r\\n    // remove limits after token is stable\\r\\n    function removelimits() external onlyowner returns (bool){\\r\\n        limitsineffect = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    // disable transfer delay - cannot be reenabled\\r\\n    function disabletransferdelay() external onlyowner returns (bool){\\r\\n        transferdelayenabled = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function setearlyselltax(bool onoff) external onlyowner  {\\r\\n        enableearlyselltax = onoff;\\r\\n    }\\r\\n \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateswaptokensatamount(uint256 newamount) external onlyowner returns (bool){\\r\\n  \\t    require(newamount >= totalsupply() * 1 / 100000, \\\"swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n  \\t    require(newamount <= totalsupply() * 5 / 1000, \\\"swap amount cannot be higher than 0.5% total supply.\\\");\\r\\n  \\t    swaptokensatamount = newamount;\\r\\n  \\t    return true;\\r\\n  \\t}\\r\\n \\r\\n    function updatemaxtxnamount(uint256 newnum) external onlyowner {\\r\\n        require(newnum >= (totalsupply() * 5 / 1000)/1e18, \\\"cannot set maxtransactionamount lower than 0.5%\\\");\\r\\n        maxtransactionamount = newnum * (10**18);\\r\\n    }\\r\\n \\r\\n    function updatemaxwalletamount(uint256 newnum) external onlyowner {\\r\\n        require(newnum >= (totalsupply() * 15 / 1000)/1e18, \\\"cannot set maxwallet lower than 1.5%\\\");\\r\\n        maxwallet = newnum * (10**18);\\r\\n    }\\r\\n \\r\\n    function excludefrommaxtransaction(address updads, bool isex) public onlyowner {\\r\\n        _isexcludedmaxtransactionamount[updads] = isex;\\r\\n    }\\r\\n \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateswapenabled(bool enabled) external onlyowner(){\\r\\n        swapenabled = enabled;\\r\\n    }\\r\\n \\r\\n    function updatebuyfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _devfee) external onlyowner {\\r\\n        buymarketingfee = _marketingfee;\\r\\n        buyliquidityfee = _liquidityfee;\\r\\n        buydevfee = _devfee;\\r\\n        buytotalfees = buymarketingfee + buyliquidityfee + buydevfee;\\r\\n        require(buytotalfees <= 30, \\\"must keep fees at 30% or less\\\");\\r\\n    }\\r\\n \\r\\n    function updatesellfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _devfee, uint256 _earlysellliquidityfee, uint256 _earlysellmarketingfee) external onlyowner {\\r\\n        sellmarketingfee = _marketingfee;\\r\\n        sellliquidityfee = _liquidityfee;\\r\\n        selldevfee = _devfee;\\r\\n        earlysellliquidityfee = _earlysellliquidityfee;\\r\\n        earlysellmarketingfee = _earlysellmarketingfee;\\r\\n        selltotalfees = sellmarketingfee + sellliquidityfee + selldevfee;\\r\\n        require(selltotalfees <= 99, \\\"must keep fees at 99% or less\\\");\\r\\n    }\\r\\n \\r\\n    function excludefromfees(address account, bool excluded) public onlyowner {\\r\\n        _isexcludedfromfees[account] = excluded;\\r\\n        emit excludefromfees(account, excluded);\\r\\n    }\\r\\n \\r\\n    function blacklistaccount (address account, bool isblacklisted) public onlyowner {\\r\\n        _blacklist[account] = isblacklisted;\\r\\n    }\\r\\n \\r\\n    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {\\r\\n        require(pair != uniswapv2pair, \\\"the pair cannot be removed from automatedmarketmakerpairs\\\");\\r\\n \\r\\n        _setautomatedmarketmakerpair(pair, value);\\r\\n    }\\r\\n \\r\\n    function _setautomatedmarketmakerpair(address pair, bool value) private {\\r\\n        automatedmarketmakerpairs[pair] = value;\\r\\n \\r\\n        emit setautomatedmarketmakerpair(pair, value);\\r\\n    }\\r\\n \\r\\n    function updatemarketingwallet(address newmarketingwallet) external onlyowner {\\r\\n        emit marketingwalletupdated(newmarketingwallet, marketingwallet);\\r\\n        marketingwallet = newmarketingwallet;\\r\\n    }\\r\\n \\r\\n    function updatedevwallet(address newwallet) external onlyowner {\\r\\n        emit devwalletupdated(newwallet, devwallet);\\r\\n        devwallet = newwallet;\\r\\n    }\\r\\n \\r\\n \\r\\n    function isexcludedfromfees(address account) public view returns(bool) {\\r\\n        return _isexcludedfromfees[account];\\r\\n    }\\r\\n \\r\\n    event boughtearly(address indexed sniper);\\r\\n \\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"erc20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"erc20: transfer to the zero address\\\");\\r\\n        require(!_blacklist[to] && !_blacklist[from], \\\"you have been blacklisted from transfering tokens\\\");\\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n \\r\\n        if(limitsineffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingactive){\\r\\n                    require(_isexcludedfromfees[from] || _isexcludedfromfees[to], \\\"trading is not active.\\\");\\r\\n                }\\r\\n \\r\\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \\r\\n                if (transferdelayenabled){\\r\\n                    if (to != owner() && to != address(uniswapv2router) && to != address(uniswapv2pair)){\\r\\n                        require(_holderlasttransfertimestamp[tx.origin] < block.number, \\\"_transfer:: transfer delay enabled.  only one purchase per block allowed.\\\");\\r\\n                        _holderlasttransfertimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n \\r\\n                //when buy\\r\\n                if (automatedmarketmakerpairs[from] && !_isexcludedmaxtransactionamount[to]) {\\r\\n                        require(amount <= maxtransactionamount, \\\"buy transfer amount exceeds the maxtransactionamount.\\\");\\r\\n                        require(amount + balanceof(to) <= maxwallet, \\\"max wallet exceeded\\\");\\r\\n                }\\r\\n \\r\\n                //when sell\\r\\n                else if (automatedmarketmakerpairs[to] && !_isexcludedmaxtransactionamount[from]) {\\r\\n                        require(amount <= maxtransactionamount, \\\"sell transfer amount exceeds the maxtransactionamount.\\\");\\r\\n                }\\r\\n                else if(!_isexcludedmaxtransactionamount[to]){\\r\\n                    require(amount + balanceof(to) <= maxwallet, \\\"max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n \\r\\n        // anti bot logic\\r\\n        if (block.number <= (launchedat + 0) && \\r\\n                to != uniswapv2pair && \\r\\n                to != address(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\\r\\n            ) { \\r\\n            _blacklist[to] = false;\\r\\n        }\\r\\n \\r\\n\\t\\tuint256 contracttokenbalance = balanceof(address(this));\\r\\n \\r\\n        bool canswap = contracttokenbalance >= swaptokensatamount;\\r\\n \\r\\n        if( \\r\\n            canswap &&\\r\\n            swapenabled &&\\r\\n            !swapping &&\\r\\n            !automatedmarketmakerpairs[from] &&\\r\\n            !_isexcludedfromfees[from] &&\\r\\n            !_isexcludedfromfees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n \\r\\n            swapback();\\r\\n \\r\\n            swapping = false;\\r\\n        }\\r\\n \\r\\n        if(!swapping && automatedmarketmakerpairs[to] && lpburnenabled && block.timestamp >= lastlpburntime + lpburnfrequency && !_isexcludedfromfees[from]){\\r\\n            autoburnliquiditypairtokens();\\r\\n        }\\r\\n \\r\\n        bool takefee = !swapping;\\r\\n \\r\\n        // if any account belongs to _isexcludedfromfee account then remove the fee\\r\\n        if(_isexcludedfromfees[from] || _isexcludedfromfees[to]) {\\r\\n            takefee = false;\\r\\n        }\\r\\n \\r\\n        uint256 fees = 0;\\r\\n        // only take fees on buys/sells, do not take on wallet transfers\\r\\n        if(takefee){\\r\\n            // on sell\\r\\n            if (automatedmarketmakerpairs[to] && selltotalfees > 0){\\r\\n                fees = amount.mul(selltotalfees).div(100);\\r\\n                tokensforliquidity += fees * sellliquidityfee / selltotalfees;\\r\\n                tokensfordev += fees * selldevfee / selltotalfees;\\r\\n                tokensformarketing += fees * sellmarketingfee / selltotalfees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedmarketmakerpairs[from] && buytotalfees > 0) {\\r\\n        \\t    fees = amount.mul(buytotalfees).div(100);\\r\\n        \\t    tokensforliquidity += fees * buyliquidityfee / buytotalfees;\\r\\n                tokensfordev += fees * buydevfee / buytotalfees;\\r\\n                tokensformarketing += fees * buymarketingfee / buytotalfees;\\r\\n            }\\r\\n \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n \\r\\n        \\tamount -= fees;\\r\\n        }\\r\\n \\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n \\r\\n    function swaptokensforeth(uint256 tokenamount) private {\\r\\n \\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapv2router.weth();\\r\\n \\r\\n        _approve(address(this), address(uniswapv2router), tokenamount);\\r\\n \\r\\n        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(\\r\\n            tokenamount,\\r\\n            0, // accept any amount of eth\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n \\r\\n    }\\r\\n\\r\\n    function addliquidity(uint256 tokenamount, uint256 ethamount) private {\\r\\n        _approve(address(this), address(uniswapv2router), tokenamount);\\r\\n \\r\\n        uniswapv2router.addliquidityeth{value: ethamount}(\\r\\n            address(this),\\r\\n            tokenamount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadaddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n \\r\\n    function swapback() private {\\r\\n        uint256 contractbalance = balanceof(address(this));\\r\\n        uint256 totaltokenstoswap = tokensforliquidity + tokensformarketing + tokensfordev;\\r\\n        bool success;\\r\\n \\r\\n        if(contractbalance == 0 || totaltokenstoswap == 0) {return;}\\r\\n \\r\\n        if(contractbalance > swaptokensatamount * 20){\\r\\n          contractbalance = swaptokensatamount * 20;\\r\\n        }\\r\\n \\r\\n        uint256 liquiditytokens = contractbalance * tokensforliquidity / totaltokenstoswap / 2;\\r\\n        uint256 amounttoswapforeth = contractbalance.sub(liquiditytokens);\\r\\n \\r\\n        uint256 initialethbalance = address(this).balance;\\r\\n \\r\\n        swaptokensforeth(amounttoswapforeth); \\r\\n \\r\\n        uint256 ethbalance = address(this).balance.sub(initialethbalance);\\r\\n \\r\\n        uint256 ethformarketing = ethbalance.mul(tokensformarketing).div(totaltokenstoswap);\\r\\n        uint256 ethfordev = ethbalance.mul(tokensfordev).div(totaltokenstoswap);\\r\\n \\r\\n \\r\\n        uint256 ethforliquidity = ethbalance - ethformarketing - ethfordev;\\r\\n \\r\\n \\r\\n        tokensforliquidity = 0;\\r\\n        tokensformarketing = 0;\\r\\n        tokensfordev = 0;\\r\\n \\r\\n        (success,) = address(devwallet).call{value: ethfordev}(\\\"\\\");\\r\\n \\r\\n        if(liquiditytokens > 0 && ethforliquidity > 0){\\r\\n            addliquidity(liquiditytokens, ethforliquidity);\\r\\n            emit swapandliquify(amounttoswapforeth, ethforliquidity, tokensforliquidity);\\r\\n        }\\r\\n \\r\\n \\r\\n        (success,) = address(marketingwallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n \\r\\n    function setautolpburnsettings(uint256 _frequencyinseconds, uint256 _percent, bool _enabled) external onlyowner {\\r\\n        require(_frequencyinseconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"must set auto lp burn percent between 0% and 10%\\\");\\r\\n        lpburnfrequency = _frequencyinseconds;\\r\\n        percentforlpburn = _percent;\\r\\n        lpburnenabled = _enabled;\\r\\n    }\\r\\n \\r\\n    function autoburnliquiditypairtokens() internal returns (bool){\\r\\n \\r\\n        lastlpburntime = block.timestamp;\\r\\n \\r\\n        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);\\r\\n \\r\\n        uint256 amounttoburn = liquiditypairbalance.mul(percentforlpburn).div(10000);\\r\\n \\r\\n        if (amounttoburn > 0){\\r\\n            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);\\r\\n        }\\r\\n \\r\\n        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);\\r\\n        pair.sync();\\r\\n        emit autonukelp();\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function manualburnliquiditypairtokens(uint256 percent) external onlyowner",
                "function_context": "\"content\": \"// https://t.me/micportal\\r\\n// https://magicinternetcash.wtf\\r\\n// SPDX-License-Identifier: Unlicensed                                                                         \\r\\n \\r\\npragma solidity 0.8.17;\\r\\n \\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n \\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n \\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n \\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n \\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n \\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n \\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n \\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n \\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n \\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n \\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n \\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n \\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n \\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n \\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n \\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n \\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n \\r\\n \\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    mapping(address => uint256) private _balances;\\r\\n \\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n \\r\\n    uint256 private _totalSupply;\\r\\n \\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n \\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n \\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n \\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n \\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n \\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n \\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n \\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n \\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n \\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n \\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n \\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n \\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n \\r\\n \\r\\n \\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n \\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n \\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n \\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n \\r\\n \\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n \\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n \\r\\n \\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n \\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n \\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n \\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n \\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n \\r\\ncontract MIC is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n \\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0x000000000000000000000000000000000000dEaD);\\r\\n \\r\\n    bool private swapping;\\r\\n \\r\\n    address public marketingWallet;\\r\\n    address public devWallet;\\r\\n \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n \\r\\n    uint256 public percentForLPBurn = 25; // 25 = .25%\\r\\n    bool public lpBurnEnabled = true;\\r\\n    uint256 public lpBurnFrequency = 7200 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n \\r\\n    uint256 public manualBurnFrequency = 30 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n \\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    bool public enableEarlySellTax = true;\\r\\n \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n \\r\\n    // Seller Map\\r\\n    mapping (address => uint256) private _holderFirstBuyTimestamp;\\r\\n \\r\\n    // Blacklist Map\\r\\n    mapping (address => bool) private _blacklist;\\r\\n    bool public transferDelayEnabled = true;\\r\\n \\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyDevFee;\\r\\n \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellDevFee;\\r\\n \\r\\n    uint256 public earlySellLiquidityFee;\\r\\n    uint256 public earlySellMarketingFee;\\r\\n \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForDev;\\r\\n \\r\\n    // block number of opened trading\\r\\n    uint256 launchedAt;\\r\\n \\r\\n    /******************/\\r\\n \\r\\n    // exclude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n \\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n \\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n \\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n \\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n \\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event devWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n \\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n \\r\\n    event AutoNukeLP();\\r\\n \\r\\n    event ManualNukeLP();\\r\\n \\r\\n    constructor() ERC20(\\\"Magic Internet Cash\\\", \\\"MIC\\\") {\\r\\n \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n \\r\\n        uint256 _buyMarketingFee = 20;\\r\\n        uint256 _buyLiquidityFee = 5;\\r\\n        uint256 _buyDevFee = 0;\\r\\n \\r\\n        uint256 _sellMarketingFee = 20;\\r\\n        uint256 _sellLiquidityFee = 5;\\r\\n        uint256 _sellDevFee = 0;\\r\\n \\r\\n        uint256 _earlySellLiquidityFee = 0;\\r\\n        uint256 _earlySellMarketingFee = 0;\\r\\n \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n \\r\\n        maxTransactionAmount = totalSupply * 10 / 1000; // 1% maxtransaction\\r\\n        maxWallet = totalSupply * 20 / 1000; // 2% maxwallet\\r\\n        swapTokensAtAmount = totalSupply * 5 / 10000; // 0.05% swap wallet \\r\\n \\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyDevFee = _buyDevFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellDevFee = _sellDevFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n \\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n \\r\\n        marketingWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // marketingwallet\\r\\n        devWallet = address(0x7C0c91C1b2152E176bF6712a8eE32472383671B8); // devwallet\\r\\n \\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n \\r\\n        /*\\r\\n            _mint is an internal function in ERC20.sol that is only called here,\\r\\n            and CANNOT be called ever again\\r\\n        */\\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n \\r\\n    receive() external payable {\\r\\n \\r\\n  \\t}\\r\\n \\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        launchedAt = block.number;\\r\\n    }\\r\\n \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function setEarlySellTax(bool onoff) external onlyOwner  {\\r\\n        enableEarlySellTax = onoff;\\r\\n    }\\r\\n \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n  \\t    require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n  \\t    require(newAmount <= totalSupply() * 5 / 1000, \\\"Swap amount cannot be higher than 0.5% total supply.\\\");\\r\\n  \\t    swapTokensAtAmount = newAmount;\\r\\n  \\t    return true;\\r\\n  \\t}\\r\\n \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.5%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 15 / 1000)/1e18, \\\"Cannot set maxWallet lower than 1.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyDevFee = _devFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyDevFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _devFee, uint256 _earlySellLiquidityFee, uint256 _earlySellMarketingFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellDevFee = _devFee;\\r\\n        earlySellLiquidityFee = _earlySellLiquidityFee;\\r\\n        earlySellMarketingFee = _earlySellMarketingFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellDevFee;\\r\\n        require(sellTotalFees <= 99, \\\"Must keep fees at 99% or less\\\");\\r\\n    }\\r\\n \\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n \\r\\n    function blacklistAccount (address account, bool isBlacklisted) public onlyOwner {\\r\\n        _blacklist[account] = isBlacklisted;\\r\\n    }\\r\\n \\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n \\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n \\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n \\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n \\r\\n    function updateDevWallet(address newWallet) external onlyOwner {\\r\\n        emit devWalletUpdated(newWallet, devWallet);\\r\\n        devWallet = newWallet;\\r\\n    }\\r\\n \\r\\n \\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n \\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(!_blacklist[to] && !_blacklist[from], \\\"You have been blacklisted from transfering tokens\\\");\\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n \\r\\n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n \\r\\n        // anti bot logic\\r\\n        if (block.number <= (launchedAt + 0) && \\r\\n                to != uniswapV2Pair && \\r\\n                to != address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\r\\n            ) { \\r\\n            _blacklist[to] = false;\\r\\n        }\\r\\n \\r\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\r\\n \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n \\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n \\r\\n            swapBack();\\r\\n \\r\\n            swapping = false;\\r\\n        }\\r\\n \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n \\r\\n        bool takeFee = !swapping;\\r\\n \\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n \\r\\n        uint256 fees = 0;\\r\\n        // only take fees on buys/sells, do not take on wallet transfers\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForDev += fees * sellDevFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n        \\t    fees = amount.mul(buyTotalFees).div(100);\\r\\n        \\t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForDev += fees * buyDevFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n \\r\\n        \\tamount -= fees;\\r\\n        }\\r\\n \\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n \\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n \\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n \\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n \\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n \\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n \\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForDev;\\r\\n        bool success;\\r\\n \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n \\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n \\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n \\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForDev = ethBalance.mul(tokensForDev).div(totalTokensToSwap);\\r\\n \\r\\n \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\\r\\n \\r\\n \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForDev = 0;\\r\\n \\r\\n        (success,) = address(devWallet).call{value: ethForDev}(\\\"\\\");\\r\\n \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n \\r\\n \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n \\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n \\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n \\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n \\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n \\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n}\"",
                "pattern": "function\\s+removeLiquidity.*onlyOwner"
              }
            ]
          }
        }
      }
    },
    "holder": {
      "total_holders": 200,
      "holders_list": {
        "0x000000000000000000000000000000000000dead": {
          "balance": 321844552.6346294,
          "percentage_of_total_supply": 32.184455263462944,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb961e90b10608cff90a76557a2e02e007fe2b062": {
          "balance": 48416834.09556618,
          "percentage_of_total_supply": 4.841683409556619,
          "percentage_of_circulating_supply": 0.0
        },
        "0x053c0607eb31a4d31fa8c18381e91dbefaf52b25": {
          "balance": 42502544.014993675,
          "percentage_of_total_supply": 4.250254401499368,
          "percentage_of_circulating_supply": 0.0
        },
        "0x702c22d9aa9e22bacdb0e39517af899b53115282": {
          "balance": 30365442.47588438,
          "percentage_of_total_supply": 3.036544247588438,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0dc52981bb71ff739b4793e5ca559a158be82db5": {
          "balance": 28399999.999999996,
          "percentage_of_total_supply": 2.84,
          "percentage_of_circulating_supply": 0.0
        },
        "0x42248e7862a9fd2e97901b9526f2a5cd28ebcdb3": {
          "balance": 27217736.504330594,
          "percentage_of_total_supply": 2.721773650433059,
          "percentage_of_circulating_supply": 0.0
        },
        "0x214c104d27fe86f263b143a2a50a5a7b7cd4af08": {
          "balance": 23638285.344552897,
          "percentage_of_total_supply": 2.3638285344552896,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbfada08faf2045ee523c54d15b2372f82f82c71e": {
          "balance": 20474705.29875688,
          "percentage_of_total_supply": 2.0474705298756875,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa697fc50875cc03ede051843f210d78190a9e49b": {
          "balance": 19680851.722802997,
          "percentage_of_total_supply": 1.9680851722802997,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3f7adca4a78d7503cd3ddb9775182bb5c5f803cb": {
          "balance": 18181366.666861184,
          "percentage_of_total_supply": 1.8181366666861185,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1d6182ebf6e25e6973c0ddfd9fdd45f667f0ff5b": {
          "balance": 16698982.672544962,
          "percentage_of_total_supply": 1.6698982672544962,
          "percentage_of_circulating_supply": 0.0
        },
        "0xe59350800a422d8c4b3a370b0c1453beceddef78": {
          "balance": 13552869.191073593,
          "percentage_of_total_supply": 1.3552869191073593,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5fbaf696402178c16fc826f0c95561992f4939ef": {
          "balance": 11177037.521225221,
          "percentage_of_total_supply": 1.1177037521225222,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd1f4212f1d61878156d21e8e9ae0e1f1fb0fd79c": {
          "balance": 11121186.655355982,
          "percentage_of_total_supply": 1.1121186655355983,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6e85767661498e8ca5d821d49cc815d6309ea9d1": {
          "balance": 10721417.945765728,
          "percentage_of_total_supply": 1.0721417945765728,
          "percentage_of_circulating_supply": 0.0
        },
        "0x083af9e1caa86aeba822edc948b32ffbd6b058ce": {
          "balance": 10135352.524292426,
          "percentage_of_total_supply": 1.0135352524292425,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd50df0a9af41d4e85a9ae51cca3922c98a3a8f90": {
          "balance": 8996420.76827368,
          "percentage_of_total_supply": 0.8996420768273681,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb93c36b91819aab37697d68d2ce55db4dc22476b": {
          "balance": 8120552.0477503305,
          "percentage_of_total_supply": 0.8120552047750331,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6a362ba8154f97c09ce9b03fd27fd0d3427d1ddb": {
          "balance": 8007476.924075497,
          "percentage_of_total_supply": 0.8007476924075498,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6fe2c2305375edffac9ea97dcd1579b25cad87b0": {
          "balance": 7927651.231364593,
          "percentage_of_total_supply": 0.7927651231364593,
          "percentage_of_circulating_supply": 0.0
        },
        "0xea9bf86f80b27d11b0a790660ce16885484e0007": {
          "balance": 7246643.754904064,
          "percentage_of_total_supply": 0.7246643754904064,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc87560a92dfcdabf183303d4e2636ec69132c0aa": {
          "balance": 7000000.0,
          "percentage_of_total_supply": 0.7000000000000001,
          "percentage_of_circulating_supply": 0.0
        },
        "0x190417184a9a19386c29022399d6b291fac6c92d": {
          "balance": 6699003.52987298,
          "percentage_of_total_supply": 0.6699003529872979,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9c40d4d7170832e79d1f1d268a700afe961ea1f0": {
          "balance": 6319569.350516536,
          "percentage_of_total_supply": 0.6319569350516536,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6695ec87b30aa2b098caecb8a80a80a89735028e": {
          "balance": 6312863.399395857,
          "percentage_of_total_supply": 0.6312863399395857,
          "percentage_of_circulating_supply": 0.0
        },
        "0x41c8efc8de9f68689043c567d212f23f578e3bbf": {
          "balance": 6007574.728330083,
          "percentage_of_total_supply": 0.6007574728330083,
          "percentage_of_circulating_supply": 0.0
        },
        "0x469e3408af880aa3df2a17d880c4137d37d8a333": {
          "balance": 5123351.234242564,
          "percentage_of_total_supply": 0.5123351234242564,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6225a9587f3a992cbb48921ff858320dabde159b": {
          "balance": 5093590.190705603,
          "percentage_of_total_supply": 0.5093590190705602,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0f2c9546f14dc7987c966a0b4aae168105ba34db": {
          "balance": 5000000.000051184,
          "percentage_of_total_supply": 0.5000000000051184,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3621455aa51711c555fd07d56796396021371949": {
          "balance": 4943274.0,
          "percentage_of_total_supply": 0.49432740000000003,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa8260aa3cebf3bbab4b3aac0043c845b777ed1bb": {
          "balance": 4770874.337967141,
          "percentage_of_total_supply": 0.4770874337967141,
          "percentage_of_circulating_supply": 0.0
        },
        "0x46907be2f347a3d08a7e484c5b6a7fe13089cb20": {
          "balance": 4548643.830150427,
          "percentage_of_total_supply": 0.45486438301504273,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd533584386ade37d29db077e6c173b99ea42051b": {
          "balance": 4336748.4161295565,
          "percentage_of_total_supply": 0.43367484161295566,
          "percentage_of_circulating_supply": 0.0
        },
        "0x10cc182e808f31234e54a0c9f7f7652801b8e91e": {
          "balance": 4237819.823132337,
          "percentage_of_total_supply": 0.4237819823132337,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0b8f4c4e7626a91460dac057eb43e0de59d5b44f": {
          "balance": 4000000.0,
          "percentage_of_total_supply": 0.4,
          "percentage_of_circulating_supply": 0.0
        },
        "0x4429b2b6e8515aaefc1a7e1889c3377072952e87": {
          "balance": 3978913.244507459,
          "percentage_of_total_supply": 0.39789132445074593,
          "percentage_of_circulating_supply": 0.0
        },
        "0x983edb2c9a31c2549fb8d8b33b5724a85ae99423": {
          "balance": 3953272.0464091017,
          "percentage_of_total_supply": 0.39532720464091015,
          "percentage_of_circulating_supply": 0.0
        },
        "0x2942324574827d139bc0b79e586ef79f99c2fc49": {
          "balance": 3755284.2612253465,
          "percentage_of_total_supply": 0.3755284261225347,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5741359bbc889a768d54d2f97a6cb18dee1ec341": {
          "balance": 3724055.6483545066,
          "percentage_of_total_supply": 0.3724055648354506,
          "percentage_of_circulating_supply": 0.0
        },
        "0x88c79c261d16b9f0180669f46796cd6cfa93f1f9": {
          "balance": 3550048.9050116176,
          "percentage_of_total_supply": 0.35500489050116174,
          "percentage_of_circulating_supply": 0.0
        },
        "0xfa8513e68d9bdd8f95ea16617cca252118c9c8f8": {
          "balance": 3119992.5444863243,
          "percentage_of_total_supply": 0.3119992544486324,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc646a7e48fe39cf57df5e6c0cf5239e230ddb1b5": {
          "balance": 3000000.0011104285,
          "percentage_of_total_supply": 0.30000000011104283,
          "percentage_of_circulating_supply": 0.0
        },
        "0xcc8d0af68cc3a6653aebbc08728cdad3de055255": {
          "balance": 3000000.0000008605,
          "percentage_of_total_supply": 0.30000000000008603,
          "percentage_of_circulating_supply": 0.0
        },
        "0x94c34584fbbef9243c46f19c6fe595fca47f538f": {
          "balance": 2998890.539238557,
          "percentage_of_total_supply": 0.2998890539238558,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5dffd11a812579440ff07cf84310ce80f31320cc": {
          "balance": 2973005.581745504,
          "percentage_of_total_supply": 0.29730055817455037,
          "percentage_of_circulating_supply": 0.0
        },
        "0x731148da916a64aab956444e5bd1cc9abf624c5e": {
          "balance": 2937185.6236875546,
          "percentage_of_total_supply": 0.2937185623687555,
          "percentage_of_circulating_supply": 0.0
        },
        "0x4c54b6895cf279c7d68c90e53a4d722e8c030d6d": {
          "balance": 2714984.5107931197,
          "percentage_of_total_supply": 0.2714984510793119,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd2464ff2a494c4d7fc871f6a4cbd41703341c5a1": {
          "balance": 2620764.7856955547,
          "percentage_of_total_supply": 0.2620764785695555,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd87d755a9f3df5d9fd55de38e06bbca24cf89a8f": {
          "balance": 2542826.2834879654,
          "percentage_of_total_supply": 0.2542826283487965,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5cdc12e520e12f74cac8ad71da0015c6fd805d36": {
          "balance": 2499391.814125671,
          "percentage_of_total_supply": 0.2499391814125671,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa9186483623e7aba81267ef3cf634eeb14934b17": {
          "balance": 2382480.0777583136,
          "percentage_of_total_supply": 0.23824800777583136,
          "percentage_of_circulating_supply": 0.0
        },
        "0x56261e415992c605c0d8d0cf93eedf252adec33d": {
          "balance": 2352792.1929932083,
          "percentage_of_total_supply": 0.23527921929932086,
          "percentage_of_circulating_supply": 0.0
        },
        "0x31a96efa6933b0c565306f11b2df594d75400eec": {
          "balance": 2247628.365861571,
          "percentage_of_total_supply": 0.2247628365861571,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc759d7e6ee79e0f9075fbfd43b7d08242799b6f8": {
          "balance": 2172611.007582211,
          "percentage_of_total_supply": 0.2172611007582211,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb35911548d34935db0d72978228a560490d4e305": {
          "balance": 2168898.838527347,
          "percentage_of_total_supply": 0.21688988385273467,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc359c63cb32e70a8afba9ec3c92abadbc0c43683": {
          "balance": 1991310.329751471,
          "percentage_of_total_supply": 0.1991310329751471,
          "percentage_of_circulating_supply": 0.0
        },
        "0x906fb788a41566bdc713eb346ca7d8bb634ccbb7": {
          "balance": 1964585.8449539514,
          "percentage_of_total_supply": 0.19645858449539513,
          "percentage_of_circulating_supply": 0.0
        },
        "0xdbdb692ef06dfe10f609a9c0eab4b038d60b4243": {
          "balance": 1881316.799313724,
          "percentage_of_total_supply": 0.1881316799313724,
          "percentage_of_circulating_supply": 0.0
        },
        "0xfa960e267507534bca857a2bdac2214ce3cc7373": {
          "balance": 1876640.0,
          "percentage_of_total_supply": 0.187664,
          "percentage_of_circulating_supply": 0.0
        },
        "0x693a0cbd3414a6ce6ebf7f936b32fda3e8b62cbc": {
          "balance": 1863538.7726104725,
          "percentage_of_total_supply": 0.18635387726104724,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1c33e5fcc502337b8120500ea030687f3d33fe13": {
          "balance": 1860166.9516933742,
          "percentage_of_total_supply": 0.18601669516933741,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9897376e0b0c3d8d6f27137f93b33e36ae6f0f45": {
          "balance": 1827888.5841367345,
          "percentage_of_total_supply": 0.18278885841367343,
          "percentage_of_circulating_supply": 0.0
        },
        "0x38336679adfc5205290317fcf8fff00e20287377": {
          "balance": 1793327.0906757957,
          "percentage_of_total_supply": 0.17933270906757956,
          "percentage_of_circulating_supply": 0.0
        },
        "0x20cc7a1a1e5630b5a962aa9acfa2f354c4e43e18": {
          "balance": 1749261.1773615875,
          "percentage_of_total_supply": 0.17492611773615876,
          "percentage_of_circulating_supply": 0.0
        },
        "0x13681c02acf56508f055dd4384c21f7b2fa936fa": {
          "balance": 1662931.9886038257,
          "percentage_of_total_supply": 0.16629319886038257,
          "percentage_of_circulating_supply": 0.0
        },
        "0x04d699f525c69a8709548007e4d37aab3a2826fb": {
          "balance": 1622791.5580512842,
          "percentage_of_total_supply": 0.16227915580512842,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd8e817d6fb57f4dfc7771d6e9d15e74a3069fb40": {
          "balance": 1605402.2145349067,
          "percentage_of_total_supply": 0.16054022145349067,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd861c7578f26d3c04bf06cb645f58cf6e927de48": {
          "balance": 1598445.0,
          "percentage_of_total_supply": 0.1598445,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6caa3d60eea5b61394152609d5978b5f4f63d1b5": {
          "balance": 1578700.1020123507,
          "percentage_of_total_supply": 0.15787001020123506,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0ee01fd0bdb6b449cf343ecafa7116be49b5286a": {
          "balance": 1556333.5345547206,
          "percentage_of_total_supply": 0.15563335345547205,
          "percentage_of_circulating_supply": 0.0
        },
        "0xee650f5599bd48f27b29b254a4c45322a755c6b4": {
          "balance": 1556193.0735475505,
          "percentage_of_total_supply": 0.15561930735475507,
          "percentage_of_circulating_supply": 0.0
        },
        "0x433ed1d2ae9d2974b9515774818d0c45df3aa81b": {
          "balance": 1543528.3357398685,
          "percentage_of_total_supply": 0.15435283357398683,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf2a2cdc1b60736e7d3e71c6c52c5adde71b63d58": {
          "balance": 1532946.178141094,
          "percentage_of_total_supply": 0.1532946178141094,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa4253330ff8ca7f55e835977401858d1a47cf1e4": {
          "balance": 1515276.3475890148,
          "percentage_of_total_supply": 0.15152763475890146,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6d0197e6e67c82c32e3c94bd3d7bab78b05d4ac1": {
          "balance": 1507597.5963640949,
          "percentage_of_total_supply": 0.1507597596364095,
          "percentage_of_circulating_supply": 0.0
        },
        "0xfd3a2baacf0566957dd8509c2f7347707f7c22b1": {
          "balance": 1500000.6976379522,
          "percentage_of_total_supply": 0.1500000697637952,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0f87d6c83066a530163eec821e499791324ce4a9": {
          "balance": 1460672.100093229,
          "percentage_of_total_supply": 0.1460672100093229,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb365fbd2402421daf7d513ca508fe3c843f73d56": {
          "balance": 1454314.21735678,
          "percentage_of_total_supply": 0.14543142173567802,
          "percentage_of_circulating_supply": 0.0
        },
        "0x596a0e578b1af28c0be36c375bc90ff7c20a049c": {
          "balance": 1436923.027574907,
          "percentage_of_total_supply": 0.1436923027574907,
          "percentage_of_circulating_supply": 0.0
        },
        "0xcdbf367d8b6fbb8195aeeaf6c6f57a5b39ce2b44": {
          "balance": 1434204.6922869114,
          "percentage_of_total_supply": 0.14342046922869114,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5e54d9059ca249e8b0d8c677fba40291e650a16e": {
          "balance": 1390032.7894324567,
          "percentage_of_total_supply": 0.13900327894324568,
          "percentage_of_circulating_supply": 0.0
        },
        "0x565a640f19a039339874d58eec3b622cbe137dd7": {
          "balance": 1349515.6137087569,
          "percentage_of_total_supply": 0.1349515613708757,
          "percentage_of_circulating_supply": 0.0
        },
        "0xff64531f6ca6e35332ddfb03ba1fffdc0e88c585": {
          "balance": 1321787.9452615816,
          "percentage_of_total_supply": 0.13217879452615816,
          "percentage_of_circulating_supply": 0.0
        },
        "0xeee4cd5e66de82350e6c346307f8383588ffb229": {
          "balance": 1243114.9136703203,
          "percentage_of_total_supply": 0.12431149136703203,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3991e557b5aac54df29ba5b79396a823ac5f3968": {
          "balance": 1190936.6030191006,
          "percentage_of_total_supply": 0.11909366030191007,
          "percentage_of_circulating_supply": 0.0
        },
        "0x34d5e2077acc2230feb84160a5ed582802e92be0": {
          "balance": 1119220.083964931,
          "percentage_of_total_supply": 0.1119220083964931,
          "percentage_of_circulating_supply": 0.0
        },
        "0x530c4d2e3d9eaab672f918384a093c314d914f29": {
          "balance": 1118247.2995280765,
          "percentage_of_total_supply": 0.11182472995280765,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd733a16f6a6a54a56ffd923bb7231acdc2ea689b": {
          "balance": 1098938.760263797,
          "percentage_of_total_supply": 0.10989387602637968,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd6316745bc2bc559d25e9c5a75fad910f67fdb10": {
          "balance": 1001049.3266649871,
          "percentage_of_total_supply": 0.10010493266649871,
          "percentage_of_circulating_supply": 0.0
        },
        "0x613bfb439fc7f633a0428c281779ed23d9e9a999": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.0
        },
        "0x196f239229aae65883802b5bb512e17084147ff6": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd0d26f0a5dd7dc0acc60334ea99136b444a11477": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.0
        },
        "0x17b04922699770e734170a00340466656729a0e0": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7c95ac0f0eeae5d8f15495e0401d799b3f9e61f8": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd6ee39b6aab45f9c6186cd8409a06446f1b760eb": {
          "balance": 951165.7172916061,
          "percentage_of_total_supply": 0.09511657172916062,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf13dfd20f6017a85b51e80551fd161c970b36599": {
          "balance": 925859.5759182905,
          "percentage_of_total_supply": 0.09258595759182905,
          "percentage_of_circulating_supply": 0.0
        },
        "0xe8f8c470546254c7116aa0d7ccad1bb30d0c951c": {
          "balance": 895077.110603416,
          "percentage_of_total_supply": 0.0895077110603416,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa6912731e019f7a19447e40bf4270676fc76c5c2": {
          "balance": 893460.9191761654,
          "percentage_of_total_supply": 0.08934609191761653,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf8e8ded9e5d10f4144d32aa33d87d2879a6e6f25": {
          "balance": 874263.6778062112,
          "percentage_of_total_supply": 0.08742636778062111,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9008d19f58aabd9ed0d60971565aa8510560ab41": {
          "balance": 866016.1516616544,
          "percentage_of_total_supply": 0.08660161516616544,
          "percentage_of_circulating_supply": 0.0
        },
        "0x992a2fcd1e096a18ed1a125c5c31069ccf21b7d3": {
          "balance": 865997.8230236016,
          "percentage_of_total_supply": 0.08659978230236016,
          "percentage_of_circulating_supply": 0.0
        },
        "0xdccc3b7a3514955e43e7815abe103c44c5a3746c": {
          "balance": 856991.0320887133,
          "percentage_of_total_supply": 0.08569910320887134,
          "percentage_of_circulating_supply": 0.0
        },
        "0x75c14a8e0a95a6f1d8f07ee146be0e9d27821626": {
          "balance": 851721.1281368778,
          "percentage_of_total_supply": 0.08517211281368778,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf3d756a3431182ee75e9e41652e21da76f2d97e0": {
          "balance": 836059.6390691494,
          "percentage_of_total_supply": 0.08360596390691494,
          "percentage_of_circulating_supply": 0.0
        },
        "0x17cc6042605381c158d2adab487434bde79aa61c": {
          "balance": 834176.1531445502,
          "percentage_of_total_supply": 0.08341761531445502,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6f66ca1988c3b264ea602ccec60b75c8e5ed97db": {
          "balance": 815384.338705582,
          "percentage_of_total_supply": 0.0815384338705582,
          "percentage_of_circulating_supply": 0.0
        },
        "0x8e79e45c9e008b430aff86f7121b122f9ad27aff": {
          "balance": 813621.2706863751,
          "percentage_of_total_supply": 0.0813621270686375,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa522048f3084d25cddb5b7bba83374272322eb61": {
          "balance": 809974.7802049142,
          "percentage_of_total_supply": 0.08099747802049143,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7926d95b5cd3b6215c260a4c529261b2dabfe5d6": {
          "balance": 744782.4580486553,
          "percentage_of_total_supply": 0.07447824580486552,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7a253d6c5c5d16ccff201edc31cee93b60a25bca": {
          "balance": 734175.7366091368,
          "percentage_of_total_supply": 0.07341757366091368,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3fc6b4da60e16bc4588f51ae53e48e766c9a62fe": {
          "balance": 725711.721697646,
          "percentage_of_total_supply": 0.0725711721697646,
          "percentage_of_circulating_supply": 0.0
        },
        "0xeca7641d54b1ec522603bfa5cdd84ccdbd57ea26": {
          "balance": 702533.7954479639,
          "percentage_of_total_supply": 0.0702533795447964,
          "percentage_of_circulating_supply": 0.0
        },
        "0x4ef2e45e7dc955522c4f273ff47ad1bf69b4969a": {
          "balance": 688446.5244598918,
          "percentage_of_total_supply": 0.06884465244598918,
          "percentage_of_circulating_supply": 0.0
        },
        "0xac07086d73fb07a8188daf191aad1e8f2ba2a0e0": {
          "balance": 686832.2468692143,
          "percentage_of_total_supply": 0.06868322468692144,
          "percentage_of_circulating_supply": 0.0
        },
        "0x81b5c412fba096e583f2272675fef92864dcdab7": {
          "balance": 683308.2502288072,
          "percentage_of_total_supply": 0.06833082502288072,
          "percentage_of_circulating_supply": 0.0
        },
        "0xe0738b71e17e8cdca296b293aa976cfc687e40e7": {
          "balance": 674820.0199806443,
          "percentage_of_total_supply": 0.06748200199806444,
          "percentage_of_circulating_supply": 0.0
        },
        "0xcbfefaafacf7822458250c19755401edb1875710": {
          "balance": 670000.0,
          "percentage_of_total_supply": 0.067,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5bd1f8538e7421d076ea16c0cabf0e5889f130cb": {
          "balance": 665555.2427732999,
          "percentage_of_total_supply": 0.06655552427733,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7e3243acb0ecc4ebce94a8f6d27cdbad43687ee9": {
          "balance": 661816.0491607585,
          "percentage_of_total_supply": 0.06618160491607586,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbcb37dc9c4ee83b3881e7bcfe4014bd450180481": {
          "balance": 651844.0776405424,
          "percentage_of_total_supply": 0.06518440776405425,
          "percentage_of_circulating_supply": 0.0
        },
        "0x4b8d760760ca80c1ec9c4f6f477fbe7e1e1d28fa": {
          "balance": 634569.8348434987,
          "percentage_of_total_supply": 0.06345698348434986,
          "percentage_of_circulating_supply": 0.0
        },
        "0x120a94949b627db6891c937d5f21a14f5d3b24c3": {
          "balance": 609053.9125301488,
          "percentage_of_total_supply": 0.06090539125301488,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf88ec8634909875a662a1416981ce16b6c8f3b22": {
          "balance": 604093.0831395925,
          "percentage_of_total_supply": 0.060409308313959256,
          "percentage_of_circulating_supply": 0.0
        },
        "0x64ccf050e7ea299c7cfd7c5d3eaf24ea1a2a12e8": {
          "balance": 602604.9500889246,
          "percentage_of_total_supply": 0.06026049500889247,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf9b205640ab5a45762b3e3a2a29ce0b56d941533": {
          "balance": 602480.9524288636,
          "percentage_of_total_supply": 0.06024809524288636,
          "percentage_of_circulating_supply": 0.0
        },
        "0x8e802e1d2f741bec7b48465ac7350832df90ad37": {
          "balance": 600000.0,
          "percentage_of_total_supply": 0.060000000000000005,
          "percentage_of_circulating_supply": 0.0
        },
        "0x65c839438d85a9d049d4d25a69a691584105c628": {
          "balance": 588752.9778347628,
          "percentage_of_total_supply": 0.05887529778347627,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd88809018c63ab48c284342e24c11805d4870d43": {
          "balance": 581595.8916349991,
          "percentage_of_total_supply": 0.058159589163499906,
          "percentage_of_circulating_supply": 0.0
        },
        "0x91f13e1add46ea92f63a5a792c46ca8f386744c8": {
          "balance": 563103.6505148512,
          "percentage_of_total_supply": 0.05631036505148512,
          "percentage_of_circulating_supply": 0.0
        },
        "0xa2e2bedab7f33b56cc7fbefa051fde247a3d006a": {
          "balance": 560878.5598577887,
          "percentage_of_total_supply": 0.056087855985778874,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc105089a64e8ea79cb72501457b5deeb09601875": {
          "balance": 546039.9265182588,
          "percentage_of_total_supply": 0.054603992651825875,
          "percentage_of_circulating_supply": 0.0
        },
        "0x036d4ff96c8db158c145b40d3f29bf094d787f71": {
          "balance": 536356.2620264516,
          "percentage_of_total_supply": 0.05363562620264516,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc8c184d2c8f1f18a590822e5652470c905a7a8ef": {
          "balance": 528776.4504096683,
          "percentage_of_total_supply": 0.05287764504096682,
          "percentage_of_circulating_supply": 0.0
        },
        "0xc6080b39f80c9a3b53ce821ce3311983fae754ba": {
          "balance": 518517.4930557797,
          "percentage_of_total_supply": 0.05185174930557797,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1aebe47a7e5cc93fa1ebc143c8521777d2b3e72c": {
          "balance": 518307.6647543755,
          "percentage_of_total_supply": 0.05183076647543755,
          "percentage_of_circulating_supply": 0.0
        },
        "0xaa341f250e45cacbb13266032d521351604fc936": {
          "balance": 517408.0684634564,
          "percentage_of_total_supply": 0.05174080684634564,
          "percentage_of_circulating_supply": 0.0
        },
        "0xae93dfe67e8ac40c919fb95626764993771975f8": {
          "balance": 515092.86943587824,
          "percentage_of_total_supply": 0.05150928694358782,
          "percentage_of_circulating_supply": 0.0
        },
        "0x90bf5a0615c98a7936455d5675258274daacbfac": {
          "balance": 507680.6214805065,
          "percentage_of_total_supply": 0.050768062148050644,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf9c04682c96be1765c9d49c4a29f8053cb054b26": {
          "balance": 504507.497971341,
          "percentage_of_total_supply": 0.0504507497971341,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9b958d4bf8e386d2e807927c36d2073608ba95b5": {
          "balance": 500000.0,
          "percentage_of_total_supply": 0.05,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf01228f5833871f1671d67e6298162ddbb917d08": {
          "balance": 495395.57148975,
          "percentage_of_total_supply": 0.049539557148975,
          "percentage_of_circulating_supply": 0.0
        },
        "0x04e798677c0d61f46a1ddcdfbc1a35c70bb6e436": {
          "balance": 487672.0860075008,
          "percentage_of_total_supply": 0.04876720860075009,
          "percentage_of_circulating_supply": 0.0
        },
        "0x16de7026b788f72668d098d39fd0cba8428abc1a": {
          "balance": 482524.6276872292,
          "percentage_of_total_supply": 0.04825246276872292,
          "percentage_of_circulating_supply": 0.0
        },
        "0x40d68c490bf7262ec40048099aec23535f734be2": {
          "balance": 476804.69635431614,
          "percentage_of_total_supply": 0.04768046963543161,
          "percentage_of_circulating_supply": 0.0
        },
        "0x30af61ed8a7b59e5376b78ddbdfc1cdfb8ccc391": {
          "balance": 475375.1999790924,
          "percentage_of_total_supply": 0.04753751999790924,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd9b8c0bd1ff0adfbbccb3d2bd1b93cea433996d6": {
          "balance": 470822.2241323256,
          "percentage_of_total_supply": 0.047082222413232566,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7e925b5f7bde501281d747a99467aabde57fec47": {
          "balance": 461972.988708294,
          "percentage_of_total_supply": 0.0461972988708294,
          "percentage_of_circulating_supply": 0.0
        },
        "0x69c666ebdad08cab4570efcca62003905977ce77": {
          "balance": 454025.9322923695,
          "percentage_of_total_supply": 0.04540259322923695,
          "percentage_of_circulating_supply": 0.0
        },
        "0x496182465b2bb36083043a77210836f421e61518": {
          "balance": 452043.66835737374,
          "percentage_of_total_supply": 0.04520436683573737,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1a36b4de48f9ce9cfb82e09e32666b4596f84660": {
          "balance": 450283.54898715555,
          "percentage_of_total_supply": 0.04502835489871555,
          "percentage_of_circulating_supply": 0.0
        },
        "0xdefb970ee6b38316938d84a02aeaaa92d5e59647": {
          "balance": 450000.0,
          "percentage_of_total_supply": 0.045,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbc6c3321aedb3ce478d84e1b2d97fd2b6debd426": {
          "balance": 442587.2407671856,
          "percentage_of_total_supply": 0.044258724076718554,
          "percentage_of_circulating_supply": 0.0
        },
        "0xac918a59442f7d569409c4da384b8eb439bf64e9": {
          "balance": 437001.6615149673,
          "percentage_of_total_supply": 0.04370016615149673,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbb1e24ca9e6e5e507a55343f48582c5120444f28": {
          "balance": 424576.9224213845,
          "percentage_of_total_supply": 0.042457692242138446,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9b277dea6145258189ae0d823783af3275310a08": {
          "balance": 422562.05079180637,
          "percentage_of_total_supply": 0.04225620507918063,
          "percentage_of_circulating_supply": 0.0
        },
        "0xcfb80bda6709f95bfd5bfdbe556dad1563fc61a3": {
          "balance": 420366.4175330386,
          "percentage_of_total_supply": 0.04203664175330386,
          "percentage_of_circulating_supply": 0.0
        },
        "0xd672e3a59d9a233d79694c8387a1cb9ba9bd7260": {
          "balance": 414659.5349492866,
          "percentage_of_total_supply": 0.04146595349492867,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb4dbcdf23fed983dacd4b296c9ef221f9a2cf55e": {
          "balance": 410262.6248621677,
          "percentage_of_total_supply": 0.04102626248621677,
          "percentage_of_circulating_supply": 0.0
        },
        "0x2a3b3ab29e88310f48739e77d008dbb0940c01a0": {
          "balance": 403638.882037639,
          "percentage_of_total_supply": 0.0403638882037639,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1c9aa05217a28bd5c84be3827d838df60e9e7b22": {
          "balance": 401457.50175830675,
          "percentage_of_total_supply": 0.04014575017583068,
          "percentage_of_circulating_supply": 0.0
        },
        "0x28521a5b7e439d3b0b8e13c5ca66de26cf6e756c": {
          "balance": 399999.99999999994,
          "percentage_of_total_supply": 0.039999999999999994,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6261ac1469e7ffecf1ca22dd16c0165a2c8c49c6": {
          "balance": 399999.99999999994,
          "percentage_of_total_supply": 0.039999999999999994,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1b7f730d97a1e5002cf43edc98a8d17e6146ec6d": {
          "balance": 399999.99999999994,
          "percentage_of_total_supply": 0.039999999999999994,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbc707853e763a267648152748202be7b657ceb66": {
          "balance": 394184.72923595423,
          "percentage_of_total_supply": 0.039418472923595425,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7faed9fddce286ab5e063225cf2b423e3e27f0f7": {
          "balance": 389168.6175039083,
          "percentage_of_total_supply": 0.03891686175039082,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3ee18b2214aff97000d974cf647e7c347e8fa585": {
          "balance": 378427.12223258003,
          "percentage_of_total_supply": 0.037842712223257996,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1b32da8873b9a8d18d2ef35809665bcb79f9bef1": {
          "balance": 375515.5263546042,
          "percentage_of_total_supply": 0.03755155263546042,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5497a74eea5ad3da839156caf8f7dd7180963bb4": {
          "balance": 375450.13200757996,
          "percentage_of_total_supply": 0.037545013200757996,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9be7152f5f0cd6959863f48ed28d0195fbdcd017": {
          "balance": 370026.35512885597,
          "percentage_of_total_supply": 0.037002635512885594,
          "percentage_of_circulating_supply": 0.0
        },
        "0x32f24a55224be5b38ed3e17ea5e3d512a6cee5d6": {
          "balance": 368503.7793434089,
          "percentage_of_total_supply": 0.036850377934340886,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6f5c78d67c59b1505d65e9b75ff2a4728bc913b4": {
          "balance": 363478.0,
          "percentage_of_total_supply": 0.0363478,
          "percentage_of_circulating_supply": 0.0
        },
        "0x5f2f7708b325f032df1a7631ca7b3e06eee21cab": {
          "balance": 360953.8962845337,
          "percentage_of_total_supply": 0.03609538962845337,
          "percentage_of_circulating_supply": 0.0
        },
        "0x1299b07218fee266fd18ecfc562f00f272e8dd79": {
          "balance": 359499.05869023927,
          "percentage_of_total_supply": 0.035949905869023926,
          "percentage_of_circulating_supply": 0.0
        },
        "0x96da08f56d907db502b6e8404552d45bd7b1985f": {
          "balance": 359245.52972070547,
          "percentage_of_total_supply": 0.03592455297207055,
          "percentage_of_circulating_supply": 0.0
        },
        "0x648e27900d0fff50adf6af9dfbabe688b93c6dd3": {
          "balance": 339064.5972616203,
          "percentage_of_total_supply": 0.033906459726162026,
          "percentage_of_circulating_supply": 0.0
        },
        "0xad3cfb7b479c54646ddefae0d89c599f8b28e0e4": {
          "balance": 335997.15747012047,
          "percentage_of_total_supply": 0.033599715747012045,
          "percentage_of_circulating_supply": 0.0
        },
        "0x3d61a4ef79afa653e740dbdf286cf17a26478838": {
          "balance": 334193.341841805,
          "percentage_of_total_supply": 0.0334193341841805,
          "percentage_of_circulating_supply": 0.0
        },
        "0x07382928e11fcb6821b89008fad8725cc8fc1246": {
          "balance": 329993.0895246395,
          "percentage_of_total_supply": 0.032999308952463946,
          "percentage_of_circulating_supply": 0.0
        },
        "0x7a63054863021e2c470af824ae36b3bd0781d513": {
          "balance": 328314.01601590106,
          "percentage_of_total_supply": 0.03283140160159011,
          "percentage_of_circulating_supply": 0.0
        },
        "0x8966cf43237a1f2c85a3a9eec15761b14f9c3b19": {
          "balance": 323221.78696245415,
          "percentage_of_total_supply": 0.032322178696245416,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb8a05a62345ddbfeaa2ea5864f1462b44c1156c0": {
          "balance": 321692.3624176463,
          "percentage_of_total_supply": 0.032169236241764626,
          "percentage_of_circulating_supply": 0.0
        },
        "0x0c1c089fe307c26b0850425a0162e09a8cfd7c43": {
          "balance": 316265.92800016154,
          "percentage_of_total_supply": 0.03162659280001616,
          "percentage_of_circulating_supply": 0.0
        },
        "0x316126f1ae657b3abf3a7ae3d3c8cf9bece579fe": {
          "balance": 311108.0,
          "percentage_of_total_supply": 0.031110800000000004,
          "percentage_of_circulating_supply": 0.0
        },
        "0x72081bda6adf4219193df0cdf3b62903ebdfe040": {
          "balance": 308801.09618836344,
          "percentage_of_total_supply": 0.030880109618836346,
          "percentage_of_circulating_supply": 0.0
        },
        "0x21a417f3b18891d5e515c46b0331425c33622100": {
          "balance": 307080.47523330076,
          "percentage_of_total_supply": 0.03070804752333008,
          "percentage_of_circulating_supply": 0.0
        },
        "0x91fcf0fbec3f619d840292cbd6374c81932a27d0": {
          "balance": 306331.26291535876,
          "percentage_of_total_supply": 0.03063312629153588,
          "percentage_of_circulating_supply": 0.0
        },
        "0x8b4068a0d54a5b98ebbfd221dc0415f656cb1a8d": {
          "balance": 303611.35837687965,
          "percentage_of_total_supply": 0.03036113583768797,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbd3d4c9ba2a7913e9a616c70cf48d9f33d24e6d7": {
          "balance": 300000.0,
          "percentage_of_total_supply": 0.030000000000000002,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbbd2f625f2ecf6b55dc9de8ec7b538e30c799ac6": {
          "balance": 295830.87968626904,
          "percentage_of_total_supply": 0.029583087968626905,
          "percentage_of_circulating_supply": 0.0
        },
        "0xbd3bfbf56283a6d22d2c137eec6916ea4de247d5": {
          "balance": 292692.6303494025,
          "percentage_of_total_supply": 0.02926926303494025,
          "percentage_of_circulating_supply": 0.0
        },
        "0x86d2f8852cc4d41ad2d0a2e33216050fb5e5fcd6": {
          "balance": 284228.0021188897,
          "percentage_of_total_supply": 0.028422800211888973,
          "percentage_of_circulating_supply": 0.0
        },
        "0xfc70624b6bb4db1b3e3d7d436e47a32906e614c5": {
          "balance": 284048.830462536,
          "percentage_of_total_supply": 0.028404883046253604,
          "percentage_of_circulating_supply": 0.0
        },
        "0xb6e3f9314691361058186a873bbc74d6ca59d44a": {
          "balance": 283317.8882123935,
          "percentage_of_total_supply": 0.02833178882123935,
          "percentage_of_circulating_supply": 0.0
        },
        "0x549bc2d24181adf7a372a21d212785ab33e4ab5b": {
          "balance": 277962.16773809417,
          "percentage_of_total_supply": 0.027796216773809418,
          "percentage_of_circulating_supply": 0.0
        },
        "0xacae657be25514516889dffa5417da9f725bbbc3": {
          "balance": 272916.5709733425,
          "percentage_of_total_supply": 0.027291657097334256,
          "percentage_of_circulating_supply": 0.0
        },
        "0x9c34c335fb8d5b2cebe582548dedab41941e6da6": {
          "balance": 272187.46492953855,
          "percentage_of_total_supply": 0.02721874649295385,
          "percentage_of_circulating_supply": 0.0
        },
        "0xaf2de8dae7d2a4567c639417b4d79db1e6739381": {
          "balance": 271528.24377578014,
          "percentage_of_total_supply": 0.02715282437757801,
          "percentage_of_circulating_supply": 0.0
        },
        "0xf0b0db37e6e0015360093ae564f7745549d8e635": {
          "balance": 267965.0267349027,
          "percentage_of_total_supply": 0.02679650267349027,
          "percentage_of_circulating_supply": 0.0
        },
        "0x06271869304d1333bb927031229b02c5833d5828": {
          "balance": 267747.18221373844,
          "percentage_of_total_supply": 0.026774718221373842,
          "percentage_of_circulating_supply": 0.0
        },
        "0x6f676e65580a1e6d604b890d5234c714ee8b165f": {
          "balance": 267643.88568807166,
          "percentage_of_total_supply": 0.02676438856880716,
          "percentage_of_circulating_supply": 0.0
        }
      },
      "total_supply": 1000000000.0,
      "total_circulating_supply": 0.0,
      "owner": {},
      "creator": {},
      "holders_exceeding_5_percent_circulating": [],
      "howmany_holders_exceeding_5_percent_circulating": 0,
      "top_10_holders": [
        {
          "address": "0x000000000000000000000000000000000000dead",
          "balance": 321844552.6346294,
          "percentage_of_total_supply": 32.184455263462944,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0xb961e90b10608cff90a76557a2e02e007fe2b062",
          "balance": 48416834.09556618,
          "percentage_of_total_supply": 4.841683409556619,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x053c0607eb31a4d31fa8c18381e91dbefaf52b25",
          "balance": 42502544.014993675,
          "percentage_of_total_supply": 4.250254401499368,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x702c22d9aa9e22bacdb0e39517af899b53115282",
          "balance": 30365442.47588438,
          "percentage_of_total_supply": 3.036544247588438,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x0dc52981bb71ff739b4793e5ca559a158be82db5",
          "balance": 28399999.999999996,
          "percentage_of_total_supply": 2.84,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x42248e7862a9fd2e97901b9526f2a5cd28ebcdb3",
          "balance": 27217736.504330594,
          "percentage_of_total_supply": 2.721773650433059,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x214c104d27fe86f263b143a2a50a5a7b7cd4af08",
          "balance": 23638285.344552897,
          "percentage_of_total_supply": 2.3638285344552896,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0xbfada08faf2045ee523c54d15b2372f82f82c71e",
          "balance": 20474705.29875688,
          "percentage_of_total_supply": 2.0474705298756875,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0xa697fc50875cc03ede051843f210d78190a9e49b",
          "balance": 19680851.722802997,
          "percentage_of_total_supply": 1.9680851722802997,
          "percentage_of_circulating_supply": 0.0
        },
        {
          "address": "0x3f7adca4a78d7503cd3ddb9775182bb5c5f803cb",
          "balance": 18181366.666861184,
          "percentage_of_total_supply": 1.8181366666861185,
          "percentage_of_circulating_supply": 0.0
        }
      ],
      "total_top_10_balance": 580722318.7583784,
      "top10_percentage_of_total_supply": 58.07223187583783,
      "top10_percentage_of_circulating_supply": 0.0,
      "top_10_less_than_70_percent_of_total": true,
      "top_10_less_than_70_percent_of_circulating": true
    },
    "liquidity": {
      "price_usd": 7.825e-05,
      "liquidity_usd": 30.13,
      "market_cap_usd": 0.0,
      "liquidity_to_market_cap_ratio": 0,
      "token_volume": 0.0,
      "volume_usd": 0.0,
      "volume_to_liquidity_ratio": 0.0,
      "locked_liquidity_percent": 72.58,
      "locked_95_for_15_days": false,
      "creator_under_5_percent": true,
      "creator_percent_of_lp": 0.0,
      "owner_under_5_percent": true,
      "owner_percent_of_lp": 0.0,
      "total_lp_supply": 39378.256476987175,
      "lp_holders_count": 6,
      "lp_holders": [
        {
          "address": "0x663a5c229c09b049e36dcc11a9b0d4a8eb9db214",
          "balance": 26627.7213972,
          "is_locked": true,
          "percent": 67.6203666171999,
          "tag": "UNCX"
        },
        {
          "address": "0xf13b56f471f198ce907690c7fea6067a92480659",
          "balance": 9939.652149429316,
          "is_locked": false,
          "percent": 25.241473439125194,
          "tag": ""
        },
        {
          "address": "0x000000000000000000000000000000000000dead",
          "balance": 1954.3347988661824,
          "is_locked": true,
          "percent": 4.962979506236656,
          "tag": ""
        },
        {
          "address": "0xd92ec2123473e0e4099733b1e03405384aa1024d",
          "balance": 793.069132260038,
          "is_locked": false,
          "percent": 2.0139772636290054,
          "tag": ""
        },
        {
          "address": "0xb1d248e9550ac090c9eb25098e27037b118a1de0",
          "balance": 63.47899923164168,
          "is_locked": false,
          "percent": 0.1612031738092291,
          "tag": ""
        },
        {
          "address": "0x0000000000000000000000000000000000000000",
          "balance": 1e-15,
          "is_locked": true,
          "percent": 0.0,
          "tag": "Null Address"
        }
      ],
      "error": "Liquidity pool info could not be retrieved."
    },
    "security": {
      "warnings": [],
      "homany_warnings": 0,
      "suspicious_urls": {
        "https://t.me/micportal\\r\\n//": "metamask recovery phrase phishing",
        "https://magicinternetcash.wtf\\r\\n//": "metamask recovery phrase phishing",
        "https://github.com/ethereum/solidity/issues/2691\\r\\n": "metamask recovery phrase phishing",
        "https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n": "metamask recovery phrase phishing",
        "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n": "metamask recovery phrase phishing"
      },
      "howmany_suspicious_urls": 5,
      "suspicious_addresses": {},
      "howmany_suspicious_addresses": 0,
      "howmany_warnings": 0
    },
    "lifecycle": {
      "token_age_seconds": 69515710.936652,
      "token_creation_date": "2023-06-15T22:02:23",
      "creation_to_first_trade_seconds": 0.0,
      "creation_to_first_trade_blocks": 0,
      "last_tx_hash": "0x29db5286426f2a1a2dd9f6e2ee9afd386e672351d8b71002174242887cf85bf2",
      "last_active_age": "2025-08-27T12:45:23",
      "inactive_days": 0.9668210265046296
    }
  },
  "errors": []
}