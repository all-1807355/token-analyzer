{
    "token_address": "0xf629cbd94d3791c9250152bd8dfbdf380e2a3b9c",
    "chain": "eth",
    "token_name": "Enjin Coin",
    "analyses": {
        "contract": {
            "contract_name": "ENJToken",
            "compiler_version": "v0.4.15+commit.bbb8e64f",
            "license_type": "",
            "implementation": "",
            "source_code": "pragma solidity ^0.4.15;\r\n/*\r\n    Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    function Utils() {\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string) { name; }\r\n    function symbol() public constant returns (string) { symbol; }\r\n    function decimals() public constant returns (uint8) { decimals; }\r\n    function totalSupply() public constant returns (uint256) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n    ERC20 Standard Token implementation\r\n*/\r\ncontract ERC20Token is IERC20Token, Utils {\r\n    string public standard = \"Token 0.1\";\r\n    string public name = \"\";\r\n    string public symbol = \"\";\r\n    uint8 public decimals = 0;\r\n    uint256 public totalSupply = 0;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n        @dev constructor\r\n\r\n        @param _name        token name\r\n        @param _symbol      token symbol\r\n        @param _decimals    decimal points, for display purposes\r\n    */\r\n    function ERC20Token(string _name, string _symbol, uint8 _decimals) {\r\n        require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value)\r\n        public\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, false if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        validAddress(_from)\r\n        validAddress(_to)\r\n        returns (bool success)\r\n    {\r\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\r\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\r\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\r\n        Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev allow another account/contract to spend some tokens on your behalf\r\n        throws on any error rather then return a false flag to minimize user errors\r\n\r\n        also, to minimize the risk of the approve/transferFrom attack vector\r\n        (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice\r\n        in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value\r\n\r\n        @param _spender approved address\r\n        @param _value   allowance amount\r\n\r\n        @return true if the approval was successful, false if it wasn't\r\n    */\r\n    function approve(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool success)\r\n    {\r\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\r\n        require(_value == 0 || allowance[msg.sender][_spender] == 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\n/*\r\n    Token Holder interface\r\n*/\r\ncontract ITokenHolder is IOwned {\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public;\r\n}\r\n\r\n/*\r\n    We consider every contract to be a 'token holder' since it's currently not possible\r\n    for a contract to deny receiving tokens.\r\n\r\n    The TokenHolder's contract sole purpose is to provide a safety mechanism that allows\r\n    the owner to send tokens that were sent to the contract by mistake back to their sender.\r\n*/\r\ncontract TokenHolder is ITokenHolder, Owned, Utils {\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function TokenHolder() {\r\n    }\r\n\r\n    /**\r\n        @dev withdraws tokens held by the contract and sends them to an account\r\n        can only be called by the owner\r\n\r\n        @param _token   ERC20 token contract address\r\n        @param _to      account to receive the new amount\r\n        @param _amount  amount to withdraw\r\n    */\r\n    function withdrawTokens(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n    }\r\n}\r\n\r\n\r\ncontract ENJToken is ERC20Token, TokenHolder {\r\n\r\n///////////////////////////////////////// VARIABLE INITIALIZATION /////////////////////////////////////////\r\n\r\n    uint256 constant public ENJ_UNIT = 10 ** 18;\r\n    uint256 public totalSupply = 1 * (10**9) * ENJ_UNIT;\r\n\r\n    //  Constants \r\n    uint256 constant public maxPresaleSupply = 600 * 10**6 * ENJ_UNIT;           // Total presale supply at max bonus\r\n    uint256 constant public minCrowdsaleAllocation = 200 * 10**6 * ENJ_UNIT;     // Min amount for crowdsale\r\n    uint256 constant public incentivisationAllocation = 100 * 10**6 * ENJ_UNIT;  // Incentivisation Allocation\r\n    uint256 constant public advisorsAllocation = 26 * 10**6 * ENJ_UNIT;          // Advisors Allocation\r\n    uint256 constant public enjinTeamAllocation = 74 * 10**6 * ENJ_UNIT;         // Enjin Team allocation\r\n\r\n    address public crowdFundAddress;                                             // Address of the crowdfund\r\n    address public advisorAddress;                                               // Enjin advisor's address\r\n    address public incentivisationFundAddress;                                   // Address that holds the incentivization funds\r\n    address public enjinTeamAddress;                                             // Enjin Team address\r\n\r\n    //  Variables\r\n\r\n    uint256 public totalAllocatedToAdvisors = 0;                                 // Counter to keep track of advisor token allocation\r\n    uint256 public totalAllocatedToTeam = 0;                                     // Counter to keep track of team token allocation\r\n    uint256 public totalAllocated = 0;                                           // Counter to keep track of overall token allocation\r\n    uint256 constant public endTime = 1509494340;                                // 10/31/2017 @ 11:59pm (UTC) crowdsale end time (in seconds)\r\n\r\n    bool internal isReleasedToPublic = false;                         // Flag to allow transfer/transferFrom before the end of the crowdfund\r\n\r\n    uint256 internal teamTranchesReleased = 0;                          // Track how many tranches (allocations of 12.5% team tokens) have been released\r\n    uint256 internal maxTeamTranches = 8;                               // The number of tranches allowed to the team until depleted\r\n\r\n///////////////////////////////////////// MODIFIERS /////////////////////////////////////////\r\n\r\n    // Enjin Team timelock    \r\n    modifier safeTimelock() {\r\n        require(now >= endTime + 6 * 4 weeks);\r\n        _;\r\n    }\r\n\r\n    // Advisor Team timelock    \r\n    modifier advisorTimelock() {\r\n        require(now >= endTime + 2 * 4 weeks);\r\n        _;\r\n    }\r\n\r\n    // Function only accessible by the Crowdfund contract\r\n    modifier crowdfundOnly() {\r\n        require(msg.sender == crowdFundAddress);\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////////////////// CONSTRUCTOR /////////////////////////////////////////\r\n\r\n    /**\r\n        @dev constructor\r\n        @param _crowdFundAddress   Crowdfund address\r\n        @param _advisorAddress     Advisor address\r\n    */\r\n    function ENJToken(address _crowdFundAddress, address _advisorAddress, address _incentivisationFundAddress, address _enjinTeamAddress)\r\n    ERC20Token(\"Enjin Coin\", \"ENJ\", 18)\r\n     {\r\n        crowdFundAddress = _crowdFundAddress;\r\n        advisorAddress = _advisorAddress;\r\n        enjinTeamAddress = _enjinTeamAddress;\r\n        incentivisationFundAddress = _incentivisationFundAddress;\r\n        balanceOf[_crowdFundAddress] = minCrowdsaleAllocation + maxPresaleSupply; // Total presale + crowdfund tokens\r\n        balanceOf[_incentivisationFundAddress] = incentivisationAllocation;       // 10% Allocated for Marketing and Incentivisation\r\n        totalAllocated += incentivisationAllocation;                              // Add to total Allocated funds\r\n    }\r\n\r\n///////////////////////////////////////// ERC20 OVERRIDE /////////////////////////////////////////\r\n\r\n    /**\r\n        @dev send coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        in addition to the standard checks, the function throws if transfers are disabled\r\n\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, throws if it wasn't\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (isTransferAllowed() == true || msg.sender == crowdFundAddress || msg.sender == incentivisationFundAddress) {\r\n            assert(super.transfer(_to, _value));\r\n            return true;\r\n        }\r\n        revert();        \r\n    }\r\n\r\n    /**\r\n        @dev an account/contract attempts to get the coins\r\n        throws on any error rather then return a false flag to minimize user errors\r\n        in addition to the standard checks, the function throws if transfers are disabled\r\n\r\n        @param _from    source address\r\n        @param _to      target address\r\n        @param _value   transfer amount\r\n\r\n        @return true if the transfer was successful, throws if it wasn't\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (isTransferAllowed() == true || msg.sender == crowdFundAddress || msg.sender == incentivisationFundAddress) {        \r\n            assert(super.transferFrom(_from, _to, _value));\r\n            return true;\r\n        }\r\n        revert();\r\n    }\r\n\r\n///////////////////////////////////////// ALLOCATION FUNCTIONS /////////////////////////////////////////\r\n\r\n    /**\r\n        @dev Release one single tranche of the Enjin Team Token allocation\r\n        throws if before timelock (6 months) ends and if not initiated by the owner of the contract\r\n        returns true if valid\r\n        Schedule goes as follows:\r\n        3 months: 12.5% (this tranche can only be released after the initial 6 months has passed)\r\n        6 months: 12.5%\r\n        9 months: 12.5%\r\n        12 months: 12.5%\r\n        15 months: 12.5%\r\n        18 months: 12.5%\r\n        21 months: 12.5%\r\n        24 months: 12.5%\r\n        @return true if successful, throws if not\r\n    */\r\n    function releaseEnjinTeamTokens() safeTimelock ownerOnly returns(bool success) {\r\n        require(totalAllocatedToTeam < enjinTeamAllocation);\r\n\r\n        uint256 enjinTeamAlloc = enjinTeamAllocation / 1000;\r\n        uint256 currentTranche = uint256(now - endTime) / 12 weeks;     // \"months\" after crowdsale end time (division floored)\r\n\r\n        if(teamTranchesReleased < maxTeamTranches && currentTranche > teamTranchesReleased) {\r\n            teamTranchesReleased++;\r\n\r\n            uint256 amount = safeMul(enjinTeamAlloc, 125);\r\n            balanceOf[enjinTeamAddress] = safeAdd(balanceOf[enjinTeamAddress], amount);\r\n            Transfer(0x0, enjinTeamAddress, amount);\r\n            totalAllocated = safeAdd(totalAllocated, amount);\r\n            totalAllocatedToTeam = safeAdd(totalAllocatedToTeam, amount);\r\n            return true;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /**\r\n        @dev release Advisors Token allocation\r\n        throws if before timelock (2 months) ends or if no initiated by the advisors address\r\n        or if there is no more allocation to give out\r\n        returns true if valid\r\n\r\n        @return true if successful, throws if not\r\n    */\r\n    function releaseAdvisorTokens() advisorTimelock ownerOnly returns(bool success) {\r\n        require(totalAllocatedToAdvisors == 0);\r\n        balanceOf[advisorAddress] = safeAdd(balanceOf[advisorAddress], advisorsAllocation);\r\n        totalAllocated = safeAdd(totalAllocated, advisorsAllocation);\r\n        totalAllocatedToAdvisors = advisorsAllocation;\r\n        Transfer(0x0, advisorAddress, advisorsAllocation);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev Retrieve unsold tokens from the crowdfund\r\n        throws if before timelock (6 months from end of Crowdfund) ends and if no initiated by the owner of the contract\r\n        returns true if valid\r\n\r\n        @return true if successful, throws if not\r\n    */\r\n    function retrieveUnsoldTokens() safeTimelock ownerOnly returns(bool success) {\r\n        uint256 amountOfTokens = balanceOf[crowdFundAddress];\r\n        balanceOf[crowdFundAddress] = 0;\r\n        balanceOf[incentivisationFundAddress] = safeAdd(balanceOf[incentivisationFundAddress], amountOfTokens);\r\n        totalAllocated = safeAdd(totalAllocated, amountOfTokens);\r\n        Transfer(crowdFundAddress, incentivisationFundAddress, amountOfTokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @dev Keep track of token allocations\r\n        can only be called by the crowdfund contract\r\n    */\r\n    function addToAllocation(uint256 _amount) crowdfundOnly {\r\n        totalAllocated = safeAdd(totalAllocated, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Function to allow transfers\r\n        can only be called by the owner of the contract\r\n        Transfers will be allowed regardless after the crowdfund end time.\r\n    */\r\n    function allowTransfers() ownerOnly {\r\n        isReleasedToPublic = true;\r\n    } \r\n\r\n    /**\r\n        @dev User transfers are allowed/rejected\r\n        Transfers are forbidden before the end of the crowdfund\r\n    */\r\n    function isTransferAllowed() internal constant returns(bool) {\r\n        if (now > endTime || isReleasedToPublic == true) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}",
            "abi": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseAdvisorTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxPresaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCrowdsaleAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enjinTeamAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retrieveUnsoldTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addToAllocation\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentivisationAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ENJ_UNIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentivisationFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseEnjinTeamTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAllocatedToAdvisors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enjinTeamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAllocatedToTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisorsAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_crowdFundAddress\",\"type\":\"address\"},{\"name\":\"_advisorAddress\",\"type\":\"address\"},{\"name\":\"_incentivisationFundAddress\",\"type\":\"address\"},{\"name\":\"_enjinTeamAddress\",\"type\":\"address\"}],\"payable\":false,\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]",
            "verified": true,
            "owner": "0xde63aef60307655405835da74ba02ce4db1a42fb",
            "creator": "0x4d70757e592c3ad3d276d59d2ee48548168f700f",
            "is_hidden_owner": false,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "ownership_renounced": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "is_honeypot_suspected": {
                    "found": true,
                    "snippets": [
                        "    function transfer(address _to, uint256 _value) public returns (bool success) {\n        if (istransferallowed() == true || msg.sender == crowdfundaddress || msg.sender == incentivisationfundaddress) {\n            assert(super.transfer(_to, _value));\n            return true;\n        }\n        revert();        \n    }",
                        "    function transferfrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (istransferallowed() == true || msg.sender == crowdfundaddress || msg.sender == incentivisationfundaddress) {        \n            assert(super.transferfrom(_from, _to, _value));\n            return true;\n        }\n        revert();\n    }",
                        "    function istransferallowed() internal constant returns(bool) {\n        if (now > endtime || isreleasedtopublic == true) {\n            return true;\n        }\n        return false;\n    }"
                    ],
                    "snippets_number": 3
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": true,
                    "snippets": [
                        "    function withdrawtokens(ierc20token _token, address _to, uint256 _amount) public;\n}",
                        "    function withdrawtokens(ierc20token _token, address _to, uint256 _amount)\n        public"
                    ],
                    "snippets_number": 2
                },
                "blacklist_or_whitelist_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 0,
            "holders_list": null,
            "total_circulating_supply": 0,
            "owner": null,
            "creator": null,
            "holders_exceeding_5_percent": null,
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": null,
            "total_top_10_balance": null,
            "top10_percentage_of_total_supply": null,
            "top10_percentage_of_circulating_supply": null,
            "top_10_less_than_70_percent_of_total": null,
            "top_10_less_than_70_percent_of_circulating": null
        },
        "liquidity": {
            "price_usd": null,
            "liquidity_usd": null,
            "market_cap_usd": null,
            "liquidity_to_market_cap_ratio": null,
            "token_volume": null,
            "volume_usd": null,
            "volume_to_liquidity_ratio": null,
            "locked_liquidity_percent": null,
            "locked_95_for_15_days": null,
            "creator_under_5_percent": null,
            "creator_percent_of_lp": null,
            "owner_under_5_percent": null,
            "owner_percent_of_lp": null,
            "total_lp_supply": null,
            "lp_holders_count": null,
            "lp_holders": null,
            "error": "Exception during liquidity analysis in liquidity_analysis: 'tuple' object has no attribute 'get'"
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/),": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 1,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 248526909.443052,
            "token_creation_date": "2017-10-02T03:02:07",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x1ad89dd24aa07587e4842389ee3a16ffcc091729af0a52798d3bd9f9099c00ef",
            "last_active_age": "2025-08-17T14:00:11",
            "inactive_days": 0.011897325532407408
        },
        "holders": {
            "error": "Exception during holder analysis in owner_circulating_supply_analysis: unsupported operand type(s) for /: 'int' and 'NoneType'"
        }
    },
    "errors": []
}