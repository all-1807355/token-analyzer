{
    "token_address": "0x6fce4a401b6b80ace52baaefe4421bd188e76f6f",
    "chain": "eth",
    "token_name": "Aave Interest bearing MANA",
    "analyses": {
        "contract": {
            "contract_name": "AToken",
            "compiler_version": "v0.5.14+commit.1f1aaa4",
            "license_type": "GNU GPLv3",
            "implementation": "",
            "source_code": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title WadRayMath library\r\n* @author Aave\r\n* @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n**/\r\n\r\nlibrary WadRayMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    /**\r\n    * @return one ray, 1e27\r\n    **/\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    /**\r\n    * @return one wad, 1e18\r\n    **/\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e27/2\r\n    **/\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    /**\r\n    * @return half ray, 1e18/2\r\n    **/\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a*b, in wad\r\n    **/\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfWAD.add(a.mul(b)).div(WAD);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two wad, rounding half up to the nearest wad\r\n    * @param a wad\r\n    * @param b wad\r\n    * @return the result of a/b, in wad\r\n    **/\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(WAD)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev multiplies two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a*b, in ray\r\n    **/\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return halfRAY.add(a.mul(b)).div(RAY);\r\n    }\r\n\r\n    /**\r\n    * @dev divides two ray, rounding half up to the nearest ray\r\n    * @param a ray\r\n    * @param b ray\r\n    * @return the result of a/b, in ray\r\n    **/\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        return halfB.add(a.mul(RAY)).div(b);\r\n    }\r\n\r\n    /**\r\n    * @dev casts ray down to wad\r\n    * @param a ray\r\n    * @return a casted to wad, rounded half up to the nearest wad\r\n    **/\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n\r\n        return halfRatio.add(a).div(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev convert wad up to ray\r\n    * @param a wad\r\n    * @return a converted in ray\r\n    **/\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        return a.mul(WAD_RAY_RATIO);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates base^exp. The code uses the ModExp precompile\r\n    * @return base^exp, in ray\r\n    */\r\n    //solium-disable-next-line\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rayMul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rayMul(z, x);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Optional functions from the ERC20 standard.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * > Note that this information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * `IERC20.balanceOf` and `IERC20.transfer`.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title VersionedInitializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n *\r\n * @author Aave, inspired by the OpenZeppelin Initializable contract\r\n */\r\ncontract VersionedInitializable {\r\n    /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n    uint256 private lastInitializedRevision = 0;\r\n\r\n    /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n    bool private initializing;\r\n\r\n    /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n    modifier initializer() {\r\n        uint256 revision = getRevision();\r\n        require(initializing || isConstructor() || revision > lastInitializedRevision, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            lastInitializedRevision = revision;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns the revision number of the contract.\r\n    /// Needs to be defined in the inherited class as a constant.\r\n    function getRevision() internal pure returns(uint256);\r\n\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            cs := extcodesize(address)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n    /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n    function() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n   * @return The Address of the implementation.\r\n   */\r\n    function _implementation() internal view returns (address);\r\n\r\n    /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n    function _delegate(address implementation) internal {\r\n        //solium-disable-next-line\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize)\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize)\r\n\r\n            switch result\r\n                // delegatecall returns 0 on error.\r\n                case 0 {\r\n                    revert(0, returndatasize)\r\n                }\r\n                default {\r\n                    return(0, returndatasize)\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n    function _willFallback() internal {}\r\n\r\n    /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n    /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n   * @dev Returns the current implementation.\r\n   * @return Address of the current implementation\r\n   */\r\n    function _implementation() internal view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(\r\n            Address.isContract(newImplementation),\r\n            \"Cannot set a proxy implementation to a non-contract address\"\r\n        );\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        //solium-disable-next-line\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title BaseAdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n   * validated in the constructor.\r\n   */\r\n\r\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _admin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n    function admin() external ifAdmin returns (address) {\r\n        return _admin();\r\n    }\r\n\r\n    /**\r\n   * @return The address of the implementation.\r\n   */\r\n    function implementation() external ifAdmin returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n    function changeAdmin(address newAdmin) external ifAdmin {\r\n        require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n        emit AdminChanged(_admin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n        (bool success, ) = newImplementation.delegatecall(data);\r\n        require(success);\r\n    }\r\n\r\n    /**\r\n   * @return The admin slot.\r\n   */\r\n    function _admin() internal view returns (address adm) {\r\n        bytes32 slot = ADMIN_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            adm := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n    function _setAdmin(address newAdmin) internal {\r\n        bytes32 slot = ADMIN_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            sstore(slot, newAdmin)\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n    function _willFallback() internal {\r\n        require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n        super._willFallback();\r\n    }\r\n}\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\r\n * implementation and init data.\r\n */\r\ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Contract constructor.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    constructor(address _logic, bytes memory _data) public payable {\r\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\r\n    /**\r\n   * Contract constructor.\r\n   * @param _logic address of the initial implementation.\r\n   * @param _admin Address of the proxy administrator.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeabilityProxy(_logic, _data) {\r\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(_admin);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n   * @dev Contract initializer.\r\n   * @param _logic Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    function initialize(address _logic, bytes memory _data) public payable {\r\n        require(_implementation() == address(0));\r\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n\r\ncontract AddressStorage {\r\n    mapping(bytes32 => address) private addresses;\r\n\r\n    function getAddress(bytes32 _key) public view returns (address) {\r\n        return addresses[_key];\r\n    }\r\n\r\n    function _setAddress(bytes32 _key, address _value) internal {\r\n        addresses[_key] = _value;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \r\n * initializing the implementation, admin, and init data.\r\n */\r\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\r\n    /**\r\n   * Contract initializer.\r\n   * @param _logic address of the initial implementation.\r\n   * @param _admin Address of the proxy administrator.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n    function initialize(address _logic, address _admin, bytes memory _data) public payable {\r\n        require(_implementation() == address(0));\r\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\r\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\r\n        _setAdmin(_admin);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n@title ILendingPoolAddressesProvider interface\r\n@notice provides the interface to fetch the LendingPoolCore address\r\n */\r\n\r\ncontract ILendingPoolAddressesProvider {\r\n\r\n    function getLendingPool() public view returns (address);\r\n    function setLendingPoolImpl(address _pool) public;\r\n\r\n    function getLendingPoolCore() public view returns (address payable);\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\r\n\r\n    function getLendingPoolConfigurator() public view returns (address);\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public;\r\n\r\n    function getLendingPoolDataProvider() public view returns (address);\r\n    function setLendingPoolDataProviderImpl(address _provider) public;\r\n\r\n    function getLendingPoolParametersProvider() public view returns (address);\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\r\n\r\n    function getTokenDistributor() public view returns (address);\r\n    function setTokenDistributor(address _tokenDistributor) public;\r\n\r\n\r\n    function getFeeProvider() public view returns (address);\r\n    function setFeeProviderImpl(address _feeProvider) public;\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address);\r\n    function setLendingPoolLiquidationManager(address _manager) public;\r\n\r\n    function getLendingPoolManager() public view returns (address);\r\n    function setLendingPoolManager(address _lendingPoolManager) public;\r\n\r\n    function getPriceOracle() public view returns (address);\r\n    function setPriceOracle(address _priceOracle) public;\r\n\r\n    function getLendingRateOracle() public view returns (address);\r\n    function setLendingRateOracle(address _lendingRateOracle) public;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @title LendingPoolAddressesProvider contract\r\n* @notice Is the main registry of the protocol. All the different components of the protocol are accessible\r\n* through the addresses provider.\r\n* @author Aave\r\n**/\r\n\r\ncontract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\r\n    //events\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event LendingPoolCoreUpdated(address indexed newAddress);\r\n    event LendingPoolParametersProviderUpdated(address indexed newAddress);\r\n    event LendingPoolManagerUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\r\n    event LendingPoolDataProviderUpdated(address indexed newAddress);\r\n    event EthereumAddressUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event FeeProviderUpdated(address indexed newAddress);\r\n    event TokenDistributorUpdated(address indexed newAddress);\r\n\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n\r\n    bytes32 private constant LENDING_POOL = \"LENDING_POOL\";\r\n    bytes32 private constant LENDING_POOL_CORE = \"LENDING_POOL_CORE\";\r\n    bytes32 private constant LENDING_POOL_CONFIGURATOR = \"LENDING_POOL_CONFIGURATOR\";\r\n    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = \"PARAMETERS_PROVIDER\";\r\n    bytes32 private constant LENDING_POOL_MANAGER = \"LENDING_POOL_MANAGER\";\r\n    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = \"LIQUIDATION_MANAGER\";\r\n    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = \"FLASHLOAN_PROVIDER\";\r\n    bytes32 private constant DATA_PROVIDER = \"DATA_PROVIDER\";\r\n    bytes32 private constant ETHEREUM_ADDRESS = \"ETHEREUM_ADDRESS\";\r\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\r\n    bytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\r\n    bytes32 private constant FEE_PROVIDER = \"FEE_PROVIDER\";\r\n    bytes32 private constant WALLET_BALANCE_PROVIDER = \"WALLET_BALANCE_PROVIDER\";\r\n    bytes32 private constant TOKEN_DISTRIBUTOR = \"TOKEN_DISTRIBUTOR\";\r\n\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPool proxy\r\n    * @return the lending pool proxy address\r\n    **/\r\n    function getLendingPool() public view returns (address) {\r\n        return getAddress(LENDING_POOL);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool\r\n    * @param _pool the new lending pool implementation\r\n    **/\r\n    function setLendingPoolImpl(address _pool) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL, _pool);\r\n        emit LendingPoolUpdated(_pool);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolCore proxy\r\n    * @return the lending pool core proxy address\r\n     */\r\n    function getLendingPoolCore() public view returns (address payable) {\r\n        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\r\n        return core;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool core\r\n    * @param _lendingPoolCore the new lending pool core implementation\r\n    **/\r\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\r\n        emit LendingPoolCoreUpdated(_lendingPoolCore);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolConfigurator proxy\r\n    * @return the lending pool configurator proxy address\r\n    **/\r\n    function getLendingPoolConfigurator() public view returns (address) {\r\n        return getAddress(LENDING_POOL_CONFIGURATOR);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool configurator\r\n    * @param _configurator the new lending pool configurator implementation\r\n    **/\r\n    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\r\n        emit LendingPoolConfiguratorUpdated(_configurator);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolDataProvider proxy\r\n    * @return the lending pool data provider proxy address\r\n     */\r\n    function getLendingPoolDataProvider() public view returns (address) {\r\n        return getAddress(DATA_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool data provider\r\n    * @param _provider the new lending pool data provider implementation\r\n    **/\r\n    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\r\n        updateImplInternal(DATA_PROVIDER, _provider);\r\n        emit LendingPoolDataProviderUpdated(_provider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolParametersProvider proxy\r\n    * @return the address of the Lending pool parameters provider proxy\r\n    **/\r\n    function getLendingPoolParametersProvider() public view returns (address) {\r\n        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the lending pool parameters provider\r\n    * @param _parametersProvider the new lending pool parameters provider implementation\r\n    **/\r\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\r\n        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\r\n        emit LendingPoolParametersProviderUpdated(_parametersProvider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the FeeProvider proxy\r\n    * @return the address of the Fee provider proxy\r\n    **/\r\n    function getFeeProvider() public view returns (address) {\r\n        return getAddress(FEE_PROVIDER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the implementation of the FeeProvider proxy\r\n    * @param _feeProvider the new lending pool fee provider implementation\r\n    **/\r\n    function setFeeProviderImpl(address _feeProvider) public onlyOwner {\r\n        updateImplInternal(FEE_PROVIDER, _feeProvider);\r\n        emit FeeProviderUpdated(_feeProvider);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\r\n    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\r\n    * the addresses are changed directly.\r\n    * @return the address of the Lending pool liquidation manager\r\n    **/\r\n\r\n    function getLendingPoolLiquidationManager() public view returns (address) {\r\n        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the address of the Lending pool liquidation manager\r\n    * @param _manager the new lending pool liquidation manager address\r\n    **/\r\n    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\r\n        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\r\n        emit LendingPoolLiquidationManagerUpdated(_manager);\r\n    }\r\n\r\n    /**\r\n    * @dev the functions below are storing specific addresses that are outside the context of the protocol\r\n    * hence the upgradable proxy pattern is not used\r\n    **/\r\n\r\n\r\n    function getLendingPoolManager() public view returns (address) {\r\n        return getAddress(LENDING_POOL_MANAGER);\r\n    }\r\n\r\n    function setLendingPoolManager(address _lendingPoolManager) public onlyOwner {\r\n        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\r\n        emit LendingPoolManagerUpdated(_lendingPoolManager);\r\n    }\r\n\r\n    function getPriceOracle() public view returns (address) {\r\n        return getAddress(PRICE_ORACLE);\r\n    }\r\n\r\n    function setPriceOracle(address _priceOracle) public onlyOwner {\r\n        _setAddress(PRICE_ORACLE, _priceOracle);\r\n        emit PriceOracleUpdated(_priceOracle);\r\n    }\r\n\r\n    function getLendingRateOracle() public view returns (address) {\r\n        return getAddress(LENDING_RATE_ORACLE);\r\n    }\r\n\r\n    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\r\n        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\r\n        emit LendingRateOracleUpdated(_lendingRateOracle);\r\n    }\r\n\r\n\r\n    function getTokenDistributor() public view returns (address) {\r\n        return getAddress(TOKEN_DISTRIBUTOR);\r\n    }\r\n\r\n    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\r\n        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\r\n        emit TokenDistributorUpdated(_tokenDistributor);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev internal function to update the implementation of a specific component of the protocol\r\n    * @param _id the id of the contract to be updated\r\n    * @param _newAddress the address of the new implementation\r\n    **/\r\n    function updateImplInternal(bytes32 _id, address _newAddress) internal {\r\n        address payable proxyAddress = address(uint160(getAddress(_id)));\r\n\r\n        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\r\n        bytes memory params = abi.encodeWithSignature(\"initialize(address)\", address(this));\r\n\r\n        if (proxyAddress == address(0)) {\r\n            proxy = new InitializableAdminUpgradeabilityProxy();\r\n            proxy.initialize(_newAddress, address(this), params);\r\n            _setAddress(_id, address(proxy));\r\n            emit ProxyCreated(_id, address(proxy));\r\n        } else {\r\n            proxy.upgradeToAndCall(_newAddress, params);\r\n        }\r\n\r\n    }\r\n}\r\n\r\ncontract UintStorage {\r\n    mapping(bytes32 => uint256) private uints;\r\n\r\n    function getUint(bytes32 _key) public view returns (uint256) {\r\n        return uints[_key];\r\n    }\r\n\r\n    function _setUint(bytes32 _key, uint256 _value) internal {\r\n        uints[_key] = _value;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n* @title LendingPoolParametersProvider\r\n* @author Aave\r\n* @notice stores the configuration parameters of the Lending Pool contract\r\n**/\r\n\r\ncontract LendingPoolParametersProvider is VersionedInitializable {\r\n\r\n    uint256 private constant MAX_STABLE_RATE_BORROW_SIZE_PERCENT = 25;\r\n    uint256 private constant REBALANCE_DOWN_RATE_DELTA = (1e27)/5;\r\n    uint256 private constant FLASHLOAN_FEE_TOTAL = 35;\r\n    uint256 private constant FLASHLOAN_FEE_PROTOCOL = 3000;\r\n\r\n    uint256 constant private DATA_PROVIDER_REVISION = 0x1;\r\n\r\n    function getRevision() internal pure returns(uint256) {\r\n        return DATA_PROVIDER_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev initializes the LendingPoolParametersProvider after it's added to the proxy\r\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider\r\n    */\r\n    function initialize(address _addressesProvider) public initializer {\r\n    }\r\n    /**\r\n    * @dev returns the maximum stable rate borrow size, in percentage of the available liquidity.\r\n    **/\r\n    function getMaxStableRateBorrowSizePercent() external pure returns (uint256)  {\r\n        return MAX_STABLE_RATE_BORROW_SIZE_PERCENT;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the delta between the current stable rate and the user stable rate at\r\n    *      which the borrow position of the user will be rebalanced (scaled down)\r\n    **/\r\n    function getRebalanceDownRateDelta() external pure returns (uint256) {\r\n        return REBALANCE_DOWN_RATE_DELTA;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the fee applied to a flashloan and the portion to redirect to the protocol, in basis points.\r\n    **/\r\n    function getFlashLoanFeesInBips() external pure returns (uint256, uint256) {\r\n        return (FLASHLOAN_FEE_TOTAL, FLASHLOAN_FEE_PROTOCOL);\r\n    }\r\n}\r\n\r\n/**\r\n* @title CoreLibrary library\r\n* @author Aave\r\n* @notice Defines the data structures of the reserves and the user data\r\n**/\r\nlibrary CoreLibrary {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\r\n\r\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\r\n\r\n    struct UserReserveData {\r\n        //principal amount borrowed by the user.\r\n        uint256 principalBorrowBalance;\r\n        //cumulated variable borrow index for the user. Expressed in ray\r\n        uint256 lastVariableBorrowCumulativeIndex;\r\n        //origination fee cumulated by the user\r\n        uint256 originationFee;\r\n        // stable borrow rate at which the user has borrowed. Expressed in ray\r\n        uint256 stableBorrowRate;\r\n        uint40 lastUpdateTimestamp;\r\n        //defines if a specific deposit should or not be used as a collateral in borrows\r\n        bool useAsCollateral;\r\n    }\r\n\r\n    struct ReserveData {\r\n        /**\r\n        * @dev refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n        **/\r\n        //the liquidity index. Expressed in ray\r\n        uint256 lastLiquidityCumulativeIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint256 currentLiquidityRate;\r\n        //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\r\n        uint256 totalBorrowsStable;\r\n        //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\r\n        uint256 totalBorrowsVariable;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint256 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint256 currentStableBorrowRate;\r\n        //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\r\n        uint256 currentAverageStableBorrowRate;\r\n        //variable borrow index. Expressed in ray\r\n        uint256 lastVariableBorrowCumulativeIndex;\r\n        //the ltv of the reserve. Expressed in percentage (0-100)\r\n        uint256 baseLTVasCollateral;\r\n        //the liquidation threshold of the reserve. Expressed in percentage (0-100)\r\n        uint256 liquidationThreshold;\r\n        //the liquidation bonus of the reserve. Expressed in percentage\r\n        uint256 liquidationBonus;\r\n        //the decimals of the reserve asset\r\n        uint256 decimals;\r\n        /**\r\n        * @dev address of the aToken representing the asset\r\n        **/\r\n        address aTokenAddress;\r\n        /**\r\n        * @dev address of the interest rate strategy contract\r\n        **/\r\n        address interestRateStrategyAddress;\r\n        uint40 lastUpdateTimestamp;\r\n        // borrowingEnabled = true means users can borrow from this reserve\r\n        bool borrowingEnabled;\r\n        // usageAsCollateralEnabled = true means users can use this reserve as collateral\r\n        bool usageAsCollateralEnabled;\r\n        // isStableBorrowRateEnabled = true means users can borrow at a stable rate\r\n        bool isStableBorrowRateEnabled;\r\n        // isActive = true means the reserve has been activated and properly configured\r\n        bool isActive;\r\n        // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\r\n        bool isFreezed;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the ongoing normalized income for the reserve.\r\n    * a value of 1e27 means there is no income. As time passes, the income is accrued.\r\n    * A value of 2*1e27 means that the income of the reserve is double the initial amount.\r\n    * @param _reserve the reserve object\r\n    * @return the normalized income. expressed in ray\r\n    **/\r\n    function getNormalizedIncome(CoreLibrary.ReserveData storage _reserve)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 cumulated = calculateLinearInterest(\r\n            _reserve\r\n                .currentLiquidityRate,\r\n            _reserve\r\n                .lastUpdateTimestamp\r\n        )\r\n            .rayMul(_reserve.lastLiquidityCumulativeIndex);\r\n\r\n        return cumulated;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\r\n    * a formal specification.\r\n    * @param _self the reserve object\r\n    **/\r\n    function updateCumulativeIndexes(ReserveData storage _self) internal {\r\n        uint256 totalBorrows = getTotalBorrows(_self);\r\n\r\n        if (totalBorrows > 0) {\r\n            //only cumulating if there is any income being produced\r\n            uint256 cumulatedLiquidityInterest = calculateLinearInterest(\r\n                _self.currentLiquidityRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n\r\n            _self.lastLiquidityCumulativeIndex = cumulatedLiquidityInterest.rayMul(\r\n                _self.lastLiquidityCumulativeIndex\r\n            );\r\n\r\n            uint256 cumulatedVariableBorrowInterest = calculateCompoundedInterest(\r\n                _self.currentVariableBorrowRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n            _self.lastVariableBorrowCumulativeIndex = cumulatedVariableBorrowInterest.rayMul(\r\n                _self.lastVariableBorrowCumulativeIndex\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\r\n    * the flashloan fee to the reserve, and spread it through the depositors.\r\n    * @param _self the reserve object\r\n    * @param _totalLiquidity the total liquidity available in the reserve\r\n    * @param _amount the amount to accomulate\r\n    **/\r\n    function cumulateToLiquidityIndex(\r\n        ReserveData storage _self,\r\n        uint256 _totalLiquidity,\r\n        uint256 _amount\r\n    ) internal {\r\n        uint256 amountToLiquidityRatio = _amount.wadToRay().rayDiv(_totalLiquidity.wadToRay());\r\n\r\n        uint256 cumulatedLiquidity = amountToLiquidityRatio.add(WadRayMath.ray());\r\n\r\n        _self.lastLiquidityCumulativeIndex = cumulatedLiquidity.rayMul(\r\n            _self.lastLiquidityCumulativeIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev initializes a reserve\r\n    * @param _self the reserve object\r\n    * @param _aTokenAddress the address of the overlying atoken contract\r\n    * @param _decimals the number of decimals of the underlying asset\r\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n    function init(\r\n        ReserveData storage _self,\r\n        address _aTokenAddress,\r\n        uint256 _decimals,\r\n        address _interestRateStrategyAddress\r\n    ) external {\r\n        require(_self.aTokenAddress == address(0), \"Reserve has already been initialized\");\r\n\r\n        if (_self.lastLiquidityCumulativeIndex == 0) {\r\n            //if the reserve has not been initialized yet\r\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\r\n        }\r\n\r\n        if (_self.lastVariableBorrowCumulativeIndex == 0) {\r\n            _self.lastVariableBorrowCumulativeIndex = WadRayMath.ray();\r\n        }\r\n\r\n        _self.aTokenAddress = _aTokenAddress;\r\n        _self.decimals = _decimals;\r\n\r\n        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\r\n        _self.isActive = true;\r\n        _self.isFreezed = false;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev enables borrowing on a reserve\r\n    * @param _self the reserve object\r\n    * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\r\n    **/\r\n    function enableBorrowing(ReserveData storage _self, bool _stableBorrowRateEnabled) external {\r\n        require(_self.borrowingEnabled == false, \"Reserve is already enabled\");\r\n\r\n        _self.borrowingEnabled = true;\r\n        _self.isStableBorrowRateEnabled = _stableBorrowRateEnabled;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev disables borrowing on a reserve\r\n    * @param _self the reserve object\r\n    **/\r\n    function disableBorrowing(ReserveData storage _self) external {\r\n        _self.borrowingEnabled = false;\r\n    }\r\n\r\n    /**\r\n    * @dev enables a reserve to be used as collateral\r\n    * @param _self the reserve object\r\n    * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\r\n    * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\r\n    * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\r\n    **/\r\n    function enableAsCollateral(\r\n        ReserveData storage _self,\r\n        uint256 _baseLTVasCollateral,\r\n        uint256 _liquidationThreshold,\r\n        uint256 _liquidationBonus\r\n    ) external {\r\n        require(\r\n            _self.usageAsCollateralEnabled == false,\r\n            \"Reserve is already enabled as collateral\"\r\n        );\r\n\r\n        _self.usageAsCollateralEnabled = true;\r\n        _self.baseLTVasCollateral = _baseLTVasCollateral;\r\n        _self.liquidationThreshold = _liquidationThreshold;\r\n        _self.liquidationBonus = _liquidationBonus;\r\n\r\n        if (_self.lastLiquidityCumulativeIndex == 0)\r\n            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev disables a reserve as collateral\r\n    * @param _self the reserve object\r\n    **/\r\n    function disableAsCollateral(ReserveData storage _self) external {\r\n        _self.usageAsCollateralEnabled = false;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev calculates the compounded borrow balance of a user\r\n    * @param _self the userReserve object\r\n    * @param _reserve the reserve object\r\n    * @return the user compounded borrow balance\r\n    **/\r\n    function getCompoundedBorrowBalance(\r\n        CoreLibrary.UserReserveData storage _self,\r\n        CoreLibrary.ReserveData storage _reserve\r\n    ) internal view returns (uint256) {\r\n        if (_self.principalBorrowBalance == 0) return 0;\r\n\r\n        uint256 principalBorrowBalanceRay = _self.principalBorrowBalance.wadToRay();\r\n        uint256 compoundedBalance = 0;\r\n        uint256 cumulatedInterest = 0;\r\n\r\n        if (_self.stableBorrowRate > 0) {\r\n            cumulatedInterest = calculateCompoundedInterest(\r\n                _self.stableBorrowRate,\r\n                _self.lastUpdateTimestamp\r\n            );\r\n        } else {\r\n            //variable interest\r\n            cumulatedInterest = calculateCompoundedInterest(\r\n                _reserve\r\n                    .currentVariableBorrowRate,\r\n                _reserve\r\n                    .lastUpdateTimestamp\r\n            )\r\n                .rayMul(_reserve.lastVariableBorrowCumulativeIndex)\r\n                .rayDiv(_self.lastVariableBorrowCumulativeIndex);\r\n        }\r\n\r\n        compoundedBalance = principalBorrowBalanceRay.rayMul(cumulatedInterest).rayToWad();\r\n\r\n        if (compoundedBalance == _self.principalBorrowBalance) {\r\n            //solium-disable-next-line\r\n            if (_self.lastUpdateTimestamp != block.timestamp) {\r\n                //no interest cumulation because of the rounding - we add 1 wei\r\n                //as symbolic cumulated interest to avoid interest free loans.\r\n\r\n                return _self.principalBorrowBalance.add(1 wei);\r\n            }\r\n        }\r\n\r\n        return compoundedBalance;\r\n    }\r\n\r\n    /**\r\n    * @dev increases the total borrows at a stable rate on a specific reserve and updates the\r\n    * average stable rate consequently\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to add to the total borrows stable\r\n    * @param _rate the rate at which the amount has been borrowed\r\n    **/\r\n    function increaseTotalBorrowsStableAndUpdateAverageRate(\r\n        ReserveData storage _reserve,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) internal {\r\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\r\n        //updating reserve borrows stable\r\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.add(_amount);\r\n\r\n        //update the average stable rate\r\n        //weighted average of all the borrows\r\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\r\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\r\n            _reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        _reserve.currentAverageStableBorrowRate = weightedLastBorrow\r\n            .add(weightedPreviousTotalBorrows)\r\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\r\n    }\r\n\r\n    /**\r\n    * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\r\n    * average stable rate consequently\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to substract to the total borrows stable\r\n    * @param _rate the rate at which the amount has been repaid\r\n    **/\r\n    function decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n        ReserveData storage _reserve,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) internal {\r\n        require(_reserve.totalBorrowsStable >= _amount, \"Invalid amount to decrease\");\r\n\r\n        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\r\n\r\n        //updating reserve borrows stable\r\n        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.sub(_amount);\r\n\r\n        if (_reserve.totalBorrowsStable == 0) {\r\n            _reserve.currentAverageStableBorrowRate = 0; //no income if there are no stable rate borrows\r\n            return;\r\n        }\r\n\r\n        //update the average stable rate\r\n        //weighted average of all the borrows\r\n        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\r\n        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable.wadToRay().rayMul(\r\n            _reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        require(\r\n            weightedPreviousTotalBorrows >= weightedLastBorrow,\r\n            \"The amounts to subtract don't match\"\r\n        );\r\n\r\n        _reserve.currentAverageStableBorrowRate = weightedPreviousTotalBorrows\r\n            .sub(weightedLastBorrow)\r\n            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\r\n    }\r\n\r\n    /**\r\n    * @dev increases the total borrows at a variable rate\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to add to the total borrows variable\r\n    **/\r\n    function increaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\r\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.add(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev decreases the total borrows at a variable rate\r\n    * @param _reserve the reserve object\r\n    * @param _amount the amount to substract to the total borrows variable\r\n    **/\r\n    function decreaseTotalBorrowsVariable(ReserveData storage _reserve, uint256 _amount) internal {\r\n        require(\r\n            _reserve.totalBorrowsVariable >= _amount,\r\n            \"The amount that is being subtracted from the variable total borrows is incorrect\"\r\n        );\r\n        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.sub(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate the interest using a linear interest rate formula\r\n    * @param _rate the interest rate, in ray\r\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\r\n    * @return the interest rate linearly accumulated during the timeDelta, in ray\r\n    **/\r\n\r\n    function calculateLinearInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //solium-disable-next-line\r\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\r\n\r\n        uint256 timeDelta = timeDifference.wadToRay().rayDiv(SECONDS_PER_YEAR.wadToRay());\r\n\r\n        return _rate.rayMul(timeDelta).add(WadRayMath.ray());\r\n    }\r\n\r\n    /**\r\n    * @dev function to calculate the interest using a compounded interest rate formula\r\n    * @param _rate the interest rate, in ray\r\n    * @param _lastUpdateTimestamp the timestamp of the last update of the interest\r\n    * @return the interest rate compounded during the timeDelta, in ray\r\n    **/\r\n    function calculateCompoundedInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        //solium-disable-next-line\r\n        uint256 timeDifference = block.timestamp.sub(uint256(_lastUpdateTimestamp));\r\n\r\n        uint256 ratePerSecond = _rate.div(SECONDS_PER_YEAR);\r\n\r\n        return ratePerSecond.add(WadRayMath.ray()).rayPow(timeDifference);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the total borrows on the reserve\r\n    * @param _reserve the reserve object\r\n    * @return the total borrows (stable + variable)\r\n    **/\r\n    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _reserve.totalBorrowsStable.add(_reserve.totalBorrowsVariable);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n* @title IPriceOracleGetter interface\r\n* @notice Interface for the Aave price oracle.\r\n**/\r\n\r\ninterface IPriceOracleGetter {\r\n    /**\r\n    * @dev returns the asset price in ETH\r\n    * @param _asset the address of the asset\r\n    * @return the ETH price of the asset\r\n    **/\r\n    function getAssetPrice(address _asset) external view returns (uint256);\r\n}\r\n\r\n/**\r\n* @title IFeeProvider interface\r\n* @notice Interface for the Aave fee provider.\r\n**/\r\n\r\ninterface IFeeProvider {\r\n    function calculateLoanOriginationFee(address _user, uint256 _amount) external view returns (uint256);\r\n    function getLoanOriginationFeePercentage() external view returns (uint256);\r\n}\r\n\r\n/**\r\n* @title LendingPoolDataProvider contract\r\n* @author Aave\r\n* @notice Implements functions to fetch data from the core, and aggregate them in order to allow computation\r\n* on the compounded balances and the account balances in ETH\r\n**/\r\ncontract LendingPoolDataProvider is VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n\r\n    LendingPoolCore public core;\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n\r\n    /**\r\n    * @dev specifies the health factor threshold at which the user position is liquidated.\r\n    * 1e18 by default, if the health factor drops below 1e18, the loan can be liquidated.\r\n    **/\r\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1e18;\r\n\r\n    uint256 public constant DATA_PROVIDER_REVISION = 0x1;\r\n\r\n    function getRevision() internal pure returns (uint256) {\r\n        return DATA_PROVIDER_REVISION;\r\n    }\r\n\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(_addressesProvider.getLendingPoolCore());\r\n    }\r\n\r\n    /**\r\n    * @dev struct to hold calculateUserGlobalData() local computations\r\n    **/\r\n    struct UserGlobalDataLocalVars {\r\n        uint256 reserveUnitPrice;\r\n        uint256 tokenUnit;\r\n        uint256 compoundedLiquidityBalance;\r\n        uint256 compoundedBorrowBalance;\r\n        uint256 reserveDecimals;\r\n        uint256 baseLtv;\r\n        uint256 liquidationThreshold;\r\n        uint256 originationFee;\r\n        bool usageAsCollateralEnabled;\r\n        bool userUsesReserveAsCollateral;\r\n        address currentReserve;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the user data across the reserves.\r\n    * this includes the total liquidity/collateral/borrow balances in ETH,\r\n    * the average Loan To Value, the average Liquidation Ratio, and the Health factor.\r\n    * @param _user the address of the user\r\n    * @return the total liquidity, total collateral, total borrow balances of the user in ETH.\r\n    * also the average Ltv, liquidation threshold, and the health factor\r\n    **/\r\n    function calculateUserGlobalData(address _user)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityBalanceETH,\r\n            uint256 totalCollateralBalanceETH,\r\n            uint256 totalBorrowBalanceETH,\r\n            uint256 totalFeesETH,\r\n            uint256 currentLtv,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 healthFactor,\r\n            bool healthFactorBelowThreshold\r\n        )\r\n    {\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        UserGlobalDataLocalVars memory vars;\r\n\r\n        address[] memory reserves = core.getReserves();\r\n\r\n        for (uint256 i = 0; i < reserves.length; i++) {\r\n            vars.currentReserve = reserves[i];\r\n\r\n            (\r\n                vars.compoundedLiquidityBalance,\r\n                vars.compoundedBorrowBalance,\r\n                vars.originationFee,\r\n                vars.userUsesReserveAsCollateral\r\n            ) = core.getUserBasicReserveData(vars.currentReserve, _user);\r\n\r\n            if (vars.compoundedLiquidityBalance == 0 && vars.compoundedBorrowBalance == 0) {\r\n                continue;\r\n            }\r\n\r\n            //fetch reserve data\r\n            (\r\n                vars.reserveDecimals,\r\n                vars.baseLtv,\r\n                vars.liquidationThreshold,\r\n                vars.usageAsCollateralEnabled\r\n            ) = core.getReserveConfiguration(vars.currentReserve);\r\n\r\n            vars.tokenUnit = 10 ** vars.reserveDecimals;\r\n            vars.reserveUnitPrice = oracle.getAssetPrice(vars.currentReserve);\r\n\r\n            //liquidity and collateral balance\r\n            if (vars.compoundedLiquidityBalance > 0) {\r\n                uint256 liquidityBalanceETH = vars\r\n                    .reserveUnitPrice\r\n                    .mul(vars.compoundedLiquidityBalance)\r\n                    .div(vars.tokenUnit);\r\n                totalLiquidityBalanceETH = totalLiquidityBalanceETH.add(liquidityBalanceETH);\r\n\r\n                if (vars.usageAsCollateralEnabled && vars.userUsesReserveAsCollateral) {\r\n                    totalCollateralBalanceETH = totalCollateralBalanceETH.add(liquidityBalanceETH);\r\n                    currentLtv = currentLtv.add(liquidityBalanceETH.mul(vars.baseLtv));\r\n                    currentLiquidationThreshold = currentLiquidationThreshold.add(\r\n                        liquidityBalanceETH.mul(vars.liquidationThreshold)\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (vars.compoundedBorrowBalance > 0) {\r\n                totalBorrowBalanceETH = totalBorrowBalanceETH.add(\r\n                    vars.reserveUnitPrice.mul(vars.compoundedBorrowBalance).div(vars.tokenUnit)\r\n                );\r\n                totalFeesETH = totalFeesETH.add(\r\n                    vars.originationFee.mul(vars.reserveUnitPrice).div(vars.tokenUnit)\r\n                );\r\n            }\r\n        }\r\n\r\n        currentLtv = totalCollateralBalanceETH > 0 ? currentLtv.div(totalCollateralBalanceETH) : 0;\r\n        currentLiquidationThreshold = totalCollateralBalanceETH > 0\r\n            ? currentLiquidationThreshold.div(totalCollateralBalanceETH)\r\n            : 0;\r\n\r\n        healthFactor = calculateHealthFactorFromBalancesInternal(\r\n            totalCollateralBalanceETH,\r\n            totalBorrowBalanceETH,\r\n            totalFeesETH,\r\n            currentLiquidationThreshold\r\n        );\r\n        healthFactorBelowThreshold = healthFactor < HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n\r\n    }\r\n\r\n    struct balanceDecreaseAllowedLocalVars {\r\n        uint256 decimals;\r\n        uint256 collateralBalanceETH;\r\n        uint256 borrowBalanceETH;\r\n        uint256 totalFeesETH;\r\n        uint256 currentLiquidationThreshold;\r\n        uint256 reserveLiquidationThreshold;\r\n        uint256 amountToDecreaseETH;\r\n        uint256 collateralBalancefterDecrease;\r\n        uint256 liquidationThresholdAfterDecrease;\r\n        uint256 healthFactorAfterDecrease;\r\n        bool reserveUsageAsCollateralEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev check if a specific balance decrease is allowed (i.e. doesn't bring the user borrow position health factor under 1e18)\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to decrease\r\n    * @return true if the decrease of the balance is allowed\r\n    **/\r\n\r\n    function balanceDecreaseAllowed(address _reserve, address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        balanceDecreaseAllowedLocalVars memory vars;\r\n\r\n        (\r\n            vars.decimals,\r\n            ,\r\n            vars.reserveLiquidationThreshold,\r\n            vars.reserveUsageAsCollateralEnabled\r\n        ) = core.getReserveConfiguration(_reserve);\r\n\r\n        if (\r\n            !vars.reserveUsageAsCollateralEnabled ||\r\n            !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)\r\n        ) {\r\n            return true; //if reserve is not used as collateral, no reasons to block the transfer\r\n        }\r\n\r\n        (\r\n            ,\r\n            vars.collateralBalanceETH,\r\n            vars.borrowBalanceETH,\r\n            vars.totalFeesETH,\r\n            ,\r\n            vars.currentLiquidationThreshold,\r\n            ,\r\n\r\n        ) = calculateUserGlobalData(_user);\r\n\r\n        if (vars.borrowBalanceETH == 0) {\r\n            return true; //no borrows - no reasons to block the transfer\r\n        }\r\n\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        vars.amountToDecreaseETH = oracle.getAssetPrice(_reserve).mul(_amount).div(\r\n            10 ** vars.decimals\r\n        );\r\n\r\n        vars.collateralBalancefterDecrease = vars.collateralBalanceETH.sub(\r\n            vars.amountToDecreaseETH\r\n        );\r\n\r\n        //if there is a borrow, there can't be 0 collateral\r\n        if (vars.collateralBalancefterDecrease == 0) {\r\n            return false;\r\n        }\r\n\r\n        vars.liquidationThresholdAfterDecrease = vars\r\n            .collateralBalanceETH\r\n            .mul(vars.currentLiquidationThreshold)\r\n            .sub(vars.amountToDecreaseETH.mul(vars.reserveLiquidationThreshold))\r\n            .div(vars.collateralBalancefterDecrease);\r\n\r\n        uint256 healthFactorAfterDecrease = calculateHealthFactorFromBalancesInternal(\r\n            vars.collateralBalancefterDecrease,\r\n            vars.borrowBalanceETH,\r\n            vars.totalFeesETH,\r\n            vars.liquidationThresholdAfterDecrease\r\n        );\r\n\r\n        return healthFactorAfterDecrease > HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n\r\n    }\r\n\r\n    /**\r\n   * @notice calculates the amount of collateral needed in ETH to cover a new borrow.\r\n   * @param _reserve the reserve from which the user wants to borrow\r\n   * @param _amount the amount the user wants to borrow\r\n   * @param _fee the fee for the amount that the user needs to cover\r\n   * @param _userCurrentBorrowBalanceTH the current borrow balance of the user (before the borrow)\r\n   * @param _userCurrentLtv the average ltv of the user given his current collateral\r\n   * @return the total amount of collateral in ETH to cover the current borrow balance + the new amount + fee\r\n   **/\r\n    function calculateCollateralNeededInETH(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _fee,\r\n        uint256 _userCurrentBorrowBalanceTH,\r\n        uint256 _userCurrentFeesETH,\r\n        uint256 _userCurrentLtv\r\n    ) external view returns (uint256) {\r\n        uint256 reserveDecimals = core.getReserveDecimals(_reserve);\r\n\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        uint256 requestedBorrowAmountETH = oracle\r\n            .getAssetPrice(_reserve)\r\n            .mul(_amount.add(_fee))\r\n            .div(10 ** reserveDecimals); //price is in ether\r\n\r\n        //add the current already borrowed amount to the amount requested to calculate the total collateral needed.\r\n        uint256 collateralNeededInETH = _userCurrentBorrowBalanceTH\r\n            .add(_userCurrentFeesETH)\r\n            .add(requestedBorrowAmountETH)\r\n            .mul(100)\r\n            .div(_userCurrentLtv); //LTV is calculated in percentage\r\n\r\n        return collateralNeededInETH;\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\r\n    * average Loan To Value.\r\n    * @param collateralBalanceETH the total collateral balance\r\n    * @param borrowBalanceETH the total borrow balance\r\n    * @param totalFeesETH the total fees\r\n    * @param ltv the average loan to value\r\n    * @return the amount available to borrow in ETH for the user\r\n    **/\r\n\r\n    function calculateAvailableBorrowsETHInternal(\r\n        uint256 collateralBalanceETH,\r\n        uint256 borrowBalanceETH,\r\n        uint256 totalFeesETH,\r\n        uint256 ltv\r\n    ) internal view returns (uint256) {\r\n        uint256 availableBorrowsETH = collateralBalanceETH.mul(ltv).div(100); //ltv is in percentage\r\n\r\n        if (availableBorrowsETH < borrowBalanceETH) {\r\n            return 0;\r\n        }\r\n\r\n        availableBorrowsETH = availableBorrowsETH.sub(borrowBalanceETH.add(totalFeesETH));\r\n        //calculate fee\r\n        uint256 borrowFee = IFeeProvider(addressesProvider.getFeeProvider())\r\n            .calculateLoanOriginationFee(msg.sender, availableBorrowsETH);\r\n        return availableBorrowsETH.sub(borrowFee);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the health factor from the corresponding balances\r\n    * @param collateralBalanceETH the total collateral balance in ETH\r\n    * @param borrowBalanceETH the total borrow balance in ETH\r\n    * @param totalFeesETH the total fees in ETH\r\n    * @param liquidationThreshold the avg liquidation threshold\r\n    **/\r\n    function calculateHealthFactorFromBalancesInternal(\r\n        uint256 collateralBalanceETH,\r\n        uint256 borrowBalanceETH,\r\n        uint256 totalFeesETH,\r\n        uint256 liquidationThreshold\r\n    ) internal pure returns (uint256) {\r\n        if (borrowBalanceETH == 0) return uint256(-1);\r\n\r\n        return\r\n            (collateralBalanceETH.mul(liquidationThreshold).div(100)).wadDiv(\r\n                borrowBalanceETH.add(totalFeesETH)\r\n            );\r\n    }\r\n\r\n    /**\r\n    * @dev returns the health factor liquidation threshold\r\n    **/\r\n    function getHealthFactorLiquidationThreshold() public pure returns (uint256) {\r\n        return HEALTH_FACTOR_LIQUIDATION_THRESHOLD;\r\n    }\r\n\r\n    /**\r\n    * @dev accessory functions to fetch data from the lendingPoolCore\r\n    **/\r\n    function getReserveConfigurationData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            address rateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive\r\n        )\r\n    {\r\n        (, ltv, liquidationThreshold, usageAsCollateralEnabled) = core.getReserveConfiguration(\r\n            _reserve\r\n        );\r\n        stableBorrowRateEnabled = core.getReserveIsStableBorrowRateEnabled(_reserve);\r\n        borrowingEnabled = core.isReserveBorrowingEnabled(_reserve);\r\n        isActive = core.getReserveIsActive(_reserve);\r\n        liquidationBonus = core.getReserveLiquidationBonus(_reserve);\r\n\r\n        rateStrategyAddress = core.getReserveInterestRateStrategyAddress(_reserve);\r\n    }\r\n\r\n    function getReserveData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,\r\n            uint256 availableLiquidity,\r\n            uint256 totalBorrowsStable,\r\n            uint256 totalBorrowsVariable,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 utilizationRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            address aTokenAddress,\r\n            uint40 lastUpdateTimestamp\r\n        )\r\n    {\r\n        totalLiquidity = core.getReserveTotalLiquidity(_reserve);\r\n        availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n        totalBorrowsStable = core.getReserveTotalBorrowsStable(_reserve);\r\n        totalBorrowsVariable = core.getReserveTotalBorrowsVariable(_reserve);\r\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        variableBorrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\r\n        stableBorrowRate = core.getReserveCurrentStableBorrowRate(_reserve);\r\n        averageStableBorrowRate = core.getReserveCurrentAverageStableBorrowRate(_reserve);\r\n        utilizationRate = core.getReserveUtilizationRate(_reserve);\r\n        liquidityIndex = core.getReserveLiquidityCumulativeIndex(_reserve);\r\n        variableBorrowIndex = core.getReserveVariableBorrowsCumulativeIndex(_reserve);\r\n        aTokenAddress = core.getReserveATokenAddress(_reserve);\r\n        lastUpdateTimestamp = core.getReserveLastUpdate(_reserve);\r\n    }\r\n\r\n    function getUserAccountData(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,\r\n            uint256 totalCollateralETH,\r\n            uint256 totalBorrowsETH,\r\n            uint256 totalFeesETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        (\r\n            totalLiquidityETH,\r\n            totalCollateralETH,\r\n            totalBorrowsETH,\r\n            totalFeesETH,\r\n            ltv,\r\n            currentLiquidationThreshold,\r\n            healthFactor,\r\n\r\n        ) = calculateUserGlobalData(_user);\r\n\r\n        availableBorrowsETH = calculateAvailableBorrowsETHInternal(\r\n            totalCollateralETH,\r\n            totalBorrowsETH,\r\n            totalFeesETH,\r\n            ltv\r\n        );\r\n    }\r\n\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentBorrowBalance,\r\n            uint256 principalBorrowBalance,\r\n            uint256 borrowRateMode,\r\n            uint256 borrowRate,\r\n            uint256 liquidityRate,\r\n            uint256 originationFee,\r\n            uint256 variableBorrowIndex,\r\n            uint256 lastUpdateTimestamp,\r\n            bool usageAsCollateralEnabled\r\n        )\r\n    {\r\n        currentATokenBalance = AToken(core.getReserveATokenAddress(_reserve)).balanceOf(_user);\r\n        CoreLibrary.InterestRateMode mode = core.getUserCurrentBorrowRateMode(_reserve, _user);\r\n        (principalBorrowBalance, currentBorrowBalance, ) = core.getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        //default is 0, if mode == CoreLibrary.InterestRateMode.NONE\r\n        if (mode == CoreLibrary.InterestRateMode.STABLE) {\r\n            borrowRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\r\n        } else if (mode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            borrowRate = core.getReserveCurrentVariableBorrowRate(_reserve);\r\n        }\r\n\r\n        borrowRateMode = uint256(mode);\r\n        liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        originationFee = core.getUserOriginationFee(_reserve, _user);\r\n        variableBorrowIndex = core.getUserVariableBorrowCumulativeIndex(_reserve, _user);\r\n        lastUpdateTimestamp = core.getUserLastUpdate(_reserve, _user);\r\n        usageAsCollateralEnabled = core.isUserUseReserveAsCollateralEnabled(_reserve, _user);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Aave ERC20 AToken\r\n *\r\n * @dev Implementation of the interest bearing token for the DLP protocol.\r\n * @author Aave\r\n */\r\ncontract AToken is ERC20, ERC20Detailed {\r\n    using WadRayMath for uint256;\r\n\r\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\r\n\r\n    /**\r\n    * @dev emitted after the redeem action\r\n    * @param _from the address performing the redeem\r\n    * @param _value the amount to be redeemed\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event Redeem(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted after the mint action\r\n    * @param _from the address performing the mint\r\n    * @param _value the amount to be minted\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event MintOnDeposit(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during the liquidation action, when the liquidator reclaims the underlying\r\n    * asset\r\n    * @param _from the address from which the tokens are being burned\r\n    * @param _value the amount to be burned\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event BurnOnLiquidation(\r\n        address indexed _from,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during the transfer action\r\n    * @param _from the address from which the tokens are being transferred\r\n    * @param _to the adress of the destination\r\n    * @param _value the amount to be minted\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _toBalanceIncrease the cumulated balance since the last update of the destination\r\n    * @param _fromIndex the last index of the user\r\n    * @param _toIndex the last index of the liquidator\r\n    **/\r\n    event BalanceTransfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _value,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _toBalanceIncrease,\r\n        uint256 _fromIndex,\r\n        uint256 _toIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when the accumulation of the interest\r\n    * by an user is redirected to another user\r\n    * @param _from the address from which the interest is being redirected\r\n    * @param _to the adress of the destination\r\n    * @param _fromBalanceIncrease the cumulated balance since the last update of the user\r\n    * @param _fromIndex the last index of the user\r\n    **/\r\n    event InterestStreamRedirected(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _redirectedBalance,\r\n        uint256 _fromBalanceIncrease,\r\n        uint256 _fromIndex\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when the redirected balance of an user is being updated\r\n    * @param _targetAddress the address of which the balance is being updated\r\n    * @param _targetBalanceIncrease the cumulated balance since the last update of the target\r\n    * @param _targetIndex the last index of the user\r\n    * @param _redirectedBalanceAdded the redirected balance being added\r\n    * @param _redirectedBalanceRemoved the redirected balance being removed\r\n    **/\r\n    event RedirectedBalanceUpdated(\r\n        address indexed _targetAddress,\r\n        uint256 _targetBalanceIncrease,\r\n        uint256 _targetIndex,\r\n        uint256 _redirectedBalanceAdded,\r\n        uint256 _redirectedBalanceRemoved\r\n    );\r\n\r\n    event InterestRedirectionAllowanceChanged(\r\n        address indexed _from,\r\n        address indexed _to\r\n    );\r\n\r\n    address public underlyingAssetAddress;\r\n\r\n    mapping (address => uint256) private userIndexes;\r\n    mapping (address => address) private interestRedirectionAddresses;\r\n    mapping (address => uint256) private redirectedBalances;\r\n    mapping (address => address) private interestRedirectionAllowances;\r\n\r\n    LendingPoolAddressesProvider private addressesProvider;\r\n    LendingPoolCore private core;\r\n    LendingPool private pool;\r\n    LendingPoolDataProvider private dataProvider;\r\n\r\n    modifier onlyLendingPool {\r\n        require(\r\n            msg.sender == address(pool),\r\n            \"The caller of this function must be a lending pool\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenTransferAllowed(address _from, uint256 _amount) {\r\n        require(isTransferAllowed(_from, _amount), \"Transfer cannot be allowed.\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        LendingPoolAddressesProvider _addressesProvider,\r\n        address _underlyingAsset,\r\n        uint8 _underlyingAssetDecimals,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) public ERC20Detailed(_name, _symbol, _underlyingAssetDecimals) {\r\n\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\r\n        pool = LendingPool(addressesProvider.getLendingPool());\r\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\r\n        underlyingAssetAddress = _underlyingAsset;\r\n    }\r\n\r\n    /**\r\n     * @notice ERC20 implementation internal function backing transfer() and transferFrom()\r\n     * @dev validates the transfer before allowing it. NOTE: This is not standard ERC20 behavior\r\n     **/\r\n    function _transfer(address _from, address _to, uint256 _amount) internal whenTransferAllowed(_from, _amount) {\r\n\r\n        executeTransferInternal(_from, _to, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev redirects the interest generated to a target address.\r\n    * when the interest is redirected, the user balance is added to\r\n    * the recepient redirected balance.\r\n    * @param _to the address to which the interest will be redirected\r\n    **/\r\n    function redirectInterestStream(address _to) external {\r\n        redirectInterestStreamInternal(msg.sender, _to);\r\n    }\r\n\r\n    /**\r\n    * @dev redirects the interest generated by _from to a target address.\r\n    * when the interest is redirected, the user balance is added to\r\n    * the recepient redirected balance. The caller needs to have allowance on\r\n    * the interest redirection to be able to execute the function.\r\n    * @param _from the address of the user whom interest is being redirected\r\n    * @param _to the address to which the interest will be redirected\r\n    **/\r\n    function redirectInterestStreamOf(address _from, address _to) external {\r\n        require(\r\n            msg.sender == interestRedirectionAllowances[_from],\r\n            \"Caller is not allowed to redirect the interest of the user\"\r\n        );\r\n        redirectInterestStreamInternal(_from,_to);\r\n    }\r\n\r\n    /**\r\n    * @dev gives allowance to an address to execute the interest redirection\r\n    * on behalf of the caller.\r\n    * @param _to the address to which the interest will be redirected. Pass address(0) to reset\r\n    * the allowance.\r\n    **/\r\n    function allowInterestRedirectionTo(address _to) external {\r\n        require(_to != msg.sender, \"User cannot give allowance to himself\");\r\n        interestRedirectionAllowances[msg.sender] = _to;\r\n        emit InterestRedirectionAllowanceChanged(\r\n            msg.sender,\r\n            _to\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev redeems aToken for the underlying asset\r\n    * @param _amount the amount being redeemed\r\n    **/\r\n    function redeem(uint256 _amount) external {\r\n\r\n        require(_amount > 0, \"Amount to redeem needs to be > 0\");\r\n\r\n        //cumulates the balance of the user\r\n        (,\r\n        uint256 currentBalance,\r\n        uint256 balanceIncrease,\r\n        uint256 index) = cumulateBalanceInternal(msg.sender);\r\n\r\n        uint256 amountToRedeem = _amount;\r\n\r\n        //if amount is equal to uint(-1), the user wants to redeem everything\r\n        if(_amount == UINT_MAX_VALUE){\r\n            amountToRedeem = currentBalance;\r\n        }\r\n\r\n        require(amountToRedeem <= currentBalance, \"User cannot redeem more than the available balance\");\r\n\r\n        //check that the user is allowed to redeem the amount\r\n        require(isTransferAllowed(msg.sender, amountToRedeem), \"Transfer cannot be allowed.\");\r\n\r\n        //if the user is redirecting his interest towards someone else,\r\n        //we update the redirected balance of the redirection address by adding the accrued interest,\r\n        //and removing the amount to redeem\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(msg.sender, balanceIncrease, amountToRedeem);\r\n\r\n        // burns tokens equivalent to the amount requested\r\n        _burn(msg.sender, amountToRedeem);\r\n\r\n        bool userIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(currentBalance.sub(amountToRedeem) == 0){\r\n            userIndexReset = resetDataOnZeroBalanceInternal(msg.sender);\r\n        }\r\n\r\n        // executes redeem of the underlying asset\r\n        pool.redeemUnderlying(\r\n            underlyingAssetAddress,\r\n            msg.sender,\r\n            amountToRedeem,\r\n            currentBalance.sub(amountToRedeem)\r\n        );\r\n\r\n        emit Redeem(msg.sender, amountToRedeem, balanceIncrease, userIndexReset ? 0 : index);\r\n    }\r\n\r\n    /**\r\n     * @dev mints token in the event of users depositing the underlying asset into the lending pool\r\n     * only lending pools can call this function\r\n     * @param _account the address receiving the minted tokens\r\n     * @param _amount the amount of tokens to mint\r\n     */\r\n    function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {\r\n\r\n        //cumulates the balance of the user\r\n        (,\r\n        ,\r\n        uint256 balanceIncrease,\r\n        uint256 index) = cumulateBalanceInternal(_account);\r\n\r\n         //if the user is redirecting his interest towards someone else,\r\n        //we update the redirected balance of the redirection address by adding the accrued interest\r\n        //and the amount deposited\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);\r\n\r\n        //mint an equivalent amount of tokens to cover the new deposit\r\n        _mint(_account, _amount);\r\n\r\n        emit MintOnDeposit(_account, _amount, balanceIncrease, index);\r\n    }\r\n\r\n    /**\r\n     * @dev burns token in the event of a borrow being liquidated, in case the liquidators reclaims the underlying asset\r\n     * Transfer of the liquidated asset is executed by the lending pool contract.\r\n     * only lending pools can call this function\r\n     * @param _account the address from which burn the aTokens\r\n     * @param _value the amount to burn\r\n     **/\r\n    function burnOnLiquidation(address _account, uint256 _value) external onlyLendingPool {\r\n\r\n        //cumulates the balance of the user being liquidated\r\n        (,uint256 accountBalance,uint256 balanceIncrease,uint256 index) = cumulateBalanceInternal(_account);\r\n\r\n        //adds the accrued interest and substracts the burned amount to\r\n        //the redirected balance\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease, _value);\r\n\r\n        //burns the requested amount of tokens\r\n        _burn(_account, _value);\r\n\r\n        bool userIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(accountBalance.sub(_value) == 0){\r\n            userIndexReset = resetDataOnZeroBalanceInternal(_account);\r\n        }\r\n\r\n        emit BurnOnLiquidation(_account, _value, balanceIncrease, userIndexReset ? 0 : index);\r\n    }\r\n\r\n    /**\r\n     * @dev transfers tokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n     *      only lending pools can call this function\r\n     * @param _from the address from which transfer the aTokens\r\n     * @param _to the destination address\r\n     * @param _value the amount to transfer\r\n     **/\r\n    function transferOnLiquidation(address _from, address _to, uint256 _value) external onlyLendingPool {\r\n\r\n        //being a normal transfer, the Transfer() and BalanceTransfer() are emitted\r\n        //so no need to emit a specific event here\r\n        executeTransferInternal(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev calculates the balance of the user, which is the\r\n    * principal balance + interest generated by the principal balance + interest generated by the redirected balance\r\n    * @param _user the user for which the balance is being calculated\r\n    * @return the total balance of the user\r\n    **/\r\n    function balanceOf(address _user) public view returns(uint256) {\r\n\r\n        //current principal balance of the user\r\n        uint256 currentPrincipalBalance = super.balanceOf(_user);\r\n        //balance redirected by other users to _user for interest rate accrual\r\n        uint256 redirectedBalance = redirectedBalances[_user];\r\n\r\n        if(currentPrincipalBalance == 0 && redirectedBalance == 0){\r\n            return 0;\r\n        }\r\n        //if the _user is not redirecting the interest to anybody, accrues\r\n        //the interest for himself\r\n\r\n        if(interestRedirectionAddresses[_user] == address(0)){\r\n\r\n            //accruing for himself means that both the principal balance and\r\n            //the redirected balance partecipate in the interest\r\n            return calculateCumulatedBalanceInternal(\r\n                _user,\r\n                currentPrincipalBalance.add(redirectedBalance)\r\n                )\r\n                .sub(redirectedBalance);\r\n        }\r\n        else {\r\n            //if the user redirected the interest, then only the redirected\r\n            //balance generates interest. In that case, the interest generated\r\n            //by the redirected balance is added to the current principal balance.\r\n            return currentPrincipalBalance.add(\r\n                calculateCumulatedBalanceInternal(\r\n                    _user,\r\n                    redirectedBalance\r\n                )\r\n                .sub(redirectedBalance)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev returns the principal balance of the user. The principal balance is the last\r\n    * updated stored balance, which does not consider the perpetually accruing interest.\r\n    * @param _user the address of the user\r\n    * @return the principal balance of the user\r\n    **/\r\n    function principalBalanceOf(address _user) external view returns(uint256) {\r\n        return super.balanceOf(_user);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev calculates the total supply of the specific aToken\r\n    * since the balance of every single user increases over time, the total supply\r\n    * does that too.\r\n    * @return the current total supply\r\n    **/\r\n    function totalSupply() public view returns(uint256) {\r\n\r\n        uint256 currentSupplyPrincipal = super.totalSupply();\r\n\r\n        if(currentSupplyPrincipal == 0){\r\n            return 0;\r\n        }\r\n\r\n        return currentSupplyPrincipal\r\n            .wadToRay()\r\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\r\n            .rayToWad();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Used to validate transfers before actually executing them.\r\n     * @param _user address of the user to check\r\n     * @param _amount the amount to check\r\n     * @return true if the _user can transfer _amount, false otherwise\r\n     **/\r\n    function isTransferAllowed(address _user, uint256 _amount) public view returns (bool) {\r\n        return dataProvider.balanceDecreaseAllowed(underlyingAssetAddress, _user, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the last index of the user, used to calculate the balance of the user\r\n    * @param _user address of the user\r\n    * @return the last user index\r\n    **/\r\n    function getUserIndex(address _user) external view returns(uint256) {\r\n        return userIndexes[_user];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev returns the address to which the interest is redirected\r\n    * @param _user address of the user\r\n    * @return 0 if there is no redirection, an address otherwise\r\n    **/\r\n    function getInterestRedirectionAddress(address _user) external view returns(address) {\r\n        return interestRedirectionAddresses[_user];\r\n    }\r\n\r\n    /**\r\n    * @dev returns the redirected balance of the user. The redirected balance is the balance\r\n    * redirected by other accounts to the user, that is accrueing interest for him.\r\n    * @param _user address of the user\r\n    * @return the total redirected balance\r\n    **/\r\n    function getRedirectedBalance(address _user) external view returns(uint256) {\r\n        return redirectedBalances[_user];\r\n    }\r\n\r\n    /**\r\n    * @dev accumulates the accrued interest of the user to the principal balance\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @return the previous principal balance, the new principal balance, the balance increase\r\n    * and the new user index\r\n    **/\r\n    function cumulateBalanceInternal(address _user)\r\n        internal\r\n        returns(uint256, uint256, uint256, uint256) {\r\n\r\n        uint256 previousPrincipalBalance = super.balanceOf(_user);\r\n\r\n        //calculate the accrued interest since the last accumulation\r\n        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);\r\n        //mints an amount of tokens equivalent to the amount accumulated\r\n        _mint(_user, balanceIncrease);\r\n        //updates the user index\r\n        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);\r\n        return (\r\n            previousPrincipalBalance,\r\n            previousPrincipalBalance.add(balanceIncrease),\r\n            balanceIncrease,\r\n            index\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev updates the redirected balance of the user. If the user is not redirecting his\r\n    * interest, nothing is executed.\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @param _balanceToAdd the amount to add to the redirected balance\r\n    * @param _balanceToRemove the amount to remove from the redirected balance\r\n    **/\r\n    function updateRedirectedBalanceOfRedirectionAddressInternal(\r\n        address _user,\r\n        uint256 _balanceToAdd,\r\n        uint256 _balanceToRemove\r\n    ) internal {\r\n\r\n        address redirectionAddress = interestRedirectionAddresses[_user];\r\n        //if there isn't any redirection, nothing to be done\r\n        if(redirectionAddress == address(0)){\r\n            return;\r\n        }\r\n\r\n        //compound balances of the redirected address\r\n        (,,uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(redirectionAddress);\r\n\r\n        //updating the redirected balance\r\n        redirectedBalances[redirectionAddress] = redirectedBalances[redirectionAddress]\r\n            .add(_balanceToAdd)\r\n            .sub(_balanceToRemove);\r\n\r\n        //if the interest of redirectionAddress is also being redirected, we need to update\r\n        //the redirected balance of the redirection target by adding the balance increase\r\n        address targetOfRedirectionAddress = interestRedirectionAddresses[redirectionAddress];\r\n\r\n        if(targetOfRedirectionAddress != address(0)){\r\n            redirectedBalances[targetOfRedirectionAddress] = redirectedBalances[targetOfRedirectionAddress].add(balanceIncrease);\r\n        }\r\n\r\n        emit RedirectedBalanceUpdated(\r\n            redirectionAddress,\r\n            balanceIncrease,\r\n            index,\r\n            _balanceToAdd,\r\n            _balanceToRemove\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev calculate the interest accrued by _user on a specific balance\r\n    * @param _user the address of the user for which the interest is being accumulated\r\n    * @param _balance the balance on which the interest is calculated\r\n    * @return the interest rate accrued\r\n    **/\r\n    function calculateCumulatedBalanceInternal(\r\n        address _user,\r\n        uint256 _balance\r\n    ) internal view returns (uint256) {\r\n        return _balance\r\n            .wadToRay()\r\n            .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))\r\n            .rayDiv(userIndexes[_user])\r\n            .rayToWad();\r\n    }\r\n\r\n    /**\r\n    * @dev executes the transfer of aTokens, invoked by both _transfer() and\r\n    *      transferOnLiquidation()\r\n    * @param _from the address from which transfer the aTokens\r\n    * @param _to the destination address\r\n    * @param _value the amount to transfer\r\n    **/\r\n    function executeTransferInternal(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) internal {\r\n\r\n        require(_value > 0, \"Transferred amount needs to be greater than zero\");\r\n\r\n        //cumulate the balance of the sender\r\n        (,\r\n        uint256 fromBalance,\r\n        uint256 fromBalanceIncrease,\r\n        uint256 fromIndex\r\n        ) = cumulateBalanceInternal(_from);\r\n\r\n        //cumulate the balance of the receiver\r\n        (,\r\n        ,\r\n        uint256 toBalanceIncrease,\r\n        uint256 toIndex\r\n        ) = cumulateBalanceInternal(_to);\r\n\r\n        //if the sender is redirecting his interest towards someone else,\r\n        //adds to the redirected balance the accrued interest and removes the amount\r\n        //being transferred\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from, fromBalanceIncrease, _value);\r\n\r\n        //if the receiver is redirecting his interest towards someone else,\r\n        //adds to the redirected balance the accrued interest and the amount\r\n        //being transferred\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_to, toBalanceIncrease.add(_value), 0);\r\n\r\n        //performs the transfer\r\n        super._transfer(_from, _to, _value);\r\n\r\n        bool fromIndexReset = false;\r\n        //reset the user data if the remaining balance is 0\r\n        if(fromBalance.sub(_value) == 0){\r\n            fromIndexReset = resetDataOnZeroBalanceInternal(_from);\r\n        }\r\n\r\n        emit BalanceTransfer(\r\n            _from,\r\n            _to,\r\n            _value,\r\n            fromBalanceIncrease,\r\n            toBalanceIncrease,\r\n            fromIndexReset ? 0 : fromIndex,\r\n            toIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev executes the redirection of the interest from one address to another.\r\n    * immediately after redirection, the destination address will start to accrue interest.\r\n    * @param _from the address from which transfer the aTokens\r\n    * @param _to the destination address\r\n    **/\r\n    function redirectInterestStreamInternal(\r\n        address _from,\r\n        address _to\r\n    ) internal {\r\n\r\n        address currentRedirectionAddress = interestRedirectionAddresses[_from];\r\n\r\n        require(_to != currentRedirectionAddress, \"Interest is already redirected to the user\");\r\n\r\n        //accumulates the accrued interest to the principal\r\n        (uint256 previousPrincipalBalance,\r\n        uint256 fromBalance,\r\n        uint256 balanceIncrease,\r\n        uint256 fromIndex) = cumulateBalanceInternal(_from);\r\n\r\n        require(fromBalance > 0, \"Interest stream can only be redirected if there is a valid balance\");\r\n\r\n        //if the user is already redirecting the interest to someone, before changing\r\n        //the redirection address we substract the redirected balance of the previous\r\n        //recipient\r\n        if(currentRedirectionAddress != address(0)){\r\n            updateRedirectedBalanceOfRedirectionAddressInternal(_from,0, previousPrincipalBalance);\r\n        }\r\n\r\n        //if the user is redirecting the interest back to himself,\r\n        //we simply set to 0 the interest redirection address\r\n        if(_to == _from) {\r\n            interestRedirectionAddresses[_from] = address(0);\r\n            emit InterestStreamRedirected(\r\n                _from,\r\n                address(0),\r\n                fromBalance,\r\n                balanceIncrease,\r\n                fromIndex\r\n            );\r\n            return;\r\n        }\r\n\r\n        //first set the redirection address to the new recipient\r\n        interestRedirectionAddresses[_from] = _to;\r\n\r\n        //adds the user balance to the redirected balance of the destination\r\n        updateRedirectedBalanceOfRedirectionAddressInternal(_from,fromBalance,0);\r\n\r\n        emit InterestStreamRedirected(\r\n            _from,\r\n            _to,\r\n            fromBalance,\r\n            balanceIncrease,\r\n            fromIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev function to reset the interest stream redirection and the user index, if the\r\n    * user has no balance left.\r\n    * @param _user the address of the user\r\n    * @return true if the user index has also been reset, false otherwise. useful to emit the proper user index value\r\n    **/\r\n    function resetDataOnZeroBalanceInternal(address _user) internal returns(bool) {\r\n\r\n        //if the user has 0 principal balance, the interest stream redirection gets reset\r\n        interestRedirectionAddresses[_user] = address(0);\r\n\r\n        //emits a InterestStreamRedirected event to notify that the redirection has been reset\r\n        emit InterestStreamRedirected(_user, address(0),0,0,0);\r\n\r\n        //if the redirected balance is also 0, we clear up the user index\r\n        if(redirectedBalances[_user] == 0){\r\n            userIndexes[_user] = 0;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* @title IFlashLoanReceiver interface\r\n* @notice Interface for the Aave fee IFlashLoanReceiver.\r\n* @author Aave\r\n* @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n**/\r\ninterface IFlashLoanReceiver {\r\n\r\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\r\n}\r\n\r\n/**\r\n* @title ILendingRateOracle interface\r\n* @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\r\n**/\r\n\r\ninterface ILendingRateOracle {\r\n    /**\r\n    @dev returns the market borrow rate in ray\r\n    **/\r\n    function getMarketBorrowRate(address _asset) external view returns (uint256);\r\n\r\n    /**\r\n    @dev sets the market borrow rate. Rate value must be in ray\r\n    **/\r\n    function setMarketBorrowRate(address _asset, uint256 _rate) external;\r\n}\r\n\r\n/**\r\n@title IReserveInterestRateStrategyInterface interface\r\n@notice Interface for the calculation of the interest rates.\r\n*/\r\n\r\ninterface IReserveInterestRateStrategy {\r\n\r\n    /**\r\n    * @dev returns the base variable borrow rate, in rays\r\n    */\r\n\r\n    function getBaseVariableBorrowRate() external view returns (uint256);\r\n    /**\r\n    * @dev calculates the liquidity, stable, and variable rates depending on the current utilization rate\r\n    *      and the base parameters\r\n    *\r\n    */\r\n    function calculateInterestRates(\r\n        address _reserve,\r\n        uint256 _utilizationRate,\r\n        uint256 _totalBorrowsStable,\r\n        uint256 _totalBorrowsVariable,\r\n        uint256 _averageStableBorrowRate)\r\n    external\r\n    view\r\n    returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\r\n}\r\n\r\nlibrary EthAddressLib {\r\n\r\n    /**\r\n    * @dev returns the address used within the protocol to identify ETH\r\n    * @return the address assigned to ETH\r\n     */\r\n    function ethAddress() internal pure returns(address) {\r\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    }\r\n}\r\n\r\n/**\r\n* @title LendingPoolCore contract\r\n* @author Aave\r\n* @notice Holds the state of the lending pool and all the funds deposited\r\n* @dev NOTE: The core does not enforce security checks on the update of the state\r\n* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\r\n* The check that an action can be performed is a duty of the overlying LendingPool contract.\r\n**/\r\n\r\ncontract LendingPoolCore is VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using CoreLibrary for CoreLibrary.ReserveData;\r\n    using CoreLibrary for CoreLibrary.UserReserveData;\r\n    using SafeERC20 for ERC20;\r\n    using Address for address payable;\r\n\r\n    /**\r\n    * @dev Emitted when the state of a reserve is updated\r\n    * @param reserve the address of the reserve\r\n    * @param liquidityRate the new liquidity rate\r\n    * @param stableBorrowRate the new stable borrow rate\r\n    * @param variableBorrowRate the new variable borrow rate\r\n    * @param liquidityIndex the new liquidity index\r\n    * @param variableBorrowIndex the new variable borrow index\r\n    **/\r\n    event ReserveUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    address public lendingPoolAddress;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n\r\n    /**\r\n    * @dev only lending pools can use functions affected by this modifier\r\n    **/\r\n    modifier onlyLendingPool {\r\n        require(lendingPoolAddress == msg.sender, \"The caller must be a lending pool contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev only lending pools configurator can use functions affected by this modifier\r\n    **/\r\n    modifier onlyLendingPoolConfigurator {\r\n        require(\r\n            addressesProvider.getLendingPoolConfigurator() == msg.sender,\r\n            \"The caller must be a lending pool configurator contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    mapping(address => CoreLibrary.ReserveData) internal reserves;\r\n    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;\r\n\r\n    address[] public reservesList;\r\n\r\n    uint256 public constant CORE_REVISION = 0x4;\r\n\r\n    /**\r\n    * @dev returns the revision number of the contract\r\n    **/\r\n    function getRevision() internal pure returns (uint256) {\r\n        return CORE_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\r\n    * @param _addressesProvider the addressesProvider contract\r\n    **/\r\n\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        refreshConfigInternal();\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a deposit action\r\n    * @param _reserve the address of the reserve in which the deposit is happening\r\n    * @param _user the address of the the user depositing\r\n    * @param _amount the amount being deposited\r\n    * @param _isFirstDeposit true if the user is depositing for the first time\r\n    **/\r\n\r\n    function updateStateOnDeposit(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amount,\r\n        bool _isFirstDeposit\r\n    ) external onlyLendingPool {\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\r\n\r\n        if (_isFirstDeposit) {\r\n            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\r\n            setUserUseReserveAsCollateral(_reserve, _user, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a redeem action\r\n    * @param _reserve the address of the reserve in which the redeem is happening\r\n    * @param _user the address of the the user redeeming\r\n    * @param _amountRedeemed the amount being redeemed\r\n    * @param _userRedeemedEverything true if the user is redeeming everything\r\n    **/\r\n    function updateStateOnRedeem(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountRedeemed,\r\n        bool _userRedeemedEverything\r\n    ) external onlyLendingPool {\r\n        //compound liquidity and variable borrow interests\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\r\n\r\n        //if user redeemed everything the useReserveAsCollateral flag is reset\r\n        if (_userRedeemedEverything) {\r\n            setUserUseReserveAsCollateral(_reserve, _user, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a result of a flashloan action\r\n    * @param _reserve the address of the reserve in which the flashloan is happening\r\n    * @param _income the income of the protocol as a result of the action\r\n    **/\r\n    function updateStateOnFlashLoan(\r\n        address _reserve,\r\n        uint256 _availableLiquidityBefore,\r\n        uint256 _income,\r\n        uint256 _protocolFee\r\n    ) external onlyLendingPool {\r\n        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\r\n\r\n        //compounding the cumulated interest\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\r\n            getReserveTotalBorrows(_reserve)\r\n        );\r\n\r\n        //compounding the received fee into the reserve\r\n        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\r\n\r\n        //refresh interest rates\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _amountBorrowed the new amount borrowed\r\n    * @param _borrowFee the fee on the amount borrowed\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    * @return the new borrow rate for the user\r\n    **/\r\n    function updateStateOnBorrow(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountBorrowed,\r\n        uint256 _borrowFee,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) external onlyLendingPool returns (uint256, uint256) {\r\n        // getting the previous borrow data of the user\r\n        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        updateReserveStateOnBorrowInternal(\r\n            _reserve,\r\n            _user,\r\n            principalBorrowBalance,\r\n            balanceIncrease,\r\n            _amountBorrowed,\r\n            _rateMode\r\n        );\r\n\r\n        updateUserStateOnBorrowInternal(\r\n            _reserve,\r\n            _user,\r\n            _amountBorrowed,\r\n            balanceIncrease,\r\n            _borrowFee,\r\n            _rateMode\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\r\n\r\n        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\r\n    **/\r\n\r\n    function updateStateOnRepay(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _originationFeeRepaid,\r\n        uint256 _balanceIncrease,\r\n        bool _repaidWholeLoan\r\n    ) external onlyLendingPool {\r\n        updateReserveStateOnRepayInternal(\r\n            _reserve,\r\n            _user,\r\n            _paybackAmountMinusFees,\r\n            _balanceIncrease\r\n        );\r\n        updateUserStateOnRepayInternal(\r\n            _reserve,\r\n            _user,\r\n            _paybackAmountMinusFees,\r\n            _originationFeeRepaid,\r\n            _balanceIncrease,\r\n            _repaidWholeLoan\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the amount borrowed by the user\r\n    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _currentRateMode the current interest rate mode for the user\r\n    **/\r\n    function updateStateOnSwapRate(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _compoundedBorrowBalance,\r\n        uint256 _balanceIncrease,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\r\n        updateReserveStateOnSwapRateInternal(\r\n            _reserve,\r\n            _user,\r\n            _principalBorrowBalance,\r\n            _compoundedBorrowBalance,\r\n            _currentRateMode\r\n        );\r\n\r\n        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\r\n            _reserve,\r\n            _user,\r\n            _balanceIncrease,\r\n            _currentRateMode\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\r\n\r\n        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a liquidation action.\r\n    * @param _principalReserve the address of the principal reserve that is being repaid\r\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _collateralToLiquidate the amount of collateral being liquidated\r\n    * @param _feeLiquidated the amount of origination fee being liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise\r\n    **/\r\n    function updateStateOnLiquidation(\r\n        address _principalReserve,\r\n        address _collateralReserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _collateralToLiquidate,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _balanceIncrease,\r\n        bool _liquidatorReceivesAToken\r\n    ) external onlyLendingPool {\r\n        updatePrincipalReserveStateOnLiquidationInternal(\r\n            _principalReserve,\r\n            _user,\r\n            _amountToLiquidate,\r\n            _balanceIncrease\r\n        );\r\n\r\n        updateCollateralReserveStateOnLiquidationInternal(\r\n            _collateralReserve\r\n        );\r\n\r\n        updateUserStateOnLiquidationInternal(\r\n            _principalReserve,\r\n            _user,\r\n            _amountToLiquidate,\r\n            _feeLiquidated,\r\n            _balanceIncrease\r\n        );\r\n\r\n        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\r\n\r\n        if (!_liquidatorReceivesAToken) {\r\n            updateReserveInterestRatesAndTimestampInternal(\r\n                _collateralReserve,\r\n                0,\r\n                _collateralToLiquidate.add(_liquidatedCollateralForFee)\r\n            );\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the core as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @return the new stable rate for the user\r\n    **/\r\n    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\r\n        external\r\n        onlyLendingPool\r\n        returns (uint256)\r\n    {\r\n        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\r\n\r\n        //update user data and rebalance the rate\r\n        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\r\n        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\r\n        return usersReserveData[_user][_reserve].stableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev enables or disables a reserve as collateral\r\n    * @param _reserve the address of the principal reserve where the user deposited\r\n    * @param _user the address of the depositor\r\n    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\r\n    **/\r\n    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\r\n        public\r\n        onlyLendingPool\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        user.useAsCollateral = _useAsCollateral;\r\n    }\r\n\r\n    /**\r\n    * @notice ETH/token transfer functions\r\n    **/\r\n\r\n    /**\r\n    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\r\n    **/\r\n    function() external payable {\r\n        //only contracts can send ETH to the core\r\n        require(msg.sender.isContract(), \"Only contracts can send ether to the Lending pool core\");\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev transfers to the user a specific amount from the reserve.\r\n    * @param _reserve the address of the reserve where the transfer is happening\r\n    * @param _user the address of the user receiving the transfer\r\n    * @param _amount the amount being transferred\r\n    **/\r\n    function transferToUser(address _reserve, address payable _user, uint256 _amount)\r\n        external\r\n        onlyLendingPool\r\n    {\r\n        if (_reserve != EthAddressLib.ethAddress()) {\r\n            ERC20(_reserve).safeTransfer(_user, _amount);\r\n        } else {\r\n            //solium-disable-next-line\r\n            (bool result, ) = _user.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers the protocol fees to the fees collection address\r\n    * @param _token the address of the token being transferred\r\n    * @param _user the address of the user from where the transfer is happening\r\n    * @param _amount the amount being transferred\r\n    * @param _destination the fee receiver address\r\n    **/\r\n\r\n    function transferToFeeCollectionAddress(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amount,\r\n        address _destination\r\n    ) external payable onlyLendingPool {\r\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            require(\r\n                msg.value == 0,\r\n                \"User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction\"\r\n            );\r\n            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\r\n        } else {\r\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\r\n            //solium-disable-next-line\r\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers the fees to the fees collection address in the case of liquidation\r\n    * @param _token the address of the token being transferred\r\n    * @param _amount the amount being transferred\r\n    * @param _destination the fee receiver address\r\n    **/\r\n    function liquidateFee(\r\n        address _token,\r\n        uint256 _amount,\r\n        address _destination\r\n    ) external payable onlyLendingPool {\r\n        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\r\n        require(\r\n            msg.value == 0,\r\n            \"Fee liquidation does not require any transfer of value\"\r\n        );\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            ERC20(_token).safeTransfer(feeAddress, _amount);\r\n        } else {\r\n            //solium-disable-next-line\r\n            (bool result, ) = feeAddress.call.value(_amount).gas(50000)(\"\");\r\n            require(result, \"Transfer of ETH failed\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev transfers an amount from a user to the destination reserve\r\n    * @param _reserve the address of the reserve where the amount is being transferred\r\n    * @param _user the address of the user from where the transfer is happening\r\n    * @param _amount the amount being transferred\r\n    **/\r\n    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\r\n        external\r\n        payable\r\n        onlyLendingPool\r\n    {\r\n        if (_reserve != EthAddressLib.ethAddress()) {\r\n            require(msg.value == 0, \"User is sending ETH along with the ERC20 transfer.\");\r\n            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\r\n\r\n        } else {\r\n            require(msg.value >= _amount, \"The amount and the value sent to deposit do not match\");\r\n\r\n            if (msg.value > _amount) {\r\n                //send back excess ETH\r\n                uint256 excessAmount = msg.value.sub(_amount);\r\n                //solium-disable-next-line\r\n                (bool result, ) = _user.call.value(excessAmount).gas(50000)(\"\");\r\n                require(result, \"Transfer of ETH failed\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice data access functions\r\n    **/\r\n\r\n    /**\r\n    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\r\n    * needed to calculate the global account data in the LendingPoolDataProvider\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\r\n    **/\r\n    function getUserBasicReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\r\n\r\n        if (user.principalBorrowBalance == 0) {\r\n            return (underlyingBalance, 0, 0, user.useAsCollateral);\r\n        }\r\n\r\n        return (\r\n            underlyingBalance,\r\n            user.getCompoundedBorrowBalance(reserve),\r\n            user.originationFee,\r\n            user.useAsCollateral\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev checks if a user is allowed to borrow at a stable rate\r\n    * @param _reserve the reserve address\r\n    * @param _user the user\r\n    * @param _amount the amount the the user wants to borrow\r\n    * @return true if the user is allowed to borrow at a stable rate, false otherwise\r\n    **/\r\n\r\n    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (!reserve.isStableBorrowRateEnabled) return false;\r\n\r\n        return\r\n            !user.useAsCollateral ||\r\n            !reserve.usageAsCollateralEnabled ||\r\n            _amount > getUserUnderlyingAssetBalance(_reserve, _user);\r\n    }\r\n\r\n    /**\r\n    * @dev gets the underlying asset balance of a user based on the corresponding aToken balance.\r\n    * @param _reserve the reserve address\r\n    * @param _user the user address\r\n    * @return the underlying deposit balance of the user\r\n    **/\r\n\r\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        AToken aToken = AToken(reserves[_reserve].aTokenAddress);\r\n        return aToken.balanceOf(_user);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev gets the interest rate strategy contract address for the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the address of the interest rate strategy contract\r\n    **/\r\n    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.interestRateStrategyAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the aToken contract address for the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the address of the aToken contract\r\n    **/\r\n\r\n    function getReserveATokenAddress(address _reserve) public view returns (address) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.aTokenAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\r\n    * @param _reserve the reserve address\r\n    * @return the available liquidity\r\n    **/\r\n    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\r\n        uint256 balance = 0;\r\n\r\n        if (_reserve == EthAddressLib.ethAddress()) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            balance = IERC20(_reserve).balanceOf(address(this));\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\r\n    * @param _reserve the reserve address\r\n    * @return the total liquidity\r\n    **/\r\n    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\r\n    }\r\n\r\n    /**\r\n    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\r\n    * there has been 100% income.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve normalized income\r\n    **/\r\n    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.getNormalizedIncome();\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows (stable + variable)\r\n    **/\r\n    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\r\n        return reserves[_reserve].getTotalBorrows();\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows stable\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows stable\r\n    **/\r\n    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.totalBorrowsStable;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve total borrows variable\r\n    * @param _reserve the reserve address\r\n    * @return the total borrows variable\r\n    **/\r\n\r\n    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.totalBorrowsVariable;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidation threshold\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidation threshold\r\n    **/\r\n\r\n    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.liquidationThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidation bonus\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidation bonus\r\n    **/\r\n\r\n    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.liquidationBonus;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current variable borrow rate\r\n    **/\r\n\r\n    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        if (reserve.currentVariableBorrowRate == 0) {\r\n            return\r\n                IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\r\n                .getBaseVariableBorrowRate();\r\n        }\r\n        return reserve.currentVariableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current stable borrow rate\r\n    **/\r\n\r\n    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\r\n\r\n        if (reserve.currentStableBorrowRate == 0) {\r\n            //no stable rate borrows yet\r\n            return oracle.getMarketBorrowRate(_reserve);\r\n        }\r\n\r\n        return reserve.currentStableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\r\n    * of all the loans taken at stable rate.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve current average borrow rate\r\n    **/\r\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.currentAverageStableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidity rate\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidity rate\r\n    **/\r\n    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.currentLiquidityRate;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve liquidity cumulative index\r\n    * @param _reserve the reserve address\r\n    * @return the reserve liquidity cumulative index\r\n    **/\r\n    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.lastLiquidityCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the reserve variable borrow index\r\n    * @param _reserve the reserve address\r\n    * @return the reserve variable borrow index\r\n    **/\r\n    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.lastVariableBorrowCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev this function aggregates the configuration parameters of the reserve.\r\n    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid\r\n    * multiple external contract calls to fetch the same data.\r\n    * @param _reserve the reserve address\r\n    * @return the reserve decimals\r\n    * @return the base ltv as collateral\r\n    * @return the liquidation threshold\r\n    * @return if the reserve is used as collateral or not\r\n    **/\r\n    function getReserveConfiguration(address _reserve)\r\n        external\r\n        view\r\n        returns (uint256, uint256, uint256, bool)\r\n    {\r\n        uint256 decimals;\r\n        uint256 baseLTVasCollateral;\r\n        uint256 liquidationThreshold;\r\n        bool usageAsCollateralEnabled;\r\n\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        decimals = reserve.decimals;\r\n        baseLTVasCollateral = reserve.baseLTVasCollateral;\r\n        liquidationThreshold = reserve.liquidationThreshold;\r\n        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\r\n\r\n        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\r\n    }\r\n\r\n    /**\r\n    * @dev returns the decimals of the reserve\r\n    * @param _reserve the reserve address\r\n    * @return the reserve decimals\r\n    **/\r\n    function getReserveDecimals(address _reserve) external view returns (uint256) {\r\n        return reserves[_reserve].decimals;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is enabled for borrowing\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is enabled for borrowing, false otherwise\r\n    **/\r\n\r\n    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.borrowingEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is enabled as collateral\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is enabled as collateral, false otherwise\r\n    **/\r\n\r\n    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.usageAsCollateralEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the stable rate is enabled on reserve\r\n    * @param _reserve the reserve address\r\n    * @return true if the stable rate is enabled on reserve, false otherwise\r\n    **/\r\n    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isStableBorrowRateEnabled;\r\n    }\r\n\r\n    /**\r\n    * @dev returns true if the reserve is active\r\n    * @param _reserve the reserve address\r\n    * @return true if the reserve is active, false otherwise\r\n    **/\r\n    function getReserveIsActive(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isActive;\r\n    }\r\n\r\n    /**\r\n    * @notice returns if a reserve is freezed\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return true if the reserve is freezed, false otherwise\r\n    **/\r\n\r\n    function getReserveIsFreezed(address _reserve) external view returns (bool) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        return reserve.isFreezed;\r\n    }\r\n\r\n    /**\r\n    * @notice returns the timestamp of the last action on the reserve\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return the last updated timestamp of the reserve\r\n    **/\r\n\r\n    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        timestamp = reserve.lastUpdateTimestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev returns the utilization rate U of a specific reserve\r\n    * @param _reserve the reserve for which the information is needed\r\n    * @return the utilization rate in ray\r\n    **/\r\n\r\n    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        uint256 totalBorrows = reserve.getTotalBorrows();\r\n\r\n        if (totalBorrows == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\r\n\r\n        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\r\n    }\r\n\r\n    /**\r\n    * @return the array of reserves configured on the core\r\n    **/\r\n    function getReserves() external view returns (address[] memory) {\r\n        return reservesList;\r\n    }\r\n\r\n    /**\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return true if the user has chosen to use the reserve as collateral, false otherwise\r\n    **/\r\n    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.useAsCollateral;\r\n    }\r\n\r\n    /**\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the origination fee for the user\r\n    **/\r\n    function getUserOriginationFee(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.originationFee;\r\n    }\r\n\r\n    /**\r\n    * @dev users with no loans in progress have NONE as borrow rate mode\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the borrow rate mode for the user,\r\n    **/\r\n\r\n    function getUserCurrentBorrowRateMode(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (CoreLibrary.InterestRateMode)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (user.principalBorrowBalance == 0) {\r\n            return CoreLibrary.InterestRateMode.NONE;\r\n        }\r\n\r\n        return\r\n            user.stableBorrowRate > 0\r\n            ? CoreLibrary.InterestRateMode.STABLE\r\n            : CoreLibrary.InterestRateMode.VARIABLE;\r\n    }\r\n\r\n    /**\r\n    * @dev gets the current borrow rate of the user\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the borrow rate for the user,\r\n    **/\r\n    function getUserCurrentBorrowRate(address _reserve, address _user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\r\n\r\n        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\r\n            return 0;\r\n        }\r\n\r\n        return\r\n            rateMode == CoreLibrary.InterestRateMode.STABLE\r\n            ? usersReserveData[_user][_reserve].stableBorrowRate\r\n            : reserves[_reserve].currentVariableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the user stable rate\r\n    **/\r\n    function getUserCurrentStableBorrowRate(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.stableBorrowRate;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates and returns the borrow balances of the user\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\r\n    **/\r\n\r\n    function getUserBorrowBalances(address _reserve, address _user)\r\n        public\r\n        view\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        if (user.principalBorrowBalance == 0) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        uint256 principal = user.principalBorrowBalance;\r\n        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\r\n            user,\r\n            reserves[_reserve]\r\n        );\r\n        return (principal, compoundedBalance, compoundedBalance.sub(principal));\r\n    }\r\n\r\n    /**\r\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the variable borrow index for the user\r\n    **/\r\n\r\n    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        return user.lastVariableBorrowCumulativeIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\r\n    * @param _reserve the address of the reserve for which the information is needed\r\n    * @param _user the address of the user for which the information is needed\r\n    * @return the variable borrow index for the user\r\n    **/\r\n\r\n    function getUserLastUpdate(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (uint256 timestamp)\r\n    {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        timestamp = user.lastUpdateTimestamp;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the lending pool core configuration\r\n    **/\r\n    function refreshConfiguration() external onlyLendingPoolConfigurator {\r\n        refreshConfigInternal();\r\n    }\r\n\r\n    /**\r\n    * @dev initializes a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _aTokenAddress the address of the overlying aToken contract\r\n    * @param _decimals the decimals of the reserve currency\r\n    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n    function initReserve(\r\n        address _reserve,\r\n        address _aTokenAddress,\r\n        uint256 _decimals,\r\n        address _interestRateStrategyAddress\r\n    ) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].init(_aTokenAddress, _decimals, _interestRateStrategyAddress);\r\n        addReserveToListInternal(_reserve);\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n    * @dev removes the last added reserve in the reservesList array\r\n    * @param _reserveToRemove the address of the reserve\r\n    **/\r\n    function removeLastAddedReserve(address _reserveToRemove)\r\n     external onlyLendingPoolConfigurator {\r\n\r\n        address lastReserve = reservesList[reservesList.length-1];\r\n\r\n        require(lastReserve == _reserveToRemove, \"Reserve being removed is different than the reserve requested\");\r\n\r\n        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\r\n        require(getReserveTotalBorrows(lastReserve) == 0, \"Cannot remove a reserve with liquidity deposited\");\r\n\r\n        reserves[lastReserve].isActive = false;\r\n        reserves[lastReserve].aTokenAddress = address(0);\r\n        reserves[lastReserve].decimals = 0;\r\n        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\r\n        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\r\n        reserves[lastReserve].borrowingEnabled = false;\r\n        reserves[lastReserve].usageAsCollateralEnabled = false;\r\n        reserves[lastReserve].baseLTVasCollateral = 0;\r\n        reserves[lastReserve].liquidationThreshold = 0;\r\n        reserves[lastReserve].liquidationBonus = 0;\r\n        reserves[lastReserve].interestRateStrategyAddress = address(0);\r\n\r\n        reservesList.pop();\r\n    }\r\n\r\n    /**\r\n    * @dev updates the address of the interest rate strategy contract\r\n    * @param _reserve the address of the reserve\r\n    * @param _rateStrategyAddress the address of the interest rate strategy contract\r\n    **/\r\n\r\n    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\r\n    }\r\n\r\n    /**\r\n    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\r\n    * @param _reserve the address of the reserve\r\n    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\r\n    **/\r\n\r\n    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\r\n    }\r\n\r\n    /**\r\n    * @dev disables borrowing on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n\r\n    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].disableBorrowing();\r\n    }\r\n\r\n    /**\r\n    * @dev enables a reserve to be used as collateral\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function enableReserveAsCollateral(\r\n        address _reserve,\r\n        uint256 _baseLTVasCollateral,\r\n        uint256 _liquidationThreshold,\r\n        uint256 _liquidationBonus\r\n    ) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].enableAsCollateral(\r\n            _baseLTVasCollateral,\r\n            _liquidationThreshold,\r\n            _liquidationBonus\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev disables a reserve to be used as collateral\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\r\n        reserves[_reserve].disableAsCollateral();\r\n    }\r\n\r\n    /**\r\n    * @dev enable the stable borrow rate mode on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isStableBorrowRateEnabled = true;\r\n    }\r\n\r\n    /**\r\n    * @dev disable the stable borrow rate mode on a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isStableBorrowRateEnabled = false;\r\n    }\r\n\r\n    /**\r\n    * @dev activates a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        require(\r\n            reserve.lastLiquidityCumulativeIndex > 0 &&\r\n                reserve.lastVariableBorrowCumulativeIndex > 0,\r\n            \"Reserve has not been initialized yet\"\r\n        );\r\n        reserve.isActive = true;\r\n    }\r\n\r\n    /**\r\n    * @dev deactivates a reserve\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isActive = false;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to freeze the reserve.\r\n    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isFreezed = true;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.isFreezed = false;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the loan to value of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _ltv the new loan to value\r\n    **/\r\n    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.baseLTVasCollateral = _ltv;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the liquidation threshold of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _threshold the new liquidation threshold\r\n    **/\r\n    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.liquidationThreshold = _threshold;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the liquidation bonus of a reserve\r\n    * @param _reserve the address of the reserve\r\n    * @param _bonus the new liquidation bonus\r\n    **/\r\n    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.liquidationBonus = _bonus;\r\n    }\r\n\r\n    /**\r\n    * @notice allows the configurator to update the reserve decimals\r\n    * @param _reserve the address of the reserve\r\n    * @param _decimals the decimals of the reserve\r\n    **/\r\n    function setReserveDecimals(address _reserve, uint256 _decimals)\r\n        external\r\n        onlyLendingPoolConfigurator\r\n    {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        reserve.decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n    * @notice internal functions\r\n    **/\r\n\r\n    /**\r\n    * @dev updates the state of a reserve as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\r\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\r\n    * @param _amountBorrowed the new amount borrowed\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    **/\r\n\r\n    function updateReserveStateOnBorrowInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _balanceIncrease,\r\n        uint256 _amountBorrowed,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) internal {\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        //increasing reserve total borrows to account for the new borrow balance of the user\r\n        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\r\n\r\n        updateReserveTotalBorrowsByRateModeInternal(\r\n            _reserve,\r\n            _user,\r\n            _principalBorrowBalance,\r\n            _balanceIncrease,\r\n            _amountBorrowed,\r\n            _rateMode\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of a user as a consequence of a borrow action.\r\n    * @param _reserve the address of the reserve on which the user is borrowing\r\n    * @param _user the address of the borrower\r\n    * @param _amountBorrowed the amount borrowed\r\n    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\r\n    * @param _rateMode the borrow rate mode (stable, variable)\r\n    * @return the final borrow rate for the user. Emitted by the borrow() event\r\n    **/\r\n\r\n    function updateUserStateOnBorrowInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountBorrowed,\r\n        uint256 _balanceIncrease,\r\n        uint256 _fee,\r\n        CoreLibrary.InterestRateMode _rateMode\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //stable\r\n            //reset the user variable index, and update the stable rate\r\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //variable\r\n            //reset the user stable rate, and store the new borrow index\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        } else {\r\n            revert(\"Invalid borrow rate mode\");\r\n        }\r\n        //increase the principal borrows and the origination fee\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\r\n            _balanceIncrease\r\n        );\r\n        user.originationFee = user.originationFee.add(_fee);\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the reserve as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateReserveStateOnRepayInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\r\n\r\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\r\n\r\n        //update the indexes\r\n        reserves[_reserve].updateCumulativeIndexes();\r\n\r\n        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\r\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _balanceIncrease,\r\n                user.stableBorrowRate\r\n            );\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _paybackAmountMinusFees,\r\n                user.stableBorrowRate\r\n            );\r\n        } else {\r\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\r\n            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a repay action.\r\n    * @param _reserve the address of the reserve on which the user is repaying\r\n    * @param _user the address of the borrower\r\n    * @param _paybackAmountMinusFees the amount being paid back minus fees\r\n    * @param _originationFeeRepaid the fee on the amount that is being repaid\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _repaidWholeLoan true if the user is repaying the whole loan\r\n    **/\r\n    function updateUserStateOnRepayInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _paybackAmountMinusFees,\r\n        uint256 _originationFeeRepaid,\r\n        uint256 _balanceIncrease,\r\n        bool _repaidWholeLoan\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\r\n            _paybackAmountMinusFees\r\n        );\r\n        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n\r\n        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\r\n        //and the rate mode is stable, we reset the interest rate mode of the user\r\n        if (_repaidWholeLoan) {\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        }\r\n        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is performing the rate swap\r\n    * @param _user the address of the borrower\r\n    * @param _principalBorrowBalance the the principal amount borrowed by the user\r\n    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\r\n    * @param _currentRateMode the rate mode at which the user borrowed\r\n    **/\r\n    function updateReserveStateOnSwapRateInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBorrowBalance,\r\n        uint256 _compoundedBorrowBalance,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        //compounding reserve indexes\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            uint256 userCurrentStableRate = user.stableBorrowRate;\r\n\r\n            //swap to variable\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _principalBorrowBalance,\r\n                userCurrentStableRate\r\n            ); //decreasing stable from old principal balance\r\n            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\r\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //swap to stable\r\n            uint256 currentStableRate = reserve.currentStableBorrowRate;\r\n            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _compoundedBorrowBalance,\r\n                currentStableRate\r\n            );\r\n\r\n        } else {\r\n            revert(\"Invalid rate mode received\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a swap rate action.\r\n    * @param _reserve the address of the reserve on which the user is performing the swap\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _currentRateMode the current rate mode of the user\r\n    **/\r\n\r\n    function updateUserStateOnSwapRateInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease,\r\n        CoreLibrary.InterestRateMode _currentRateMode\r\n    ) internal returns (CoreLibrary.InterestRateMode) {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\r\n\r\n        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            //switch to stable\r\n            newMode = CoreLibrary.InterestRateMode.STABLE;\r\n            user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n            user.lastVariableBorrowCumulativeIndex = 0;\r\n        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            newMode = CoreLibrary.InterestRateMode.VARIABLE;\r\n            user.stableBorrowRate = 0;\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        } else {\r\n            revert(\"Invalid interest rate mode received\");\r\n        }\r\n        //compounding cumulated interest\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n        return newMode;\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\r\n    * @param _principalReserve the address of the principal reserve that is being repaid\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updatePrincipalReserveStateOnLiquidationInternal(\r\n        address _principalReserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\r\n\r\n        //update principal reserve data\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\r\n            _principalReserve,\r\n            _user\r\n        );\r\n\r\n        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //increase the total borrows by the compounded interest\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _balanceIncrease,\r\n                user.stableBorrowRate\r\n            );\r\n\r\n            //decrease by the actual amount to liquidate\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _amountToLiquidate,\r\n                user.stableBorrowRate\r\n            );\r\n\r\n        } else {\r\n            //increase the total borrows by the compounded interest\r\n            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\r\n\r\n            //decrease by the actual amount to liquidate\r\n            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\r\n    * @param _collateralReserve the address of the collateral reserve that is being liquidated\r\n    **/\r\n    function updateCollateralReserveStateOnLiquidationInternal(\r\n        address _collateralReserve\r\n    ) internal {\r\n        //update collateral reserve\r\n        reserves[_collateralReserve].updateCumulativeIndexes();\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\r\n    * @param _reserve the address of the principal reserve that is being repaid\r\n    * @param _user the address of the borrower\r\n    * @param _amountToLiquidate the amount being repaid by the liquidator\r\n    * @param _feeLiquidated the amount of origination fee being liquidated\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n    function updateUserStateOnLiquidationInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _amountToLiquidate,\r\n        uint256 _feeLiquidated,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        //first increase by the compounded interest, then decrease by the liquidated amount\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\r\n            _amountToLiquidate\r\n        );\r\n\r\n        if (\r\n            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\r\n        ) {\r\n            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\r\n        }\r\n\r\n        if(_feeLiquidated > 0){\r\n            user.originationFee = user.originationFee.sub(_feeLiquidated);\r\n        }\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateReserveStateOnRebalanceInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n\r\n        reserve.updateCumulativeIndexes();\r\n\r\n        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n            _balanceIncrease,\r\n            user.stableBorrowRate\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    **/\r\n\r\n    function updateUserStateOnRebalanceInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _balanceIncrease\r\n    ) internal {\r\n        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\r\n        user.stableBorrowRate = reserve.currentStableBorrowRate;\r\n\r\n        //solium-disable-next-line\r\n        user.lastUpdateTimestamp = uint40(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev updates the state of the user as a consequence of a stable rate rebalance\r\n    * @param _reserve the address of the principal reserve where the user borrowed\r\n    * @param _user the address of the borrower\r\n    * @param _balanceIncrease the accrued interest on the borrowed amount\r\n    * @param _amountBorrowed the accrued interest on the borrowed amount\r\n    **/\r\n    function updateReserveTotalBorrowsByRateModeInternal(\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _principalBalance,\r\n        uint256 _balanceIncrease,\r\n        uint256 _amountBorrowed,\r\n        CoreLibrary.InterestRateMode _newBorrowRateMode\r\n    ) internal {\r\n        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\r\n            _reserve,\r\n            _user\r\n        );\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n\r\n        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\r\n            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\r\n                _principalBalance,\r\n                user.stableBorrowRate\r\n            );\r\n        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            reserve.decreaseTotalBorrowsVariable(_principalBalance);\r\n        }\r\n\r\n        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\r\n        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\r\n                newPrincipalAmount,\r\n                reserve.currentStableBorrowRate\r\n            );\r\n        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\r\n        } else {\r\n            revert(\"Invalid new borrow rate mode\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\r\n    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\r\n    * @param _reserve the address of the reserve to be updated\r\n    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\r\n    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\r\n    **/\r\n\r\n    function updateReserveInterestRatesAndTimestampInternal(\r\n        address _reserve,\r\n        uint256 _liquidityAdded,\r\n        uint256 _liquidityTaken\r\n    ) internal {\r\n        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\r\n        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\r\n            reserve\r\n                .interestRateStrategyAddress\r\n        )\r\n            .calculateInterestRates(\r\n            _reserve,\r\n            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\r\n            reserve.totalBorrowsStable,\r\n            reserve.totalBorrowsVariable,\r\n            reserve.currentAverageStableBorrowRate\r\n        );\r\n\r\n        reserve.currentLiquidityRate = newLiquidityRate;\r\n        reserve.currentStableBorrowRate = newStableRate;\r\n        reserve.currentVariableBorrowRate = newVariableRate;\r\n\r\n        //solium-disable-next-line\r\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\r\n\r\n        emit ReserveUpdated(\r\n            _reserve,\r\n            newLiquidityRate,\r\n            newStableRate,\r\n            newVariableRate,\r\n            reserve.lastLiquidityCumulativeIndex,\r\n            reserve.lastVariableBorrowCumulativeIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev transfers to the protocol fees of a flashloan to the fees collection address\r\n    * @param _token the address of the token being transferred\r\n    * @param _amount the amount being transferred\r\n    **/\r\n\r\n    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\r\n        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\r\n\r\n        if (_token != EthAddressLib.ethAddress()) {\r\n            ERC20(_token).safeTransfer(receiver, _amount);\r\n        } else {\r\n            receiver.transfer(_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev updates the internal configuration of the core\r\n    **/\r\n    function refreshConfigInternal() internal {\r\n        lendingPoolAddress = addressesProvider.getLendingPool();\r\n    }\r\n\r\n    /**\r\n    * @dev adds a reserve to the array of the reserves address\r\n    **/\r\n    function addReserveToListInternal(address _reserve) internal {\r\n        bool reserveAlreadyAdded = false;\r\n        for (uint256 i = 0; i < reservesList.length; i++)\r\n            if (reservesList[i] == _reserve) {\r\n                reserveAlreadyAdded = true;\r\n            }\r\n        if (!reserveAlreadyAdded) reservesList.push(_reserve);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n* @title LendingPool contract\r\n* @notice Implements the actions of the LendingPool, and exposes accessory methods to fetch the users and reserve data\r\n* @author Aave\r\n **/\r\n\r\ncontract LendingPool is ReentrancyGuard, VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using Address for address;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n    LendingPoolCore public core;\r\n    LendingPoolDataProvider public dataProvider;\r\n    LendingPoolParametersProvider public parametersProvider;\r\n    IFeeProvider feeProvider;\r\n\r\n    /**\r\n    * @dev emitted on deposit\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _referral the referral number of the action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Deposit(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint16 indexed _referral,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted during a redeem action.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event RedeemUnderlying(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted on borrow\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    * @param _amount the amount to be deposited\r\n    * @param _borrowRateMode the rate mode, can be either 1-stable or 2-variable\r\n    * @param _borrowRate the rate at which the user has borrowed\r\n    * @param _originationFee the origination fee to be paid by the user\r\n    * @param _borrowBalanceIncrease the balance increase since the last borrow, 0 if it's the first time borrowing\r\n    * @param _referral the referral number of the action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Borrow(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _borrowRateMode,\r\n        uint256 _borrowRate,\r\n        uint256 _originationFee,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint16 indexed _referral,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted on repay\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user for which the repay has been executed\r\n    * @param _repayer the address of the user that has performed the repay action\r\n    * @param _amountMinusFees the amount repaid minus fees\r\n    * @param _fees the fees repaid\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Repay(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        address indexed _repayer,\r\n        uint256 _amountMinusFees,\r\n        uint256 _fees,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a user performs a rate swap\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user executing the swap\r\n    * @param _newRateMode the new interest rate mode\r\n    * @param _newRate the new borrow rate\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event Swap(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _newRateMode,\r\n        uint256 _newRate,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a user enables a reserve as collateral\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    **/\r\n    event ReserveUsedAsCollateralEnabled(address indexed _reserve, address indexed _user);\r\n\r\n    /**\r\n    * @dev emitted when a user disables a reserve as collateral\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user\r\n    **/\r\n    event ReserveUsedAsCollateralDisabled(address indexed _reserve, address indexed _user);\r\n\r\n    /**\r\n    * @dev emitted when the stable rate of a user gets rebalanced\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user for which the rebalance has been executed\r\n    * @param _newStableRate the new stable borrow rate after the rebalance\r\n    * @param _borrowBalanceIncrease the balance increase since the last action\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _newStableRate,\r\n        uint256 _borrowBalanceIncrease,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a flashloan is executed\r\n    * @param _target the address of the flashLoanReceiver\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount requested\r\n    * @param _totalFee the total fee on the amount\r\n    * @param _protocolFee the part of the fee for the protocol\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event FlashLoan(\r\n        address indexed _target,\r\n        address indexed _reserve,\r\n        uint256 _amount,\r\n        uint256 _totalFee,\r\n        uint256 _protocolFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev these events are not emitted directly by the LendingPool\r\n    * but they are declared here as the LendingPoolLiquidationManager\r\n    * is executed using a delegateCall().\r\n    * This allows to have the events in the generated ABI for LendingPool.\r\n    **/\r\n\r\n    /**\r\n    * @dev emitted when a borrow fee is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _feeLiquidated the total fee liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event OriginationFeeLiquidated(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a borrower is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _purchaseAmount the total amount liquidated\r\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\r\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\r\n    * @param _liquidator the address of the liquidator\r\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event LiquidationCall(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _purchaseAmount,\r\n        uint256 _liquidatedCollateralAmount,\r\n        uint256 _accruedBorrowInterest,\r\n        address _liquidator,\r\n        bool _receiveAToken,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked by the\r\n    * aToken.sol contract\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyOverlyingAToken(address _reserve) {\r\n        require(\r\n            msg.sender == core.getReserveATokenAddress(_reserve),\r\n            \"The caller of this function can only be the aToken contract of this reserve\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the reserve is active\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyActiveReserve(address _reserve) {\r\n        requireReserveActiveInternal(_reserve);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the reserve is not freezed.\r\n    * A freezed reserve only allows redeems, repays, rebalances and liquidations.\r\n    * @param _reserve the address of the reserve\r\n    **/\r\n    modifier onlyUnfreezedReserve(address _reserve) {\r\n        requireReserveNotFreezedInternal(_reserve);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev functions affected by this modifier can only be invoked if the provided _amount input parameter\r\n    * is not zero.\r\n    * @param _amount the amount provided\r\n    **/\r\n    modifier onlyAmountGreaterThanZero(uint256 _amount) {\r\n        requireAmountGreaterThanZeroInternal(_amount);\r\n        _;\r\n    }\r\n\r\n    uint256 public constant UINT_MAX_VALUE = uint256(-1);\r\n\r\n    uint256 public constant LENDINGPOOL_REVISION = 0x2;\r\n\r\n    function getRevision() internal pure returns (uint256) {\r\n        return LENDINGPOOL_REVISION;\r\n    }\r\n\r\n    /**\r\n    * @dev this function is invoked by the proxy contract when the LendingPool contract is added to the\r\n    * AddressesProvider.\r\n    * @param _addressesProvider the address of the LendingPoolAddressesProvider registry\r\n    **/\r\n    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\r\n        addressesProvider = _addressesProvider;\r\n        core = LendingPoolCore(addressesProvider.getLendingPoolCore());\r\n        dataProvider = LendingPoolDataProvider(addressesProvider.getLendingPoolDataProvider());\r\n        parametersProvider = LendingPoolParametersProvider(\r\n            addressesProvider.getLendingPoolParametersProvider()\r\n        );\r\n        feeProvider = IFeeProvider(addressesProvider.getFeeProvider());\r\n    }\r\n\r\n    /**\r\n    * @dev deposits The underlying asset into the reserve. A corresponding amount of the overlying asset (aTokens)\r\n    * is minted.\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount to be deposited\r\n    * @param _referralCode integrators are assigned a referral code and can potentially receive rewards.\r\n    **/\r\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        AToken aToken = AToken(core.getReserveATokenAddress(_reserve));\r\n\r\n        bool isFirstDeposit = aToken.balanceOf(msg.sender) == 0;\r\n\r\n        core.updateStateOnDeposit(_reserve, msg.sender, _amount, isFirstDeposit);\r\n\r\n        //minting AToken to user 1:1 with the specific exchange rate\r\n        aToken.mintOnDeposit(msg.sender, _amount);\r\n\r\n        //transfer to the core contract\r\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, _amount);\r\n\r\n        //solium-disable-next-line\r\n        emit Deposit(_reserve, msg.sender, _amount, _referralCode, block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Redeems the underlying amount of assets requested by _user.\r\n    * This function is executed by the overlying aToken contract in response to a redeem action.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user performing the action\r\n    * @param _amount the underlying amount to be redeemed\r\n    **/\r\n    function redeemUnderlying(\r\n        address _reserve,\r\n        address payable _user,\r\n        uint256 _amount,\r\n        uint256 _aTokenBalanceAfterRedeem\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyOverlyingAToken(_reserve)\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        uint256 currentAvailableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n        require(\r\n            currentAvailableLiquidity >= _amount,\r\n            \"There is not enough liquidity available to redeem\"\r\n        );\r\n\r\n        core.updateStateOnRedeem(_reserve, _user, _amount, _aTokenBalanceAfterRedeem == 0);\r\n\r\n        core.transferToUser(_reserve, _user, _amount);\r\n\r\n        //solium-disable-next-line\r\n        emit RedeemUnderlying(_reserve, _user, _amount, block.timestamp);\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev data structures for local computations in the borrow() method.\r\n    */\r\n\r\n    struct BorrowLocalVars {\r\n        uint256 principalBorrowBalance;\r\n        uint256 currentLtv;\r\n        uint256 currentLiquidationThreshold;\r\n        uint256 borrowFee;\r\n        uint256 requestedBorrowAmountETH;\r\n        uint256 amountOfCollateralNeededETH;\r\n        uint256 userCollateralBalanceETH;\r\n        uint256 userBorrowBalanceETH;\r\n        uint256 userTotalFeesETH;\r\n        uint256 borrowBalanceIncrease;\r\n        uint256 currentReserveStableRate;\r\n        uint256 availableLiquidity;\r\n        uint256 reserveDecimals;\r\n        uint256 finalUserBorrowRate;\r\n        CoreLibrary.InterestRateMode rateMode;\r\n        bool healthFactorBelowThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows users to borrow a specific amount of the reserve currency, provided that the borrower\r\n    * already deposited enough collateral.\r\n    * @param _reserve the address of the reserve\r\n    * @param _amount the amount to be borrowed\r\n    * @param _interestRateMode the interest rate mode at which the user wants to borrow. Can be 0 (STABLE) or 1 (VARIABLE)\r\n    **/\r\n    function borrow(\r\n        address _reserve,\r\n        uint256 _amount,\r\n        uint256 _interestRateMode,\r\n        uint16 _referralCode\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        BorrowLocalVars memory vars;\r\n\r\n        //check that the reserve is enabled for borrowing\r\n        require(core.isReserveBorrowingEnabled(_reserve), \"Reserve is not enabled for borrowing\");\r\n        //validate interest rate mode\r\n        require(\r\n            uint256(CoreLibrary.InterestRateMode.VARIABLE) == _interestRateMode ||\r\n                uint256(CoreLibrary.InterestRateMode.STABLE) == _interestRateMode,\r\n            \"Invalid interest rate mode selected\"\r\n        );\r\n\r\n        //cast the rateMode to coreLibrary.interestRateMode\r\n        vars.rateMode = CoreLibrary.InterestRateMode(_interestRateMode);\r\n\r\n        //check that the amount is available in the reserve\r\n        vars.availableLiquidity = core.getReserveAvailableLiquidity(_reserve);\r\n\r\n        require(\r\n            vars.availableLiquidity >= _amount,\r\n            \"There is not enough liquidity available in the reserve\"\r\n        );\r\n\r\n        (\r\n            ,\r\n            vars.userCollateralBalanceETH,\r\n            vars.userBorrowBalanceETH,\r\n            vars.userTotalFeesETH,\r\n            vars.currentLtv,\r\n            vars.currentLiquidationThreshold,\r\n            ,\r\n            vars.healthFactorBelowThreshold\r\n        ) = dataProvider.calculateUserGlobalData(msg.sender);\r\n\r\n        require(vars.userCollateralBalanceETH > 0, \"The collateral balance is 0\");\r\n\r\n        require(\r\n            !vars.healthFactorBelowThreshold,\r\n            \"The borrower can already be liquidated so he cannot borrow more\"\r\n        );\r\n\r\n        //calculating fees\r\n        vars.borrowFee = feeProvider.calculateLoanOriginationFee(msg.sender, _amount);\r\n\r\n        require(vars.borrowFee > 0, \"The amount to borrow is too small\");\r\n\r\n        vars.amountOfCollateralNeededETH = dataProvider.calculateCollateralNeededInETH(\r\n            _reserve,\r\n            _amount,\r\n            vars.borrowFee,\r\n            vars.userBorrowBalanceETH,\r\n            vars.userTotalFeesETH,\r\n            vars.currentLtv\r\n        );\r\n\r\n        require(\r\n            vars.amountOfCollateralNeededETH <= vars.userCollateralBalanceETH,\r\n            \"There is not enough collateral to cover a new borrow\"\r\n        );\r\n\r\n        /**\r\n        * Following conditions need to be met if the user is borrowing at a stable rate:\r\n        * 1. Reserve must be enabled for stable rate borrowing\r\n        * 2. Users cannot borrow from the reserve if their collateral is (mostly) the same currency\r\n        *    they are borrowing, to prevent abuses.\r\n        * 3. Users will be able to borrow only a relatively small, configurable amount of the total\r\n        *    liquidity\r\n        **/\r\n\r\n        if (vars.rateMode == CoreLibrary.InterestRateMode.STABLE) {\r\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\r\n            require(\r\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, _amount),\r\n                \"User cannot borrow the selected amount with a stable rate\"\r\n            );\r\n\r\n            //calculate the max available loan size in stable rate mode as a percentage of the\r\n            //available liquidity\r\n            uint256 maxLoanPercent = parametersProvider.getMaxStableRateBorrowSizePercent();\r\n            uint256 maxLoanSizeStable = vars.availableLiquidity.mul(maxLoanPercent).div(100);\r\n\r\n            require(\r\n                _amount <= maxLoanSizeStable,\r\n                \"User is trying to borrow too much liquidity at a stable rate\"\r\n            );\r\n        }\r\n\r\n        //all conditions passed - borrow is accepted\r\n        (vars.finalUserBorrowRate, vars.borrowBalanceIncrease) = core.updateStateOnBorrow(\r\n            _reserve,\r\n            msg.sender,\r\n            _amount,\r\n            vars.borrowFee,\r\n            vars.rateMode\r\n        );\r\n\r\n        //if we reached this point, we can transfer\r\n        core.transferToUser(_reserve, msg.sender, _amount);\r\n\r\n        emit Borrow(\r\n            _reserve,\r\n            msg.sender,\r\n            _amount,\r\n            _interestRateMode,\r\n            vars.finalUserBorrowRate,\r\n            vars.borrowFee,\r\n            vars.borrowBalanceIncrease,\r\n            _referralCode,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice repays a borrow on the specific reserve, for the specified amount (or for the whole amount, if uint256(-1) is specified).\r\n    * @dev the target user is defined by _onBehalfOf. If there is no repayment on behalf of another account,\r\n    * _onBehalfOf must be equal to msg.sender.\r\n    * @param _reserve the address of the reserve on which the user borrowed\r\n    * @param _amount the amount to repay, or uint256(-1) if the user wants to repay everything\r\n    * @param _onBehalfOf the address for which msg.sender is repaying.\r\n    **/\r\n\r\n    struct RepayLocalVars {\r\n        uint256 principalBorrowBalance;\r\n        uint256 compoundedBorrowBalance;\r\n        uint256 borrowBalanceIncrease;\r\n        bool isETH;\r\n        uint256 paybackAmount;\r\n        uint256 paybackAmountMinusFees;\r\n        uint256 currentStableRate;\r\n        uint256 originationFee;\r\n    }\r\n\r\n    function repay(address _reserve, uint256 _amount, address payable _onBehalfOf)\r\n        external\r\n        payable\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        RepayLocalVars memory vars;\r\n\r\n        (\r\n            vars.principalBorrowBalance,\r\n            vars.compoundedBorrowBalance,\r\n            vars.borrowBalanceIncrease\r\n        ) = core.getUserBorrowBalances(_reserve, _onBehalfOf);\r\n\r\n        vars.originationFee = core.getUserOriginationFee(_reserve, _onBehalfOf);\r\n        vars.isETH = EthAddressLib.ethAddress() == _reserve;\r\n\r\n        require(vars.compoundedBorrowBalance > 0, \"The user does not have any borrow pending\");\r\n\r\n        require(\r\n            _amount != UINT_MAX_VALUE || msg.sender == _onBehalfOf,\r\n            \"To repay on behalf of an user an explicit amount to repay is needed.\"\r\n        );\r\n\r\n        //default to max amount\r\n        vars.paybackAmount = vars.compoundedBorrowBalance.add(vars.originationFee);\r\n\r\n        if (_amount != UINT_MAX_VALUE && _amount < vars.paybackAmount) {\r\n            vars.paybackAmount = _amount;\r\n        }\r\n\r\n        require(\r\n            !vars.isETH || msg.value >= vars.paybackAmount,\r\n            \"Invalid msg.value sent for the repayment\"\r\n        );\r\n\r\n        //if the amount is smaller than the origination fee, just transfer the amount to the fee destination address\r\n        if (vars.paybackAmount <= vars.originationFee) {\r\n            core.updateStateOnRepay(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                0,\r\n                vars.paybackAmount,\r\n                vars.borrowBalanceIncrease,\r\n                false\r\n            );\r\n\r\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.paybackAmount : 0)(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                vars.paybackAmount,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n\r\n            emit Repay(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                msg.sender,\r\n                0,\r\n                vars.paybackAmount,\r\n                vars.borrowBalanceIncrease,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n            return;\r\n        }\r\n\r\n        vars.paybackAmountMinusFees = vars.paybackAmount.sub(vars.originationFee);\r\n\r\n        core.updateStateOnRepay(\r\n            _reserve,\r\n            _onBehalfOf,\r\n            vars.paybackAmountMinusFees,\r\n            vars.originationFee,\r\n            vars.borrowBalanceIncrease,\r\n            vars.compoundedBorrowBalance == vars.paybackAmountMinusFees\r\n        );\r\n\r\n        //if the user didn't repay the origination fee, transfer the fee to the fee collection address\r\n        if(vars.originationFee > 0) {\r\n            core.transferToFeeCollectionAddress.value(vars.isETH ? vars.originationFee : 0)(\r\n                _reserve,\r\n                _onBehalfOf,\r\n                vars.originationFee,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n        }\r\n\r\n        //sending the total msg.value if the transfer is ETH.\r\n        //the transferToReserve() function will take care of sending the\r\n        //excess ETH back to the caller\r\n        core.transferToReserve.value(vars.isETH ? msg.value.sub(vars.originationFee) : 0)(\r\n            _reserve,\r\n            msg.sender,\r\n            vars.paybackAmountMinusFees\r\n        );\r\n\r\n        emit Repay(\r\n            _reserve,\r\n            _onBehalfOf,\r\n            msg.sender,\r\n            vars.paybackAmountMinusFees,\r\n            vars.originationFee,\r\n            vars.borrowBalanceIncrease,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev borrowers can user this function to swap between stable and variable borrow rate modes.\r\n    * @param _reserve the address of the reserve on which the user borrowed\r\n    **/\r\n    function swapBorrowRateMode(address _reserve)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n    {\r\n        (uint256 principalBorrowBalance, uint256 compoundedBorrowBalance, uint256 borrowBalanceIncrease) = core\r\n            .getUserBorrowBalances(_reserve, msg.sender);\r\n\r\n        require(\r\n            compoundedBorrowBalance > 0,\r\n            \"User does not have a borrow in progress on this reserve\"\r\n        );\r\n\r\n        CoreLibrary.InterestRateMode currentRateMode = core.getUserCurrentBorrowRateMode(\r\n            _reserve,\r\n            msg.sender\r\n        );\r\n\r\n        if (currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\r\n            /**\r\n            * user wants to swap to stable, before swapping we need to ensure that\r\n            * 1. stable borrow rate is enabled on the reserve\r\n            * 2. user is not trying to abuse the reserve by depositing\r\n            * more collateral than he is borrowing, artificially lowering\r\n            * the interest rate, borrowing at variable, and switching to stable\r\n            **/\r\n            require(\r\n                core.isUserAllowedToBorrowAtStable(_reserve, msg.sender, compoundedBorrowBalance),\r\n                \"User cannot borrow the selected amount at stable\"\r\n            );\r\n        }\r\n\r\n        (CoreLibrary.InterestRateMode newRateMode, uint256 newBorrowRate) = core\r\n            .updateStateOnSwapRate(\r\n            _reserve,\r\n            msg.sender,\r\n            principalBorrowBalance,\r\n            compoundedBorrowBalance,\r\n            borrowBalanceIncrease,\r\n            currentRateMode\r\n        );\r\n\r\n        emit Swap(\r\n            _reserve,\r\n            msg.sender,\r\n            uint256(newRateMode),\r\n            newBorrowRate,\r\n            borrowBalanceIncrease,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev rebalances the stable interest rate of a user if current liquidity rate > user stable rate.\r\n    * this is regulated by Aave to ensure that the protocol is not abused, and the user is paying a fair\r\n    * rate. Anyone can call this function though.\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user to be rebalanced\r\n    **/\r\n    function rebalanceStableBorrowRate(address _reserve, address _user)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n    {\r\n        (, uint256 compoundedBalance, uint256 borrowBalanceIncrease) = core.getUserBorrowBalances(\r\n            _reserve,\r\n            _user\r\n        );\r\n\r\n        //step 1: user must be borrowing on _reserve at a stable rate\r\n        require(compoundedBalance > 0, \"User does not have any borrow for this reserve\");\r\n\r\n        require(\r\n            core.getUserCurrentBorrowRateMode(_reserve, _user) ==\r\n                CoreLibrary.InterestRateMode.STABLE,\r\n            \"The user borrow is variable and cannot be rebalanced\"\r\n        );\r\n\r\n        uint256 userCurrentStableRate = core.getUserCurrentStableBorrowRate(_reserve, _user);\r\n        uint256 liquidityRate = core.getReserveCurrentLiquidityRate(_reserve);\r\n        uint256 reserveCurrentStableRate = core.getReserveCurrentStableBorrowRate(_reserve);\r\n        uint256 rebalanceDownRateThreshold = reserveCurrentStableRate.rayMul(\r\n            WadRayMath.ray().add(parametersProvider.getRebalanceDownRateDelta())\r\n        );\r\n\r\n        //step 2: we have two possible situations to rebalance:\r\n\r\n        //1. user stable borrow rate is below the current liquidity rate. The loan needs to be rebalanced,\r\n        //as this situation can be abused (user putting back the borrowed liquidity in the same reserve to earn on it)\r\n        //2. user stable rate is above the market avg borrow rate of a certain delta, and utilization rate is low.\r\n        //In this case, the user is paying an interest that is too high, and needs to be rescaled down.\r\n        if (\r\n            userCurrentStableRate < liquidityRate ||\r\n            userCurrentStableRate > rebalanceDownRateThreshold\r\n        ) {\r\n            uint256 newStableRate = core.updateStateOnRebalance(\r\n                _reserve,\r\n                _user,\r\n                borrowBalanceIncrease\r\n            );\r\n\r\n            emit RebalanceStableBorrowRate(\r\n                _reserve,\r\n                _user,\r\n                newStableRate,\r\n                borrowBalanceIncrease,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n\r\n            return;\r\n\r\n        }\r\n\r\n        revert(\"Interest rate rebalance conditions were not met\");\r\n    }\r\n\r\n    /**\r\n    * @dev allows depositors to enable or disable a specific deposit as collateral.\r\n    * @param _reserve the address of the reserve\r\n    * @param _useAsCollateral true if the user wants to user the deposit as collateral, false otherwise.\r\n    **/\r\n    function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)\r\n        external\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyUnfreezedReserve(_reserve)\r\n    {\r\n        uint256 underlyingBalance = core.getUserUnderlyingAssetBalance(_reserve, msg.sender);\r\n\r\n        require(underlyingBalance > 0, \"User does not have any liquidity deposited\");\r\n\r\n        require(\r\n            dataProvider.balanceDecreaseAllowed(_reserve, msg.sender, underlyingBalance),\r\n            \"User deposit is already being used as collateral\"\r\n        );\r\n\r\n        core.setUserUseReserveAsCollateral(_reserve, msg.sender, _useAsCollateral);\r\n\r\n        if (_useAsCollateral) {\r\n            emit ReserveUsedAsCollateralEnabled(_reserve, msg.sender);\r\n        } else {\r\n            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev users can invoke this function to liquidate an undercollateralized position.\r\n    * @param _reserve the address of the collateral to liquidated\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _user the address of the borrower\r\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\r\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\r\n    * he wants to receive the underlying asset directly\r\n    **/\r\n    function liquidationCall(\r\n        address _collateral,\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _purchaseAmount,\r\n        bool _receiveAToken\r\n    ) external payable nonReentrant onlyActiveReserve(_reserve) onlyActiveReserve(_collateral) {\r\n        address liquidationManager = addressesProvider.getLendingPoolLiquidationManager();\r\n\r\n        //solium-disable-next-line\r\n        (bool success, bytes memory result) = liquidationManager.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"liquidationCall(address,address,address,uint256,bool)\",\r\n                _collateral,\r\n                _reserve,\r\n                _user,\r\n                _purchaseAmount,\r\n                _receiveAToken\r\n            )\r\n        );\r\n        require(success, \"Liquidation call failed\");\r\n\r\n        (uint256 returnCode, string memory returnMessage) = abi.decode(result, (uint256, string));\r\n\r\n        if (returnCode != 0) {\r\n            //error found\r\n            revert(string(abi.encodePacked(\"Liquidation failed: \", returnMessage)));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev allows smartcontracts to access the liquidity of the pool within one transaction,\r\n    * as long as the amount taken plus a fee is returned. NOTE There are security concerns for developers of flashloan receiver contracts\r\n    * that must be kept into consideration. For further details please visit https://developers.aave.com\r\n    * @param _receiver The address of the contract receiving the funds. The receiver should implement the IFlashLoanReceiver interface.\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _amount the amount requested for this flashloan\r\n    **/\r\n    function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\r\n        public\r\n        nonReentrant\r\n        onlyActiveReserve(_reserve)\r\n        onlyAmountGreaterThanZero(_amount)\r\n    {\r\n        //check that the reserve has enough available liquidity\r\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\r\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\r\n            ? address(core).balance\r\n            : IERC20(_reserve).balanceOf(address(core));\r\n\r\n        require(\r\n            availableLiquidityBefore >= _amount,\r\n            \"There is not enough liquidity available to borrow\"\r\n        );\r\n\r\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\r\n            .getFlashLoanFeesInBips();\r\n        //calculate amount fee\r\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\r\n\r\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\r\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\r\n        require(\r\n            amountFee > 0 && protocolFee > 0,\r\n            \"The requested amount is too small for a flashLoan.\"\r\n        );\r\n\r\n        //get the FlashLoanReceiver instance\r\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\r\n\r\n        address payable userPayable = address(uint160(_receiver));\r\n\r\n        //transfer funds to the receiver\r\n        core.transferToUser(_reserve, userPayable, _amount);\r\n\r\n        //execute action of the receiver\r\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\r\n\r\n        //check that the actual balance of the core contract includes the returned amount\r\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\r\n            ? address(core).balance\r\n            : IERC20(_reserve).balanceOf(address(core));\r\n\r\n        require(\r\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\r\n            \"The actual balance of the protocol is inconsistent\"\r\n        );\r\n\r\n        core.updateStateOnFlashLoan(\r\n            _reserve,\r\n            availableLiquidityBefore,\r\n            amountFee.sub(protocolFee),\r\n            protocolFee\r\n        );\r\n\r\n        //solium-disable-next-line\r\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @dev accessory functions to fetch data from the core contract\r\n    **/\r\n\r\n    function getReserveConfigurationData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 ltv,\r\n            uint256 liquidationThreshold,\r\n            uint256 liquidationBonus,\r\n            address interestRateStrategyAddress,\r\n            bool usageAsCollateralEnabled,\r\n            bool borrowingEnabled,\r\n            bool stableBorrowRateEnabled,\r\n            bool isActive\r\n        )\r\n    {\r\n        return dataProvider.getReserveConfigurationData(_reserve);\r\n    }\r\n\r\n    function getReserveData(address _reserve)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidity,\r\n            uint256 availableLiquidity,\r\n            uint256 totalBorrowsStable,\r\n            uint256 totalBorrowsVariable,\r\n            uint256 liquidityRate,\r\n            uint256 variableBorrowRate,\r\n            uint256 stableBorrowRate,\r\n            uint256 averageStableBorrowRate,\r\n            uint256 utilizationRate,\r\n            uint256 liquidityIndex,\r\n            uint256 variableBorrowIndex,\r\n            address aTokenAddress,\r\n            uint40 lastUpdateTimestamp\r\n        )\r\n    {\r\n        return dataProvider.getReserveData(_reserve);\r\n    }\r\n\r\n    function getUserAccountData(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalLiquidityETH,\r\n            uint256 totalCollateralETH,\r\n            uint256 totalBorrowsETH,\r\n            uint256 totalFeesETH,\r\n            uint256 availableBorrowsETH,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        )\r\n    {\r\n        return dataProvider.getUserAccountData(_user);\r\n    }\r\n\r\n    function getUserReserveData(address _reserve, address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 currentATokenBalance,\r\n            uint256 currentBorrowBalance,\r\n            uint256 principalBorrowBalance,\r\n            uint256 borrowRateMode,\r\n            uint256 borrowRate,\r\n            uint256 liquidityRate,\r\n            uint256 originationFee,\r\n            uint256 variableBorrowIndex,\r\n            uint256 lastUpdateTimestamp,\r\n            bool usageAsCollateralEnabled\r\n        )\r\n    {\r\n        return dataProvider.getUserReserveData(_reserve, _user);\r\n    }\r\n\r\n    function getReserves() external view returns (address[] memory) {\r\n        return core.getReserves();\r\n    }\r\n\r\n    /**\r\n    * @dev internal function to save on code size for the onlyActiveReserve modifier\r\n    **/\r\n    function requireReserveActiveInternal(address _reserve) internal view {\r\n        require(core.getReserveIsActive(_reserve), \"Action requires an active reserve\");\r\n    }\r\n\r\n    /**\r\n    * @notice internal function to save on code size for the onlyUnfreezedReserve modifier\r\n    **/\r\n    function requireReserveNotFreezedInternal(address _reserve) internal view {\r\n        require(!core.getReserveIsFreezed(_reserve), \"Action requires an unfreezed reserve\");\r\n    }\r\n\r\n    /**\r\n    * @notice internal function to save on code size for the onlyAmountGreaterThanZero modifier\r\n    **/\r\n    function requireAmountGreaterThanZeroInternal(uint256 _amount) internal pure {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n    }\r\n}\r\n\r\n/**\r\n* @title LendingPoolLiquidationManager contract\r\n* @author Aave\r\n* @notice Implements the liquidation function.\r\n**/\r\ncontract LendingPoolLiquidationManager is ReentrancyGuard, VersionedInitializable {\r\n    using SafeMath for uint256;\r\n    using WadRayMath for uint256;\r\n    using Address for address;\r\n\r\n    LendingPoolAddressesProvider public addressesProvider;\r\n    LendingPoolCore core;\r\n    LendingPoolDataProvider dataProvider;\r\n    LendingPoolParametersProvider parametersProvider;\r\n    IFeeProvider feeProvider;\r\n    address ethereumAddress;\r\n\r\n    uint256 constant LIQUIDATION_CLOSE_FACTOR_PERCENT = 50;\r\n\r\n    /**\r\n    * @dev emitted when a borrow fee is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _feeLiquidated the total fee liquidated\r\n    * @param _liquidatedCollateralForFee the amount of collateral received by the protocol in exchange for the fee\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event OriginationFeeLiquidated(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _feeLiquidated,\r\n        uint256 _liquidatedCollateralForFee,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n    * @dev emitted when a borrower is liquidated\r\n    * @param _collateral the address of the collateral being liquidated\r\n    * @param _reserve the address of the reserve\r\n    * @param _user the address of the user being liquidated\r\n    * @param _purchaseAmount the total amount liquidated\r\n    * @param _liquidatedCollateralAmount the amount of collateral being liquidated\r\n    * @param _accruedBorrowInterest the amount of interest accrued by the borrower since the last action\r\n    * @param _liquidator the address of the liquidator\r\n    * @param _receiveAToken true if the liquidator wants to receive aTokens, false otherwise\r\n    * @param _timestamp the timestamp of the action\r\n    **/\r\n    event LiquidationCall(\r\n        address indexed _collateral,\r\n        address indexed _reserve,\r\n        address indexed _user,\r\n        uint256 _purchaseAmount,\r\n        uint256 _liquidatedCollateralAmount,\r\n        uint256 _accruedBorrowInterest,\r\n        address _liquidator,\r\n        bool _receiveAToken,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    enum LiquidationErrors {\r\n        NO_ERROR,\r\n        NO_COLLATERAL_AVAILABLE,\r\n        COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n        CURRRENCY_NOT_BORROWED,\r\n        HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n        NOT_ENOUGH_LIQUIDITY\r\n    }\r\n\r\n    struct LiquidationCallLocalVars {\r\n        uint256 userCollateralBalance;\r\n        uint256 userCompoundedBorrowBalance;\r\n        uint256 borrowBalanceIncrease;\r\n        uint256 maxPrincipalAmountToLiquidate;\r\n        uint256 actualAmountToLiquidate;\r\n        uint256 liquidationRatio;\r\n        uint256 collateralPrice;\r\n        uint256 principalCurrencyPrice;\r\n        uint256 maxAmountCollateralToLiquidate;\r\n        uint256 originationFee;\r\n        uint256 feeLiquidated;\r\n        uint256 liquidatedCollateralForFee;\r\n        CoreLibrary.InterestRateMode borrowRateMode;\r\n        uint256 userStableRate;\r\n        bool isCollateralEnabled;\r\n        bool healthFactorBelowThreshold;\r\n    }\r\n\r\n    /**\r\n    * @dev as the contract extends the VersionedInitializable contract to match the state\r\n    * of the LendingPool contract, the getRevision() function is needed.\r\n    */\r\n    function getRevision() internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n    * @dev users can invoke this function to liquidate an undercollateralized position.\r\n    * @param _reserve the address of the collateral to liquidated\r\n    * @param _reserve the address of the principal reserve\r\n    * @param _user the address of the borrower\r\n    * @param _purchaseAmount the amount of principal that the liquidator wants to repay\r\n    * @param _receiveAToken true if the liquidators wants to receive the aTokens, false if\r\n    * he wants to receive the underlying asset directly\r\n    **/\r\n    function liquidationCall(\r\n        address _collateral,\r\n        address _reserve,\r\n        address _user,\r\n        uint256 _purchaseAmount,\r\n        bool _receiveAToken\r\n    ) external payable returns (uint256, string memory) {\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        LiquidationCallLocalVars memory vars;\r\n\r\n        (, , , , , , , vars.healthFactorBelowThreshold) = dataProvider.calculateUserGlobalData(\r\n            _user\r\n        );\r\n\r\n        if (!vars.healthFactorBelowThreshold) {\r\n            return (\r\n                uint256(LiquidationErrors.HEALTH_FACTOR_ABOVE_THRESHOLD),\r\n                \"Health factor is not below the threshold\"\r\n            );\r\n        }\r\n\r\n        vars.userCollateralBalance = core.getUserUnderlyingAssetBalance(_collateral, _user);\r\n\r\n        //if _user hasn't deposited this specific collateral, nothing can be liquidated\r\n        if (vars.userCollateralBalance == 0) {\r\n            return (\r\n                uint256(LiquidationErrors.NO_COLLATERAL_AVAILABLE),\r\n                \"Invalid collateral to liquidate\"\r\n            );\r\n        }\r\n\r\n        vars.isCollateralEnabled =\r\n            core.isReserveUsageAsCollateralEnabled(_collateral) &&\r\n            core.isUserUseReserveAsCollateralEnabled(_collateral, _user);\r\n\r\n        //if _collateral isn't enabled as collateral by _user, it cannot be liquidated\r\n        if (!vars.isCollateralEnabled) {\r\n            return (\r\n                uint256(LiquidationErrors.COLLATERAL_CANNOT_BE_LIQUIDATED),\r\n                \"The collateral chosen cannot be liquidated\"\r\n            );\r\n        }\r\n\r\n        //if the user hasn't borrowed the specific currency defined by _reserve, it cannot be liquidated\r\n        (, vars.userCompoundedBorrowBalance, vars.borrowBalanceIncrease) = core\r\n            .getUserBorrowBalances(_reserve, _user);\r\n\r\n        if (vars.userCompoundedBorrowBalance == 0) {\r\n            return (\r\n                uint256(LiquidationErrors.CURRRENCY_NOT_BORROWED),\r\n                \"User did not borrow the specified currency\"\r\n            );\r\n        }\r\n\r\n        //all clear - calculate the max principal amount that can be liquidated\r\n        vars.maxPrincipalAmountToLiquidate = vars\r\n            .userCompoundedBorrowBalance\r\n            .mul(LIQUIDATION_CLOSE_FACTOR_PERCENT)\r\n            .div(100);\r\n\r\n        vars.actualAmountToLiquidate = _purchaseAmount > vars.maxPrincipalAmountToLiquidate\r\n            ? vars.maxPrincipalAmountToLiquidate\r\n            : _purchaseAmount;\r\n\r\n        (uint256 maxCollateralToLiquidate, uint256 principalAmountNeeded) = calculateAvailableCollateralToLiquidate(\r\n            _collateral,\r\n            _reserve,\r\n            vars.actualAmountToLiquidate,\r\n            vars.userCollateralBalance\r\n        );\r\n\r\n        vars.originationFee = core.getUserOriginationFee(_reserve, _user);\r\n\r\n        //if there is a fee to liquidate, calculate the maximum amount of fee that can be liquidated\r\n        if (vars.originationFee > 0) {\r\n            (\r\n                vars.liquidatedCollateralForFee,\r\n                vars.feeLiquidated\r\n            ) = calculateAvailableCollateralToLiquidate(\r\n                _collateral,\r\n                _reserve,\r\n                vars.originationFee,\r\n                vars.userCollateralBalance.sub(maxCollateralToLiquidate)\r\n            );\r\n        }\r\n\r\n        //if principalAmountNeeded < vars.ActualAmountToLiquidate, there isn't enough\r\n        //of _collateral to cover the actual amount that is being liquidated, hence we liquidate\r\n        //a smaller amount\r\n\r\n        if (principalAmountNeeded < vars.actualAmountToLiquidate) {\r\n            vars.actualAmountToLiquidate = principalAmountNeeded;\r\n        }\r\n\r\n        //if liquidator reclaims the underlying asset, we make sure there is enough available collateral in the reserve\r\n        if (!_receiveAToken) {\r\n            uint256 currentAvailableCollateral = core.getReserveAvailableLiquidity(_collateral);\r\n            if (currentAvailableCollateral < maxCollateralToLiquidate) {\r\n                return (\r\n                    uint256(LiquidationErrors.NOT_ENOUGH_LIQUIDITY),\r\n                    \"There isn't enough liquidity available to liquidate\"\r\n                );\r\n            }\r\n        }\r\n\r\n        core.updateStateOnLiquidation(\r\n            _reserve,\r\n            _collateral,\r\n            _user,\r\n            vars.actualAmountToLiquidate,\r\n            maxCollateralToLiquidate,\r\n            vars.feeLiquidated,\r\n            vars.liquidatedCollateralForFee,\r\n            vars.borrowBalanceIncrease,\r\n            _receiveAToken\r\n        );\r\n\r\n        AToken collateralAtoken = AToken(core.getReserveATokenAddress(_collateral));\r\n\r\n        //if liquidator reclaims the aToken, he receives the equivalent atoken amount\r\n        if (_receiveAToken) {\r\n            collateralAtoken.transferOnLiquidation(_user, msg.sender, maxCollateralToLiquidate);\r\n        } else {\r\n            //otherwise receives the underlying asset\r\n            //burn the equivalent amount of atoken\r\n            collateralAtoken.burnOnLiquidation(_user, maxCollateralToLiquidate);\r\n            core.transferToUser(_collateral, msg.sender, maxCollateralToLiquidate);\r\n        }\r\n\r\n        //transfers the principal currency to the pool\r\n        core.transferToReserve.value(msg.value)(_reserve, msg.sender, vars.actualAmountToLiquidate);\r\n\r\n        if (vars.feeLiquidated > 0) {\r\n            //if there is enough collateral to liquidate the fee, first transfer burn an equivalent amount of\r\n            //aTokens of the user\r\n            collateralAtoken.burnOnLiquidation(_user, vars.liquidatedCollateralForFee);\r\n\r\n            //then liquidate the fee by transferring it to the fee collection address\r\n            core.liquidateFee(\r\n                _collateral,\r\n                vars.liquidatedCollateralForFee,\r\n                addressesProvider.getTokenDistributor()\r\n            );\r\n\r\n            emit OriginationFeeLiquidated(\r\n                _collateral,\r\n                _reserve,\r\n                _user,\r\n                vars.feeLiquidated,\r\n                vars.liquidatedCollateralForFee,\r\n                //solium-disable-next-line\r\n                block.timestamp\r\n            );\r\n\r\n        }\r\n        emit LiquidationCall(\r\n            _collateral,\r\n            _reserve,\r\n            _user,\r\n            vars.actualAmountToLiquidate,\r\n            maxCollateralToLiquidate,\r\n            vars.borrowBalanceIncrease,\r\n            msg.sender,\r\n            _receiveAToken,\r\n            //solium-disable-next-line\r\n            block.timestamp\r\n        );\r\n\r\n        return (uint256(LiquidationErrors.NO_ERROR), \"No errors\");\r\n    }\r\n\r\n    struct AvailableCollateralToLiquidateLocalVars {\r\n        uint256 userCompoundedBorrowBalance;\r\n        uint256 liquidationBonus;\r\n        uint256 collateralPrice;\r\n        uint256 principalCurrencyPrice;\r\n        uint256 maxAmountCollateralToLiquidate;\r\n    }\r\n\r\n    /**\r\n    * @dev calculates how much of a specific collateral can be liquidated, given\r\n    * a certain amount of principal currency. This function needs to be called after\r\n    * all the checks to validate the liquidation have been performed, otherwise it might fail.\r\n    * @param _collateral the collateral to be liquidated\r\n    * @param _principal the principal currency to be liquidated\r\n    * @param _purchaseAmount the amount of principal being liquidated\r\n    * @param _userCollateralBalance the collatera balance for the specific _collateral asset of the user being liquidated\r\n    * @return the maximum amount that is possible to liquidated given all the liquidation constraints (user balance, close factor) and\r\n    * the purchase amount\r\n    **/\r\n    function calculateAvailableCollateralToLiquidate(\r\n        address _collateral,\r\n        address _principal,\r\n        uint256 _purchaseAmount,\r\n        uint256 _userCollateralBalance\r\n    ) internal view returns (uint256 collateralAmount, uint256 principalAmountNeeded) {\r\n        collateralAmount = 0;\r\n        principalAmountNeeded = 0;\r\n        IPriceOracleGetter oracle = IPriceOracleGetter(addressesProvider.getPriceOracle());\r\n\r\n        // Usage of a memory struct of vars to avoid \"Stack too deep\" errors due to local variables\r\n        AvailableCollateralToLiquidateLocalVars memory vars;\r\n\r\n        vars.collateralPrice = oracle.getAssetPrice(_collateral);\r\n        vars.principalCurrencyPrice = oracle.getAssetPrice(_principal);\r\n        vars.liquidationBonus = core.getReserveLiquidationBonus(_collateral);\r\n\r\n        //this is the maximum possible amount of the selected collateral that can be liquidated, given the\r\n        //max amount of principal currency that is available for liquidation.\r\n        vars.maxAmountCollateralToLiquidate = vars\r\n            .principalCurrencyPrice\r\n            .mul(_purchaseAmount)\r\n            .div(vars.collateralPrice)\r\n            .mul(vars.liquidationBonus)\r\n            .div(100);\r\n\r\n        if (vars.maxAmountCollateralToLiquidate > _userCollateralBalance) {\r\n            collateralAmount = _userCollateralBalance;\r\n            principalAmountNeeded = vars\r\n                .collateralPrice\r\n                .mul(collateralAmount)\r\n                .div(vars.principalCurrencyPrice)\r\n                .mul(100)\r\n                .div(vars.liquidationBonus);\r\n        } else {\r\n            collateralAmount = vars.maxAmountCollateralToLiquidate;\r\n            principalAmountNeeded = _purchaseAmount;\r\n        }\r\n\r\n        return (collateralAmount, principalAmountNeeded);\r\n    }\r\n}",
            "abi": "[{\"inputs\":[{\"internalType\":\"contract LendingPoolAddressesProvider\",\"name\":\"_addressesProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_underlyingAssetDecimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toIndex\",\"type\":\"uint256\"}],\"name\":\"BalanceTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"BurnOnLiquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"InterestRedirectionAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"InterestStreamRedirected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"MintOnDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromIndex\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_targetBalanceIncrease\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_targetIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalanceAdded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_redirectedBalanceRemoved\",\"type\":\"uint256\"}],\"name\":\"RedirectedBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"UINT_MAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"allowInterestRedirectionTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnOnLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getInterestRedirectionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRedirectedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintOnDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"principalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"redirectInterestStream\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"redirectInterestStreamOf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferOnLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlyingAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
            "verified": true,
            "owner": null,
            "creator": "0x2fbb0c60a41cb7ea5323071624dcead3d213d0fa",
            "is_hidden_owner": true,
            "is_proxy": false,
            "is_sellable": false,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": true,
                    "snippets": [
                        "    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"erc20: mint to the zero address\");\n\n        _totalsupply = _totalsupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit transfer(address(0), account, amount);\n    }",
                        "    function redirectintereststream(address _to) external {\n        redirectintereststreaminternal(msg.sender, _to);\n    }",
                        "    function redirectintereststreamof(address _from, address _to) external {\n        require(\n            msg.sender == interestredirectionallowances[_from],\n            \"caller is not allowed to redirect the interest of the user\"\n        );\n        redirectintereststreaminternal(_from,_to);\n    }",
                        "    function mintondeposit(address _account, uint256 _amount) external onlylendingpool {\n\n        //cumulates the balance of the user\n        (,\n        ,\n        uint256 balanceincrease,\n        uint256 index) = cumulatebalanceinternal(_account);\n\n         //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest\n        //and the amount deposited\n        updateredirectedbalanceofredirectionaddressinternal(_account, balanceincrease.add(_amount), 0);\n\n        //mint an equivalent amount of tokens to cover the new deposit\n        _mint(_account, _amount);\n\n        emit mintondeposit(_account, _amount, balanceincrease, index);\n    }",
                        "    function redirectintereststreaminternal(\n        address _from,",
                        "    function getreserveliquidationbonus(address _reserve) external view returns (uint256) {\n        corelibrary.reservedata storage reserve = reserves[_reserve];\n        return reserve.liquidationbonus;\n    }",
                        "    function removelastaddedreserve(address _reservetoremove)\n     external onlylendingpoolconfigurator {\n\n        address lastreserve = reserveslist[reserveslist.length-1];\n\n        require(lastreserve == _reservetoremove, \"reserve being removed is different than the reserve requested\");\n\n        //as we can't check if totalliquidity is 0 (since the reserve added might not be an erc20) we at least check that there is nothing borrowed\n        require(getreservetotalborrows(lastreserve) == 0, \"cannot remove a reserve with liquidity deposited\");\n\n        reserves[lastreserve].isactive = false;\n        reserves[lastreserve].atokenaddress = address(0);\n        reserves[lastreserve].decimals = 0;\n        reserves[lastreserve].lastliquiditycumulativeindex = 0;\n        reserves[lastreserve].lastvariableborrowcumulativeindex = 0;\n        reserves[lastreserve].borrowingenabled = false;\n        reserves[lastreserve].usageascollateralenabled = false;\n        reserves[lastreserve].baseltvascollateral = 0;\n        reserves[lastreserve].liquidationthreshold = 0;\n        reserves[lastreserve].liquidationbonus = 0;\n        reserves[lastreserve].interestratestrategyaddress = address(0);\n\n        reserveslist.pop();\n    }",
                        "    function setreserveliquidationbonus(address _reserve, uint256 _bonus)\n        external"
                    ],
                    "snippets_number": 8
                },
                "ownership_renounced": {
                    "found": true,
                    "snippets": [
                        "    function calloptionalreturn(ierc20 token, bytes memory data) private {\n        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // a solidity high level call has three parts:\n        //  1. the target address is checked to verify it contains contract code\n        //  2. the call itself is made, and success asserted\n        //  3. the return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).iscontract(), \"safeerc20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"safeerc20: low-level call failed\");\n\n        if (returndata.length > 0) { // return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"safeerc20: erc20 operation did not succeed\");\n        }\n    }",
                        "    function renounceownership() public onlyowner {\n        emit ownershiptransferred(_owner, address(0));\n        _owner = address(0);\n    }"
                    ],
                    "snippets_number": 2
                },
                "is_honeypot_suspected": {
                    "found": true,
                    "snippets": [
                        "    function calloptionalreturn(ierc20 token, bytes memory data) private {\n        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // a solidity high level call has three parts:\n        //  1. the target address is checked to verify it contains contract code\n        //  2. the call itself is made, and success asserted\n        //  3. the return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).iscontract(), \"safeerc20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"safeerc20: low-level call failed\");\n\n        if (returndata.length > 0) { // return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"safeerc20: erc20 operation did not succeed\");\n        }\n    }",
                        "    function redeem(uint256 _amount) external {\n\n        require(_amount > 0, \"amount to redeem needs to be > 0\");\n\n        //cumulates the balance of the user\n        (,\n        uint256 currentbalance,\n        uint256 balanceincrease,\n        uint256 index) = cumulatebalanceinternal(msg.sender);\n\n        uint256 amounttoredeem = _amount;\n\n        //if amount is equal to uint(-1), the user wants to redeem everything\n        if(_amount == uint_max_value){\n            amounttoredeem = currentbalance;\n        }\n\n        require(amounttoredeem <= currentbalance, \"user cannot redeem more than the available balance\");\n\n        //check that the user is allowed to redeem the amount\n        require(istransferallowed(msg.sender, amounttoredeem), \"transfer cannot be allowed.\");\n\n        //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest,\n        //and removing the amount to redeem\n        updateredirectedbalanceofredirectionaddressinternal(msg.sender, balanceincrease, amounttoredeem);\n\n        // burns tokens equivalent to the amount requested\n        _burn(msg.sender, amounttoredeem);\n\n        bool userindexreset = false;\n        //reset the user data if the remaining balance is 0\n        if(currentbalance.sub(amounttoredeem) == 0){\n            userindexreset = resetdataonzerobalanceinternal(msg.sender);\n        }\n\n        // executes redeem of the underlying asset\n        pool.redeemunderlying(\n            underlyingassetaddress,\n            msg.sender,\n            amounttoredeem,\n            currentbalance.sub(amounttoredeem)\n        );\n\n        emit redeem(msg.sender, amounttoredeem, balanceincrease, userindexreset ? 0 : index);\n    }",
                        "    function istransferallowed(address _user, uint256 _amount) public view returns (bool) {\n        return dataprovider.balancedecreaseallowed(underlyingassetaddress, _user, _amount);\n    }"
                    ],
                    "snippets_number": 3
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": true,
                    "snippets": [
                        "    function safeapprove(ierc20 token, address spender, uint256 value) internal {\n        // safeapprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. to increase and decrease it, use\n        // 'safeincreaseallowance' and 'safedecreaseallowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"safeerc20: approve from non-zero to non-zero allowance\"\n        );\n        calloptionalreturn(token, abi.encodewithselector(token.approve.selector, spender, value));\n    }",
                        "    function calloptionalreturn(ierc20 token, bytes memory data) private {\n        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // a solidity high level call has three parts:\n        //  1. the target address is checked to verify it contains contract code\n        //  2. the call itself is made, and success asserted\n        //  3. the return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).iscontract(), \"safeerc20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"safeerc20: low-level call failed\");\n\n        if (returndata.length > 0) { // return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"safeerc20: erc20 operation did not succeed\");\n        }\n    }",
                        "    function setfeeproviderimpl(address _feeprovider) public;\n",
                        "    function getfeeprovider() public view returns (address) {\n        return getaddress(fee_provider);\n    }",
                        "    function setfeeproviderimpl(address _feeprovider) public onlyowner {\n        updateimplinternal(fee_provider, _feeprovider);\n        emit feeproviderupdated(_feeprovider);\n    }",
                        "    function getflashloanfeesinbips() external pure returns (uint256, uint256) {\n        return (flashloan_fee_total, flashloan_fee_protocol);\n    }",
                        "    function getloanoriginationfeepercentage() external view returns (uint256);\n}",
                        "    function mintondeposit(address _account, uint256 _amount) external onlylendingpool {\n\n        //cumulates the balance of the user\n        (,\n        ,\n        uint256 balanceincrease,\n        uint256 index) = cumulatebalanceinternal(_account);\n\n         //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest\n        //and the amount deposited\n        updateredirectedbalanceofredirectionaddressinternal(_account, balanceincrease.add(_amount), 0);\n\n        //mint an equivalent amount of tokens to cover the new deposit\n        _mint(_account, _amount);\n\n        emit mintondeposit(_account, _amount, balanceincrease, index);\n    }",
                        "    function executeoperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\n}",
                        "    function updatestateondeposit(\n        address _reserve,",
                        "    function updatestateonswaprate(\n        address _reserve,",
                        "    function transfertofeecollectionaddress(\n        address _token,",
                        "    function liquidatefee(\n        address _token,",
                        "    function getuseroriginationfee(address _reserve, address _user)\n        external",
                        "    function removelastaddedreserve(address _reservetoremove)\n     external onlylendingpoolconfigurator {\n\n        address lastreserve = reserveslist[reserveslist.length-1];\n\n        require(lastreserve == _reservetoremove, \"reserve being removed is different than the reserve requested\");\n\n        //as we can't check if totalliquidity is 0 (since the reserve added might not be an erc20) we at least check that there is nothing borrowed\n        require(getreservetotalborrows(lastreserve) == 0, \"cannot remove a reserve with liquidity deposited\");\n\n        reserves[lastreserve].isactive = false;\n        reserves[lastreserve].atokenaddress = address(0);\n        reserves[lastreserve].decimals = 0;\n        reserves[lastreserve].lastliquiditycumulativeindex = 0;\n        reserves[lastreserve].lastvariableborrowcumulativeindex = 0;\n        reserves[lastreserve].borrowingenabled = false;\n        reserves[lastreserve].usageascollateralenabled = false;\n        reserves[lastreserve].baseltvascollateral = 0;\n        reserves[lastreserve].liquidationthreshold = 0;\n        reserves[lastreserve].liquidationbonus = 0;\n        reserves[lastreserve].interestratestrategyaddress = address(0);\n\n        reserveslist.pop();\n    }",
                        "    function updatereservestateonswaprateinternal(\n        address _reserve,",
                        "    function updateuserstateonswaprateinternal(\n        address _reserve,",
                        "    function transferflashloanprotocolfeeinternal(address _token, uint256 _amount) internal {\n        address payable receiver = address(uint160(addressesprovider.gettokendistributor()));\n\n        if (_token != ethaddresslib.ethaddress()) {\n            erc20(_token).safetransfer(receiver, _amount);\n        } else {\n            receiver.transfer(_amount);\n        }\n    }",
                        "    function initialize(lendingpooladdressesprovider _addressesprovider) public initializer {\n        addressesprovider = _addressesprovider;\n        core = lendingpoolcore(addressesprovider.getlendingpoolcore());\n        dataprovider = lendingpooldataprovider(addressesprovider.getlendingpooldataprovider());\n        parametersprovider = lendingpoolparametersprovider(\n            addressesprovider.getlendingpoolparametersprovider()\n        );\n        feeprovider = ifeeprovider(addressesprovider.getfeeprovider());\n    }",
                        "    function deposit(address _reserve, uint256 _amount, uint16 _referralcode)\n        external",
                        "    function swapborrowratemode(address _reserve)\n        external"
                    ],
                    "snippets_number": 21
                },
                "blacklist_or_whitelist_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 200,
            "holders_list": {
                "0x0e976211b38c623f5d882ed0859f34d85527b35a": {
                    "balance": 13000018283689452503040,
                    "percentage_of_total_supply": 17.074008417261314,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x302037d4f06c4258d742428a78e1f3774d58bb70": {
                    "balance": 11725553656320000786432,
                    "percentage_of_total_supply": 15.40014771181066,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbd83d8f4c1d132d74724891df4257f8f059347aa": {
                    "balance": 10000000000000000000000,
                    "percentage_of_total_supply": 13.133834156743701,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf8422385032dcded2e8af849058ae32543a3665e": {
                    "balance": 5016725806805514452992,
                    "percentage_of_total_supply": 6.5888844756439875,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa38a488b74b14a1005eda3518a3a71408af3fed8": {
                    "balance": 2888569548599999856640,
                    "percentage_of_total_supply": 3.7937993401532415,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x328184c03e8d4468730a755ecf20b2dd01c76991": {
                    "balance": 2121593878317543981056,
                    "percentage_of_total_supply": 2.78646621457853,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2d6f46e2aa0f900f75aa68be57eabb70be1db5ba": {
                    "balance": 1993800000000000000000,
                    "percentage_of_total_supply": 2.6186238541715587,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x815362b1908004e06be568b23768d8bcec7b3cec": {
                    "balance": 1808329585090291040256,
                    "percentage_of_total_supply": 2.375030087130903,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8d205d869f9d5451712b10f3dd5254a118f0bd6f": {
                    "balance": 1503260979069999906816,
                    "percentage_of_total_supply": 1.974358039340954,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1d7386afa54bc8f8e815f58fcc669ea88b605e6b": {
                    "balance": 1498328000000000000000,
                    "percentage_of_total_supply": 1.9678791464405476,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3300959c2d32f93401a5e7d01f9ce3deafb4404f": {
                    "balance": 1354111523846985089024,
                    "percentage_of_total_supply": 1.7784676183941794,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd6fd905931d32f206c87f36cc9f29e1fe10a6940": {
                    "balance": 1346871308429999996928,
                    "percentage_of_total_supply": 1.7689584395396016,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa1a282db6707c3d77c8bd6a2234fb56cdf27fa74": {
                    "balance": 1200000000000000000000,
                    "percentage_of_total_supply": 1.5760600988092441,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd378f6a3a958c7aae49e59ce8f21158e148b079f": {
                    "balance": 1115111606999999971328,
                    "percentage_of_total_supply": 1.4645690912597957,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x53755b1acc4fcf3df944c000cd1e16428a88d5b6": {
                    "balance": 1018268041239999938560,
                    "percentage_of_total_supply": 1.3373763580758415,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3885eb1621ec6d97bc6fde6fdf3c088db704e844": {
                    "balance": 960520459410000052224,
                    "percentage_of_total_supply": 1.261531641805021,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x55b8e2c4ae5951d1a8e77d0e513a6e598ee0be86": {
                    "balance": 815791551419477131264,
                    "percentage_of_total_supply": 1.0714470942816063,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9eb45be82e65186bd2ea8d2f0b995c3c34857d7d": {
                    "balance": 800000000000000000000,
                    "percentage_of_total_supply": 1.050706732539496,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf3a463ec537b8024bd69d756df0d548c148ba4f6": {
                    "balance": 711897204665650511872,
                    "percentage_of_total_supply": 0.9349939822728082,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfe7bcb3676aabe9a6b39cb23f3a5fa41eed7ad1b": {
                    "balance": 698304657069527924736,
                    "percentage_of_total_supply": 0.9171417556832963,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x83fbbf69517fb34c69e0dccfdf0d2d3f80232005": {
                    "balance": 662178902320000008192,
                    "percentage_of_total_supply": 0.8696947885165467,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6694f15e5384a552884f538a2b4f212e750bc4d8": {
                    "balance": 656093402429999939584,
                    "percentage_of_total_supply": 0.8617021938849324,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd3b07031cc5eedc55af5d0419ea6a21056ac5da3": {
                    "balance": 641020647426853437440,
                    "percentage_of_total_supply": 0.841905887435277,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x61dc2d7cc88d72be25eb287354c934cefa244223": {
                    "balance": 585080000000000000000,
                    "percentage_of_total_supply": 0.7684343688427605,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6b0e6639399aa75a2dfb64f258c2a7e723334b69": {
                    "balance": 525000000000000000000,
                    "percentage_of_total_supply": 0.6895262932290442,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4321ff95a1bfba35fc6e13352dbbd74bc792d76d": {
                    "balance": 472543082240000000000,
                    "percentage_of_total_supply": 0.620630247405666,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x663c17234fb49b5e6f372a32fb97feb1d4a059df": {
                    "balance": 445282777672682700800,
                    "percentage_of_total_supply": 0.5848270154807191,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xb03ec001a41d37a4d1dff55857f0e07cd9d388f0": {
                    "balance": 419147393259999985664,
                    "percentage_of_total_supply": 0.5505012350308272,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfe4bb7f517be3460ed363889e3dc5f9ec80adef4": {
                    "balance": 402193026130000019456,
                    "percentage_of_total_supply": 0.5282336504190306,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3fc141d8dc3dafcfecf92936a68b526bf2d1640c": {
                    "balance": 395232495077283397632,
                    "percentage_of_total_supply": 0.5190918043701062,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x839f19b7ef7ddd0eca99715390086ca97265a3da": {
                    "balance": 343001394862785429504,
                    "percentage_of_total_supply": 0.45049234356595846,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc55e44d797db70249b5e0bcb6ad322ee75830e83": {
                    "balance": 310000000000000000000,
                    "percentage_of_total_supply": 0.4071488588590548,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf38507a1e7890f056814e84b1f79d7adf398464f": {
                    "balance": 300000000000000000000,
                    "percentage_of_total_supply": 0.39401502470231103,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4979b8d84ae7618da4a10defada9c2a506fcd915": {
                    "balance": 300000000000000000000,
                    "percentage_of_total_supply": 0.39401502470231103,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcd61137d2fd64283a45749bd62e4364d8924ad3b": {
                    "balance": 267963360499999997952,
                    "percentage_of_total_supply": 0.3519386336890726,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x948194d7e80a2c506e8fb8123a72ade13a1798fa": {
                    "balance": 255885547329999994880,
                    "percentage_of_total_supply": 0.3360758341739811,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdf60dcbb3bfcf9b4cd6e12359b27b6740013bbb5": {
                    "balance": 255657220574627528704,
                    "percentage_of_total_supply": 0.33577595360012014,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3398a37a716239b3bc4ecfbc05535c40ea9ca5f8": {
                    "balance": 247552663761835884544,
                    "percentage_of_total_supply": 0.3251315630908089,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x04f10a3dbd1cca699748ad02bbd5290ebfb03553": {
                    "balance": 240412918697297575936,
                    "percentage_of_total_supply": 0.31575434033090133,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd3ea9be28b71c8eb52cac2686f1f722e5c86ca2e": {
                    "balance": 228657482280771715072,
                    "percentage_of_total_supply": 0.30031494509742174,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4b5160ab8efec1742f20a74428e08790cbc90a48": {
                    "balance": 224984890700000002048,
                    "percentage_of_total_supply": 0.2954914242226908,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfb514ee258c829df0e768e3df372e0d403aa42a9": {
                    "balance": 215159688494525153280,
                    "percentage_of_total_supply": 0.2825871665903729,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x83abf943785244cebdcf232929627745a7026f51": {
                    "balance": 204907749048702500864,
                    "percentage_of_total_supply": 0.26912243934373153,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xebdfd63f69a5ee9f31897938b95c9accd430d5bf": {
                    "balance": 200000001028808605696,
                    "percentage_of_total_supply": 0.26267668448609416,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfab9718db7cee30bad26157bf0500894fefbaab8": {
                    "balance": 200000000000000000000,
                    "percentage_of_total_supply": 0.262676683134874,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xccd935a3d9e8bc78ea67e19cb2e9c1c2919ab92a": {
                    "balance": 196716121151825444864,
                    "percentage_of_total_supply": 0.25836369111659774,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x392d8cdcd5b98981389cce105e2ea8495d48e90a": {
                    "balance": 196006379640074960896,
                    "percentage_of_total_supply": 0.257431528385649,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbb34fe1227303ac6121092783dce6fc567a57034": {
                    "balance": 191743000000000000000,
                    "percentage_of_total_supply": 0.2518320762716508,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x34cb8c7bc0e0cb5d0ffc4a8d5cb373a255db598e": {
                    "balance": 160857425623823056896,
                    "percentage_of_total_supply": 0.21126747510240265,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbe8728b5992194647838943a900123077f5500e8": {
                    "balance": 158301945083950891008,
                    "percentage_of_total_supply": 0.207911149342256,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4d5522427aaed18886f4c8af4be37c081fbefa88": {
                    "balance": 156549699539241467904,
                    "percentage_of_total_supply": 0.2056097791036453,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x61af3966da969b3204e4cfa75761edbd5db92442": {
                    "balance": 151299997568130482176,
                    "percentage_of_total_supply": 0.1987149075975551,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdeaa598d3632bcc0a2999a24520b826608ce8c02": {
                    "balance": 125400990572059574272,
                    "percentage_of_total_supply": 0.16469958132648108,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7925794445ff3665038117fb54f3478fbb1317ac": {
                    "balance": 125000000000000000000,
                    "percentage_of_total_supply": 0.16417292695929628,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xce914dd7a9f90353b598953bd45a79000cb78233": {
                    "balance": 113788411256047910912,
                    "percentage_of_total_supply": 0.14944781223962816,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x82feee8e969c3f79d5c3b971315c95eb042180f4": {
                    "balance": 108411514100452327424,
                    "percentage_of_total_supply": 0.1423858846876822,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xda874f844389df33c0fad140df4970fe1b366726": {
                    "balance": 107672320020600750080,
                    "percentage_of_total_supply": 0.1414150394422405,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc2b077ca6a7f3df06e43c1c776242cab8c0fa267": {
                    "balance": 105103245880000004096,
                    "percentage_of_total_supply": 0.1380408600723376,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x065c965f2c8f7478e0f81042b1c07313bad30d6b": {
                    "balance": 100000425016892850176,
                    "percentage_of_total_supply": 0.13133889977757546,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd603b61e0a0552f9f1a3775d99262c8f570a24ed": {
                    "balance": 100000000073417555968,
                    "percentage_of_total_supply": 0.13133834166386243,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x42627c54ebef07bf50a8d1127940fa5e834d81ca": {
                    "balance": 100000000000000000000,
                    "percentage_of_total_supply": 0.131338341567437,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x962e1ed475389b32aa7b8cef9f999cef0a6ae82e": {
                    "balance": 100000000000000000000,
                    "percentage_of_total_supply": 0.131338341567437,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4aa049222c62533f26578842574b6a542abc6d31": {
                    "balance": 100000000000000000000,
                    "percentage_of_total_supply": 0.131338341567437,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd7f8c284c8ab88a0329966a0e939a7854d2da175": {
                    "balance": 99818160059999993856,
                    "percentage_of_total_supply": 0.13109951600593378,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd2628ea414c98b6c93de255504ab3ae050a0521e": {
                    "balance": 97336973507884072960,
                    "percentage_of_total_supply": 0.12784076673719044,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xb1c91bf26ad7d580d0ceb93f3f7659c347871555": {
                    "balance": 95235978698388357120,
                    "percentage_of_total_supply": 0.12508135499798087,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5b7a7379a97a33341376bcf85fe6a7f47b49ca0b": {
                    "balance": 91897099485174267904,
                    "percentage_of_total_supply": 0.12069612641240558,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa0bb038a8981fc526fecf3fcea8701312d932e86": {
                    "balance": 88338342578860425216,
                    "percentage_of_total_supply": 0.11602211411123635,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf86b6d7c82597de4441c4d3df218824672990fc9": {
                    "balance": 86030212970000007168,
                    "percentage_of_total_supply": 0.1129906549617321,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x337116108553db7d0f6ab10b1fce85d7d072b7e2": {
                    "balance": 85300050339128918016,
                    "percentage_of_total_supply": 0.11203167147160085,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x36943c2e4cfe6ec7c24166f066c81ac84096c1b0": {
                    "balance": 81910423692773408768,
                    "percentage_of_total_supply": 0.10757979204894959,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcce4bd1d08aec08de12ac7730ac4facd143a2abf": {
                    "balance": 79158452180420739072,
                    "percentage_of_total_supply": 0.10396539830421728,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe96653aaa2e52887225a1cbce12148edd4ba1c7e": {
                    "balance": 77508209920000000000,
                    "percentage_of_total_supply": 0.1017979974875357,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x47999bca436053480df4d12399f5498306a11f7d": {
                    "balance": 68191503900000002048,
                    "percentage_of_total_supply": 0.08956159031215413,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6a3a1ca139a6bdff2fcda84e266b8057c311a609": {
                    "balance": 64870746690000003072,
                    "percentage_of_total_supply": 0.08520016286505905,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf88e565cdfad36e796b70ec075b9bf3e10ad2ead": {
                    "balance": 61888165940458971136,
                    "percentage_of_total_supply": 0.08128289077270222,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe40afc776c18d8925199dcce78d0b06c9222b896": {
                    "balance": 58473398070773694464,
                    "percentage_of_total_supply": 0.07679799128427987,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbef0ad760b9788b755e2bff513099405080af865": {
                    "balance": 58274035931347206144,
                    "percentage_of_total_supply": 0.07653615235664377,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0addaf96125e360904aa8e945889a9e1d60cf2f3": {
                    "balance": 57047603129999998976,
                    "percentage_of_total_supply": 0.07492537585491528,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x94b6dcf72ecaae9ce0f2a00188e26f5391993e94": {
                    "balance": 56994883633859518464,
                    "percentage_of_total_supply": 0.07485613494300167,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x583509a34553ae917a820b2702c9d6aa61e22818": {
                    "balance": 55991689836461334528,
                    "percentage_of_total_supply": 0.0735385568467915,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x973331837f2c0be230faacf4a2ab83679eeb0e00": {
                    "balance": 50456377938453307392,
                    "percentage_of_total_supply": 0.06626856999936274,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5b919e7e08ada8b0fb0169b2f37d34ec7d17c81c": {
                    "balance": 48625393049724182528,
                    "percentage_of_total_supply": 0.06386378481215553,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9055191182d345054b53bcd94f348b1965c83674": {
                    "balance": 46595176760000004096,
                    "percentage_of_total_supply": 0.061197332406999844,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x607955751aeb540c9b5a3ebf6add50345a69c32c": {
                    "balance": 42700843309999996928,
                    "percentage_of_total_supply": 0.056082579438663877,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa67be45c4e5c54b44b28c79b7af28aa313ec39e0": {
                    "balance": 41921363299999997952,
                    "percentage_of_total_supply": 0.055058823320680184,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4dbc360b9608fafc233092b96986c5549bdd1f0d": {
                    "balance": 39297877910000001024,
                    "percentage_of_total_supply": 0.05161318111819018,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd54e6cf8aa560d28f8c889f6eb869fbc77d1d49b": {
                    "balance": 36359684249999998976,
                    "percentage_of_total_supply": 0.047754206293106595,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcacbdb0d7f56f43ac4dd74684fffc8a48ca80118": {
                    "balance": 34625000000000000000,
                    "percentage_of_total_supply": 0.045475900767725064,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7a8e7b7197e94d2cb194dbed7a80575c047a7575": {
                    "balance": 33520857036910297088,
                    "percentage_of_total_supply": 0.0440257377114695,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdad4c11e8cc6a5c37808d3b31b3b284809f702d1": {
                    "balance": 30000000000000000000,
                    "percentage_of_total_supply": 0.0394015024702311,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x42349e0048e9da478a07aa5f146d9ac3dc677b03": {
                    "balance": 30000000000000000000,
                    "percentage_of_total_supply": 0.0394015024702311,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x973c9d264d6c18df73a4d5d592a57770589c1cd9": {
                    "balance": 27810472309371269120,
                    "percentage_of_total_supply": 0.03652581311319952,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xba80790e0aecae07d7eddaf99ba788739c002436": {
                    "balance": 26219267919967342592,
                    "percentage_of_total_supply": 0.03443595165720815,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3f6f7276a388d7cf365f4ae85979443561ae030a": {
                    "balance": 25053263548258660352,
                    "percentage_of_total_supply": 0.03290454085280215,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc9784bae7b3ce53580821e01eb82c6b1ce411e03": {
                    "balance": 24896487237123031040,
                    "percentage_of_total_supply": 0.03269863344578601,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x11bd5ed522b067390314c256e36d90b1f8b8ef33": {
                    "balance": 24715458860000002048,
                    "percentage_of_total_supply": 0.03246087377750617,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3b7d96dcce69edabac5aa9fec4fdfcb1f54c76be": {
                    "balance": 23113627550000001024,
                    "percentage_of_total_supply": 0.030357055100244227,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8219da4a0514dbbd29d4521fc50a2bca2f668f42": {
                    "balance": 16493012960000000000,
                    "percentage_of_total_supply": 0.021661649696166456,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xad346c7762f74c78da86d2941c6eb546e316fbd0": {
                    "balance": 15507031370623893504,
                    "percentage_of_total_supply": 0.02036667782851962,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x85b6a47cf3d31aa54b425a837c8530a2382d8125": {
                    "balance": 14970465226970019840,
                    "percentage_of_total_supply": 0.01966196075403227,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0d80b3000b3170f83602190867c905b768dc1cc5": {
                    "balance": 14636490717410187264,
                    "percentage_of_total_supply": 0.019223324171918403,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8e22b1a86dac78e7aaeac5e4c6a27d7b57864a16": {
                    "balance": 14492753624999999488,
                    "percentage_of_total_supply": 0.01903454225852961,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x353bec4ea7cdf6029b93a284fbabaa13e719d3e8": {
                    "balance": 13298691193176143872,
                    "percentage_of_total_supply": 0.01746628046329235,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2c348fa2c2f282b435094c9277074375a9fae6d1": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.0131338341567437,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x78f32a27559170f9a005b319ed53441b9e852158": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.0131338341567437,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5f121c60f501781eaf323c1c27fa9caf028f6a40": {
                    "balance": 9980099502487560192,
                    "percentage_of_total_supply": 0.013107697173347194,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7fb8f436d5c6d16a9f20110443a315891baa3708": {
                    "balance": 9773544642221508608,
                    "percentage_of_total_supply": 0.012836411445446824,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc60c784a4556126720b113e12fe950163427499c": {
                    "balance": 9693954732912207872,
                    "percentage_of_total_supply": 0.012731879378504962,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x571a6a108adb08f9ca54fe8605280f9ee0ed4af6": {
                    "balance": 9565906974475335680,
                    "percentage_of_total_supply": 0.012563703576159695,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x011965bdba6a0a7e9245f29d0755547d5fb6604e": {
                    "balance": 9016507530000000000,
                    "percentage_of_total_supply": 0.011842131457205078,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x230a4e0d273fd89e749129029fc1d469069ceb7e": {
                    "balance": 7582659958721046528,
                    "percentage_of_total_supply": 0.009958939836482326,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1edac1f2ca7eee84d105c9ff98f984c2851406de": {
                    "balance": 6778690535287727104,
                    "percentage_of_total_supply": 0.008903019729035719,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x68a17b587caf4f9329f0e372e3a78d23a46de6b5": {
                    "balance": 6071394209478437888,
                    "percentage_of_total_supply": 0.007974068464750383,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1c91b6f03f781593cb2a429e479091e493ec1c4d": {
                    "balance": 6035163352466149376,
                    "percentage_of_total_supply": 0.007926483458014773,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x446cf290cf48480f996b03a89dd9d03ee9a83779": {
                    "balance": 5411235420000000000,
                    "percentage_of_total_supply": 0.007107026858937735,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x602f69e8f5896fdbcefceadd7eb769b837c96e05": {
                    "balance": 5106889051682483200,
                    "percentage_of_total_supply": 0.006707303386168784,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2cc34136643911c8cf2aac28b0a6fe7accd70911": {
                    "balance": 5001581382782907392,
                    "percentage_of_total_supply": 0.006568994040292754,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x77d25848b2396250df5860ae566f7c341d81efac": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.00656691707837185,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8033562521fedecdcc05487303522375597f9094": {
                    "balance": 4611620795108062208,
                    "percentage_of_total_supply": 0.0060568262716739815,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x044a6041d8ae8f23a5a095dc2884297ffefb3f8d": {
                    "balance": 4328851065576280064,
                    "percentage_of_total_supply": 0.0056854411984522115,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x42065376eb96b313ffffd97de658848f33628e1f": {
                    "balance": 3780805710000000000,
                    "percentage_of_total_supply": 0.0049656475174009625,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9e250ee8ad4a8eef6eb03452813879f086d61441": {
                    "balance": 3455260009072489984,
                    "percentage_of_total_supply": 0.004538081192758682,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x05ef80bbca154cd63b43728421dea896fdbc5295": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.00394015024702311,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfc377aed5d0a379fcab2ddae735a7ea5369df8b2": {
                    "balance": 2508171758845596160,
                    "percentage_of_total_supply": 0.0032941911917306215,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4231fdfff585b02d78c65c4fc8e44867990b45dd": {
                    "balance": 2388283186266825216,
                    "percentage_of_total_supply": 0.0031367315287767904,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3c25c2f2c920a39030d1d6288f7c0846cd91e0b7": {
                    "balance": 2126801530399918592,
                    "percentage_of_total_supply": 0.002793305858458123,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x073dd1d8e25e630fa7f1c51b69e9bdac3c210293": {
                    "balance": 1940000000000000000,
                    "percentage_of_total_supply": 0.002547963826408278,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7e05faa0c088d5a92593a404826fe1f16fde8472": {
                    "balance": 1190067562898996992,
                    "percentage_of_total_supply": 0.0015630150006435578,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4420f4efa831d9fa76109c6fc9378e8759d365df": {
                    "balance": 1000000000000000000,
                    "percentage_of_total_supply": 0.0013133834156743701,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9d2685ae39388e39438e9aa9c670390c243a9a85": {
                    "balance": 1000000000000000000,
                    "percentage_of_total_supply": 0.0013133834156743701,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4af1afc2516b3eaa06a4645fb16bfcdc2fa28906": {
                    "balance": 902336058576934912,
                    "percentage_of_total_supply": 0.0011851132146999232,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6a7904f0ba2ded9c41a8b03a36b3880c174a5597": {
                    "balance": 614472998391156352,
                    "percentage_of_total_supply": 0.0008070386454666486,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xacf98af36845ec9aeda29feed2907ea287388cf3": {
                    "balance": 566981318975347072,
                    "percentage_of_total_supply": 0.0007446638613394009,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x890790e70511ab0868f362a8004fb44e8a52c55a": {
                    "balance": 425377397685783296,
                    "percentage_of_total_supply": 0.000558683619523229,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9e77162d6e50e6d8bdb5e0de7da8653e21f63350": {
                    "balance": 394303874368129472,
                    "percentage_of_total_supply": 0.0005178721693312517,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xb1720612d0131839dc489fcf20398ea925282fca": {
                    "balance": 375317917129397376,
                    "percentage_of_total_supply": 0.0004929363279631981,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x373ee50362218860652c15babf53879d8076bbf2": {
                    "balance": 166109421722869184,
                    "percentage_of_total_supply": 0.0002181653596780763,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x47f7ea0dd4418aa1cec00786f5c47623ac37ba42": {
                    "balance": 70728611642431976,
                    "percentage_of_total_supply": 9.289378554484333e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4c9df57276dc17dee5635ded208c07b0be32afd0": {
                    "balance": 65754697669973704,
                    "percentage_of_total_supply": 8.636112942242561e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd1a8dd23e356b9fae27df5def9ea025a602ec81e": {
                    "balance": 9895779225958172,
                    "percentage_of_total_supply": 1.299695232054842e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3a29267ca2418aa4e81a72d3c39f8854f648b369": {
                    "balance": 6790779927080610,
                    "percentage_of_total_supply": 8.918897735722081e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcfb7ab914c8b93391cb5b2ba95fa7239e1ee2bbc": {
                    "balance": 5299447408903364,
                    "percentage_of_total_supply": 6.960206339092191e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x90b30f9387d67a1f722a600029d2f7615c2e0e70": {
                    "balance": 4263416480748285,
                    "percentage_of_total_supply": 5.599500499927585e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x55d9245895495bc38c5ed5faefae9cde5b50db70": {
                    "balance": 2953635514101964,
                    "percentage_of_total_supply": 3.879255900168361e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x13b9fbd6d642db0c9f54f58b21abca7e8cac48de": {
                    "balance": 2951706455562653,
                    "percentage_of_total_supply": 3.876722306674966e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9d5025b327e6b863e5050141c987d988c07fd8b2": {
                    "balance": 2732866849802852,
                    "percentage_of_total_supply": 3.5893019977773256e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd51e0b1a8953eba9f063c4852b46865392c7dab1": {
                    "balance": 1790469603020370,
                    "percentage_of_total_supply": 2.351573082876027e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd5231e5a2e90aae268dca3ce87b687618760d36a": {
                    "balance": 1732731586272931,
                    "percentage_of_total_supply": 2.275740929226012e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x959a88c769fa377c5cd95649d270cd415c4e2f66": {
                    "balance": 1269835777624542,
                    "percentage_of_total_supply": 1.6677812509620409e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x03dfb24f6c8079468230abbad99dad56f7f67b50": {
                    "balance": 772335119019455,
                    "percentage_of_total_supply": 1.014372136663043e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x165be24e4678d7bfa9fc8d58a275dd93b98aa008": {
                    "balance": 754714405360906,
                    "percentage_of_total_supply": 9.912293835715578e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x309035272aed1fb538a2dbc476508c4dd4c70ffb": {
                    "balance": 479682949292483,
                    "percentage_of_total_supply": 6.30007630382517e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x86d4e948153328209cfd1ece16158f724ca356cb": {
                    "balance": 376262040120992,
                    "percentage_of_total_supply": 4.941763234427154e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2e2338a3568cc7f5a74cde4038077eca7482b794": {
                    "balance": 294930175784128,
                    "percentage_of_total_supply": 3.873564016568005e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xce2a3294f800b1bf9a907db3c7e377cf9486a456": {
                    "balance": 236954030120369,
                    "percentage_of_total_supply": 3.112114934372978e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfd97b288ddd0012bd95ffed61b16d1c80ef4e6c3": {
                    "balance": 218405653768157,
                    "percentage_of_total_supply": 2.8685036354861593e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf23b6f71a0574b55f03cb2e42166e60b1754d145": {
                    "balance": 99000000000000,
                    "percentage_of_total_supply": 1.3002495815176264e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1a03d916ff1e2a5a3bc1a8200c7368af2e9e074b": {
                    "balance": 94025951149844,
                    "percentage_of_total_supply": 1.234921248832136e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x13b1b1060e0ad50cba36372c31b74124dd3c8945": {
                    "balance": 64745543101821,
                    "percentage_of_total_supply": 8.503572254876181e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xec6e6c0841a2ba474e92bf42baf76bfe80e8657c": {
                    "balance": 59169349510139,
                    "percentage_of_total_supply": 7.771204236285697e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8ca21f3c66e482069deade93476bdf2b39b692fb": {
                    "balance": 55794040937784,
                    "percentage_of_total_supply": 7.327896806114238e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x44b97b5ca0d8ca50de1fcf2f640a9bd41c7421de": {
                    "balance": 50835921954041,
                    "percentage_of_total_supply": 6.676705681495407e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc3db570803f41884e6973c0c2b9a9c2b39cb3758": {
                    "balance": 45097677353475,
                    "percentage_of_total_supply": 5.9230541521487685e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcbcefb4c64acdf0dc4eb11eb65acb0613dc4fbb9": {
                    "balance": 44539413423105,
                    "percentage_of_total_supply": 5.849732693377053e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfeff5e65097525721a441c692d632ddecb8fe78f": {
                    "balance": 28129830060516,
                    "percentage_of_total_supply": 3.6945252287220076e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0be7b271ba03874ad78d712246066c20c81693d3": {
                    "balance": 27613249762995,
                    "percentage_of_total_supply": 3.626678429159186e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9ec53a521496700afd23736ff21fae04789f0171": {
                    "balance": 22695980131916,
                    "percentage_of_total_supply": 2.9808523907733475e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9e6b88834a5d8cbc890f4fb4dd36e2f667074789": {
                    "balance": 5482010512314,
                    "percentage_of_total_supply": 7.199981691425765e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xca77f69134fa71027147936a048ac6bd5e4121a1": {
                    "balance": 3841459945217,
                    "percentage_of_total_supply": 5.045309784025382e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x81b5ec3be3d9339299e56665d8206d4d28ece898": {
                    "balance": 3785612765246,
                    "percentage_of_total_supply": 4.971961024039289e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3c4f7c102c4efde117824416aa502630d682ee2d": {
                    "balance": 3514472349610,
                    "percentage_of_total_supply": 4.615849698823911e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa3b038f87eccdc066b2f24e32dc801e7889e61e8": {
                    "balance": 3146149978111,
                    "percentage_of_total_supply": 4.13210120447527e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x293ed9b32b23a828e0554552fa6f35438ee0f40e": {
                    "balance": 2975664809538,
                    "percentage_of_total_supply": 3.908188811453043e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4eeffb197bec742e4a3b6270e098b0c25e81870f": {
                    "balance": 2817544937026,
                    "percentage_of_total_supply": 3.700516793207236e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x281a28cb2ebeb4a26e5b572117baf1c7d278c9bf": {
                    "balance": 2014867181441,
                    "percentage_of_total_supply": 2.6462931408911716e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc82161c1c154c86a1c85207b1d226187c6ee1766": {
                    "balance": 1488723741904,
                    "percentage_of_total_supply": 1.955265073137405e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcad37b26317bc5204a285885c79b011771c17e4c": {
                    "balance": 1439868768603,
                    "percentage_of_total_supply": 1.8910997614306572e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0ab33b3c4d5de6967df7cc570302a8ce159169e4": {
                    "balance": 1414697105114,
                    "percentage_of_total_supply": 1.8580397160592689e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd24f05d16550eb5c00a20302c0b545b8444b0cc1": {
                    "balance": 1362580650102,
                    "percentage_of_total_supply": 1.7895908283627686e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe4b4862f83e4ccb65a5ed730405ce118d043bacd": {
                    "balance": 1215636138538,
                    "percentage_of_total_supply": 1.5965963438502402e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7e04c173965d839469f44e232cbfc5529bddd23d": {
                    "balance": 778288494699,
                    "percentage_of_total_supply": 1.0221912015478364e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4dec800e37f68192e5f93e1dd3baf1aa1baae51e": {
                    "balance": 763504838046,
                    "percentage_of_total_supply": 1.0027745920767623e-09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x97acc7f320a059ee55037063e2454f1539a68e62": {
                    "balance": 592178065076,
                    "percentage_of_total_supply": 7.777568497969563e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3cc6bc27c36d23ed95289baf5b0bcb8538d1467c": {
                    "balance": 497514239382,
                    "percentage_of_total_supply": 6.534269510661674e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x33f10e6668f2ae057a758b30758a6fbab92c8ae0": {
                    "balance": 495201621543,
                    "percentage_of_total_supply": 6.503895971496321e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4d955701d1e24cb1df0a32e4460766ae0dee4a91": {
                    "balance": 467135044730,
                    "percentage_of_total_supply": 6.135274206286871e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x35dcf6a631fbd170d2a64fb0d9b5273899e951f3": {
                    "balance": 442188629577,
                    "percentage_of_total_supply": 5.807632126862091e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd8408a97401ec903dc9955372fd0fb790cfdcea6": {
                    "balance": 211110828269,
                    "percentage_of_total_supply": 2.7726946071778457e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1956975c32e2b40bfde4d125d634710e026949f2": {
                    "balance": 170538525231,
                    "percentage_of_total_supply": 2.2398247077196052e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xac285f541c80d98e0bacf6aaa59a4e6d4d2fc87b": {
                    "balance": 149549599992,
                    "percentage_of_total_supply": 1.9641596445022872e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6a3b00ac576dc9130defcafd5a744f8437d9befc": {
                    "balance": 130024989155,
                    "percentage_of_total_supply": 1.7077266437941682e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa3c59a1fa80e256a88a1851b3f82f6ff5a64780d": {
                    "balance": 129996714717,
                    "percentage_of_total_supply": 1.7073552920146012e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x18611933289645be87f8d06620c66f45b763681f": {
                    "balance": 112195993743,
                    "percentage_of_total_supply": 1.473563574871616e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8d8b1a6d04ae59e505e0f5557d977bb603365f3c": {
                    "balance": 103711554773,
                    "percentage_of_total_supply": 1.3621303605266228e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x19221de454ca78e846f0aee7273f20c02b9065c4": {
                    "balance": 101175014713,
                    "percentage_of_total_supply": 1.3288158640466457e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa6ee5666ffcea5dc12846dabe9e178c2dc3a37a3": {
                    "balance": 92804032872,
                    "percentage_of_total_supply": 1.218872776817839e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc5be7e93a6b13fbeec302c40c4326537d0ed1247": {
                    "balance": 82730536371,
                    "percentage_of_total_supply": 1.086569144395167e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x151ab7f0a7b756c2396bc02eabd503bd3719f121": {
                    "balance": 69729824048,
                    "percentage_of_total_supply": 9.158199448253507e-11,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x33550b687e54a153dab074de2b269dcff61e2643": {
                    "balance": 15591882592,
                    "percentage_of_total_supply": 2.047812001547471e-11,
                    "percentage_of_circulating_supply": 0.0
                }
            },
            "total_supply": 76139228504460732650814,
            "total_circulating_supply": 0.0,
            "owner": {},
            "creator": {},
            "holders_exceeding_5_percent": [],
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": [
                {
                    "address": "0x0e976211b38c623f5d882ed0859f34d85527b35a",
                    "balance": 13000018283689452503040,
                    "percentage_of_total_supply": 17.074008417261314,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x302037d4f06c4258d742428a78e1f3774d58bb70",
                    "balance": 11725553656320000786432,
                    "percentage_of_total_supply": 15.40014771181066,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xbd83d8f4c1d132d74724891df4257f8f059347aa",
                    "balance": 10000000000000000000000,
                    "percentage_of_total_supply": 13.133834156743701,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xf8422385032dcded2e8af849058ae32543a3665e",
                    "balance": 5016725806805514452992,
                    "percentage_of_total_supply": 6.5888844756439875,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xa38a488b74b14a1005eda3518a3a71408af3fed8",
                    "balance": 2888569548599999856640,
                    "percentage_of_total_supply": 3.7937993401532415,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x328184c03e8d4468730a755ecf20b2dd01c76991",
                    "balance": 2121593878317543981056,
                    "percentage_of_total_supply": 2.78646621457853,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x2d6f46e2aa0f900f75aa68be57eabb70be1db5ba",
                    "balance": 1993800000000000000000,
                    "percentage_of_total_supply": 2.6186238541715587,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x815362b1908004e06be568b23768d8bcec7b3cec",
                    "balance": 1808329585090291040256,
                    "percentage_of_total_supply": 2.375030087130903,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x8d205d869f9d5451712b10f3dd5254a118f0bd6f",
                    "balance": 1503260979069999906816,
                    "percentage_of_total_supply": 1.974358039340954,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x1d7386afa54bc8f8e815f58fcc669ea88b605e6b",
                    "balance": 1498328000000000000000,
                    "percentage_of_total_supply": 1.9678791464405476,
                    "percentage_of_circulating_supply": 0
                }
            ],
            "total_top_10_balance": 51556179737892802527232,
            "top10_percentage_of_total_supply": 67.7130314432754,
            "top10_percentage_of_circulating_supply": 0,
            "top_10_less_than_70_percent_of_total": true,
            "top_10_less_than_70_percent_of_circulating": true
        },
        "liquidity": {
            "price_usd": null,
            "liquidity_usd": null,
            "market_cap_usd": null,
            "liquidity_to_market_cap_ratio": null,
            "token_volume": null,
            "volume_usd": null,
            "volume_to_liquidity_ratio": null,
            "locked_liquidity_percent": 0.0,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 0.0,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 0.0,
            "total_lp_supply": 0.0,
            "lp_holders_count": 0,
            "lp_holders": [],
            "error": "Liquidity pool info could not be retrieved."
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522": "metamask recovery phrase phishing",
                "https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729": "metamask recovery phrase phishing",
                "https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*": "metamask recovery phrase phishing",
                "https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.": "metamask recovery phrase phishing",
                "https://developers.aave.com": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 5,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 177290472.620853,
            "token_creation_date": null,
            "creation_to_first_trade_seconds": null,
            "creation_to_first_trade_blocks": null,
            "last_tx_hash": "0x4c9f71e046399a0116fe90189ac5f6640ab9603d2f32157ab11cd55713b5a0d7",
            "last_active_age": "2025-08-16T05:46:23",
            "inactive_days": 5.473622384097222
        }
    },
    "errors": []
}