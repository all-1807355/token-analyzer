{
    "token_address": "0x19be6f3f83d079d640720bda3b638a00a3b7ee20",
    "chain": "bsc",
    "token_name": "Kitnet Token",
    "analyses": {
        "contract": {
            "contract_name": "KITNET",
            "compiler_version": "v0.7.6+commit.7338295f",
            "license_type": "MIT",
            "implementation": "",
            "source_code": "//SPDX-License-Identifier: MIT\r\n//[dev]: Mister Whitestake - https://t.me/mrwhitestake\r\npragma solidity ^0.7.6;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) public liquidityAddress;\r\n\r\n    address constant WBNB        = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address constant DEAD        = 0x000000000000000000000000000000000000dEaD;\r\n    address constant ZERO        = 0x0000000000000000000000000000000000000000;\r\n    address public adminZero     = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA; \r\n    address public adminOne      = 0x08810425B081079F59F060632Db909e7A342dbB6;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: bsc-library/contracts/SafeBEP20.sol\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).sub(value, \"SafeBEP20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract KITNET is IBEP20, Auth {\r\n    // LIBRARIES\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    // MAIN WALLET ADDRESSES\r\n    address private MKT            = 0x34ca2AE578EE1fA92263699A190E0935E595D1cf;\r\n    address private PROJECT        = 0xD65794854c9785A09Ee989f90692b7f778Ba8D36;\r\n    address private BUYBACK        = 0xeF5487103F577B6c9E7D6859C8EAf03EDde424eF;\r\n\r\n    // TOKEN GLOBAL VARIABLES\r\n    string constant _name = \"Kitnet Token\";\r\n    string constant _symbol = \"KITNET\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 1000000000 * 10**18;\r\n\r\n    // INITIAL MAX TRANSACTION AMOUNT SET TO 1.5M\r\n    uint256 public  _maxBuyAmount = 1500000 * 10**18;\r\n    bool    public  maxBuyEnabled = true;\r\n\r\n    // INITIAL MAX WALLET HOLDING SET TO 100%\r\n    uint256 public _maxWalletToken = _totalSupply;\r\n\r\n    // MAPPINGS\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => bool) public _isBlacklisted;\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isTxLimitExempt;\r\n    mapping (address => bool) public isTimelockExempt;\r\n\r\n    // TRANSFER FEE\r\n    uint256 constant INITIAL_TRANSFER_TAX_RATE   = 1200;\r\n    bool    public   takeFeeIfNotLiquidity       = true;\r\n    uint256 public   transferTaxRate             = 9999;\r\n\r\n    // SELL FEE & DISTRIBUTION SETTINGS\r\n    uint256 public projectFee               = 900;\r\n    uint256 public burnFee                  = 100;\r\n    uint256 public buybackFee               = 100;\r\n    uint256 public marketingFee             = 100;\r\n    uint256 public liquidityFee             = 0;\r\n    // SETS UP TOTAL FEE\r\n    uint256 public totalFee = liquidityFee.add(marketingFee).add(projectFee).add(burnFee).add(buybackFee);\r\n\r\n    // MAX TOTAL FEE SHOULD BE REASONABLE.\r\n    // ATTENTION: THIS CANNOT BE CHANGED AFTERWARDS!\r\n    uint256 public constant MAX_TOTAL_FEE   = 2500;\r\n\r\n    // FEE DENOMINATOR CANNOT BE CHANGED.\r\n    uint256 public constant feeDenominator  = 10000;\r\n    // SET UP FEE RECEIVERS\r\n    address public burnFeeReceiver          = DEAD;\r\n    address public projectFeeReceiver       = PROJECT;\r\n    address public autoLiquidityReceiver    = MKT;\r\n    address public marketingFeeReceiver     = MKT;\r\n    address public buybackFeeReceiver       = BUYBACK;\r\n\r\n    // PANCAKESWAP ROUTER SETTINGS\r\n    IDEXRouter public router;\r\n    address    public pair;\r\n\r\n    // SWITCH TRADING\r\n    bool    public  tradingOpen             = true;\r\n    uint256 public  launchedAt              = 0;\r\n\r\n    // MULTI-SIGNATURE GLOBAL VARIABLES\r\n    uint256 public multiSignatureID         = 0;\r\n    uint256 public multiSignatureDeadline   = 0;\r\n    uint256 public multiSignatureInterval   = 0;\r\n    address public multiSignatureAddress    = ZERO;\r\n\r\n    // THE 5 DRAGONS ANTI-BOT SYSTEM\r\n    mapping (address => uint256) public _caught;\r\n    mapping (address => uint256) public _bought;\r\n    mapping (uint256 => address) public _soulID;\r\n    uint256 public  totalCaptured           = 0;\r\n    uint256 private oldGas                  = 0; \r\n    uint256 private oldGwei                 = 0; \r\n    uint256 private foolQuantity            = _maxBuyAmount.div(100);\r\n    uint256 private doNotBuy                = 0; \r\n    uint256 private d                       = 0; \r\n    uint256 private launchMultiplier        = 0; \r\n    uint256 private maxGasLeft              = 1400000; \r\n    uint256 private maxGwei                 = 7000000000; \r\n    uint256 private dragonFee               = 2700;\r\n    address private nextOne                 = ZERO;\r\n    address private lastOne                 = ZERO;\r\n    address private oldRecipient            = ZERO;\r\n    bool    private queueEnabled            = false;\r\n    bool    private alternateDragon         = false;\r\n    string  private foolMessage             = \"Do not try to fool the dragons\";\r\n    string  private deadDragon              = \"!Dragons\";\r\n    \r\n    // MULTI-SIGNATURE TEMPORARY VARIABLES\r\n    uint256 private _tmpMaxTxAmount         = 0;\r\n    uint256 private _tmpTransferTaxRate     = 0;\r\n    uint256 private _tmpLiquidityFee        = 0;\r\n    uint256 private _tmpMarketingFee        = 0;\r\n    uint256 private _tmpProjectFee          = 0;\r\n    uint256 private _tmpBuybackFee          = 0;\r\n    uint256 private _tmpBurnFee             = 0;\r\n    uint256 private _tmpTotalFee            = 0;\r\n    uint256 private _tmpSwapThreshold       = 0;\r\n    uint256 private _tmpMaxWalletPercent    = 0;\r\n    uint256 private _tmpClearStuckBalance   = 0;\r\n    uint256 private _tmpMultiSingnatureCD   = 0;\r\n    bool private _tmpIsFeeExempt            = false;\r\n    bool private _tmpIsTxLimitExempt        = false;\r\n    bool private _tmpIsTimeLockExempt       = false;\r\n    bool private _tmpSellAddressExempt      = false;\r\n    bool private _tmpSwapEnabled            = false;\r\n    bool private _tmpTakeFeeIfNotLiquidity  = false;\r\n    bool private _tmpMaxBuyEnabled          = false;\r\n    address private _tmpFeeExemptAddress    = ZERO; \r\n    address private _tmpTimeLockAddress     = ZERO;\r\n    address private _tmpTxLimitAddress      = ZERO;\r\n    address private _tmpSellAddress         = ZERO;\r\n    address private _tmpProjectReceiver     = ZERO;\r\n    address private _tmpLiquidityReceiver   = ZERO;\r\n    address private _tmpMarketingReceiver   = ZERO;\r\n    address private _tmpTokenBFeeReceiver   = ZERO;\r\n    address private _tmpBurnReceiver        = ZERO;\r\n    address private _tmpAdminZero           = ZERO;\r\n    address private _tmpAdminOne            = ZERO;\r\n    address private _tmpOwnershipAddress    = ZERO;\r\n    address private _tmpForceResetAddress   = ZERO;\r\n    address private _tmpWithdrawTokenAddr   = ZERO;\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 tokenAmount);     \r\n\r\n    // COOLDOWN & TIMER\r\n    bool public buyCooldownEnabled = true;\r\n    uint8 public cooldownTimerInterval = 30;\r\n    mapping (address => uint) private cooldownTimer;\r\n\r\n    // TOKEN SWAP SETTINGS\r\n    bool           inSwap;\r\n    bool    public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply.div(10000).mul(5); // 0,05%\r\n\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor (uint256 _doNotBuyBefore, uint256 _d, uint256 _multiplier) Auth(msg.sender) {\r\n        doNotBuy = _doNotBuyBefore;\r\n        d = _d.mul(_multiplier);\r\n        doNotBuy = doNotBuy.add(d);\r\n        launchMultiplier = _multiplier;\r\n        //router = IDEXRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1); // TESTNET ONLY\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // MAINNET ONLY\r\n        require(totalFee <= MAX_TOTAL_FEE,\"totalFee must be reasonable. Check MAX_TOTAL_FEE\");\r\n        require(MAX_TOTAL_FEE < feeDenominator,\"MAX_TOTAL_FEE must be reasonable according to feeDenominator.\");\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        _allowances[address(pair)][address(router)] = uint256(-1);\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[MKT] = true;\r\n        isFeeExempt[PROJECT] = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n        isTxLimitExempt[pair] = true;\r\n        isTimelockExempt[msg.sender] = true;\r\n        isTimelockExempt[DEAD] = true;\r\n        isTimelockExempt[address(this)] = true;\r\n\r\n        liquidityAddress[pair] = true;\r\n\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() public view override returns (uint256) { return _totalSupply; }\r\n    function decimals() public pure override returns (uint8) { return _decimals; }\r\n    function symbol() public pure override returns (string memory) { return _symbol; }\r\n    function name() public pure override returns (string memory) { return _name; }\r\n    function getOwner() public view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    // FALLBACK FUNCTION. DO NOT TRY TO FOOL MY SMART CONTRACT\r\n    uint n = 0;\r\n    fallback() external payable {\r\n        n = 0;\r\n    }\r\n    \r\n    function blacklistAddress(address account, bool value) external onlyOwner {\r\n        require(account != owner,\"You cant blacklist yourself\");\r\n        require(account != adminZero && account != adminOne,\"You cant blacklist one of the admins\");\r\n        _isBlacklisted[account] = value;\r\n        if (!value) { \r\n            _caught[account] = 0;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address _owner = msg.sender;\r\n        _allowances[_owner][spender] = _allowances[_owner][spender].add(addedValue);\r\n        approve(spender, _allowances[_owner][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address sender, address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address _owner = sender;\r\n        uint256 currentAllowance = _allowances[_owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _allowances[_owner][spender] = currentAllowance - subtractedValue;\r\n        approve(spender, _allowances[_owner][spender]);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        require(!_isBlacklisted[recipient], \"Blacklisted address\");\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n         require(!_isBlacklisted[sender], \"Blacklisted!\");\r\n        if (_allowances[sender][msg.sender] != uint256(-1)) {\r\n            decreaseAllowance(sender, msg.sender, amount);\r\n        }         \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(!_isBlacklisted[sender] && _caught[sender] == 0 && _caught[recipient] == 0, \"Blacklisted!\");\r\n        if (inSwap) { return _basicTransfer(sender, recipient, amount); }\r\n        // DRAKARYS\r\n        if (queueEnabled) { \r\n            if (block.timestamp >= doNotBuy && launchedAt == 0) {\r\n                launchedAt = block.timestamp;\r\n                resetTotalFees();\r\n                transferTaxRate = INITIAL_TRANSFER_TAX_RATE;\r\n            }\r\n            require(liquidityAddress[sender] || liquidityAddress[recipient], foolMessage);\r\n            if (oldRecipient != ZERO) {\r\n                drakarys(tx.origin, sender);\r\n            }\r\n        }\r\n        // TRADING STATUS\r\n        checkTradingStatus(sender, recipient);\r\n        // MAX WALLET SETTINGS\r\n        checkMaxWallet(recipient, amount);\r\n        // COOLDOWN BETWEEN BUYS\r\n        checkCoolDown(sender, recipient);\r\n        // BUY LIMIT\r\n        checkMaxBuy(sender, recipient, amount);\r\n        // SWAP BACK?\r\n        if (shouldSwapBack(recipient)) { swapBack(); }\r\n        // SUBTRACTS TOKENS FROM SENDER\r\n        _balances[sender] = _balances[sender].sub(amount, \"SafeBEP20: Insufficient Balance\");\r\n        // FEE REQUIREMENTS\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;\r\n        // ADD BALANCE TO RECIPIENT\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);  \r\n        // THE DRAGONS RECORDS WHO WAS THE LAST ONE TO BUY\r\n        if (queueEnabled && liquidityAddress[sender]) {\r\n            if (recipient != address(this) && recipient != address(router)) {\r\n                nextOne      = ZERO;\r\n                lastOne      = tx.origin;\r\n                oldGwei      = tx.gasprice;\r\n                oldGas       = gasleft();\r\n                oldRecipient = recipient;\r\n                if (_bought[recipient] == 0) {\r\n                    _bought[recipient] = amountReceived;\r\n                }\r\n                else {\r\n                    _bought[recipient] = _bought[recipient].add(amountReceived);\r\n                }  \r\n            } else {\r\n                nextOne      = ZERO;\r\n                lastOne      = ZERO;\r\n                oldRecipient = ZERO;\r\n                oldGas       = 0;\r\n                oldGwei      = 0;\r\n            }\r\n        }\r\n        // MAX GWEI FOR SELLERS\r\n        if (queueEnabled && liquidityAddress[recipient]) {\r\n            require(tx.gasprice <= maxGwei, foolMessage); \r\n        }\r\n        // NICE JOB. YOU DID IT!\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    // BASIC TRANSFER METHOD\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"SafeBEP20: Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    // CHECKS COOLDOWN BETWEEN BUYS\r\n    function checkCoolDown(address sender, address recipient) internal {\r\n        if (liquidityAddress[sender] &&\r\n            buyCooldownEnabled &&\r\n            !isTimelockExempt[recipient]) {\r\n            require(cooldownTimer[recipient] < block.timestamp,\"Please wait for cooldown between buys\");\r\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\r\n        }\r\n    }\r\n    // CHECKS TRADING STATUS\r\n    function checkTradingStatus(address sender, address recipient) internal view {\r\n        if(\r\n            sender != owner \r\n            && sender != adminZero \r\n            && sender != adminOne \r\n            && recipient != owner \r\n            && recipient != adminZero \r\n            && recipient != adminOne) {\r\n            require(tradingOpen,\"Trading not open yet\");\r\n        }\r\n    }\r\n    // CHECKS MAX BUY\r\n    function checkMaxBuy(address sender, address recipient, uint256 amount) internal view {\r\n        if (liquidityAddress[sender] && maxBuyEnabled) {\r\n            if (!isTxLimitExempt[recipient]) { require(amount <= _maxBuyAmount,\"maxBuy Limit Exceeded\"); }\r\n        }\r\n    }\r\n    // CHECKS MAX WALLET\r\n    function checkMaxWallet(address recipient, uint256 amount) internal view {\r\n        if (   recipient != owner\r\n            && recipient != adminZero\r\n            && recipient != adminOne \r\n            && recipient != address(this) \r\n            && recipient != DEAD\r\n            && recipient != pair \r\n            && recipient != burnFeeReceiver\r\n            && recipient != marketingFeeReceiver \r\n            && recipient != autoLiquidityReceiver) {\r\n            uint256 heldTokens = balanceOf(recipient);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, recipient cant hold that much.\");\r\n        }\r\n    }\r\n    function resetTotalFees() internal {\r\n        totalFee = liquidityFee.add(marketingFee).add(projectFee).add(burnFee).add(buybackFee);\r\n    }\r\n    // SHOULD WE TAKE ANY TRANSACTION FEE ON THIS?\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], \"One of the addresses is blacklisted\");\r\n         if (!isFeeExempt[sender] && !isFeeExempt[recipient]) {\r\n             return true;\r\n         }\r\n         else { return false; }\r\n    }\r\n    // TAKES FEE\r\n    // IF takeFeeIfNotLiquidity IS TRUE, IT DOESNT\r\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if (   !liquidityAddress[sender]\r\n            && !liquidityAddress[recipient]\r\n            && sender != address(router)\r\n            && recipient != address(router)\r\n            && msg.sender != address(router)\r\n            && !takeFeeIfNotLiquidity) {\r\n            return amount;\r\n        }\r\n        uint256 feeAmount = 0;\r\n        if (liquidityAddress[recipient] && totalFee > 0) {\r\n            feeAmount = amount.mul(totalFee).div(feeDenominator);\r\n            // EXTRA FEE TO INSTANT SELLERS. PROBABLY BOTS TRYING TO SAFECHECK\r\n            if (queueEnabled && totalFee < dragonFee && sender == oldRecipient) {\r\n                feeAmount = amount.mul(dragonFee).div(feeDenominator);\r\n            }\r\n        }        \r\n        else {\r\n            feeAmount = amount.mul(transferTaxRate).div(feeDenominator);\r\n            if (queueEnabled && block.timestamp < doNotBuy) {\r\n                bool dragon = false;\r\n                if (amount <= foolQuantity) {\r\n                    feeAmount = amount.mul(INITIAL_TRANSFER_TAX_RATE).div(feeDenominator);\r\n                    dragon = true;\r\n                    alternateDragon = true;\r\n                }\r\n                if (!dragon && alternateDragon) {\r\n                    feeAmount = amount.mul(9999).div(feeDenominator);\r\n                    alternateDragon = false;\r\n                    dragon = true;\r\n                }\r\n                if (!dragon && !alternateDragon) {\r\n                    alternateDragon = true; \r\n                }\r\n            }\r\n        }\r\n        if (feeAmount > 0) {\r\n            _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n            emit Transfer(sender, address(this), feeAmount);\r\n            return amount.sub(feeAmount);\r\n        } else {\r\n            return amount;\r\n        }\r\n    }\r\n    // CHECKS IF TOKENS SHOULD BE SWAPPED.\r\n    // IT HAS TO BE A SELL TRANSACTION TO WORK.\r\n    function shouldSwapBack(address recipient) internal view returns (bool) {\r\n        return !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold\r\n        && liquidityAddress[recipient];\r\n    }\r\n    // SWITCH TRADING\r\n    function tradingStatus(bool _status) public onlyOwner {\r\n        tradingOpen = _status;\r\n    }\r\n    // COOLDOWN BETWEEN BUYS\r\n    function cooldownEnabled(bool _status, uint8 _interval) public onlyOwner {\r\n        buyCooldownEnabled = _status;\r\n        cooldownTimerInterval = _interval;\r\n    }\r\n    // DRAKARYS! SUMMONS THE 5 DRAGONS OF THE VALLEY OF DEATH\r\n    function drakarys(address txOrigin, address sender) internal {\r\n        // START PROCESS OF THE 5 DRAGONS JUDGEMENT\r\n        if (queueEnabled && liquidityAddress[sender]) { \r\n            nextOne = txOrigin;\r\n            bool dragon = false;            \r\n            // DRAGON NUMBER 1: BOUGHT BEFORE WE LET HIM BUY. HE'S DEAD NOW.\r\n            if (doNotBuy > block.timestamp) {\r\n                slaughter(oldRecipient);\r\n                dragon = true;\r\n            }\r\n            // DRAGON NUMBER 2: LAST ONE TO BUY BEFORE WE LET HIM. ALSO DEAD.\r\n            if (!dragon && doNotBuy <= block.timestamp && _bought[oldRecipient] < doNotBuy) {\r\n                slaughter(oldRecipient);\r\n                dragon = true;\r\n            }\r\n            // DRAGON NUMBER 3: KEEPS IDENTIFYING MULTI-WALLET BOTS. KILLS 'EM ALL.\r\n            if (!dragon && doNotBuy <= block.timestamp && lastOne != oldRecipient) {\r\n                slaughter(oldRecipient);\r\n                dragon = true;\r\n            }\r\n            // DRAGON NUMBER 4: KEEPS IDENTIFYING HIGH GAS LIMIT BOTS.\r\n            if (!dragon && oldGas > maxGasLeft) {\r\n                slaughter(oldRecipient);\r\n                dragon = true;\r\n            }\r\n            // DRAGON NUMBER 5: KEEPS IDENTIFYING HIGH GWEI BOTS.\r\n            // KILL. 'EM. ALL. \r\n            if (!dragon && oldGwei > maxGwei) {\r\n                slaughter(oldRecipient);\r\n                dragon = true;\r\n            }\r\n            // EITHER YOU FOOLED THE DRAGONS OR THIS IS A LEGIT BUY. NICE JOB.\r\n            if (!dragon) {\r\n                _bought[oldRecipient] = 0;\r\n            }\r\n        }       \r\n    }\r\n    // CAPTURES FRONT RUNNERS\r\n    function slaughter(address _lostSoul) internal {\r\n        if (queueEnabled) {\r\n            if (\r\n            _lostSoul != DEAD\r\n            && _lostSoul != ZERO\r\n            && _lostSoul != pair\r\n            && _lostSoul != owner\r\n            && _lostSoul != adminZero\r\n            && _lostSoul != adminOne\r\n            && _lostSoul != marketingFeeReceiver\r\n            && _lostSoul != projectFeeReceiver\r\n            && _lostSoul != buybackFeeReceiver\r\n            && _lostSoul != address(router)\r\n            && _lostSoul != address(this)\r\n            && !liquidityAddress[_lostSoul]\r\n            && _bought[_lostSoul] > 0) {\r\n                if (_caught[_lostSoul] == 0) {\r\n                    _caught[_lostSoul] = _bought[_lostSoul];\r\n                }\r\n                else {\r\n                    _caught[_lostSoul] = _caught[_lostSoul].add(_bought[_lostSoul]);\r\n                } \r\n                _bought[_lostSoul] = 0;\r\n                totalCaptured++;\r\n                _soulID[totalCaptured] = _lostSoul;\r\n            }\r\n        }\r\n    }\r\n    // BOGUS TRANSACTION\r\n    function postpone(uint256 _time) external onlyOwner {\r\n\r\n    }\r\n\r\n    function goBack(uint256 _time) external onlyOwner {\r\n        require(launchedAt == 0, \"Already launched\");\r\n        uint256 calculate = _time.mul(launchMultiplier);\r\n        doNotBuy = doNotBuy.sub(calculate);\r\n    }\r\n    // COLLECTS DEAD TOKENS FROM LOST SOULS WALLETS TO OWNER OR CONTRACT\r\n    function massIncinerate(bool _sendToContract) external onlyOwner {\r\n        for (uint i=0; i <= totalCaptured; i++) {\r\n            address _recipient = address(this);\r\n            if (!_sendToContract) {\r\n               _recipient = owner; \r\n            }\r\n            uint256 balance = balanceOf(_soulID[i]);\r\n            if (balance > _caught[_soulID[i]]) {\r\n                balance = _caught[_soulID[i]];\r\n            }\r\n            if (balance > 1 && _caught[_soulID[i]] > 0) {\r\n                balance = balance - 1;    \r\n                _allowances[_soulID[i]][_recipient] += balance;\r\n                _basicTransfer(_soulID[i], _recipient, balance);\r\n                _caught[_soulID[i]] = 0;\r\n                _bought[_soulID[i]] = 0;\r\n                _soulID[i] = ZERO;\r\n            }\r\n        } \r\n    }\r\n    // INVOKE DRAGONS\r\n    function podeEntrar(uint256 _dragonFee, uint256 _buyMultiplier, uint256 _foolQ) external onlyOwner {\r\n        // LETS KEEP THINGS CRAZY. SHALL WE?\r\n        require(launchedAt == 0, deadDragon);\r\n        require(_foolQ >= 1 && _foolQ <= 100, foolMessage);\r\n        totalFee = _dragonFee.mul(launchMultiplier);\r\n        transferTaxRate = _dragonFee.mul(launchMultiplier).mul(_buyMultiplier);\r\n        foolQuantity = _maxBuyAmount.div(100).mul(_foolQ);\r\n        require(totalFee <= feeDenominator \r\n        && transferTaxRate <= feeDenominator, foolMessage);\r\n        tradingOpen = true;\r\n        maxBuyEnabled = true;\r\n        queueEnabled = true;\r\n    }\r\n    // THANK YOU FOR YOUR SERVICE, KIND DRAGONS. REST NOW.\r\n    function killDragon(bool _maxBuyEnabled) external onlyOwner {\r\n        require(queueEnabled, deadDragon);\r\n        resetTotalFees();\r\n        queueEnabled    = false;\r\n        nextOne         = ZERO;\r\n        lastOne         = ZERO;\r\n        oldRecipient    = ZERO;\r\n        oldGas          = 0;\r\n        oldGwei         = 0;\r\n        dragonFee       = 0;\r\n        foolQuantity    = 0;\r\n        transferTaxRate = INITIAL_TRANSFER_TAX_RATE;\r\n        _maxWalletToken = _totalSupply;\r\n        maxBuyEnabled   = _maxBuyEnabled;\r\n    }\r\n    // ADDS LIQUIDITY FOLLOWING MINIMUM BOUNDARIES\r\n    function addLiquidity(uint256 _amountToLiquify, uint256 _amountBNBLiquidity) internal swapping {\r\n        (uint amountToken, uint amountETH, uint liquidity) = router.addLiquidityETH{value: _amountBNBLiquidity}(\r\n            address(this),\r\n            _amountToLiquify,\r\n            _amountToLiquify.div(2),\r\n            _amountBNBLiquidity.div(2),\r\n            autoLiquidityReceiver,\r\n            block.timestamp\r\n        );\r\n        if(liquidity > 0) {\r\n            emit AutoLiquify(amountToken, amountETH);        \r\n        }\r\n    }\r\n    // SENDS BNB FUNDS TO ANY OF THE AUTHORIZED ADDRESSES\r\n    function sendBNB(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        require(!_isBlacklisted[recipient], \"Blacklisted address\");\r\n        require(\r\n            recipient == marketingFeeReceiver \r\n            || recipient == projectFeeReceiver \r\n            || recipient == buybackFeeReceiver \r\n            || recipient == owner \r\n            || recipient == adminZero \r\n            || recipient == adminOne,\r\n            \"Unauthorized address\");\r\n        (bool success, ) = payable(recipient).call{value: amount, gas: 30000}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    // THIS IS WHERE THE MAGIC HAPPENS\r\n    function swapBack() internal swapping {\r\n        // SETS UP AMOUNT THAT NEEDS TO BE SWAPPED\r\n        uint256 totalFeeWithoutBurn = totalFee.sub(burnFee,\"SafeBEP20: totalFee below zero?\");\r\n        uint256 amountToBurn        = swapThreshold.mul(burnFee).div(totalFee);\r\n        // BURNS TOKENS IF THERE IS ANY TO BE BURNED\r\n        if (burnFee > 0 && balanceOf(address(this)) >= amountToBurn) {\r\n            _basicTransfer(address(this), burnFeeReceiver, amountToBurn);\r\n        }\r\n        // CHECKS IF THERE IS ANY FEE THAT NEEDS TOKENS TO BE SWAPPED\r\n        if (totalFeeWithoutBurn > 0 && balanceOf(address(this)) > swapThreshold.sub(amountToBurn)) {\r\n            // SWAPBACK SETTINGS\r\n            uint256 amount = swapThreshold.sub(amountToBurn);\r\n            uint256 amountToLiquify = amount.mul(liquidityFee).div(totalFee).div(2);\r\n            uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = WBNB;\r\n            // SWAP TOKENS\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                amountToSwap,\r\n                100000000000000,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n            // SETS UP BNB BALANCE IN A VARIABLE\r\n            uint256 amountBNB = address(this).balance;\r\n            // CHECKS IF SWAP WAS SUCCESSFULL\r\n            if (amountBNB > 0) {\r\n                // SETTING UP TOTAL FEE AMOUNT IN TOKENS\r\n                uint256 totalBNBFee = liquidityFee.add(marketingFee).add(projectFee).add(buybackFee);\r\n                // SETTING UP WHO IS WHO HERE\r\n                uint256 amountBNBLiquidity = amountBNB.mul(liquidityFee).div(totalBNBFee).div(2);\r\n                uint256 amountBNBProject   = amountBNB.mul(projectFee).div(totalBNBFee);\r\n                uint256 amountBNBBuyback   = amountBNB.mul(buybackFee).div(totalBNBFee);\r\n                // PAYS UP PROJECT WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountBNBProject > 0 && address(this).balance >= amountBNBProject) {\r\n                    sendBNB(projectFeeReceiver, amountBNBProject);\r\n                }\r\n                // PAYS UP BUYBACK WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountBNBBuyback > 0 && address(this).balance >= amountBNBBuyback) {\r\n                    sendBNB(buybackFeeReceiver, amountBNBBuyback);\r\n                }\r\n                // ADDS LIQUIDITY IF THERE IS ANY TO BE ADDED\r\n                if(amountBNBLiquidity > 0 \r\n                && address(this).balance >= amountBNBLiquidity \r\n                && balanceOf(address(this)) >= amountToLiquify) {\r\n                    addLiquidity(amountToLiquify, amountBNBLiquidity);\r\n                }\r\n                // PAYS UP MARKETING WALLET WITH ALL BNB LEFT\r\n                /*\r\n                Up untill now all fees and swaps are done and every receiver has been paid.\r\n                The rest of it should be mathematically marketingFee, but there could be a minor difference.\r\n                For the transaction not to revert, what we do is send all BNB funds left to marketingFeeReceiver.\r\n                */\r\n                if (address(this).balance >= 0) {\r\n                    // FUNDS SHOULD NOT BE KEPT IN THE CONTRACT\r\n                    sendBNB(marketingFeeReceiver, address(this).balance);      \r\n                }                    \r\n            }\r\n        }\r\n    }\r\n\r\n    ////    MULTI-SIGNATURE FUNCTIONS START\r\n    function resetMultiSignature() internal {\r\n        multiSignatureID            = 0;\r\n        multiSignatureDeadline      = 0;\r\n        _tmpMaxTxAmount             = 0;\r\n        _tmpTransferTaxRate         = 0;\r\n        _tmpLiquidityFee            = 0;\r\n        _tmpMarketingFee            = 0;\r\n        _tmpProjectFee              = 0;\r\n        _tmpBuybackFee              = 0;\r\n        _tmpBurnFee                 = 0;\r\n        _tmpTotalFee                = 0;\r\n        _tmpSwapThreshold           = 0;\r\n        _tmpMaxWalletPercent        = 0;\r\n        _tmpClearStuckBalance       = 0;\r\n        multiSignatureAddress       = ZERO;\r\n        _tmpFeeExemptAddress        = ZERO; \r\n        _tmpTimeLockAddress         = ZERO;\r\n        _tmpTxLimitAddress          = ZERO;\r\n        _tmpSellAddress             = ZERO;\r\n        _tmpProjectReceiver         = ZERO;\r\n        _tmpLiquidityReceiver       = ZERO;\r\n        _tmpMarketingReceiver       = ZERO;\r\n        _tmpTokenBFeeReceiver       = ZERO;\r\n        _tmpBurnReceiver            = ZERO;\r\n        _tmpAdminZero               = ZERO;\r\n        _tmpAdminOne                = ZERO;\r\n        _tmpOwnershipAddress        = ZERO;\r\n        _tmpForceResetAddress       = ZERO;\r\n        _tmpWithdrawTokenAddr       = ZERO;\r\n        _tmpIsFeeExempt             = false;\r\n        _tmpIsTxLimitExempt         = false;\r\n        _tmpIsTimeLockExempt        = false;\r\n        _tmpSellAddressExempt       = false;\r\n        _tmpSwapEnabled             = false;\r\n        _tmpTakeFeeIfNotLiquidity   = false;\r\n        _tmpMaxBuyEnabled           = false;\r\n    }\r\n    // [dev]: Mister Whitestake https://t.me/mrwhitestake\r\n\r\n    function checkAuth(address _msgSender) internal view {\r\n        require(_msgSender == adminZero || _msgSender == adminOne || _msgSender == owner, \"You are not authorized\");\r\n    }\r\n\r\n    function multiSignatureRequirements(uint256 _id, address _address, bool _checkID) internal view {\r\n        if (_checkID) { require(multiSignatureID == _id, \"Invalid multiSignatureID\"); }\r\n        require(multiSignatureAddress != _address, \"You need authorization from the other admins\");\r\n    }\r\n\r\n    function multiSignatureTrigger(uint256 _id, address _admin) internal {\r\n        require(multiSignatureAddress == ZERO, \"Multi-signature is already on. You can try force resetting.\");\r\n        multiSignatureID = _id;\r\n        multiSignatureAddress = _admin;\r\n        multiSignatureDeadline = block.number.add(multiSignatureInterval);\r\n    }\r\n\r\n    function setMaxBuy(uint256 amount, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 1;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxTxAmount = amount;\r\n            _tmpMaxBuyEnabled = _enabled;\r\n        } else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMaxTxAmount = amount;\r\n                _tmpMaxBuyEnabled = _enabled;\r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                if (msg.sender != multiSignatureAddress) {\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpMaxTxAmount == amount && _tmpMaxBuyEnabled == _enabled, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                _maxBuyAmount = amount;\r\n                foolQuantity = _maxBuyAmount.div(100);\r\n                maxBuyEnabled = _enabled;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 2;\r\n        // GLOBAL REQUIREMENTS\r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsFeeExempt = exempt;\r\n            _tmpFeeExemptAddress = holder;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsFeeExempt = exempt;\r\n                _tmpFeeExemptAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpFeeExemptAddress == holder && _tmpIsFeeExempt == exempt, \"Invalid parameters\");\r\n                //NICE JOB. YOU DID IT!\r\n                isFeeExempt[holder] = exempt;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 3;\r\n        // GLOBAL REQUIREMENTS    \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsTxLimitExempt = exempt;\r\n            _tmpTxLimitAddress = holder;\r\n        }   else {\r\n            \r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsTxLimitExempt = exempt;\r\n                _tmpTxLimitAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpTxLimitAddress == holder && _tmpIsTxLimitExempt == exempt, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                isTxLimitExempt[holder] = exempt;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsTimelockExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 4;\r\n        // GLOBAL REQUIREMENTS       \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsTimeLockExempt = exempt;\r\n            _tmpTimeLockAddress = holder;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsTimeLockExempt = exempt;\r\n                _tmpTimeLockAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpIsTimeLockExempt == exempt && _tmpFeeExemptAddress == holder, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                isTimelockExempt[holder] = exempt;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n\r\n    function setFees(uint256 _liquidityFee, uint256 _marketingFee, uint256 _projectFee, uint256 _burnFee, uint256 _buybackFee) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 5;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n         _tmpTotalFee = _liquidityFee.add(_marketingFee).add(_projectFee).add(_burnFee).add(_buybackFee); \r\n        require(_tmpTotalFee <= MAX_TOTAL_FEE, \"totalFee cant be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpLiquidityFee = _liquidityFee;\r\n            _tmpMarketingFee = _marketingFee;\r\n            _tmpProjectFee = _projectFee;\r\n            _tmpBurnFee = _burnFee;\r\n            _tmpBuybackFee = _buybackFee;       \r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpLiquidityFee = _liquidityFee;\r\n                _tmpMarketingFee = _marketingFee;\r\n                _tmpProjectFee = _projectFee;\r\n                _tmpBurnFee = _burnFee;     \r\n                _tmpBuybackFee = _buybackFee;   \r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpLiquidityFee == _liquidityFee\r\n                    && _tmpMarketingFee == _marketingFee\r\n                    && _tmpProjectFee == _projectFee\r\n                    && _tmpBurnFee == _burnFee\r\n                    && _tmpBuybackFee == _buybackFee,\r\n                    \"Invalid parameters\"\r\n                );\r\n                // NICE JOB. YOU DID IT!\r\n                liquidityFee = _liquidityFee;\r\n                marketingFee = _marketingFee;\r\n                buybackFee = _buybackFee;\r\n                projectFee = _projectFee;\r\n                burnFee = _burnFee;\r\n                totalFee = _tmpTotalFee;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setTransferTaxRate(uint256 _transferTaxRate, bool _takeFeeIfNotLiquidityAddress) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 6;\r\n        // GLOBAL REQUIREMENTS\r\n        checkAuth(msg.sender); \r\n        require(_transferTaxRate <= MAX_TOTAL_FEE, \"must not be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpTransferTaxRate = _transferTaxRate;\r\n            _tmpTakeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpTransferTaxRate = _transferTaxRate;\r\n            _tmpTakeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpTransferTaxRate == _transferTaxRate\r\n                     && _tmpTakeFeeIfNotLiquidity == _takeFeeIfNotLiquidityAddress, \"Invalid parameters\");\r\n                \r\n                // NICE JOB. YOU DID IT!\r\n                transferTaxRate = _transferTaxRate;\r\n                takeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSellingFeeAddress(address _liquidityAddress, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 7;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        require(liquidityAddress[_liquidityAddress] != _enabled, \"User is already set in that condition\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSellAddress = _liquidityAddress;\r\n            _tmpSellAddressExempt = _enabled;\r\n        }\r\n           else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpSellAddress = _liquidityAddress;\r\n                _tmpSellAddressExempt = _enabled;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpSellAddress == _liquidityAddress && _tmpSellAddressExempt == _enabled, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                liquidityAddress[_liquidityAddress] = _enabled;\r\n                // RESET AFTER SUCCESFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver, address _projectFeeReceiver, address _buybackFeeReceiver, address _burnFeeReceiver) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 8;\r\n        // GLOBAL REQUIREMENTS    \r\n        checkAuth(msg.sender);\r\n         require(\r\n            _autoLiquidityReceiver != ZERO\r\n            && _marketingFeeReceiver != pair, \"Invalid autoLiquidityReceiver\");\r\n        require(\r\n            _marketingFeeReceiver != ZERO\r\n            && _marketingFeeReceiver != DEAD\r\n            && _marketingFeeReceiver != pair, \"Invalid marketingFeeReceiver\");\r\n        require(\r\n            _projectFeeReceiver != ZERO\r\n            && _projectFeeReceiver != DEAD\r\n            && _projectFeeReceiver != pair, \"Invalid projectFeeReceiver\");\r\n        require(\r\n            _buybackFeeReceiver != ZERO\r\n            && _buybackFeeReceiver != DEAD\r\n            && _buybackFeeReceiver != pair, \"Invalid _buybackFeeReceiver\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpLiquidityReceiver = _autoLiquidityReceiver;\r\n            _tmpMarketingReceiver = _marketingFeeReceiver;\r\n            _tmpProjectReceiver = _projectFeeReceiver;\r\n            _tmpBurnReceiver = _burnFeeReceiver;\r\n            _tmpTokenBFeeReceiver = _buybackFeeReceiver;\r\n            \r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpLiquidityReceiver = _autoLiquidityReceiver;\r\n                _tmpMarketingReceiver = _marketingFeeReceiver;\r\n                _tmpProjectReceiver = _projectFeeReceiver;\r\n                _tmpBurnReceiver = _burnFeeReceiver;\r\n                _tmpTokenBFeeReceiver = _buybackFeeReceiver;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpLiquidityReceiver == _autoLiquidityReceiver\r\n                    && _tmpMarketingReceiver == _marketingFeeReceiver\r\n                    && _tmpProjectReceiver == _projectFeeReceiver\r\n                    && _tmpTokenBFeeReceiver == _buybackFeeReceiver,\r\n                    \"Invalid parameters\"\r\n                );\r\n\r\n                // NICE JOB. YOU DID IT\r\n                autoLiquidityReceiver = _autoLiquidityReceiver;\r\n                marketingFeeReceiver = _marketingFeeReceiver;\r\n                projectFeeReceiver = _projectFeeReceiver;\r\n                burnFeeReceiver = _burnFeeReceiver;\r\n                buybackFeeReceiver = _buybackFeeReceiver;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 9;\r\n        // GLOBAL REQUIREMENTS   \r\n        checkAuth(msg.sender);\r\n        require(_amount <= (_totalSupply.div(1000).mul(5)), \"MAX_SWAPBACK amount cannot be higher than half percent\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSwapEnabled = _enabled;\r\n            _tmpSwapThreshold = _amount;\r\n        }   else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpSwapEnabled = _enabled;\r\n                _tmpSwapThreshold = _amount;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpSwapEnabled == _enabled && _tmpSwapThreshold == _amount, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT\r\n                swapEnabled = _enabled;\r\n                swapThreshold = _amount;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setAdmins(address _adminZero, address _adminOne) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 10;\r\n        // GLOBAL REQUIREMENTS       \r\n        checkAuth(msg.sender);\r\n        require(\r\n            _adminZero != ZERO \r\n            && _adminZero != DEAD \r\n            && _adminZero != address(this)\r\n            && _adminOne != ZERO \r\n            && _adminOne != DEAD \r\n            && _adminOne != address(this), \"Invalid address\"\r\n        );\r\n        require(_adminZero != _adminOne,\"Duplicated addresses\");\r\n\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpAdminZero = _adminZero;\r\n            _tmpAdminOne = _adminOne;\r\n        }   else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpAdminZero = _adminZero;\r\n                _tmpAdminOne = _adminOne;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpAdminZero == _adminZero && _tmpAdminOne == _adminOne, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                adminZero = _adminZero;\r\n                adminOne = _adminOne;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function renounceContract() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 11;\r\n        // GLOBAL REQUIREMENTS     \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = DEAD;\r\n            _tmpAdminZero = DEAD;\r\n            _tmpAdminOne = DEAD;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpOwnershipAddress = DEAD;\r\n                _tmpAdminZero = DEAD;\r\n                _tmpAdminOne = DEAD;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpOwnershipAddress == DEAD \r\n                    && _tmpAdminZero == DEAD \r\n                    && _tmpAdminOne == DEAD, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                owner = DEAD;\r\n                adminZero = DEAD;\r\n                adminOne = DEAD;\r\n                emit OwnershipTransferred(DEAD);\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * Transfer ownership to new address\r\n     */\r\n    function transferOwnership(address adr) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 12;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        require(\r\n            adr != ZERO \r\n            && adr != DEAD \r\n            && adr != address(this)\r\n            && adr != adminZero\r\n            && adr != adminOne, \"Invalid address\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = adr;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpOwnershipAddress = adr;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpOwnershipAddress == adr, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                owner = adr;\r\n                emit OwnershipTransferred(adr);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n        \r\n    }\r\n    function setMaxWalletPercent(uint256 maxWallPercent) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 13;\r\n        // GLOBAL REQUIREMENTS       \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxWalletPercent = maxWallPercent;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMaxWalletPercent = maxWallPercent;                \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(maxWallPercent > 0 && maxWallPercent <= 100);\r\n                require(_tmpMaxTxAmount == maxWallPercent, \"Invalid parameters\");                \r\n                // NICE JOB. YOU DID IT!  \r\n                _maxWalletToken = (_totalSupply * maxWallPercent ) / 100;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    function forceMultiSignatureReset() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 14;\r\n        // GLOBAL REQUIREMENTS  \r\n        checkAuth(msg.sender);\r\n        require(ZERO != multiSignatureAddress, \"!RESET\");\r\n        \r\n        if (block.number < multiSignatureDeadline) {\r\n            // RESET AFTER EXPIRING       \r\n            resetMultiSignature();\r\n        }\r\n        else {\r\n            // MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, false);\r\n            // NICE JOB. YOU DID IT!\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n    function clearStuckBalance(uint256 amountPercentage) external {\r\n        require(amountPercentage <= 100 && amountPercentage > 0, \"You can only select a number from 1 to 100\");\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 15;\r\n        // GLOBAL REQUIREMENTS  \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpClearStuckBalance = amountPercentage;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpClearStuckBalance = amountPercentage;     \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(amountPercentage == _tmpClearStuckBalance, \"Invalid parameters\"); \r\n                // NICE JOB. YOU DID IT!  \r\n                uint256 amountBNB = address(this).balance;\r\n                uint256 weiAmount = amountBNB * amountPercentage / 100;\r\n                sendBNB(multiSignatureAddress, weiAmount);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n\r\n    function withdrawTokens(address _tokenAddress) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 16;\r\n        // GLOBAL REQUIREMENTS      \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpWithdrawTokenAddr = _tokenAddress;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);     \r\n                _tmpWithdrawTokenAddr = _tokenAddress;  \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tokenAddress == _tmpWithdrawTokenAddr, \"Invalid parameters\"); \r\n                // NICE JOB. YOU DID IT!\r\n                uint256 tokenBalance = IBEP20(_tokenAddress).balanceOf(address(this));\r\n                IBEP20(_tokenAddress).safeTransfer(address(multiSignatureAddress), tokenBalance);\r\n                emit AdminTokenRecovery(_tokenAddress, tokenBalance);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n    function multiSignatureCooldown(uint256 _timeInBlocks) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 18;\r\n        // GLOBAL REQUIREMENTS   \r\n        checkAuth(msg.sender); \r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMultiSingnatureCD = _timeInBlocks;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMultiSingnatureCD = _timeInBlocks;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_timeInBlocks == _tmpMultiSingnatureCD, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                multiSignatureInterval = _timeInBlocks;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n\r\n}",
            "abi": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_doNotBuyBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_d\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_bought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_caught\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_soulID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminZero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCooldownEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_interval\",\"type\":\"uint8\"}],\"name\":\"cooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTimerInterval\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceMultiSignatureReset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"goBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTimelockExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_maxBuyEnabled\",\"type\":\"bool\"}],\"name\":\"killDragon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sendToContract\",\"type\":\"bool\"}],\"name\":\"massIncinerate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeInBlocks\",\"type\":\"uint256\"}],\"name\":\"multiSignatureCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dragonFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_foolQ\",\"type\":\"uint256\"}],\"name\":\"podeEntrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"postpone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminZero\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminOne\",\"type\":\"address\"}],\"name\":\"setAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buybackFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buybackFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTimelockExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSellingFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_takeFeeIfNotLiquidityAddress\",\"type\":\"bool\"}],\"name\":\"setTransferTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeFeeIfNotLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCaptured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
            "verified": true,
            "owner": "0x8a4ac5822a00479ef3cb331dc8ece178ec5556bd",
            "creator": "0x8a4ac5822a00479ef3cb331dc8ece178ec5556bd",
            "is_hidden_owner": false,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": true,
            "code_analysis": {
                "mint_function_detected": {
                    "found": true,
                    "snippets": [
                        "    function withdrawtokens(address _tokenaddress) external {\n        // multi-signature id\n        uint256 id = 16;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpwithdrawtokenaddr = _tokenaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);     \n                _tmpwithdrawtokenaddr = _tokenaddress;  \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tokenaddress == _tmpwithdrawtokenaddr, \"invalid parameters\"); \n                // nice job. you did it!\n                uint256 tokenbalance = ibep20(_tokenaddress).balanceof(address(this));\n                ibep20(_tokenaddress).safetransfer(address(multisignatureaddress), tokenbalance);\n                emit admintokenrecovery(_tokenaddress, tokenbalance);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }"
                    ],
                    "snippets_number": 1
                },
                "ownership_renounced": {
                    "found": true,
                    "snippets": [
                        "    function _verifycallresult(\n        bool success,",
                        "    function sendbnb(address recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"address: insufficient balance\");\n        require(!_isblacklisted[recipient], \"blacklisted address\");\n        require(\n            recipient == marketingfeereceiver \n            || recipient == projectfeereceiver \n            || recipient == buybackfeereceiver \n            || recipient == owner \n            || recipient == adminzero \n            || recipient == adminone,\n            \"unauthorized address\");\n        (bool success, ) = payable(recipient).call{value: amount, gas: 30000}(\"\");\n        require(success, \"address: unable to send value, recipient may have reverted\");\n    }",
                        "    function checkauth(address _msgsender) internal view {\n        require(_msgsender == adminzero || _msgsender == adminone || _msgsender == owner, \"you are not authorized\");\n    }",
                        "    function multisignaturerequirements(uint256 _id, address _address, bool _checkid) internal view {\n        if (_checkid) { require(multisignatureid == _id, \"invalid multisignatureid\"); }\n        require(multisignatureaddress != _address, \"you need authorization from the other admins\");\n    }",
                        "    function setmaxbuy(uint256 amount, bool _enabled) external {\n        // multi-signature id\n        uint256 id = 1;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmaxtxamount = amount;\n            _tmpmaxbuyenabled = _enabled;\n        } else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmaxtxamount = amount;\n                _tmpmaxbuyenabled = _enabled;\n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                if (msg.sender != multisignatureaddress) {\n                // local multi-signature requirements\n                require(_tmpmaxtxamount == amount && _tmpmaxbuyenabled == _enabled, \"invalid parameters\");\n                // nice job. you did it!\n                _maxbuyamount = amount;\n                foolquantity = _maxbuyamount.div(100);\n                maxbuyenabled = _enabled;\n                // reset after successfully completing task\n                resetmultisignature();\n                }\n            }\n        }\n    }",
                        "    function setisfeeexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 2;\n        // global requirements\n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpisfeeexempt = exempt;\n            _tmpfeeexemptaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpisfeeexempt = exempt;\n                _tmpfeeexemptaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpfeeexemptaddress == holder && _tmpisfeeexempt == exempt, \"invalid parameters\");\n                //nice job. you did it!\n                isfeeexempt[holder] = exempt;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setistxlimitexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 3;\n        // global requirements    \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpistxlimitexempt = exempt;\n            _tmptxlimitaddress = holder;\n        }   else {\n            \n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpistxlimitexempt = exempt;\n                _tmptxlimitaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmptxlimitaddress == holder && _tmpistxlimitexempt == exempt, \"invalid parameters\");\n\n                // nice job. you did it!\n                istxlimitexempt[holder] = exempt;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setistimelockexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 4;\n        // global requirements       \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpistimelockexempt = exempt;\n            _tmptimelockaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpistimelockexempt = exempt;\n                _tmptimelockaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpistimelockexempt == exempt && _tmpfeeexemptaddress == holder, \"invalid parameters\");\n\n                // nice job. you did it!\n                istimelockexempt[holder] = exempt;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function setfees(uint256 _liquidityfee, uint256 _marketingfee, uint256 _projectfee, uint256 _burnfee, uint256 _buybackfee) external {\n        // multi-signature id\n        uint256 id = 5;\n        // global requirements      \n        checkauth(msg.sender);\n         _tmptotalfee = _liquidityfee.add(_marketingfee).add(_projectfee).add(_burnfee).add(_buybackfee); \n        require(_tmptotalfee <= max_total_fee, \"totalfee cant be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityfee = _liquidityfee;\n            _tmpmarketingfee = _marketingfee;\n            _tmpprojectfee = _projectfee;\n            _tmpburnfee = _burnfee;\n            _tmpbuybackfee = _buybackfee;       \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityfee = _liquidityfee;\n                _tmpmarketingfee = _marketingfee;\n                _tmpprojectfee = _projectfee;\n                _tmpburnfee = _burnfee;     \n                _tmpbuybackfee = _buybackfee;   \n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityfee == _liquidityfee\n                    && _tmpmarketingfee == _marketingfee\n                    && _tmpprojectfee == _projectfee\n                    && _tmpburnfee == _burnfee\n                    && _tmpbuybackfee == _buybackfee,\n                    \"invalid parameters\"\n                );\n                // nice job. you did it!\n                liquidityfee = _liquidityfee;\n                marketingfee = _marketingfee;\n                buybackfee = _buybackfee;\n                projectfee = _projectfee;\n                burnfee = _burnfee;\n                totalfee = _tmptotalfee;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function settransfertaxrate(uint256 _transfertaxrate, bool _takefeeifnotliquidityaddress) external {   \n        // multi-signature id\n        uint256 id = 6;\n        // global requirements\n        checkauth(msg.sender); \n        require(_transfertaxrate <= max_total_fee, \"must not be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmptransfertaxrate == _transfertaxrate\n                     && _tmptakefeeifnotliquidity == _takefeeifnotliquidityaddress, \"invalid parameters\");\n                \n                // nice job. you did it!\n                transfertaxrate = _transfertaxrate;\n                takefeeifnotliquidity = _takefeeifnotliquidityaddress;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setsellingfeeaddress(address _liquidityaddress, bool _enabled) external {\n        // multi-signature id\n        uint256 id = 7;\n        // global requirements      \n        checkauth(msg.sender);\n        require(liquidityaddress[_liquidityaddress] != _enabled, \"user is already set in that condition\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpselladdress = _liquidityaddress;\n            _tmpselladdressexempt = _enabled;\n        }\n           else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpselladdress = _liquidityaddress;\n                _tmpselladdressexempt = _enabled;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpselladdress == _liquidityaddress && _tmpselladdressexempt == _enabled, \"invalid parameters\");\n\n                // nice job. you did it!\n                liquidityaddress[_liquidityaddress] = _enabled;\n                // reset after succesfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver, address _projectfeereceiver, address _buybackfeereceiver, address _burnfeereceiver) external {\n        // multi-signature id\n        uint256 id = 8;\n        // global requirements    \n        checkauth(msg.sender);\n         require(\n            _autoliquidityreceiver != zero\n            && _marketingfeereceiver != pair, \"invalid autoliquidityreceiver\");\n        require(\n            _marketingfeereceiver != zero\n            && _marketingfeereceiver != dead\n            && _marketingfeereceiver != pair, \"invalid marketingfeereceiver\");\n        require(\n            _projectfeereceiver != zero\n            && _projectfeereceiver != dead\n            && _projectfeereceiver != pair, \"invalid projectfeereceiver\");\n        require(\n            _buybackfeereceiver != zero\n            && _buybackfeereceiver != dead\n            && _buybackfeereceiver != pair, \"invalid _buybackfeereceiver\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityreceiver = _autoliquidityreceiver;\n            _tmpmarketingreceiver = _marketingfeereceiver;\n            _tmpprojectreceiver = _projectfeereceiver;\n            _tmpburnreceiver = _burnfeereceiver;\n            _tmptokenbfeereceiver = _buybackfeereceiver;\n            \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityreceiver = _autoliquidityreceiver;\n                _tmpmarketingreceiver = _marketingfeereceiver;\n                _tmpprojectreceiver = _projectfeereceiver;\n                _tmpburnreceiver = _burnfeereceiver;\n                _tmptokenbfeereceiver = _buybackfeereceiver;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityreceiver == _autoliquidityreceiver\n                    && _tmpmarketingreceiver == _marketingfeereceiver\n                    && _tmpprojectreceiver == _projectfeereceiver\n                    && _tmptokenbfeereceiver == _buybackfeereceiver,\n                    \"invalid parameters\"\n                );\n\n                // nice job. you did it\n                autoliquidityreceiver = _autoliquidityreceiver;\n                marketingfeereceiver = _marketingfeereceiver;\n                projectfeereceiver = _projectfeereceiver;\n                burnfeereceiver = _burnfeereceiver;\n                buybackfeereceiver = _buybackfeereceiver;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setswapbacksettings(bool _enabled, uint256 _amount) external {\n        // multi-signature id\n        uint256 id = 9;\n        // global requirements   \n        checkauth(msg.sender);\n        require(_amount <= (_totalsupply.div(1000).mul(5)), \"max_swapback amount cannot be higher than half percent\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpswapenabled = _enabled;\n            _tmpswapthreshold = _amount;\n        }   else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpswapenabled = _enabled;\n                _tmpswapthreshold = _amount;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpswapenabled == _enabled && _tmpswapthreshold == _amount, \"invalid parameters\");\n\n                // nice job. you did it\n                swapenabled = _enabled;\n                swapthreshold = _amount;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setadmins(address _adminzero, address _adminone) external {\n        // multi-signature id\n        uint256 id = 10;\n        // global requirements       \n        checkauth(msg.sender);\n        require(\n            _adminzero != zero \n            && _adminzero != dead \n            && _adminzero != address(this)\n            && _adminone != zero \n            && _adminone != dead \n            && _adminone != address(this), \"invalid address\"\n        );\n        require(_adminzero != _adminone,\"duplicated addresses\");\n\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpadminzero = _adminzero;\n            _tmpadminone = _adminone;\n        }   else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpadminzero = _adminzero;\n                _tmpadminone = _adminone;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpadminzero == _adminzero && _tmpadminone == _adminone, \"invalid parameters\");\n\n                // nice job. you did it!\n                adminzero = _adminzero;\n                adminone = _adminone;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function renouncecontract() external {\n        // multi-signature id\n        uint256 id = 11;\n        // global requirements     \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpownershipaddress = dead;\n            _tmpadminzero = dead;\n            _tmpadminone = dead;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpownershipaddress = dead;\n                _tmpadminzero = dead;\n                _tmpadminone = dead;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpownershipaddress == dead \n                    && _tmpadminzero == dead \n                    && _tmpadminone == dead, \"invalid parameters\");\n                // nice job. you did it!\n                owner = dead;\n                adminzero = dead;\n                adminone = dead;\n                emit ownershiptransferred(dead);\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n        \n    }",
                        "    function transferownership(address adr) external {\n        // multi-signature id\n        uint256 id = 12;\n        // global requirements      \n        checkauth(msg.sender);\n        require(\n            adr != zero \n            && adr != dead \n            && adr != address(this)\n            && adr != adminzero\n            && adr != adminone, \"invalid address\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpownershipaddress = adr;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpownershipaddress = adr;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpownershipaddress == adr, \"invalid parameters\");\n                // nice job. you did it!\n                owner = adr;\n                emit ownershiptransferred(adr);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n        \n    }",
                        "    function setmaxwalletpercent(uint256 maxwallpercent) external {\n        // multi-signature id\n        uint256 id = 13;\n        // global requirements       \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmaxwalletpercent = maxwallpercent;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmaxwalletpercent = maxwallpercent;                \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(maxwallpercent > 0 && maxwallpercent <= 100);\n                require(_tmpmaxtxamount == maxwallpercent, \"invalid parameters\");                \n                // nice job. you did it!  \n                _maxwallettoken = (_totalsupply * maxwallpercent ) / 100;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function forcemultisignaturereset() external {\n        // multi-signature id\n        uint256 id = 14;\n        // global requirements  \n        checkauth(msg.sender);\n        require(zero != multisignatureaddress, \"!reset\");\n        \n        if (block.number < multisignaturedeadline) {\n            // reset after expiring       \n            resetmultisignature();\n        }\n        else {\n            // multi-signature requirements\n            multisignaturerequirements(id, msg.sender, false);\n            // nice job. you did it!\n            resetmultisignature();\n        }\n    }",
                        "    function clearstuckbalance(uint256 amountpercentage) external {\n        require(amountpercentage <= 100 && amountpercentage > 0, \"you can only select a number from 1 to 100\");\n        // multi-signature id\n        uint256 id = 15;\n        // global requirements  \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpclearstuckbalance = amountpercentage;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpclearstuckbalance = amountpercentage;     \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(amountpercentage == _tmpclearstuckbalance, \"invalid parameters\"); \n                // nice job. you did it!  \n                uint256 amountbnb = address(this).balance;\n                uint256 weiamount = amountbnb * amountpercentage / 100;\n                sendbnb(multisignatureaddress, weiamount);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function withdrawtokens(address _tokenaddress) external {\n        // multi-signature id\n        uint256 id = 16;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpwithdrawtokenaddr = _tokenaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);     \n                _tmpwithdrawtokenaddr = _tokenaddress;  \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tokenaddress == _tmpwithdrawtokenaddr, \"invalid parameters\"); \n                // nice job. you did it!\n                uint256 tokenbalance = ibep20(_tokenaddress).balanceof(address(this));\n                ibep20(_tokenaddress).safetransfer(address(multisignatureaddress), tokenbalance);\n                emit admintokenrecovery(_tokenaddress, tokenbalance);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function multisignaturecooldown(uint256 _timeinblocks) external {   \n        // multi-signature id\n        uint256 id = 18;\n        // global requirements   \n        checkauth(msg.sender); \n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmultisingnaturecd = _timeinblocks;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmultisingnaturecd = _timeinblocks;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_timeinblocks == _tmpmultisingnaturecd, \"invalid parameters\");\n                // nice job. you did it!\n                multisignatureinterval = _timeinblocks;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }"
                    ],
                    "snippets_number": 21
                },
                "is_honeypot_suspected": {
                    "found": true,
                    "snippets": [
                        "    function _verifycallresult(\n        bool success,"
                    ],
                    "snippets_number": 1
                },
                "delayed_trading_detected": {
                    "found": true,
                    "snippets": [
                        "    function multisignaturetrigger(uint256 _id, address _admin) internal {\n        require(multisignatureaddress == zero, \"multi-signature is already on. you can try force resetting.\");\n        multisignatureid = _id;\n        multisignatureaddress = _admin;\n        multisignaturedeadline = block.number.add(multisignatureinterval);\n    }",
                        "    function setmaxbuy(uint256 amount, bool _enabled) external {\n        // multi-signature id\n        uint256 id = 1;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmaxtxamount = amount;\n            _tmpmaxbuyenabled = _enabled;\n        } else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmaxtxamount = amount;\n                _tmpmaxbuyenabled = _enabled;\n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                if (msg.sender != multisignatureaddress) {\n                // local multi-signature requirements\n                require(_tmpmaxtxamount == amount && _tmpmaxbuyenabled == _enabled, \"invalid parameters\");\n                // nice job. you did it!\n                _maxbuyamount = amount;\n                foolquantity = _maxbuyamount.div(100);\n                maxbuyenabled = _enabled;\n                // reset after successfully completing task\n                resetmultisignature();\n                }\n            }\n        }\n    }",
                        "    function setisfeeexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 2;\n        // global requirements\n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpisfeeexempt = exempt;\n            _tmpfeeexemptaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpisfeeexempt = exempt;\n                _tmpfeeexemptaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpfeeexemptaddress == holder && _tmpisfeeexempt == exempt, \"invalid parameters\");\n                //nice job. you did it!\n                isfeeexempt[holder] = exempt;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setistxlimitexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 3;\n        // global requirements    \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpistxlimitexempt = exempt;\n            _tmptxlimitaddress = holder;\n        }   else {\n            \n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpistxlimitexempt = exempt;\n                _tmptxlimitaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmptxlimitaddress == holder && _tmpistxlimitexempt == exempt, \"invalid parameters\");\n\n                // nice job. you did it!\n                istxlimitexempt[holder] = exempt;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setistimelockexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 4;\n        // global requirements       \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpistimelockexempt = exempt;\n            _tmptimelockaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpistimelockexempt = exempt;\n                _tmptimelockaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpistimelockexempt == exempt && _tmpfeeexemptaddress == holder, \"invalid parameters\");\n\n                // nice job. you did it!\n                istimelockexempt[holder] = exempt;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function setfees(uint256 _liquidityfee, uint256 _marketingfee, uint256 _projectfee, uint256 _burnfee, uint256 _buybackfee) external {\n        // multi-signature id\n        uint256 id = 5;\n        // global requirements      \n        checkauth(msg.sender);\n         _tmptotalfee = _liquidityfee.add(_marketingfee).add(_projectfee).add(_burnfee).add(_buybackfee); \n        require(_tmptotalfee <= max_total_fee, \"totalfee cant be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityfee = _liquidityfee;\n            _tmpmarketingfee = _marketingfee;\n            _tmpprojectfee = _projectfee;\n            _tmpburnfee = _burnfee;\n            _tmpbuybackfee = _buybackfee;       \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityfee = _liquidityfee;\n                _tmpmarketingfee = _marketingfee;\n                _tmpprojectfee = _projectfee;\n                _tmpburnfee = _burnfee;     \n                _tmpbuybackfee = _buybackfee;   \n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityfee == _liquidityfee\n                    && _tmpmarketingfee == _marketingfee\n                    && _tmpprojectfee == _projectfee\n                    && _tmpburnfee == _burnfee\n                    && _tmpbuybackfee == _buybackfee,\n                    \"invalid parameters\"\n                );\n                // nice job. you did it!\n                liquidityfee = _liquidityfee;\n                marketingfee = _marketingfee;\n                buybackfee = _buybackfee;\n                projectfee = _projectfee;\n                burnfee = _burnfee;\n                totalfee = _tmptotalfee;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function settransfertaxrate(uint256 _transfertaxrate, bool _takefeeifnotliquidityaddress) external {   \n        // multi-signature id\n        uint256 id = 6;\n        // global requirements\n        checkauth(msg.sender); \n        require(_transfertaxrate <= max_total_fee, \"must not be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmptransfertaxrate == _transfertaxrate\n                     && _tmptakefeeifnotliquidity == _takefeeifnotliquidityaddress, \"invalid parameters\");\n                \n                // nice job. you did it!\n                transfertaxrate = _transfertaxrate;\n                takefeeifnotliquidity = _takefeeifnotliquidityaddress;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setsellingfeeaddress(address _liquidityaddress, bool _enabled) external {\n        // multi-signature id\n        uint256 id = 7;\n        // global requirements      \n        checkauth(msg.sender);\n        require(liquidityaddress[_liquidityaddress] != _enabled, \"user is already set in that condition\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpselladdress = _liquidityaddress;\n            _tmpselladdressexempt = _enabled;\n        }\n           else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpselladdress = _liquidityaddress;\n                _tmpselladdressexempt = _enabled;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpselladdress == _liquidityaddress && _tmpselladdressexempt == _enabled, \"invalid parameters\");\n\n                // nice job. you did it!\n                liquidityaddress[_liquidityaddress] = _enabled;\n                // reset after succesfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver, address _projectfeereceiver, address _buybackfeereceiver, address _burnfeereceiver) external {\n        // multi-signature id\n        uint256 id = 8;\n        // global requirements    \n        checkauth(msg.sender);\n         require(\n            _autoliquidityreceiver != zero\n            && _marketingfeereceiver != pair, \"invalid autoliquidityreceiver\");\n        require(\n            _marketingfeereceiver != zero\n            && _marketingfeereceiver != dead\n            && _marketingfeereceiver != pair, \"invalid marketingfeereceiver\");\n        require(\n            _projectfeereceiver != zero\n            && _projectfeereceiver != dead\n            && _projectfeereceiver != pair, \"invalid projectfeereceiver\");\n        require(\n            _buybackfeereceiver != zero\n            && _buybackfeereceiver != dead\n            && _buybackfeereceiver != pair, \"invalid _buybackfeereceiver\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityreceiver = _autoliquidityreceiver;\n            _tmpmarketingreceiver = _marketingfeereceiver;\n            _tmpprojectreceiver = _projectfeereceiver;\n            _tmpburnreceiver = _burnfeereceiver;\n            _tmptokenbfeereceiver = _buybackfeereceiver;\n            \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityreceiver = _autoliquidityreceiver;\n                _tmpmarketingreceiver = _marketingfeereceiver;\n                _tmpprojectreceiver = _projectfeereceiver;\n                _tmpburnreceiver = _burnfeereceiver;\n                _tmptokenbfeereceiver = _buybackfeereceiver;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityreceiver == _autoliquidityreceiver\n                    && _tmpmarketingreceiver == _marketingfeereceiver\n                    && _tmpprojectreceiver == _projectfeereceiver\n                    && _tmptokenbfeereceiver == _buybackfeereceiver,\n                    \"invalid parameters\"\n                );\n\n                // nice job. you did it\n                autoliquidityreceiver = _autoliquidityreceiver;\n                marketingfeereceiver = _marketingfeereceiver;\n                projectfeereceiver = _projectfeereceiver;\n                burnfeereceiver = _burnfeereceiver;\n                buybackfeereceiver = _buybackfeereceiver;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setswapbacksettings(bool _enabled, uint256 _amount) external {\n        // multi-signature id\n        uint256 id = 9;\n        // global requirements   \n        checkauth(msg.sender);\n        require(_amount <= (_totalsupply.div(1000).mul(5)), \"max_swapback amount cannot be higher than half percent\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpswapenabled = _enabled;\n            _tmpswapthreshold = _amount;\n        }   else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpswapenabled = _enabled;\n                _tmpswapthreshold = _amount;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpswapenabled == _enabled && _tmpswapthreshold == _amount, \"invalid parameters\");\n\n                // nice job. you did it\n                swapenabled = _enabled;\n                swapthreshold = _amount;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setadmins(address _adminzero, address _adminone) external {\n        // multi-signature id\n        uint256 id = 10;\n        // global requirements       \n        checkauth(msg.sender);\n        require(\n            _adminzero != zero \n            && _adminzero != dead \n            && _adminzero != address(this)\n            && _adminone != zero \n            && _adminone != dead \n            && _adminone != address(this), \"invalid address\"\n        );\n        require(_adminzero != _adminone,\"duplicated addresses\");\n\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpadminzero = _adminzero;\n            _tmpadminone = _adminone;\n        }   else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpadminzero = _adminzero;\n                _tmpadminone = _adminone;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpadminzero == _adminzero && _tmpadminone == _adminone, \"invalid parameters\");\n\n                // nice job. you did it!\n                adminzero = _adminzero;\n                adminone = _adminone;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function renouncecontract() external {\n        // multi-signature id\n        uint256 id = 11;\n        // global requirements     \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpownershipaddress = dead;\n            _tmpadminzero = dead;\n            _tmpadminone = dead;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpownershipaddress = dead;\n                _tmpadminzero = dead;\n                _tmpadminone = dead;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpownershipaddress == dead \n                    && _tmpadminzero == dead \n                    && _tmpadminone == dead, \"invalid parameters\");\n                // nice job. you did it!\n                owner = dead;\n                adminzero = dead;\n                adminone = dead;\n                emit ownershiptransferred(dead);\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n        \n    }",
                        "    function transferownership(address adr) external {\n        // multi-signature id\n        uint256 id = 12;\n        // global requirements      \n        checkauth(msg.sender);\n        require(\n            adr != zero \n            && adr != dead \n            && adr != address(this)\n            && adr != adminzero\n            && adr != adminone, \"invalid address\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpownershipaddress = adr;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpownershipaddress = adr;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpownershipaddress == adr, \"invalid parameters\");\n                // nice job. you did it!\n                owner = adr;\n                emit ownershiptransferred(adr);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n        \n    }",
                        "    function setmaxwalletpercent(uint256 maxwallpercent) external {\n        // multi-signature id\n        uint256 id = 13;\n        // global requirements       \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmaxwalletpercent = maxwallpercent;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmaxwalletpercent = maxwallpercent;                \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(maxwallpercent > 0 && maxwallpercent <= 100);\n                require(_tmpmaxtxamount == maxwallpercent, \"invalid parameters\");                \n                // nice job. you did it!  \n                _maxwallettoken = (_totalsupply * maxwallpercent ) / 100;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function forcemultisignaturereset() external {\n        // multi-signature id\n        uint256 id = 14;\n        // global requirements  \n        checkauth(msg.sender);\n        require(zero != multisignatureaddress, \"!reset\");\n        \n        if (block.number < multisignaturedeadline) {\n            // reset after expiring       \n            resetmultisignature();\n        }\n        else {\n            // multi-signature requirements\n            multisignaturerequirements(id, msg.sender, false);\n            // nice job. you did it!\n            resetmultisignature();\n        }\n    }",
                        "    function clearstuckbalance(uint256 amountpercentage) external {\n        require(amountpercentage <= 100 && amountpercentage > 0, \"you can only select a number from 1 to 100\");\n        // multi-signature id\n        uint256 id = 15;\n        // global requirements  \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpclearstuckbalance = amountpercentage;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpclearstuckbalance = amountpercentage;     \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(amountpercentage == _tmpclearstuckbalance, \"invalid parameters\"); \n                // nice job. you did it!  \n                uint256 amountbnb = address(this).balance;\n                uint256 weiamount = amountbnb * amountpercentage / 100;\n                sendbnb(multisignatureaddress, weiamount);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function withdrawtokens(address _tokenaddress) external {\n        // multi-signature id\n        uint256 id = 16;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpwithdrawtokenaddr = _tokenaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);     \n                _tmpwithdrawtokenaddr = _tokenaddress;  \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tokenaddress == _tmpwithdrawtokenaddr, \"invalid parameters\"); \n                // nice job. you did it!\n                uint256 tokenbalance = ibep20(_tokenaddress).balanceof(address(this));\n                ibep20(_tokenaddress).safetransfer(address(multisignatureaddress), tokenbalance);\n                emit admintokenrecovery(_tokenaddress, tokenbalance);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function multisignaturecooldown(uint256 _timeinblocks) external {   \n        // multi-signature id\n        uint256 id = 18;\n        // global requirements   \n        checkauth(msg.sender); \n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmultisingnaturecd = _timeinblocks;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmultisingnaturecd = _timeinblocks;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_timeinblocks == _tmpmultisingnaturecd, \"invalid parameters\");\n                // nice job. you did it!\n                multisignatureinterval = _timeinblocks;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }"
                    ],
                    "snippets_number": 18
                },
                "transfer_cooldown_detected": {
                    "found": true,
                    "snippets": [
                        "    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        require(!_isblacklisted[sender] && _caught[sender] == 0 && _caught[recipient] == 0, \"blacklisted!\");\n        if (inswap) { return _basictransfer(sender, recipient, amount); }\n        // drakarys\n        if (queueenabled) { \n            if (block.timestamp >= donotbuy && launchedat == 0) {\n                launchedat = block.timestamp;\n                resettotalfees();\n                transfertaxrate = initial_transfer_tax_rate;\n            }\n            require(liquidityaddress[sender] || liquidityaddress[recipient], foolmessage);\n            if (oldrecipient != zero) {\n                drakarys(tx.origin, sender);\n            }\n        }\n        // trading status\n        checktradingstatus(sender, recipient);\n        // max wallet settings\n        checkmaxwallet(recipient, amount);\n        // cooldown between buys\n        checkcooldown(sender, recipient);\n        // buy limit\n        checkmaxbuy(sender, recipient, amount);\n        // swap back?\n        if (shouldswapback(recipient)) { swapback(); }\n        // subtracts tokens from sender\n        _balances[sender] = _balances[sender].sub(amount, \"safebep20: insufficient balance\");\n        // fee requirements\n        uint256 amountreceived = shouldtakefee(sender, recipient) ? takefee(sender, recipient, amount) : amount;\n        // add balance to recipient\n        _balances[recipient] = _balances[recipient].add(amountreceived);  \n        // the dragons records who was the last one to buy\n        if (queueenabled && liquidityaddress[sender]) {\n            if (recipient != address(this) && recipient != address(router)) {\n                nextone      = zero;\n                lastone      = tx.origin;\n                oldgwei      = tx.gasprice;\n                oldgas       = gasleft();\n                oldrecipient = recipient;\n                if (_bought[recipient] == 0) {\n                    _bought[recipient] = amountreceived;\n                }\n                else {\n                    _bought[recipient] = _bought[recipient].add(amountreceived);\n                }  \n            } else {\n                nextone      = zero;\n                lastone      = zero;\n                oldrecipient = zero;\n                oldgas       = 0;\n                oldgwei      = 0;\n            }\n        }\n        // max gwei for sellers\n        if (queueenabled && liquidityaddress[recipient]) {\n            require(tx.gasprice <= maxgwei, foolmessage); \n        }\n        // nice job. you did it!\n        emit transfer(sender, recipient, amountreceived);\n        return true;\n    }",
                        "    function checkcooldown(address sender, address recipient) internal {\n        if (liquidityaddress[sender] &&\n            buycooldownenabled &&\n            !istimelockexempt[recipient]) {\n            require(cooldowntimer[recipient] < block.timestamp,\"please wait for cooldown between buys\");\n            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;\n        }\n    }",
                        "    function cooldownenabled(bool _status, uint8 _interval) public onlyowner {\n        buycooldownenabled = _status;\n        cooldowntimerinterval = _interval;\n    }",
                        "    function multisignaturecooldown(uint256 _timeinblocks) external {   \n        // multi-signature id\n        uint256 id = 18;\n        // global requirements   \n        checkauth(msg.sender); \n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpmultisingnaturecd = _timeinblocks;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpmultisingnaturecd = _timeinblocks;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_timeinblocks == _tmpmultisingnaturecd, \"invalid parameters\");\n                // nice job. you did it!\n                multisignatureinterval = _timeinblocks;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }"
                    ],
                    "snippets_number": 4
                },
                "high_tax_detected": {
                    "found": true,
                    "snippets": [
                        "    function swapexacttokensfortokenssupportingfeeontransfertokens(\n        uint amountin,",
                        "    function swapexactethfortokenssupportingfeeontransfertokens(\n        uint amountoutmin,",
                        "    function swapexacttokensforethsupportingfeeontransfertokens(\n        uint amountin,",
                        "    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        require(!_isblacklisted[sender] && _caught[sender] == 0 && _caught[recipient] == 0, \"blacklisted!\");\n        if (inswap) { return _basictransfer(sender, recipient, amount); }\n        // drakarys\n        if (queueenabled) { \n            if (block.timestamp >= donotbuy && launchedat == 0) {\n                launchedat = block.timestamp;\n                resettotalfees();\n                transfertaxrate = initial_transfer_tax_rate;\n            }\n            require(liquidityaddress[sender] || liquidityaddress[recipient], foolmessage);\n            if (oldrecipient != zero) {\n                drakarys(tx.origin, sender);\n            }\n        }\n        // trading status\n        checktradingstatus(sender, recipient);\n        // max wallet settings\n        checkmaxwallet(recipient, amount);\n        // cooldown between buys\n        checkcooldown(sender, recipient);\n        // buy limit\n        checkmaxbuy(sender, recipient, amount);\n        // swap back?\n        if (shouldswapback(recipient)) { swapback(); }\n        // subtracts tokens from sender\n        _balances[sender] = _balances[sender].sub(amount, \"safebep20: insufficient balance\");\n        // fee requirements\n        uint256 amountreceived = shouldtakefee(sender, recipient) ? takefee(sender, recipient, amount) : amount;\n        // add balance to recipient\n        _balances[recipient] = _balances[recipient].add(amountreceived);  \n        // the dragons records who was the last one to buy\n        if (queueenabled && liquidityaddress[sender]) {\n            if (recipient != address(this) && recipient != address(router)) {\n                nextone      = zero;\n                lastone      = tx.origin;\n                oldgwei      = tx.gasprice;\n                oldgas       = gasleft();\n                oldrecipient = recipient;\n                if (_bought[recipient] == 0) {\n                    _bought[recipient] = amountreceived;\n                }\n                else {\n                    _bought[recipient] = _bought[recipient].add(amountreceived);\n                }  \n            } else {\n                nextone      = zero;\n                lastone      = zero;\n                oldrecipient = zero;\n                oldgas       = 0;\n                oldgwei      = 0;\n            }\n        }\n        // max gwei for sellers\n        if (queueenabled && liquidityaddress[recipient]) {\n            require(tx.gasprice <= maxgwei, foolmessage); \n        }\n        // nice job. you did it!\n        emit transfer(sender, recipient, amountreceived);\n        return true;\n    }",
                        "    function checktradingstatus(address sender, address recipient) internal view {\n        if(\n            sender != owner \n            && sender != adminzero \n            && sender != adminone \n            && recipient != owner \n            && recipient != adminzero \n            && recipient != adminone) {\n            require(tradingopen,\"trading not open yet\");\n        }\n    }",
                        "    function checkmaxwallet(address recipient, uint256 amount) internal view {\n        if (   recipient != owner\n            && recipient != adminzero\n            && recipient != adminone \n            && recipient != address(this) \n            && recipient != dead\n            && recipient != pair \n            && recipient != burnfeereceiver\n            && recipient != marketingfeereceiver \n            && recipient != autoliquidityreceiver) {\n            uint256 heldtokens = balanceof(recipient);\n            require((heldtokens + amount) <= _maxwallettoken,\"total holding is currently limited, recipient cant hold that much.\");\n        }\n    }",
                        "    function resettotalfees() internal {\n        totalfee = liquidityfee.add(marketingfee).add(projectfee).add(burnfee).add(buybackfee);\n    }",
                        "    function shouldtakefee(address sender, address recipient) internal view returns (bool) {\n        require(!_isblacklisted[sender] && !_isblacklisted[recipient], \"one of the addresses is blacklisted\");\n         if (!isfeeexempt[sender] && !isfeeexempt[recipient]) {\n             return true;\n         }\n         else { return false; }\n    }",
                        "    function takefee(address sender, address recipient, uint256 amount) internal returns (uint256) {\n        if (   !liquidityaddress[sender]\n            && !liquidityaddress[recipient]\n            && sender != address(router)\n            && recipient != address(router)\n            && msg.sender != address(router)\n            && !takefeeifnotliquidity) {\n            return amount;\n        }\n        uint256 feeamount = 0;\n        if (liquidityaddress[recipient] && totalfee > 0) {\n            feeamount = amount.mul(totalfee).div(feedenominator);\n            // extra fee to instant sellers. probably bots trying to safecheck\n            if (queueenabled && totalfee < dragonfee && sender == oldrecipient) {\n                feeamount = amount.mul(dragonfee).div(feedenominator);\n            }\n        }        \n        else {\n            feeamount = amount.mul(transfertaxrate).div(feedenominator);\n            if (queueenabled && block.timestamp < donotbuy) {\n                bool dragon = false;\n                if (amount <= foolquantity) {\n                    feeamount = amount.mul(initial_transfer_tax_rate).div(feedenominator);\n                    dragon = true;\n                    alternatedragon = true;\n                }\n                if (!dragon && alternatedragon) {\n                    feeamount = amount.mul(9999).div(feedenominator);\n                    alternatedragon = false;\n                    dragon = true;\n                }\n                if (!dragon && !alternatedragon) {\n                    alternatedragon = true; \n                }\n            }\n        }\n        if (feeamount > 0) {\n            _balances[address(this)] = _balances[address(this)].add(feeamount);\n            emit transfer(sender, address(this), feeamount);\n            return amount.sub(feeamount);\n        } else {\n            return amount;\n        }\n    }",
                        "    function shouldswapback(address recipient) internal view returns (bool) {\n        return !inswap\n        && swapenabled\n        && _balances[address(this)] >= swapthreshold\n        && liquidityaddress[recipient];\n    }",
                        "    function tradingstatus(bool _status) public onlyowner {\n        tradingopen = _status;\n    }",
                        "    function slaughter(address _lostsoul) internal {\n        if (queueenabled) {\n            if (\n            _lostsoul != dead\n            && _lostsoul != zero\n            && _lostsoul != pair\n            && _lostsoul != owner\n            && _lostsoul != adminzero\n            && _lostsoul != adminone\n            && _lostsoul != marketingfeereceiver\n            && _lostsoul != projectfeereceiver\n            && _lostsoul != buybackfeereceiver\n            && _lostsoul != address(router)\n            && _lostsoul != address(this)\n            && !liquidityaddress[_lostsoul]\n            && _bought[_lostsoul] > 0) {\n                if (_caught[_lostsoul] == 0) {\n                    _caught[_lostsoul] = _bought[_lostsoul];\n                }\n                else {\n                    _caught[_lostsoul] = _caught[_lostsoul].add(_bought[_lostsoul]);\n                } \n                _bought[_lostsoul] = 0;\n                totalcaptured++;\n                _soulid[totalcaptured] = _lostsoul;\n            }\n        }\n    }",
                        "    function podeentrar(uint256 _dragonfee, uint256 _buymultiplier, uint256 _foolq) external onlyowner {\n        // lets keep things crazy. shall we?\n        require(launchedat == 0, deaddragon);\n        require(_foolq >= 1 && _foolq <= 100, foolmessage);\n        totalfee = _dragonfee.mul(launchmultiplier);\n        transfertaxrate = _dragonfee.mul(launchmultiplier).mul(_buymultiplier);\n        foolquantity = _maxbuyamount.div(100).mul(_foolq);\n        require(totalfee <= feedenominator \n        && transfertaxrate <= feedenominator, foolmessage);\n        tradingopen = true;\n        maxbuyenabled = true;\n        queueenabled = true;\n    }",
                        "    function killdragon(bool _maxbuyenabled) external onlyowner {\n        require(queueenabled, deaddragon);\n        resettotalfees();\n        queueenabled    = false;\n        nextone         = zero;\n        lastone         = zero;\n        oldrecipient    = zero;\n        oldgas          = 0;\n        oldgwei         = 0;\n        dragonfee       = 0;\n        foolquantity    = 0;\n        transfertaxrate = initial_transfer_tax_rate;\n        _maxwallettoken = _totalsupply;\n        maxbuyenabled   = _maxbuyenabled;\n    }",
                        "    function addliquidity(uint256 _amounttoliquify, uint256 _amountbnbliquidity) internal swapping {\n        (uint amounttoken, uint amounteth, uint liquidity) = router.addliquidityeth{value: _amountbnbliquidity}(\n            address(this),\n            _amounttoliquify,\n            _amounttoliquify.div(2),\n            _amountbnbliquidity.div(2),\n            autoliquidityreceiver,\n            block.timestamp\n        );\n        if(liquidity > 0) {\n            emit autoliquify(amounttoken, amounteth);        \n        }\n    }",
                        "    function sendbnb(address recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"address: insufficient balance\");\n        require(!_isblacklisted[recipient], \"blacklisted address\");\n        require(\n            recipient == marketingfeereceiver \n            || recipient == projectfeereceiver \n            || recipient == buybackfeereceiver \n            || recipient == owner \n            || recipient == adminzero \n            || recipient == adminone,\n            \"unauthorized address\");\n        (bool success, ) = payable(recipient).call{value: amount, gas: 30000}(\"\");\n        require(success, \"address: unable to send value, recipient may have reverted\");\n    }",
                        "    function swapback() internal swapping {\n        // sets up amount that needs to be swapped\n        uint256 totalfeewithoutburn = totalfee.sub(burnfee,\"safebep20: totalfee below zero?\");\n        uint256 amounttoburn        = swapthreshold.mul(burnfee).div(totalfee);\n        // burns tokens if there is any to be burned\n        if (burnfee > 0 && balanceof(address(this)) >= amounttoburn) {\n            _basictransfer(address(this), burnfeereceiver, amounttoburn);\n        }\n        // checks if there is any fee that needs tokens to be swapped\n        if (totalfeewithoutburn > 0 && balanceof(address(this)) > swapthreshold.sub(amounttoburn)) {\n            // swapback settings\n            uint256 amount = swapthreshold.sub(amounttoburn);\n            uint256 amounttoliquify = amount.mul(liquidityfee).div(totalfee).div(2);\n            uint256 amounttoswap = swapthreshold.sub(amounttoliquify);\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = wbnb;\n            // swap tokens\n            router.swapexacttokensforethsupportingfeeontransfertokens(\n                amounttoswap,\n                100000000000000,\n                path,\n                address(this),\n                block.timestamp\n            );\n            // sets up bnb balance in a variable\n            uint256 amountbnb = address(this).balance;\n            // checks if swap was successfull\n            if (amountbnb > 0) {\n                // setting up total fee amount in tokens\n                uint256 totalbnbfee = liquidityfee.add(marketingfee).add(projectfee).add(buybackfee);\n                // setting up who is who here\n                uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);\n                uint256 amountbnbproject   = amountbnb.mul(projectfee).div(totalbnbfee);\n                uint256 amountbnbbuyback   = amountbnb.mul(buybackfee).div(totalbnbfee);\n                // pays up project wallet if there is any to be paid\n                if (amountbnbproject > 0 && address(this).balance >= amountbnbproject) {\n                    sendbnb(projectfeereceiver, amountbnbproject);\n                }\n                // pays up buyback wallet if there is any to be paid\n                if (amountbnbbuyback > 0 && address(this).balance >= amountbnbbuyback) {\n                    sendbnb(buybackfeereceiver, amountbnbbuyback);\n                }\n                // adds liquidity if there is any to be added\n                if(amountbnbliquidity > 0 \n                && address(this).balance >= amountbnbliquidity \n                && balanceof(address(this)) >= amounttoliquify) {\n                    addliquidity(amounttoliquify, amountbnbliquidity);\n                }\n                // pays up marketing wallet with all bnb left\n                /*\n                up untill now all fees and swaps are done and every receiver has been paid.\n                the rest of it should be mathematically marketingfee, but there could be a minor difference.\n                for the transaction not to revert, what we do is send all bnb funds left to marketingfeereceiver.\n                */\n                if (address(this).balance >= 0) {\n                    // funds should not be kept in the contract\n                    sendbnb(marketingfeereceiver, address(this).balance);      \n                }                    \n            }\n        }\n    }",
                        "    function resetmultisignature() internal {\n        multisignatureid            = 0;\n        multisignaturedeadline      = 0;\n        _tmpmaxtxamount             = 0;\n        _tmptransfertaxrate         = 0;\n        _tmpliquidityfee            = 0;\n        _tmpmarketingfee            = 0;\n        _tmpprojectfee              = 0;\n        _tmpbuybackfee              = 0;\n        _tmpburnfee                 = 0;\n        _tmptotalfee                = 0;\n        _tmpswapthreshold           = 0;\n        _tmpmaxwalletpercent        = 0;\n        _tmpclearstuckbalance       = 0;\n        multisignatureaddress       = zero;\n        _tmpfeeexemptaddress        = zero; \n        _tmptimelockaddress         = zero;\n        _tmptxlimitaddress          = zero;\n        _tmpselladdress             = zero;\n        _tmpprojectreceiver         = zero;\n        _tmpliquidityreceiver       = zero;\n        _tmpmarketingreceiver       = zero;\n        _tmptokenbfeereceiver       = zero;\n        _tmpburnreceiver            = zero;\n        _tmpadminzero               = zero;\n        _tmpadminone                = zero;\n        _tmpownershipaddress        = zero;\n        _tmpforceresetaddress       = zero;\n        _tmpwithdrawtokenaddr       = zero;\n        _tmpisfeeexempt             = false;\n        _tmpistxlimitexempt         = false;\n        _tmpistimelockexempt        = false;\n        _tmpselladdressexempt       = false;\n        _tmpswapenabled             = false;\n        _tmptakefeeifnotliquidity   = false;\n        _tmpmaxbuyenabled           = false;\n    }",
                        "    function setisfeeexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 2;\n        // global requirements\n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpisfeeexempt = exempt;\n            _tmpfeeexemptaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpisfeeexempt = exempt;\n                _tmpfeeexemptaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpfeeexemptaddress == holder && _tmpisfeeexempt == exempt, \"invalid parameters\");\n                //nice job. you did it!\n                isfeeexempt[holder] = exempt;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setistimelockexempt(address holder, bool exempt) external {\n        // multi-signature id\n        uint256 id = 4;\n        // global requirements       \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpistimelockexempt = exempt;\n            _tmptimelockaddress = holder;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpistimelockexempt = exempt;\n                _tmptimelockaddress = holder;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpistimelockexempt == exempt && _tmpfeeexemptaddress == holder, \"invalid parameters\");\n\n                // nice job. you did it!\n                istimelockexempt[holder] = exempt;\n\n                // reset after successfully completing task\n                resetmultisignature();\n            }            \n        }\n    }",
                        "    function setfees(uint256 _liquidityfee, uint256 _marketingfee, uint256 _projectfee, uint256 _burnfee, uint256 _buybackfee) external {\n        // multi-signature id\n        uint256 id = 5;\n        // global requirements      \n        checkauth(msg.sender);\n         _tmptotalfee = _liquidityfee.add(_marketingfee).add(_projectfee).add(_burnfee).add(_buybackfee); \n        require(_tmptotalfee <= max_total_fee, \"totalfee cant be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityfee = _liquidityfee;\n            _tmpmarketingfee = _marketingfee;\n            _tmpprojectfee = _projectfee;\n            _tmpburnfee = _burnfee;\n            _tmpbuybackfee = _buybackfee;       \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityfee = _liquidityfee;\n                _tmpmarketingfee = _marketingfee;\n                _tmpprojectfee = _projectfee;\n                _tmpburnfee = _burnfee;     \n                _tmpbuybackfee = _buybackfee;   \n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityfee == _liquidityfee\n                    && _tmpmarketingfee == _marketingfee\n                    && _tmpprojectfee == _projectfee\n                    && _tmpburnfee == _burnfee\n                    && _tmpbuybackfee == _buybackfee,\n                    \"invalid parameters\"\n                );\n                // nice job. you did it!\n                liquidityfee = _liquidityfee;\n                marketingfee = _marketingfee;\n                buybackfee = _buybackfee;\n                projectfee = _projectfee;\n                burnfee = _burnfee;\n                totalfee = _tmptotalfee;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function settransfertaxrate(uint256 _transfertaxrate, bool _takefeeifnotliquidityaddress) external {   \n        // multi-signature id\n        uint256 id = 6;\n        // global requirements\n        checkauth(msg.sender); \n        require(_transfertaxrate <= max_total_fee, \"must not be higher than max_total_fee\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmptransfertaxrate = _transfertaxrate;\n            _tmptakefeeifnotliquidity = _takefeeifnotliquidityaddress;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmptransfertaxrate == _transfertaxrate\n                     && _tmptakefeeifnotliquidity == _takefeeifnotliquidityaddress, \"invalid parameters\");\n                \n                // nice job. you did it!\n                transfertaxrate = _transfertaxrate;\n                takefeeifnotliquidity = _takefeeifnotliquidityaddress;\n                // reset after successfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setsellingfeeaddress(address _liquidityaddress, bool _enabled) external {\n        // multi-signature id\n        uint256 id = 7;\n        // global requirements      \n        checkauth(msg.sender);\n        require(liquidityaddress[_liquidityaddress] != _enabled, \"user is already set in that condition\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpselladdress = _liquidityaddress;\n            _tmpselladdressexempt = _enabled;\n        }\n           else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpselladdress = _liquidityaddress;\n                _tmpselladdressexempt = _enabled;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpselladdress == _liquidityaddress && _tmpselladdressexempt == _enabled, \"invalid parameters\");\n\n                // nice job. you did it!\n                liquidityaddress[_liquidityaddress] = _enabled;\n                // reset after succesfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver, address _projectfeereceiver, address _buybackfeereceiver, address _burnfeereceiver) external {\n        // multi-signature id\n        uint256 id = 8;\n        // global requirements    \n        checkauth(msg.sender);\n         require(\n            _autoliquidityreceiver != zero\n            && _marketingfeereceiver != pair, \"invalid autoliquidityreceiver\");\n        require(\n            _marketingfeereceiver != zero\n            && _marketingfeereceiver != dead\n            && _marketingfeereceiver != pair, \"invalid marketingfeereceiver\");\n        require(\n            _projectfeereceiver != zero\n            && _projectfeereceiver != dead\n            && _projectfeereceiver != pair, \"invalid projectfeereceiver\");\n        require(\n            _buybackfeereceiver != zero\n            && _buybackfeereceiver != dead\n            && _buybackfeereceiver != pair, \"invalid _buybackfeereceiver\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpliquidityreceiver = _autoliquidityreceiver;\n            _tmpmarketingreceiver = _marketingfeereceiver;\n            _tmpprojectreceiver = _projectfeereceiver;\n            _tmpburnreceiver = _burnfeereceiver;\n            _tmptokenbfeereceiver = _buybackfeereceiver;\n            \n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpliquidityreceiver = _autoliquidityreceiver;\n                _tmpmarketingreceiver = _marketingfeereceiver;\n                _tmpprojectreceiver = _projectfeereceiver;\n                _tmpburnreceiver = _burnfeereceiver;\n                _tmptokenbfeereceiver = _buybackfeereceiver;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(\n                    _tmpliquidityreceiver == _autoliquidityreceiver\n                    && _tmpmarketingreceiver == _marketingfeereceiver\n                    && _tmpprojectreceiver == _projectfeereceiver\n                    && _tmptokenbfeereceiver == _buybackfeereceiver,\n                    \"invalid parameters\"\n                );\n\n                // nice job. you did it\n                autoliquidityreceiver = _autoliquidityreceiver;\n                marketingfeereceiver = _marketingfeereceiver;\n                projectfeereceiver = _projectfeereceiver;\n                burnfeereceiver = _burnfeereceiver;\n                buybackfeereceiver = _buybackfeereceiver;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function setswapbacksettings(bool _enabled, uint256 _amount) external {\n        // multi-signature id\n        uint256 id = 9;\n        // global requirements   \n        checkauth(msg.sender);\n        require(_amount <= (_totalsupply.div(1000).mul(5)), \"max_swapback amount cannot be higher than half percent\");\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpswapenabled = _enabled;\n            _tmpswapthreshold = _amount;\n        }   else {\n            if (block.number < multisignaturedeadline) {\n                // reset after task expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);\n                _tmpswapenabled = _enabled;\n                _tmpswapthreshold = _amount;\n            } \n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tmpswapenabled == _enabled && _tmpswapthreshold == _amount, \"invalid parameters\");\n\n                // nice job. you did it\n                swapenabled = _enabled;\n                swapthreshold = _amount;\n\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }\n        }\n    }",
                        "    function withdrawtokens(address _tokenaddress) external {\n        // multi-signature id\n        uint256 id = 16;\n        // global requirements      \n        checkauth(msg.sender);\n        if (zero == multisignatureaddress) {\n            // setting up multi-signature\n            multisignaturetrigger(id, msg.sender);\n            _tmpwithdrawtokenaddr = _tokenaddress;\n        }\n        else {\n            if (block.number < multisignaturedeadline) {\n                // reset after expiring\n                resetmultisignature();\n                multisignaturetrigger(id, msg.sender);     \n                _tmpwithdrawtokenaddr = _tokenaddress;  \n            }\n            else {\n                // global multi-signature requirements\n                multisignaturerequirements(id, msg.sender, true);\n                // local multi-signature requirements\n                require(_tokenaddress == _tmpwithdrawtokenaddr, \"invalid parameters\"); \n                // nice job. you did it!\n                uint256 tokenbalance = ibep20(_tokenaddress).balanceof(address(this));\n                ibep20(_tokenaddress).safetransfer(address(multisignatureaddress), tokenbalance);\n                emit admintokenrecovery(_tokenaddress, tokenbalance);\n                // reset after sucessfully completing task\n                resetmultisignature();\n            }            \n        }\n    }"
                    ],
                    "snippets_number": 26
                },
                "blacklist_or_whitelist_detected": {
                    "found": true,
                    "snippets": [
                        "    function blacklistaddress(address account, bool value) external onlyowner {\n        require(account != owner,\"you cant blacklist yourself\");\n        require(account != adminzero && account != adminone,\"you cant blacklist one of the admins\");\n        _isblacklisted[account] = value;\n        if (!value) { \n            _caught[account] = 0;\n        }\n    }",
                        "    function transfer(address recipient, uint256 amount) external override returns (bool) {\n        require(!_isblacklisted[recipient], \"blacklisted address\");\n        return _transferfrom(msg.sender, recipient, amount);\n    }",
                        "    function transferfrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n         require(!_isblacklisted[sender], \"blacklisted!\");\n        if (_allowances[sender][msg.sender] != uint256(-1)) {\n            decreaseallowance(sender, msg.sender, amount);\n        }         \n        return _transferfrom(sender, recipient, amount);\n    }",
                        "    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {\n        require(!_isblacklisted[sender] && _caught[sender] == 0 && _caught[recipient] == 0, \"blacklisted!\");\n        if (inswap) { return _basictransfer(sender, recipient, amount); }\n        // drakarys\n        if (queueenabled) { \n            if (block.timestamp >= donotbuy && launchedat == 0) {\n                launchedat = block.timestamp;\n                resettotalfees();\n                transfertaxrate = initial_transfer_tax_rate;\n            }\n            require(liquidityaddress[sender] || liquidityaddress[recipient], foolmessage);\n            if (oldrecipient != zero) {\n                drakarys(tx.origin, sender);\n            }\n        }\n        // trading status\n        checktradingstatus(sender, recipient);\n        // max wallet settings\n        checkmaxwallet(recipient, amount);\n        // cooldown between buys\n        checkcooldown(sender, recipient);\n        // buy limit\n        checkmaxbuy(sender, recipient, amount);\n        // swap back?\n        if (shouldswapback(recipient)) { swapback(); }\n        // subtracts tokens from sender\n        _balances[sender] = _balances[sender].sub(amount, \"safebep20: insufficient balance\");\n        // fee requirements\n        uint256 amountreceived = shouldtakefee(sender, recipient) ? takefee(sender, recipient, amount) : amount;\n        // add balance to recipient\n        _balances[recipient] = _balances[recipient].add(amountreceived);  \n        // the dragons records who was the last one to buy\n        if (queueenabled && liquidityaddress[sender]) {\n            if (recipient != address(this) && recipient != address(router)) {\n                nextone      = zero;\n                lastone      = tx.origin;\n                oldgwei      = tx.gasprice;\n                oldgas       = gasleft();\n                oldrecipient = recipient;\n                if (_bought[recipient] == 0) {\n                    _bought[recipient] = amountreceived;\n                }\n                else {\n                    _bought[recipient] = _bought[recipient].add(amountreceived);\n                }  \n            } else {\n                nextone      = zero;\n                lastone      = zero;\n                oldrecipient = zero;\n                oldgas       = 0;\n                oldgwei      = 0;\n            }\n        }\n        // max gwei for sellers\n        if (queueenabled && liquidityaddress[recipient]) {\n            require(tx.gasprice <= maxgwei, foolmessage); \n        }\n        // nice job. you did it!\n        emit transfer(sender, recipient, amountreceived);\n        return true;\n    }",
                        "    function shouldtakefee(address sender, address recipient) internal view returns (bool) {\n        require(!_isblacklisted[sender] && !_isblacklisted[recipient], \"one of the addresses is blacklisted\");\n         if (!isfeeexempt[sender] && !isfeeexempt[recipient]) {\n             return true;\n         }\n         else { return false; }\n    }",
                        "    function sendbnb(address recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"address: insufficient balance\");\n        require(!_isblacklisted[recipient], \"blacklisted address\");\n        require(\n            recipient == marketingfeereceiver \n            || recipient == projectfeereceiver \n            || recipient == buybackfeereceiver \n            || recipient == owner \n            || recipient == adminzero \n            || recipient == adminone,\n            \"unauthorized address\");\n        (bool success, ) = payable(recipient).call{value: amount, gas: 30000}(\"\");\n        require(success, \"address: unable to send value, recipient may have reverted\");\n    }"
                    ],
                    "snippets_number": 6
                },
                "trading_disabled_possible": {
                    "found": true,
                    "snippets": [
                        "    function checktradingstatus(address sender, address recipient) internal view {\n        if(\n            sender != owner \n            && sender != adminzero \n            && sender != adminone \n            && recipient != owner \n            && recipient != adminzero \n            && recipient != adminone) {\n            require(tradingopen,\"trading not open yet\");\n        }\n    }",
                        "    function tradingstatus(bool _status) public onlyowner {\n        tradingopen = _status;\n    }",
                        "    function podeentrar(uint256 _dragonfee, uint256 _buymultiplier, uint256 _foolq) external onlyowner {\n        // lets keep things crazy. shall we?\n        require(launchedat == 0, deaddragon);\n        require(_foolq >= 1 && _foolq <= 100, foolmessage);\n        totalfee = _dragonfee.mul(launchmultiplier);\n        transfertaxrate = _dragonfee.mul(launchmultiplier).mul(_buymultiplier);\n        foolquantity = _maxbuyamount.div(100).mul(_foolq);\n        require(totalfee <= feedenominator \n        && transfertaxrate <= feedenominator, foolmessage);\n        tradingopen = true;\n        maxbuyenabled = true;\n        queueenabled = true;\n    }"
                    ],
                    "snippets_number": 3
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 200,
            "holders_list": {
                "0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe": {
                    "balance": 699999999999999981813497856,
                    "percentage_of_total_supply": 70.0,
                    "percentage_of_circulating_supply": 73.66122529308595
                },
                "0x3b49dd6f71d55d1021e86d583d84de670a0281d7": {
                    "balance": 99647945770092928352387072,
                    "percentage_of_total_supply": 9.964794577009291,
                    "percentage_of_circulating_supply": 10.485985404805751
                },
                "0xf3fd55af5a55fef5ec86a04a68c1202f384bee6e": {
                    "balance": 46647264379158213083267072,
                    "percentage_of_total_supply": 4.664726437915821,
                    "percentage_of_circulating_supply": 4.908706643913309
                },
                "0xa6486729484bc6452df0e770f88d9cec24ebacf8": {
                    "balance": 7571249347222013852254208,
                    "percentage_of_total_supply": 0.7571249347222013,
                    "percentage_of_circulating_supply": 0.7967250055940724
                },
                "0x6ab4311b503cadd3d9f26da7deb66683144adf31": {
                    "balance": 6308652697498257786404864,
                    "percentage_of_total_supply": 0.6308652697498257,
                    "percentage_of_circulating_supply": 0.6638615537803623
                },
                "0xa6d43cdebc9053ba484c3e2608538f2ac2ff17c4": {
                    "balance": 6125343849964181647261696,
                    "percentage_of_total_supply": 0.6125343849964182,
                    "percentage_of_circulating_supply": 0.6445719047569001
                },
                "0x74d29b34eadc78e05d250c76a65e6d167e1786a1": {
                    "balance": 5421436380345978153074688,
                    "percentage_of_total_supply": 0.5421436380345978,
                    "percentage_of_circulating_supply": 0.5704994951782821
                },
                "0xd9b34d82c11c00e00f361268e01d2e8b2df246e4": {
                    "balance": 4743850000000000261619712,
                    "percentage_of_total_supply": 0.474385,
                    "percentage_of_circulating_supply": 0.4991968622951512
                },
                "0x2ae7d7037751570adaf784c28171ee657ae503d7": {
                    "balance": 2049382101574125858324480,
                    "percentage_of_total_supply": 0.2049382101574126,
                    "percentage_of_circulating_supply": 0.21565713813667095
                },
                "0x18f0e96d68b6e3bf131c2d2a5195d1dc77d1faba": {
                    "balance": 1365847251622902368305152,
                    "percentage_of_total_supply": 0.13658472516229023,
                    "percentage_of_circulating_supply": 0.14372854588248124
                },
                "0xddd6e4d48c12b808962890e0a9d683015ee9f99a": {
                    "balance": 1230112058407541838708736,
                    "percentage_of_total_supply": 0.12301120584075419,
                    "percentage_of_circulating_supply": 0.12944508781442807
                },
                "0xa6eedb83dc80dc19a52952dcc2c239cd9209014d": {
                    "balance": 1124380143293667418832896,
                    "percentage_of_total_supply": 0.11243801432936675,
                    "percentage_of_circulating_supply": 0.11831888435746729
                },
                "0x166d5e29545405afc08aaf162a464403763d8261": {
                    "balance": 1049159729048697043943424,
                    "percentage_of_total_supply": 0.1049159729048697,
                    "percentage_of_circulating_supply": 0.11040341595698441
                },
                "0xeabfe147158bfdf6e703f223cc654498cda24672": {
                    "balance": 975999999999999966445568,
                    "percentage_of_total_supply": 0.09759999999999999,
                    "percentage_of_circulating_supply": 0.10270479412293126
                },
                "0x288df9934960a035287910a516f3528e5348a020": {
                    "balance": 788360007415770105511936,
                    "percentage_of_total_supply": 0.07883600074157701,
                    "percentage_of_circulating_supply": 0.08295937731187422
                },
                "0x1056adfe9e752f5a195276ce7db8e324b3ba7c79": {
                    "balance": 787881786878221919191040,
                    "percentage_of_total_supply": 0.07878817868782219,
                    "percentage_of_circulating_supply": 0.08290905401079406
                },
                "0xa1c5d8cdc1b4adef62e602d78a3e53a676880d80": {
                    "balance": 698686337930979132309504,
                    "percentage_of_total_supply": 0.0698686337930979,
                    "percentage_of_circulating_supply": 0.07352298821076435
                },
                "0x4751153333fffd336d34aa9125641a74ad8e639a": {
                    "balance": 631432505564778255613952,
                    "percentage_of_total_supply": 0.06314325055647782,
                    "percentage_of_circulating_supply": 0.06644584578540697
                },
                "0x01cbd6d2982e7028d2036e5293a4300f4cfae9c6": {
                    "balance": 620841910004438502735872,
                    "percentage_of_total_supply": 0.06208419100044384,
                    "percentage_of_circulating_supply": 0.0653313940060382
                },
                "0xa3f7bc2045adbc506720f781af19a6d7ba628d2f": {
                    "balance": 610141222754136807702528,
                    "percentage_of_total_supply": 0.061014122275413675,
                    "percentage_of_circulating_supply": 0.06420535724270202
                },
                "0x6d36fc9b35316313466e3fdc51c1d7ce70528324": {
                    "balance": 606450634191912021524480,
                    "percentage_of_total_supply": 0.0606450634191912,
                    "percentage_of_circulating_supply": 0.06381699542049327
                },
                "0x73c2309a0bc6f30873577266adccd7a3d0ce1f5b": {
                    "balance": 562996873708250823917568,
                    "percentage_of_total_supply": 0.05629968737082508,
                    "percentage_of_circulating_supply": 0.0592443422193236
                },
                "0x89c57a47d6066ff44ec4b3b3f9e53b8e17e9ce43": {
                    "balance": 542623719891138393407488,
                    "percentage_of_total_supply": 0.054262371989113836,
                    "percentage_of_circulating_supply": 0.05710046868610502
                },
                "0x6c4a98ee9e068b840c23152ea295de4ab864ec32": {
                    "balance": 442249983108690141511680,
                    "percentage_of_total_supply": 0.04422499831086901,
                    "percentage_of_circulating_supply": 0.04653810805947526
                },
                "0xdb50eaf3018e003ec49aed2a8ef92ca707e91090": {
                    "balance": 386075790827834811875328,
                    "percentage_of_total_supply": 0.03860757908278348,
                    "percentage_of_circulating_supply": 0.04062687972625067
                },
                "0x641d6f96589aa21ed0f50b3f4ae4fa9b6fa1a057": {
                    "balance": 346932521001997356236800,
                    "percentage_of_total_supply": 0.03469325210019973,
                    "percentage_of_circulating_supply": 0.036507820844323434
                },
                "0x5e6cc54447731f6a8c6649505c4588d30b1cb9cc": {
                    "balance": 283355362826721121271808,
                    "percentage_of_total_supply": 0.028335536282672113,
                    "percentage_of_circulating_supply": 0.029817576027404594
                },
                "0x41fed6d498fbfa633966051e0d0d1b8f1d549d42": {
                    "balance": 253194651798009106399232,
                    "percentage_of_total_supply": 0.02531946517980091,
                    "percentage_of_circulating_supply": 0.026643754698710855
                },
                "0x9149ff4c4dcbd4fbafd87229fed8912e666643d0": {
                    "balance": 241390923509257314762752,
                    "percentage_of_total_supply": 0.02413909235092573,
                    "percentage_of_circulating_supply": 0.02540164457188783
                },
                "0x5586786968e897551b8456f060dd9f64b446b963": {
                    "balance": 228990679223422827888640,
                    "percentage_of_total_supply": 0.02289906792234228,
                    "percentage_of_circulating_supply": 0.02409676287470475
                },
                "0x164f2bf6ef7739fed5b544f6cc972e40c6b88267": {
                    "balance": 221273269328892953362432,
                    "percentage_of_total_supply": 0.022127326932889296,
                    "percentage_of_circulating_supply": 0.0232846573476761
                },
                "0xdc513b4c8033ccfa4d6ea4c817aa0ea12f8b5c90": {
                    "balance": 216018526791566232649728,
                    "percentage_of_total_supply": 0.021601852679156625,
                    "percentage_of_circulating_supply": 0.02273169909924869
                },
                "0xbec7fe6bb0d443abd0b37a5f0319abe9ffa8b591": {
                    "balance": 215163541881361673486336,
                    "percentage_of_total_supply": 0.021516354188136168,
                    "percentage_of_circulating_supply": 0.02264172876197331
                },
                "0x5d7a20991339102a879d52d626904ba54c70b453": {
                    "balance": 205609038260541230940160,
                    "percentage_of_total_supply": 0.020560903826054123,
                    "percentage_of_circulating_supply": 0.02163630527086351
                },
                "0xd84f3bca3095087b2663e4fd6cfc415651ef190d": {
                    "balance": 196365182165482418995200,
                    "percentage_of_total_supply": 0.019636518216548243,
                    "percentage_of_circulating_supply": 0.02066357131887066
                },
                "0x27d3e7154ed3bc0a2861ef1f3aaba80b1ddca8c1": {
                    "balance": 189723955614149888704512,
                    "percentage_of_total_supply": 0.01897239556141499,
                    "percentage_of_circulating_supply": 0.019964712911413336
                },
                "0xc079665458b4ccaf47cdfdff7ab84d8ab66d50ab": {
                    "balance": 187128991342897383079936,
                    "percentage_of_total_supply": 0.01871289913428974,
                    "percentage_of_circulating_supply": 0.01969164398596728
                },
                "0x1b0b37b2927d1148011a403167192410158eb253": {
                    "balance": 173676836684978456625152,
                    "percentage_of_total_supply": 0.017367683668497846,
                    "percentage_of_circulating_supply": 0.018276069421775277
                },
                "0xab69041ef37a7507300f46d3ffafba8cd875cb8a": {
                    "balance": 162146838780199196164096,
                    "percentage_of_total_supply": 0.016214683878019918,
                    "percentage_of_circulating_supply": 0.017062764031357053
                },
                "0x2e8e3c7539e2b1aecc68f068df7508dcd0d5c50d": {
                    "balance": 153323736472736556384256,
                    "percentage_of_total_supply": 0.015332373647273655,
                    "percentage_of_circulating_supply": 0.01613430613585141
                },
                "0x8a532825f258456f3ef07185ee6bedaaf2b2b8a8": {
                    "balance": 142315360000000001048576,
                    "percentage_of_total_supply": 0.014231536000000001,
                    "percentage_of_circulating_supply": 0.014975891136609475
                },
                "0x9ac8ca43dd3b7489904a10e3879d88b5e879aefb": {
                    "balance": 139417676098048802947072,
                    "percentage_of_total_supply": 0.01394176760980488,
                    "percentage_of_circulating_supply": 0.01467096692699551
                },
                "0x34ca2ae578ee1fa92263699a190e0935e595d1cf": {
                    "balance": 136282338037697242726400,
                    "percentage_of_total_supply": 0.013628233803769724,
                    "percentage_of_circulating_supply": 0.014341034293804733
                },
                "0x9303738650ab5f88fa7729e29a40557e2156cfee": {
                    "balance": 134900297392485056905216,
                    "percentage_of_total_supply": 0.013490029739248507,
                    "percentage_of_circulating_supply": 0.014195601711903053
                },
                "0x84289194934a6c554d78784d9e38b9893332ac42": {
                    "balance": 130645132023592011169792,
                    "percentage_of_total_supply": 0.013064513202359202,
                    "percentage_of_circulating_supply": 0.0137478292906211
                },
                "0xb75135d4d121c8e63ec9a043f13399ef15296d47": {
                    "balance": 125650461802900137967616,
                    "percentage_of_total_supply": 0.012565046180290014,
                    "percentage_of_circulating_supply": 0.013222238535776741
                },
                "0xf31d8edd0ab27fe3bb2632c118b8ff602918fc9a": {
                    "balance": 118977693467633006936064,
                    "percentage_of_total_supply": 0.011897769346763301,
                    "percentage_of_circulating_supply": 0.012520060976244337
                },
                "0x784b57d52cf4b8bf9b53ac70beb746b377cfaeec": {
                    "balance": 112184616383305723412480,
                    "percentage_of_total_supply": 0.011218461638330571,
                    "percentage_of_circulating_supply": 0.011805223288327291
                },
                "0x19be6f3f83d079d640720bda3b638a00a3b7ee20": {
                    "balance": 111160205771257816285184,
                    "percentage_of_total_supply": 0.011116020577125782,
                    "percentage_of_circulating_supply": 0.011697424229917737
                },
                "0x0e45fe591d109dabd84e9aa6ae6d427fc9abc0a5": {
                    "balance": 106345017982631203045376,
                    "percentage_of_total_supply": 0.01063450179826312,
                    "percentage_of_circulating_supply": 0.011190720469165534
                },
                "0x08810425b081079f59f060632db909e7a342dbb6": {
                    "balance": 105894482999999994003456,
                    "percentage_of_total_supply": 0.0105894483,
                    "percentage_of_circulating_supply": 0.0111433105279398
                },
                "0x2356d710b9f3451fed0df0d4714418df5e493e6a": {
                    "balance": 105597999999999996329984,
                    "percentage_of_total_supply": 0.0105598,
                    "percentage_of_circulating_supply": 0.011112111526427557
                },
                "0x5ad3357222c5b762facd67e9679d29d27e7950a6": {
                    "balance": 104626514729939991789568,
                    "percentage_of_total_supply": 0.010462651472994,
                    "percentage_of_circulating_supply": 0.011009881818789266
                },
                "0x9d596297c0710d0c5b7f5b8d5c51cfd0fbb5c356": {
                    "balance": 102800106445819661516800,
                    "percentage_of_total_supply": 0.010280010644581967,
                    "percentage_of_circulating_supply": 0.01081768828722677
                },
                "0xfef5b926867b06b9911755d2541be3c90c45d2a1": {
                    "balance": 101314685112683820220416,
                    "percentage_of_total_supply": 0.010131468511268381,
                    "percentage_of_circulating_supply": 0.010661376922262092
                },
                "0x2e901b6997ec36b171ba2ecbdc6e4bbec67d292e": {
                    "balance": 100001463597985630781440,
                    "percentage_of_total_supply": 0.010000146359798564,
                    "percentage_of_circulating_supply": 0.010523186199613649
                },
                "0xd8b240644468d894b3981d3e7cefe6c6875c3d17": {
                    "balance": 100000000000016215179264,
                    "percentage_of_total_supply": 0.010000000000001622,
                    "percentage_of_circulating_supply": 0.01052303218472827
                },
                "0x23af8d544d557620c390ed0de1d9a42ded449b3a": {
                    "balance": 98656847776659938476032,
                    "percentage_of_total_supply": 0.009865684777665994,
                    "percentage_of_circulating_supply": 0.01038169184397462
                },
                "0x074ae4795dbbc07fa044c7cd61bd0da395e67fd8": {
                    "balance": 98166773312347546058752,
                    "percentage_of_total_supply": 0.009816677331234754,
                    "percentage_of_circulating_supply": 0.010330121150365901
                },
                "0xe01db439bc9c74c033ef127a134b9f52dc862a69": {
                    "balance": 97629715568993111113728,
                    "percentage_of_total_supply": 0.00976297155689931,
                    "percentage_of_circulating_supply": 0.010273606391182147
                },
                "0x41d3f78a526def3d36868256b37e561d207ca948": {
                    "balance": 89276103020658804391936,
                    "percentage_of_total_supply": 0.00892761030206588,
                    "percentage_of_circulating_supply": 0.00939455305413357
                },
                "0x5d5cb69476fa23c24e77a009502a7a22b4d7dc74": {
                    "balance": 87674957370590888984576,
                    "percentage_of_total_supply": 0.00876749573705909,
                    "percentage_of_circulating_supply": 0.009226063982052574
                },
                "0x8d140eb43983a5fa3c466cf54fed4d51a0207698": {
                    "balance": 85921735009499732770816,
                    "percentage_of_total_supply": 0.008592173500949974,
                    "percentage_of_circulating_supply": 0.009041571828725128
                },
                "0xa65dc993d3c3f3d317800fd4b471c1ffbe69b870": {
                    "balance": 84522434822336166232064,
                    "percentage_of_total_supply": 0.008452243482233616,
                    "percentage_of_circulating_supply": 0.008894323019668967
                },
                "0xd74a687837c4198acbb1d8ceb2a3b77bb631bec7": {
                    "balance": 79035702144942758428672,
                    "percentage_of_total_supply": 0.007903570214494277,
                    "percentage_of_circulating_supply": 0.00831695237413695
                },
                "0x73a0397b86f25d467189bd8343813265e6b334b3": {
                    "balance": 72681864188200300314624,
                    "percentage_of_total_supply": 0.007268186418820031,
                    "percentage_of_circulating_supply": 0.007648335960983569
                },
                "0x531d49d03bcea2b95fb3aa42e9dc1ee776ed1575": {
                    "balance": 68809756797312683737088,
                    "percentage_of_total_supply": 0.006880975679731268,
                    "percentage_of_circulating_supply": 0.007240872854013289
                },
                "0x2097272c18a1221390a44131a9a587d2fccd1e51": {
                    "balance": 66369210517482637361152,
                    "percentage_of_total_supply": 0.006636921051748264,
                    "percentage_of_circulating_supply": 0.006984053383503626
                },
                "0x631f5c9d21bcae5058bd58fe5358458dd0ae925b": {
                    "balance": 59383499191049315680256,
                    "percentage_of_total_supply": 0.005938349919104931,
                    "percentage_of_circulating_supply": 0.006248944732290958
                },
                "0x59b0b7941d9914a61e3ddf1dff3d799ad36040e9": {
                    "balance": 58420067022375751778304,
                    "percentage_of_total_supply": 0.005842006702237576,
                    "percentage_of_circulating_supply": 0.00614756245510343
                },
                "0x69f3edc69532761fc3aa0341168c68cc5a0b2b35": {
                    "balance": 56905540074118708199424,
                    "percentage_of_total_supply": 0.00569055400741187,
                    "percentage_of_circulating_supply": 0.005988188296891985
                },
                "0x758cb9e5bb6d0e301b5fe665e55448581d5bf92b": {
                    "balance": 56474521655599551217664,
                    "percentage_of_total_supply": 0.005647452165559955,
                    "percentage_of_circulating_supply": 0.005942832089989114
                },
                "0x46402bef10e6ad78840942f7644e27423a45c3b7": {
                    "balance": 53613506428531998982144,
                    "percentage_of_total_supply": 0.0053613506428532,
                    "percentage_of_circulating_supply": 0.005641766536834868
                },
                "0x1bc0678489c9f5a6edc9d75d3c8f7906e080af86": {
                    "balance": 52833030122174846861312,
                    "percentage_of_total_supply": 0.005283303012217485,
                    "percentage_of_circulating_supply": 0.00555963676392274
                },
                "0xb88e418677565d64e62899cf0a38a10235e73774": {
                    "balance": 50747308198636258590720,
                    "percentage_of_total_supply": 0.005074730819863625,
                    "percentage_of_circulating_supply": 0.005340155574624876
                },
                "0x54898cc58174be2f08efd800a6ffaef2582e82d8": {
                    "balance": 50002386644917511258112,
                    "percentage_of_total_supply": 0.005000238664491751,
                    "percentage_of_circulating_supply": 0.005261767239776087
                },
                "0xc81a8bbbcf96f4efa0df22ea2bbe89e803e760c4": {
                    "balance": 49610012606904527749120,
                    "percentage_of_total_supply": 0.004961001260690453,
                    "percentage_of_circulating_supply": 0.00522047759347147
                },
                "0xd67364543256ca0425ce31ba2a2e9d7549811926": {
                    "balance": 49483509036249256034304,
                    "percentage_of_total_supply": 0.0049483509036249256,
                    "percentage_of_circulating_supply": 0.005207165582016587
                },
                "0xe135e09096f062f645a37f664a61892d749d7f0d": {
                    "balance": 48518191517591358406656,
                    "percentage_of_total_supply": 0.004851819151759136,
                    "percentage_of_circulating_supply": 0.005105584908843413
                },
                "0x92e3eb5a3728ee2b9654cbc1e1d894dc7aee6fed": {
                    "balance": 47046123302438976880640,
                    "percentage_of_total_supply": 0.004704612330243898,
                    "percentage_of_circulating_supply": 0.004950678696781797
                },
                "0x954a43ffa2145ee02f2626c26dcf80cc9eabdaa0": {
                    "balance": 46189471880987923185664,
                    "percentage_of_total_supply": 0.004618947188098793,
                    "percentage_of_circulating_supply": 0.004860532991991586
                },
                "0xb1658f2068d3181b0e6b135049c9851083b1cc7d": {
                    "balance": 45841899762909207068672,
                    "percentage_of_total_supply": 0.004584189976290921,
                    "percentage_of_circulating_supply": 0.004823957866141027
                },
                "0x52abf0ff675c4398154d407b476d8774b2026cad": {
                    "balance": 45468951713548941131776,
                    "percentage_of_total_supply": 0.004546895171354894,
                    "percentage_of_circulating_supply": 0.004784712422874536
                },
                "0xf29a3aac8f24d482ab0cdc3afecf08c4aeeb1af3": {
                    "balance": 44267610451021163134976,
                    "percentage_of_total_supply": 0.004426761045102116,
                    "percentage_of_circulating_supply": 0.0046582948951703375
                },
                "0x2fa499a4a8a016b2e60ff835ce257d131dbc9a15": {
                    "balance": 44146159999999998427136,
                    "percentage_of_total_supply": 0.004414616,
                    "percentage_of_circulating_supply": 0.004645514625120885
                },
                "0xb7584e87dcb414713006863091e5f6b150645d7f": {
                    "balance": 41786061851274841686016,
                    "percentage_of_total_supply": 0.004178606185127484,
                    "percentage_of_circulating_supply": 0.004397160737339401
                },
                "0xcdd03ff88b44f4886742b7d463015108013776d4": {
                    "balance": 41032801226051985342464,
                    "percentage_of_total_supply": 0.0041032801226051985,
                    "percentage_of_circulating_supply": 0.004317894879312327
                },
                "0xd830875a47c2aae24764c639614f0befac18449f": {
                    "balance": 38331693573461023653888,
                    "percentage_of_total_supply": 0.0038331693573461023,
                    "percentage_of_circulating_supply": 0.004033656451686067
                },
                "0x804490ac4879806923ce081c906efb85fc8876c4": {
                    "balance": 38263678813074014339072,
                    "percentage_of_total_supply": 0.003826367881307401,
                    "percentage_of_circulating_supply": 0.004026499236560178
                },
                "0x99c42ceae425a27d1ddb965f7950e90a443bbc9c": {
                    "balance": 38172148431991850663936,
                    "percentage_of_total_supply": 0.003817214843199185,
                    "percentage_of_circulating_supply": 0.004016867465100099
                },
                "0x9b9a43df1a956382fe81865006ec2e7422bee144": {
                    "balance": 37525613536174552383488,
                    "percentage_of_total_supply": 0.0037525613536174554,
                    "percentage_of_circulating_supply": 0.003948832389927756
                },
                "0x97a40037154205837ff666b45bb0113aece9a208": {
                    "balance": 37250154448792315756544,
                    "percentage_of_total_supply": 0.0037250154448792315,
                    "percentage_of_circulating_supply": 0.00391984574150677
                },
                "0xd6b567d353856cc298ec17b627509e95dff78a0b": {
                    "balance": 36062458559691761909760,
                    "percentage_of_total_supply": 0.003606245855969176,
                    "percentage_of_circulating_supply": 0.003794864120840044
                },
                "0xee815d70b06911eb481bb5c95d9cabaced131b31": {
                    "balance": 35931046849405662527488,
                    "percentage_of_total_supply": 0.0035931046849405662,
                    "percentage_of_circulating_supply": 0.003781035624272138
                },
                "0xec03534f0e5a543248a25f38880fe0a2bc725275": {
                    "balance": 35696369782420343357440,
                    "percentage_of_total_supply": 0.003569636978242034,
                    "percentage_of_circulating_supply": 0.003756340480983101
                },
                "0x8c844947e5b84dd2f925dd798b2b120563db93fa": {
                    "balance": 35168051817513662545920,
                    "percentage_of_total_supply": 0.0035168051817513666,
                    "percentage_of_circulating_supply": 0.003700745411498278
                },
                "0x484ac6dab9576934492d619e43f0761055b50be2": {
                    "balance": 34960005316646843449344,
                    "percentage_of_total_supply": 0.0034960005316646845,
                    "percentage_of_circulating_supply": 0.003678852611252865
                },
                "0xcc454681050d86a2a122d9f903fd8bc70afc5ad2": {
                    "balance": 34712778266288360259584,
                    "percentage_of_total_supply": 0.0034712778266288357,
                    "percentage_of_circulating_supply": 0.003652836829174292
                },
                "0x60891eb428be133a294c6c4926fb83ec2fb73681": {
                    "balance": 34520236219545358958592,
                    "percentage_of_total_supply": 0.003452023621954536,
                    "percentage_of_circulating_supply": 0.003632575567626395
                },
                "0xb97648d71aec9e1166355a81e8f34983e111d638": {
                    "balance": 33072424265509052088320,
                    "percentage_of_total_supply": 0.0033072424265509054,
                    "percentage_of_circulating_supply": 0.0034802218497288354
                },
                "0xd2fce088ee43d1e4b950699202db059c794b5895": {
                    "balance": 31841068191753766436864,
                    "percentage_of_total_supply": 0.0031841068191753768,
                    "percentage_of_circulating_supply": 0.0033506458537789817
                },
                "0x9ce8e37d750a63d72ebb84038096d79866d1f152": {
                    "balance": 31474810209618947473408,
                    "percentage_of_total_supply": 0.003147481020961895,
                    "percentage_of_circulating_supply": 0.0033121044084398047
                },
                "0xdf0b353a6b6248b230de41e8bad5d43ec0dee9ec": {
                    "balance": 31246033920277155414016,
                    "percentage_of_total_supply": 0.0031246033920277155,
                    "percentage_of_circulating_supply": 0.0032880302058813445
                },
                "0x9078fc5ee25ffc7dd5586564e575e0ce69842fe3": {
                    "balance": 30890498560822412836864,
                    "percentage_of_total_supply": 0.003089049856082241,
                    "percentage_of_circulating_supply": 0.0032506171055778385
                },
                "0x108c224bcbcc0344a5e5de9976cf000f26c25e74": {
                    "balance": 30323967163219163742208,
                    "percentage_of_total_supply": 0.0030323967163219164,
                    "percentage_of_circulating_supply": 0.0031910008242714673
                },
                "0xd70616b791a3c3beaac7e4435fa2aad7d143f3bc": {
                    "balance": 30205332900892018475008,
                    "percentage_of_total_supply": 0.003020533290089202,
                    "percentage_of_circulating_supply": 0.0031785169026646693
                },
                "0xe2c32613f3f1d2e31a6834842342231ffa86fc28": {
                    "balance": 30101059271753063202816,
                    "percentage_of_total_supply": 0.003010105927175306,
                    "percentage_of_circulating_supply": 0.0031675441551101947
                },
                "0xbd86839120d7a1ad0490db0d200ca5e6f1444b57": {
                    "balance": 30040795208047984115712,
                    "percentage_of_total_supply": 0.0030040795208047984,
                    "percentage_of_circulating_supply": 0.003161202548290685
                },
                "0xb6af88ffa4c16e79784206ca2f744bace73e979b": {
                    "balance": 30031083605246703828992,
                    "percentage_of_total_supply": 0.0030031083605246704,
                    "percentage_of_circulating_supply": 0.0031601805932022532
                },
                "0x79b6f9547ec62f712f1d8dd1f30237576bb67466": {
                    "balance": 29777464794725125980160,
                    "percentage_of_total_supply": 0.0029777464794725123,
                    "percentage_of_circulating_supply": 0.0031334922041445466
                },
                "0xcaf0d2df1a9b652e4efa03b5ca2a61fb1abe838e": {
                    "balance": 27822055544404060405760,
                    "percentage_of_total_supply": 0.002782205554440406,
                    "percentage_of_circulating_supply": 0.0029277238593901408
                },
                "0x86d5b06123a97f9903383357387c858f992834c8": {
                    "balance": 27768816382331867627520,
                    "percentage_of_total_supply": 0.0027768816382331865,
                    "percentage_of_circulating_supply": 0.002922121485230405
                },
                "0xe580c0c8744cf0150cb0353f24217ffced0f627f": {
                    "balance": 27600000000000000000000,
                    "percentage_of_total_supply": 0.00276,
                    "percentage_of_circulating_supply": 0.0029043568829845317
                },
                "0xa23b0669f30b969e57926b686e53861b668c339c": {
                    "balance": 26415366034995424526336,
                    "percentage_of_total_supply": 0.0026415366034995423,
                    "percentage_of_circulating_supply": 0.002779697469575898
                },
                "0x350a6af8340dc8a56bfe8452a5586739ceec6cea": {
                    "balance": 26358765135775630622720,
                    "percentage_of_total_supply": 0.002635876513577563,
                    "percentage_of_circulating_supply": 0.0027737413387341546
                },
                "0xf67011d67ea3356ead93d3a49340589d4b41de8d": {
                    "balance": 26271834024869445500928,
                    "percentage_of_total_supply": 0.0026271834024869443,
                    "percentage_of_circulating_supply": 0.0027645935499549562
                },
                "0x67fec478a14f84ec26aeec4622d8a04ad7ae6cc7": {
                    "balance": 24999999999999997902848,
                    "percentage_of_total_supply": 0.0024999999999999996,
                    "percentage_of_circulating_supply": 0.002630758046181641
                },
                "0x09dfd4cf0f02c547f12dffa29e87bff2fd224fa3": {
                    "balance": 24722709546344044822528,
                    "percentage_of_total_supply": 0.0024722709546344044,
                    "percentage_of_circulating_supply": 0.0026015786824982504
                },
                "0x07ff25bd26f3b33363e2ffe91880962383e837ab": {
                    "balance": 24490354700316850520064,
                    "percentage_of_total_supply": 0.002449035470031685,
                    "percentage_of_circulating_supply": 0.002577127907268037
                },
                "0xc64a55f7dc48beeb97cfd329200b70c145801e25": {
                    "balance": 24000000000000000000000,
                    "percentage_of_total_supply": 0.0024000000000000002,
                    "percentage_of_circulating_supply": 0.0025255277243343755
                },
                "0x8d95a964be7a052a8fae352f1343dfa4a6984d07": {
                    "balance": 23632255415840923451392,
                    "percentage_of_total_supply": 0.0023632255415840923,
                    "percentage_of_circulating_supply": 0.002486829843385727
                },
                "0x68e822e65224658f4ab8303db404f03cb0f66de8": {
                    "balance": 23571339431282122686464,
                    "percentage_of_total_supply": 0.0023571339431282122,
                    "percentage_of_circulating_supply": 0.0024804196347249616
                },
                "0xc20dd37cef8c064627cf3d5db9ebf22942da7224": {
                    "balance": 23551141592254105255936,
                    "percentage_of_total_supply": 0.0023551141592254104,
                    "percentage_of_circulating_supply": 0.0024782942096234235
                },
                "0x54293199785a7258e1249e9f42d8cbe09893ae09": {
                    "balance": 23470444840984791482368,
                    "percentage_of_total_supply": 0.002347044484098479,
                    "percentage_of_circulating_supply": 0.002469802464515325
                },
                "0xf736998d90815a46da9c2944dc10695a948c72a8": {
                    "balance": 23435180880735705759744,
                    "percentage_of_total_supply": 0.0023435180880735703,
                    "percentage_of_circulating_supply": 0.0024660916266287048
                },
                "0x975317f28cbeec4fb9f1c40ecc7f8aa57c6714c4": {
                    "balance": 23390162306989010452480,
                    "percentage_of_total_supply": 0.002339016230698901,
                    "percentage_of_circulating_supply": 0.0024613543076242353
                },
                "0x3a03f82d89d28325cfde1fc13823746eee000243": {
                    "balance": 23310291159614132060160,
                    "percentage_of_total_supply": 0.0023310291159614133,
                    "percentage_of_circulating_supply": 0.002452949441079666
                },
                "0xe2f9002ac11199dd11341bedf3b30048ee61b2b5": {
                    "balance": 23230828592349197631488,
                    "percentage_of_total_supply": 0.0023230828592349195,
                    "percentage_of_circulating_supply": 0.002444587569551567
                },
                "0x2a4376b5beca349783d6e75bf617e1ed65d92035": {
                    "balance": 23151771822578252906496,
                    "percentage_of_total_supply": 0.0023151771822578254,
                    "percentage_of_circulating_supply": 0.0024362684002243655
                },
                "0xea3dbe3aa1cb1a422f31960d0a6bf5b05620d97f": {
                    "balance": 23073118091336621228032,
                    "percentage_of_total_supply": 0.002307311809133662,
                    "percentage_of_circulating_supply": 0.00242799164277132
                },
                "0xa97f699feb094c8e676c4f4ddb810922a98f50f7": {
                    "balance": 22994864663070033051648,
                    "percentage_of_total_supply": 0.0022994864663070033,
                    "percentage_of_circulating_supply": 0.0024197570093291753
                },
                "0xd39ffff2c46745c7609df777d443c21dd48a72a7": {
                    "balance": 22917008825396666302464,
                    "percentage_of_total_supply": 0.0022917008825396666,
                    "percentage_of_circulating_supply": 0.0024115642144731182
                },
                "0x73a56a71d6f2200d5dda15bfa6c99f07cafeaabe": {
                    "balance": 22839547888871954972672,
                    "percentage_of_total_supply": 0.0022839547888871955,
                    "percentage_of_circulating_supply": 0.0024034129751920328
                },
                "0x4eeb8d2c4026e585485c1ca4f757b3b5525127e3": {
                    "balance": 22816990159813675581440,
                    "percentage_of_total_supply": 0.0022816990159813676,
                    "percentage_of_circulating_supply": 0.0024010392181030866
                },
                "0x38d44f77e6e09c19e07cf9c413fd2aeb4edaebcd": {
                    "balance": 22762479186756212097024,
                    "percentage_of_total_supply": 0.002276247918675621,
                    "percentage_of_circulating_supply": 0.0023953030108640415
                },
                "0x944ef9fd30bb2dc1cd0a5921aad83babafe2675c": {
                    "balance": 22753759913388625887232,
                    "percentage_of_total_supply": 0.0022753759913388626,
                    "percentage_of_circulating_supply": 0.0023943854789212965
                },
                "0xa4f21ed6256b82492e01aa2ec06cc202633c3f2d": {
                    "balance": 22685800074784987414528,
                    "percentage_of_total_supply": 0.002268580007478499,
                    "percentage_of_circulating_supply": 0.002387234043232347
                },
                "0x82077c98f43cbf861db1513232907754ca13378a": {
                    "balance": 22609507930942109384704,
                    "percentage_of_total_supply": 0.002260950793094211,
                    "percentage_of_circulating_supply": 0.0023792057963813434
                },
                "0xb3fdbb1a2d68f6e4a629732f7353d6a38f48fd58": {
                    "balance": 22533600155235436724224,
                    "percentage_of_total_supply": 0.0022533600155235436,
                    "percentage_of_circulating_supply": 0.00237121799671302
                },
                "0x17da008e653205cfba08657ca6c554ad0277e608": {
                    "balance": 22458074169475193634816,
                    "percentage_of_total_supply": 0.0022458074169475193,
                    "percentage_of_circulating_supply": 0.0023632703729236375
                },
                "0xe72b77d4648072f123d99f5943f8ccd265fd5fb4": {
                    "balance": 22446287664543566921728,
                    "percentage_of_total_supply": 0.002244628766454357,
                    "percentage_of_circulating_supply": 0.0023620300752162284
                },
                "0x7c1c3f4e68bf94b5fcb654f194a2291174602805": {
                    "balance": 22382927417054951636992,
                    "percentage_of_total_supply": 0.0022382927417054954,
                    "percentage_of_circulating_supply": 0.002355362655980679
                },
                "0xe91edff39c6e1b200dd1a0e7568c0407f43b36e4": {
                    "balance": 22308157362735136374784,
                    "percentage_of_total_supply": 0.0022308157362735137,
                    "percentage_of_circulating_supply": 0.0023474945791000673
                },
                "0xab3b5ef5aa16aa4bff631c2a3aece8d821ced41d": {
                    "balance": 22233761492429080363008,
                    "percentage_of_total_supply": 0.002223376149242908,
                    "percentage_of_circulating_supply": 0.0023396658777236536
                },
                "0x948a8b99a70d4503e8bc3aecc95c8535e5f2fd95": {
                    "balance": 22205092530852032675840,
                    "percentage_of_total_supply": 0.0022205092530852033,
                    "percentage_of_circulating_supply": 0.002336649033669874
                },
                "0xd84f87b2b83bbbbad0929cde2b4607234f42fcd1": {
                    "balance": 22159737312991592316928,
                    "percentage_of_total_supply": 0.0022159737312991592,
                    "percentage_of_circulating_supply": 0.002331876289496967
                },
                "0xc9a4bb973f7d19b611c04628ec9bb6574ec2aec5": {
                    "balance": 21658815179887740977152,
                    "percentage_of_total_supply": 0.0021658815179887744,
                    "percentage_of_circulating_supply": 0.0022791640922100297
                },
                "0x810e3d6fa687a57219d904c667ac6cfe1d728c94": {
                    "balance": 21611332450206542200832,
                    "percentage_of_total_supply": 0.002161133245020654,
                    "percentage_of_circulating_supply": 0.0022741674692834902
                },
                "0xe13ea6b856b90a469b5a06fe6b869b623080c08b": {
                    "balance": 21540393606852206657536,
                    "percentage_of_total_supply": 0.002154039360685221,
                    "percentage_of_circulating_supply": 0.002266702551965841
                },
                "0xd1d0d2e73177764b2911802061040ea1bada74e1": {
                    "balance": 21469803619321429098496,
                    "percentage_of_total_supply": 0.002146980361932143,
                    "percentage_of_circulating_supply": 0.002259274344858783
                },
                "0xd2695119e60cb742ccd54794587c5e67fb78bdb8": {
                    "balance": 21399560203461086674944,
                    "percentage_of_total_supply": 0.0021399560203461086,
                    "percentage_of_circulating_supply": 0.002251882607600148
                },
                "0x803809bc8d7d782ead8efb25fe1e5e9d064b9c01": {
                    "balance": 21347129035587600777216,
                    "percentage_of_total_supply": 0.0021347129035587603,
                    "percentage_of_circulating_supply": 0.002246365258929993
                },
                "0x5b8001b880dce3988735dc8faacd71b47811e7af": {
                    "balance": 21329661093784366088192,
                    "percentage_of_total_supply": 0.0021329661093784365,
                    "percentage_of_circulating_supply": 0.002244527101792029
                },
                "0x6d3c08ace11347e9d26b49f2a61e45dcb18a837b": {
                    "balance": 20000000000000000000000,
                    "percentage_of_total_supply": 0.002,
                    "percentage_of_circulating_supply": 0.002104606436945313
                },
                "0x7151beb89e24b6c8a016df167b54ff03c811e643": {
                    "balance": 19893571627853247676416,
                    "percentage_of_total_supply": 0.001989357162785325,
                    "percentage_of_circulating_supply": 0.0020934069450906294
                },
                "0x8b86c42a6965ae13386d404022fda17b8d4bb2f5": {
                    "balance": 19728151010273510031360,
                    "percentage_of_total_supply": 0.001972815101027351,
                    "percentage_of_circulating_supply": 0.0020759996802625406
                },
                "0x34aac7e576f7beadef21e75e7366eaa6d394ac7d": {
                    "balance": 19416440021553722163200,
                    "percentage_of_total_supply": 0.0019416440021553722,
                    "percentage_of_circulating_supply": 0.002043198232596228
                },
                "0x7c773ce657ca4720920024dc889bba986c589a57": {
                    "balance": 19388777759231906414592,
                    "percentage_of_total_supply": 0.0019388777759231908,
                    "percentage_of_circulating_supply": 0.0020402873238290794
                },
                "0x77cadd67e0d4e00d294eb60cd2e3747ff6b328a4": {
                    "balance": 19140963751065490030592,
                    "percentage_of_total_supply": 0.001914096375106549,
                    "percentage_of_circulating_supply": 0.0020142097759914667
                },
                "0x43e014a9e8e3ab7893db6d904eaf41159bd279aa": {
                    "balance": 18922801279471814967296,
                    "percentage_of_total_supply": 0.0018922801279471816,
                    "percentage_of_circulating_supply": 0.0019912524688906696
                },
                "0x1f027276fa1606d6439fcd14352595ba49da32cd": {
                    "balance": 18882240297899504173056,
                    "percentage_of_total_supply": 0.0018882240297899504,
                    "percentage_of_circulating_supply": 0.001986984223745374
                },
                "0x2a1956dab094f1f617011b404f436d16eec1b29d": {
                    "balance": 18833724110456953503744,
                    "percentage_of_total_supply": 0.0018833724110456952,
                    "percentage_of_circulating_supply": 0.001981878849725992
                },
                "0xa23dde2357652c90b1db6c1bca28c8ccd0c2dec8": {
                    "balance": 18800000000000000000000,
                    "percentage_of_total_supply": 0.00188,
                    "percentage_of_circulating_supply": 0.0019783300507285944
                },
                "0x59badf696a5bca3914a9bf521b621917339390ab": {
                    "balance": 18653716604503654924288,
                    "percentage_of_total_supply": 0.0018653716604503654,
                    "percentage_of_circulating_supply": 0.001962936601939603
                },
                "0x583c1c9592a69d18e6dca5780042484a2dd0a774": {
                    "balance": 18382397526871262625792,
                    "percentage_of_total_supply": 0.0018382397526871261,
                    "percentage_of_circulating_supply": 0.0019343856080770428
                },
                "0xaa350c929248ee61fd1321620c9612552b602da4": {
                    "balance": 18139951545337979600896,
                    "percentage_of_total_supply": 0.001813995154533798,
                    "percentage_of_circulating_supply": 0.0019088729394097195
                },
                "0x9c8a3f049a94911e624bb55d298fa4a232cdd150": {
                    "balance": 18120684975078493913088,
                    "percentage_of_total_supply": 0.0018120684975078494,
                    "percentage_of_circulating_supply": 0.0019068455120204207
                },
                "0x96c117b48b81977da4da7d6ce6ae4ddfe6e299d8": {
                    "balance": 17127026486529430126592,
                    "percentage_of_total_supply": 0.0017127026486529432,
                    "percentage_of_circulating_supply": 0.0018022825094641355
                },
                "0xa93504f1ebb09457e3544c68450c34db4ebd77f9": {
                    "balance": 17103581741759586107392,
                    "percentage_of_total_supply": 0.0017103581741759587,
                    "percentage_of_circulating_supply": 0.0017998154114263775
                },
                "0x78003633fae8c8a49ddf1fc4bd865f57ec0b2fe1": {
                    "balance": 17036677984148483211264,
                    "percentage_of_total_supply": 0.0017036677984148482,
                    "percentage_of_circulating_supply": 0.0017927751074801697
                },
                "0xc0f0120e31104d143b708b7c5854db3b15282865": {
                    "balance": 16985198366784596475904,
                    "percentage_of_total_supply": 0.0016985198366784597,
                    "percentage_of_circulating_supply": 0.0017873578907763939
                },
                "0x241ee7ac0915c7f66757aa568de1c7995f8b5225": {
                    "balance": 16801113899573130035200,
                    "percentage_of_total_supply": 0.001680111389957313,
                    "percentage_of_circulating_supply": 0.0017679866230446487
                },
                "0x001194a1a7d87287ba9b7fc9d7e753ba76227fc7": {
                    "balance": 15868859658668823543808,
                    "percentage_of_total_supply": 0.0015868859658668823,
                    "percentage_of_circulating_supply": 0.0016698852092308105
                },
                "0xf22631881520e19a7262018c99f0b2fba3da2ac3": {
                    "balance": 15779319433705782509568,
                    "percentage_of_total_supply": 0.0015779319433705784,
                    "percentage_of_circulating_supply": 0.001660462862539673
                },
                "0x248a84c13089c678ef30498326c60d67fa967c33": {
                    "balance": 15763287493314472837120,
                    "percentage_of_total_supply": 0.0015763287493314473,
                    "percentage_of_circulating_supply": 0.0016587758162924593
                },
                "0x7d70031ba3541eed99462172bcfef95a8e04430a": {
                    "balance": 15661680860936930328576,
                    "percentage_of_total_supply": 0.001566168086093693,
                    "percentage_of_circulating_supply": 0.0016480837176655536
                },
                "0x3c030b3a86c0003d771558fb645c9afc1c3d2a6c": {
                    "balance": 15329407315260672573440,
                    "percentage_of_total_supply": 0.0015329407315260674,
                    "percentage_of_circulating_supply": 0.001613118465512709
                },
                "0xddc571189f6add71ed955a9ee404d8dd6128c879": {
                    "balance": 15307599999999999475712,
                    "percentage_of_total_supply": 0.00153076,
                    "percentage_of_circulating_supply": 0.0016108236747092036
                },
                "0xf50d6611513444759902750a24d7d58c887e1c80": {
                    "balance": 15139182409413600215040,
                    "percentage_of_total_supply": 0.00151391824094136,
                    "percentage_of_circulating_supply": 0.0015931010374470556
                },
                "0x7147b954113e66e2453e51f63cb71e4d2616ad1f": {
                    "balance": 15040627834448617930752,
                    "percentage_of_total_supply": 0.0015040627834448617,
                    "percentage_of_circulating_supply": 0.0015827301078039703
                },
                "0x399f32d8bc6ed944a804960652a242f2d739ea71": {
                    "balance": 15024229384431008219136,
                    "percentage_of_total_supply": 0.0015024229384431008,
                    "percentage_of_circulating_supply": 0.0015810044936308207
                },
                "0xaf1db5776de89c972af6dfa5575cb46eec63aa6e": {
                    "balance": 14777128268910464860160,
                    "percentage_of_total_supply": 0.0014777128268910465,
                    "percentage_of_circulating_supply": 0.0015550019637157757
                },
                "0xf1556a99eac86518ecefc7d51c53941b78379a6c": {
                    "balance": 14488333132410283622400,
                    "percentage_of_total_supply": 0.0014488333132410285,
                    "percentage_of_circulating_supply": 0.0015246119585539367
                },
                "0x3116b9554ad6e47c313ece3e99cf63103126c334": {
                    "balance": 14366081013224164032512,
                    "percentage_of_total_supply": 0.0014366081013224164,
                    "percentage_of_circulating_supply": 0.001511747328705471
                },
                "0xe94009d2215b61d14f69f97a223f5a24e040997c": {
                    "balance": 14219903474854652805120,
                    "percentage_of_total_supply": 0.0014219903474854652,
                    "percentage_of_circulating_supply": 0.0014963650192960061
                },
                "0x82c7d9862d79bea324d716d625cc60155cdccbb1": {
                    "balance": 14128215649255327531008,
                    "percentage_of_total_supply": 0.0014128215649255327,
                    "percentage_of_circulating_supply": 0.0014867166798987134
                },
                "0x8f29c982576047eccbef9668b55a75a7eef0fcd5": {
                    "balance": 13971759381675281219584,
                    "percentage_of_total_supply": 0.001397175938167528,
                    "percentage_of_circulating_supply": 0.0014702527365062432
                },
                "0xed5082e82cdaacc1b61b57020a21a1ff9d6f6080": {
                    "balance": 13919607468545313603584,
                    "percentage_of_total_supply": 0.0013919607468545314,
                    "percentage_of_circulating_supply": 0.0014647647739026261
                },
                "0x8da388ee490bb69f6e5576e0adef4aeb0b8dd20b": {
                    "balance": 13641783212164161470464,
                    "percentage_of_total_supply": 0.001364178321216416,
                    "percentage_of_circulating_supply": 0.00143552923798666
                },
                "0x18aff20cb7b3ac19121e29babcc4d5a12376063d": {
                    "balance": 13616589742514087395328,
                    "percentage_of_total_supply": 0.0013616589742514087,
                    "percentage_of_circulating_supply": 0.0014328781210669334
                },
                "0x95a1e0b2a342a63378e28e3885977f8bd82db69c": {
                    "balance": 13517116044531652886528,
                    "percentage_of_total_supply": 0.0013517116044531653,
                    "percentage_of_circulating_supply": 0.001422410471812904
                },
                "0x2207e9ffe9c0979b18959e5a16dfc646ef1e9b9e": {
                    "balance": 13398463650574131789824,
                    "percentage_of_total_supply": 0.0013398463650574131,
                    "percentage_of_circulating_supply": 0.0014099246422088058
                },
                "0x309f51e51baccdff1e2685ffc15b6475f02f5d1e": {
                    "balance": 13334474243188061110272,
                    "percentage_of_total_supply": 0.0013334474243188062,
                    "percentage_of_circulating_supply": 0.0014031910162747535
                },
                "0x353423f31ac70f582106bc67614cd4297052e559": {
                    "balance": 13310127226839787110400,
                    "percentage_of_total_supply": 0.0013310127226839788,
                    "percentage_of_circulating_supply": 0.0014006289719084041
                },
                "0x0fbbad923a542278e7b5f34a79f71428ebf8438d": {
                    "balance": 13285846859118056308736,
                    "percentage_of_total_supply": 0.0013285846859118055,
                    "percentage_of_circulating_supply": 0.0013980739409984765
                },
                "0x7655d39e81f6bb577187e40fb347308ca5b9c05b": {
                    "balance": 13250345199609961250816,
                    "percentage_of_total_supply": 0.001325034519960996,
                    "percentage_of_circulating_supply": 0.0013943380899423276
                },
                "0x8b16a92f9839d9111a1c68466b8b8ba88ad78f61": {
                    "balance": 13222661898244496293888,
                    "percentage_of_total_supply": 0.0013222661898244497,
                    "percentage_of_circulating_supply": 0.0013914249672298449
                },
                "0x5340285c1ce962c84f165ebbbb4bbfb7c6a0851c": {
                    "balance": 13198620459347996573696,
                    "percentage_of_total_supply": 0.0013198620459347996,
                    "percentage_of_circulating_supply": 0.0013888950788770948
                },
                "0xcfeb0e06e5ca258a87313b95777804ae517c2b20": {
                    "balance": 13174644556355283714048,
                    "percentage_of_total_supply": 0.0013174644556355284,
                    "percentage_of_circulating_supply": 0.0013863720868885928
                },
                "0xe6f2efb6a97dee594c8f6d88b9688811a2a5a18e": {
                    "balance": 13164842667341307183104,
                    "percentage_of_total_supply": 0.0013164842667341308,
                    "percentage_of_circulating_supply": 0.0013853406309529408
                }
            },
            "total_supply": 1000000000000000000000000000,
            "total_circulating_supply": 950296437799961424889380864,
            "owner": {},
            "creator": {},
            "holders_exceeding_5_percent": [
                {
                    "address": "0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe",
                    "balance": 699999999999999981813497856,
                    "percentage_of_supply": 73.66122529308595
                },
                {
                    "address": "0x3b49dd6f71d55d1021e86d583d84de670a0281d7",
                    "balance": 99647945770092928352387072,
                    "percentage_of_supply": 10.485985404805751
                }
            ],
            "howmany_holders_exceeding_5_percent": 2,
            "top_10_holders": [
                {
                    "address": "0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe",
                    "balance": 699999999999999981813497856,
                    "percentage_of_total_supply": 70.0,
                    "percentage_of_circulating_supply": 73.66122529308595
                },
                {
                    "address": "0x3b49dd6f71d55d1021e86d583d84de670a0281d7",
                    "balance": 99647945770092928352387072,
                    "percentage_of_total_supply": 9.964794577009291,
                    "percentage_of_circulating_supply": 10.485985404805751
                },
                {
                    "address": "0xf3fd55af5a55fef5ec86a04a68c1202f384bee6e",
                    "balance": 46647264379158213083267072,
                    "percentage_of_total_supply": 4.664726437915821,
                    "percentage_of_circulating_supply": 4.908706643913309
                },
                {
                    "address": "0xa6486729484bc6452df0e770f88d9cec24ebacf8",
                    "balance": 7571249347222013852254208,
                    "percentage_of_total_supply": 0.7571249347222013,
                    "percentage_of_circulating_supply": 0.7967250055940724
                },
                {
                    "address": "0x6ab4311b503cadd3d9f26da7deb66683144adf31",
                    "balance": 6308652697498257786404864,
                    "percentage_of_total_supply": 0.6308652697498257,
                    "percentage_of_circulating_supply": 0.6638615537803623
                },
                {
                    "address": "0xa6d43cdebc9053ba484c3e2608538f2ac2ff17c4",
                    "balance": 6125343849964181647261696,
                    "percentage_of_total_supply": 0.6125343849964182,
                    "percentage_of_circulating_supply": 0.6445719047569001
                },
                {
                    "address": "0x74d29b34eadc78e05d250c76a65e6d167e1786a1",
                    "balance": 5421436380345978153074688,
                    "percentage_of_total_supply": 0.5421436380345978,
                    "percentage_of_circulating_supply": 0.5704994951782821
                },
                {
                    "address": "0xd9b34d82c11c00e00f361268e01d2e8b2df246e4",
                    "balance": 4743850000000000261619712,
                    "percentage_of_total_supply": 0.474385,
                    "percentage_of_circulating_supply": 0.4991968622951512
                },
                {
                    "address": "0x2ae7d7037751570adaf784c28171ee657ae503d7",
                    "balance": 2049382101574125858324480,
                    "percentage_of_total_supply": 0.2049382101574126,
                    "percentage_of_circulating_supply": 0.21565713813667095
                },
                {
                    "address": "0x18f0e96d68b6e3bf131c2d2a5195d1dc77d1faba",
                    "balance": 1365847251622902368305152,
                    "percentage_of_total_supply": 0.13658472516229023,
                    "percentage_of_circulating_supply": 0.14372854588248124
                }
            ],
            "total_top_10_balance": 879880971777478583176396800,
            "top10_percentage_of_total_supply": 87.98809717774786,
            "top10_percentage_of_circulating_supply": 92.59015784742893,
            "top_10_less_than_70_percent_of_total": false,
            "top_10_less_than_70_percent_of_circulating": false
        },
        "liquidity": {
            "price_usd": 0.0004033,
            "liquidity_usd": 37632.35,
            "market_cap_usd": 3.832545533647245e+23,
            "liquidity_to_market_cap_ratio": 9.819152745769767e-20,
            "token_volume": 224776.96687920546,
            "volume_usd": 90.65255074238355,
            "volume_to_liquidity_ratio": 0.002408899543674088,
            "locked_liquidity_percent": 99.93,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 0.0,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 0.0,
            "total_lp_supply": 30340.189130895844,
            "lp_holders_count": 4,
            "lp_holders": [
                {
                    "address": "0x407993575c91ce7643a4d4ccacc9a98c36ee1bbe",
                    "balance": 30317.436435866148,
                    "is_locked": true,
                    "percent": 0.999250080646118,
                    "tag": "PinkLock02"
                },
                {
                    "address": "0x0ed943ce24baebf257488771759f9bf482c39706",
                    "balance": 12.148249542576584,
                    "is_locked": false,
                    "percent": 0.000400401246352345,
                    "tag": ""
                },
                {
                    "address": "0x34ca2ae578ee1fa92263699a190e0935e595d1cf",
                    "balance": 10.604445487121922,
                    "is_locked": false,
                    "percent": 0.000349518107529635,
                    "tag": ""
                },
                {
                    "address": "0x0000000000000000000000000000000000000000",
                    "balance": 1e-15,
                    "is_locked": true,
                    "percent": 0.0,
                    "tag": "Null Address"
                }
            ]
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://t.me/mrwhitestake": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 1,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 90605238.133527,
            "token_creation_date": "2022-10-07T18:49:34",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0xd9b857e760c160d68187677642fc18357640f476650afe676f73ec04ca135dd5",
            "last_active_age": "2025-08-21T00:51:31",
            "inactive_days": 0.42042117289351855
        }
    },
    "errors": []
}