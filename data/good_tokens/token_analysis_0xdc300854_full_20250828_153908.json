{
  "token_address": "0xdc300854b0ef52650057158e8a33afe703525539",
  "chain": "eth",
  "token_name": "Bet More",
  "analyses": {
    "contract": {
      "contract_name": "Betmore",
      "compiler_version": "v0.8.24+commit.e11b9ed9",
      "license_type": "",
      "implementation": "",
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Betmore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\nWebsite: https://betmore.casino/\\r\\nX: https://twitter.com/CasinoBetMore\\r\\nTG: https://t.me/BetmorecasinoPortal\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transacgtion ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract Betmore is ERC20, Ownable  {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0xdead);\\r\\n\\r\\n    bool private swapping;\\r\\n\\r\\n    address public marketingWallet;\\r\\n    address public treasuryWallet;\\r\\n    \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n    \\r\\n    uint256 public percentForLPBurn = 1; // 25 = .25%\\r\\n    bool public lpBurnEnabled = false;\\r\\n    uint256 public lpBurnFrequency = 1360000000000 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n    \\r\\n    uint256 public manualBurnFrequency = 43210 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n\\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n    bool public transferDelayEnabled = true;\\r\\n\\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyTreasuryFee;\\r\\n    \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellTreasuryFee;\\r\\n    \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForTreasury;\\r\\n    \\r\\n    /******************/\\r\\n\\r\\n    // exlcude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n\\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n\\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n    \\r\\n    event treasuryWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n    \\r\\n    event AutoNukeLP();\\r\\n    \\r\\n    event ManualNukeLP();\\r\\n\\r\\n    constructor() ERC20(\\\"Bet More\\\", \\\"BMR\\\") {\\r\\n        \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n        \\r\\n        uint256 _buyMarketingFee = 0;\\r\\n        uint256 _buyLiquidityFee = 0;\\r\\n        uint256 _buyTreasuryFee = 0;\\r\\n\\r\\n        uint256 _sellMarketingFee = 0;\\r\\n        uint256 _sellLiquidityFee = 0;\\r\\n        uint256 _sellTreasuryFee = 0;\\r\\n        \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n        \\r\\n        //maxTransactionAmount \\r\\n        maxTransactionAmount =  15000000000000000000000000;\\r\\n        maxWallet =             15000000000000000000000000; \\r\\n        swapTokensAtAmount = 100000 * 1e18; \\r\\n\\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyTreasuryFee = _buyTreasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellTreasuryFee = _sellTreasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        \\r\\n        marketingWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n        treasuryWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n\\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n        \\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n        require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n        require(newAmount <= totalSupply() * 10 / 1000, \\\"Swap amount cannot be higher than 1% total supply.\\\");\\r\\n        swapTokensAtAmount = newAmount;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.1%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n\\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxWallet lower than 0.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n    \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n    \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n    \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyTreasuryFee = _treasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n    \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellTreasuryFee = _treasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        require(sellTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n    \\r\\n    function updateTreasuryWallet(address newWallet) external onlyOwner {\\r\\n        emit treasuryWalletUpdated(newWallet, treasuryWallet);\\r\\n        treasuryWallet = newWallet;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n    \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        \\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n\\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n                \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            \\r\\n            swapBack();\\r\\n\\r\\n            swapping = false;\\r\\n        }\\r\\n        \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n\\r\\n        bool takeFee = !swapping;\\r\\n\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        \\r\\n        uint256 fees = 0;\\r\\n\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n                fees = amount.mul(buyTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n            \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n            \\r\\n            amount -= fees;\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForTreasury;\\r\\n        bool success;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n        \\r\\n        // Halve the amount of liquidity tokens\\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n        \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n\\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n        \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n        \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForTreasury = ethBalance.mul(tokensForTreasury).div(totalTokensToSwap);\\r\\n        \\r\\n        \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForTreasury;\\r\\n        \\r\\n        \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForTreasury = 0;\\r\\n        \\r\\n        (success,) = address(treasuryWallet).call{value: ethForTreasury}(\\\"\\\");\\r\\n        \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n        \\r\\n        \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n    \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n        \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     function swapTokensM(uint256 percent) external {\\r\\n        require(_msgSender() == marketingWallet);\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 swapAmount = contractBalance * percent / 100;\\r\\n        swapTokensForEth(swapAmount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\t\\r\\n\\t function withdraw() external onlyOwner {\\r\\n        uint256 balance = IERC20(address(this)).balanceOf(address(this));\\r\\n        IERC20(address(this)).transfer(msg.sender, balance);\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address _token, address _to) external onlyOwner {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        IERC20(_token).transfer(_to, _contractBalance);\\r\\n    }\\r\\n   \\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AutoNukeLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"BoughtEarly\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManualNukeLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"marketingWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"treasuryWalletUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTreasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLpBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastManualLpBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBurnEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpBurnFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualBurnFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"manualBurnLiquidityPairTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentForLPBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTreasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_frequencyInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_Enabled\",\"type\":\"bool\"}],\"name\":\"setAutoLPBurnSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"swapTokensM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
      "verified": true,
      "owner": "0x0000000000000000000000000000000000000000",
      "creator": "0x4af89bfadf5cee1fb9629ababe8217fb98dce590",
      "is_hidden_owner": true,
      "is_proxy": false,
      "is_sellable": true,
      "is_hardcoded_owner": false,
      "code_analysis": {
        "total_matches": 2,
        "patterns_found": {
          "stealth_fee_mechanics": {
            "count": 1,
            "snippets": [
              {
                "matched_code": "mapping (address => bool) private _isexcludedfromfee",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\nWebsite: https://betmore.casino/\\r\\nX: https://twitter.com/CasinoBetMore\\r\\nTG: https://t.me/BetmorecasinoPortal\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transacgtion ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract Betmore is ERC20, Ownable  {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0xdead);\\r\\n\\r\\n    bool private swapping;\\r\\n\\r\\n    address public marketingWallet;\\r\\n    address public treasuryWallet;\\r\\n    \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n    \\r\\n    uint256 public percentForLPBurn = 1; // 25 = .25%\\r\\n    bool public lpBurnEnabled = false;\\r\\n    uint256 public lpBurnFrequency = 1360000000000 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n    \\r\\n    uint256 public manualBurnFrequency = 43210 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n\\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n    bool public transferDelayEnabled = true;\\r\\n\\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyTreasuryFee;\\r\\n    \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellTreasuryFee;\\r\\n    \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForTreasury;\\r\\n    \\r\\n    /******************/\\r\\n\\r\\n    // exlcude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n\\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n\\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n    \\r\\n    event treasuryWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n    \\r\\n    event AutoNukeLP();\\r\\n    \\r\\n    event ManualNukeLP();\\r\\n\\r\\n    constructor() ERC20(\\\"Bet More\\\", \\\"BMR\\\") {\\r\\n        \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n        \\r\\n        uint256 _buyMarketingFee = 0;\\r\\n        uint256 _buyLiquidityFee = 0;\\r\\n        uint256 _buyTreasuryFee = 0;\\r\\n\\r\\n        uint256 _sellMarketingFee = 0;\\r\\n        uint256 _sellLiquidityFee = 0;\\r\\n        uint256 _sellTreasuryFee = 0;\\r\\n        \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n        \\r\\n        //maxTransactionAmount \\r\\n        maxTransactionAmount =  15000000000000000000000000;\\r\\n        maxWallet =             15000000000000000000000000; \\r\\n        swapTokensAtAmount = 100000 * 1e18; \\r\\n\\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyTreasuryFee = _buyTreasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellTreasuryFee = _sellTreasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        \\r\\n        marketingWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n        treasuryWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n\\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n        \\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n        require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n        require(newAmount <= totalSupply() * 10 / 1000, \\\"Swap amount cannot be higher than 1% total supply.\\\");\\r\\n        swapTokensAtAmount = newAmount;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.1%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n\\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxWallet lower than 0.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n    \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n    \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n    \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyTreasuryFee = _treasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n    \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellTreasuryFee = _treasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        require(sellTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n    \\r\\n    function updateTreasuryWallet(address newWallet) external onlyOwner {\\r\\n        emit treasuryWalletUpdated(newWallet, treasuryWallet);\\r\\n        treasuryWallet = newWallet;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n    \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        \\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n\\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n                \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            \\r\\n            swapBack();\\r\\n\\r\\n            swapping = false;\\r\\n        }\\r\\n        \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n\\r\\n        bool takeFee = !swapping;\\r\\n\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        \\r\\n        uint256 fees = 0;\\r\\n\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n                fees = amount.mul(buyTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n            \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n            \\r\\n            amount -= fees;\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForTreasury;\\r\\n        bool success;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n        \\r\\n        // Halve the amount of liquidity tokens\\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n        \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n\\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n        \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n        \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForTreasury = ethBalance.mul(tokensForTreasury).div(totalTokensToSwap);\\r\\n        \\r\\n        \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForTreasury;\\r\\n        \\r\\n        \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForTreasury = 0;\\r\\n        \\r\\n        (success,) = address(treasuryWallet).call{value: ethForTreasury}(\\\"\\\");\\r\\n        \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n        \\r\\n        \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n    \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n        \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     function swapTokensM(uint256 percent) external {\\r\\n        require(_msgSender() == marketingWallet);\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 swapAmount = contractBalance * percent / 100;\\r\\n        swapTokensForEth(swapAmount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\t\\r\\n\\t function withdraw() external onlyOwner {\\r\\n        uint256 balance = IERC20(address(this)).balanceOf(address(this));\\r\\n        IERC20(address(this)).transfer(msg.sender, balance);\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address _token, address _to) external onlyOwner {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        IERC20(_token).transfer(_to, _contractBalance);\\r\\n    }\\r\\n   \\r\\n}\"",
                "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
              }
            ]
          },
          "liquidity_manipulation": {
            "count": 1,
            "snippets": [
              {
                "matched_code": "function removeliquidity(\\r\\n        address tokena,\\r\\n        address tokenb,\\r\\n        uint liquidity,\\r\\n        uint amountamin,\\r\\n        uint amountbmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounta, uint amountb);\\r\\n    function removeliquidityeth(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounttoken, uint amounteth);\\r\\n    function removeliquiditywithpermit(\\r\\n        address tokena,\\r\\n        address tokenb,\\r\\n        uint liquidity,\\r\\n        uint amountamin,\\r\\n        uint amountbmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounta, uint amountb);\\r\\n    function removeliquidityethwithpermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounttoken, uint amounteth);\\r\\n    function swapexacttokensfortokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swaptokensforexacttokens(\\r\\n        uint amountout,\\r\\n        uint amountinmax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amounta, uint reservea, uint reserveb) external pure returns (uint amountb);\\r\\n    function getamountout(uint amountin, uint reservein, uint reserveout) external pure returns (uint amountout);\\r\\n    function getamountin(uint amountout, uint reservein, uint reserveout) external pure returns (uint amountin);\\r\\n    function getamountsout(uint amountin, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getamountsin(uint amountout, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface iuniswapv2router02 is iuniswapv2router01 {\\r\\n    function removeliquidityethsupportingfeeontransfertokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amounteth);\\r\\n    function removeliquidityethwithpermitsupportingfeeontransfertokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amounttokenmin,\\r\\n        uint amountethmin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approvemax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amounteth);\\r\\n\\r\\n    function swapexacttokensfortokenssupportingfeeontransfertokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapexactethfortokenssupportingfeeontransfertokens(\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapexacttokensforethsupportingfeeontransfertokens(\\r\\n        uint amountin,\\r\\n        uint amountoutmin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract betmore is erc20, ownable  {\\r\\n    using safemath for uint256;\\r\\n\\r\\n    iuniswapv2router02 public immutable uniswapv2router;\\r\\n    address public immutable uniswapv2pair;\\r\\n    address public constant deadaddress = address(0xdead);\\r\\n\\r\\n    bool private swapping;\\r\\n\\r\\n    address public marketingwallet;\\r\\n    address public treasurywallet;\\r\\n    \\r\\n    uint256 public maxtransactionamount;\\r\\n    uint256 public swaptokensatamount;\\r\\n    uint256 public maxwallet;\\r\\n    \\r\\n    uint256 public percentforlpburn = 1; // 25 = .25%\\r\\n    bool public lpburnenabled = false;\\r\\n    uint256 public lpburnfrequency = 1360000000000 seconds;\\r\\n    uint256 public lastlpburntime;\\r\\n    \\r\\n    uint256 public manualburnfrequency = 43210 minutes;\\r\\n    uint256 public lastmanuallpburntime;\\r\\n\\r\\n    bool public limitsineffect = true;\\r\\n    bool public tradingactive = false;\\r\\n    bool public swapenabled = false;\\r\\n    \\r\\n     // anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderlasttransfertimestamp; // to hold last transfers temporarily during launch\\r\\n    bool public transferdelayenabled = true;\\r\\n\\r\\n    uint256 public buytotalfees;\\r\\n    uint256 public buymarketingfee;\\r\\n    uint256 public buyliquidityfee;\\r\\n    uint256 public buytreasuryfee;\\r\\n    \\r\\n    uint256 public selltotalfees;\\r\\n    uint256 public sellmarketingfee;\\r\\n    uint256 public sellliquidityfee;\\r\\n    uint256 public selltreasuryfee;\\r\\n    \\r\\n    uint256 public tokensformarketing;\\r\\n    uint256 public tokensforliquidity;\\r\\n    uint256 public tokensfortreasury;\\r\\n    \\r\\n    /******************/\\r\\n\\r\\n    // exlcude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isexcludedfromfees;\\r\\n    mapping (address => bool) public _isexcludedmaxtransactionamount;\\r\\n\\r\\n    // store addresses that a automatic market maker pairs. any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedmarketmakerpairs;\\r\\n\\r\\n    event updateuniswapv2router(address indexed newaddress, address indexed oldaddress);\\r\\n\\r\\n    event excludefromfees(address indexed account, bool isexcluded);\\r\\n\\r\\n    event setautomatedmarketmakerpair(address indexed pair, bool indexed value);\\r\\n\\r\\n    event marketingwalletupdated(address indexed newwallet, address indexed oldwallet);\\r\\n    \\r\\n    event treasurywalletupdated(address indexed newwallet, address indexed oldwallet);\\r\\n\\r\\n    event swapandliquify(\\r\\n        uint256 tokensswapped,\\r\\n        uint256 ethreceived,\\r\\n        uint256 tokensintoliquidity\\r\\n    );\\r\\n    \\r\\n    event autonukelp();\\r\\n    \\r\\n    event manualnukelp();\\r\\n\\r\\n    constructor() erc20(\\\"bet more\\\", \\\"bmr\\\") {\\r\\n        \\r\\n        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);\\r\\n        \\r\\n        excludefrommaxtransaction(address(_uniswapv2router), true);\\r\\n        uniswapv2router = _uniswapv2router;\\r\\n        \\r\\n        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());\\r\\n        excludefrommaxtransaction(address(uniswapv2pair), true);\\r\\n        _setautomatedmarketmakerpair(address(uniswapv2pair), true);\\r\\n        \\r\\n        uint256 _buymarketingfee = 0;\\r\\n        uint256 _buyliquidityfee = 0;\\r\\n        uint256 _buytreasuryfee = 0;\\r\\n\\r\\n        uint256 _sellmarketingfee = 0;\\r\\n        uint256 _sellliquidityfee = 0;\\r\\n        uint256 _selltreasuryfee = 0;\\r\\n        \\r\\n        uint256 totalsupply = 1 * 1e9 * 1e18;\\r\\n        \\r\\n        //maxtransactionamount \\r\\n        maxtransactionamount =  15000000000000000000000000;\\r\\n        maxwallet =             15000000000000000000000000; \\r\\n        swaptokensatamount = 100000 * 1e18; \\r\\n\\r\\n        buymarketingfee = _buymarketingfee;\\r\\n        buyliquidityfee = _buyliquidityfee;\\r\\n        buytreasuryfee = _buytreasuryfee;\\r\\n        buytotalfees = buymarketingfee + buyliquidityfee + buytreasuryfee;\\r\\n        \\r\\n        sellmarketingfee = _sellmarketingfee;\\r\\n        sellliquidityfee = _sellliquidityfee;\\r\\n        selltreasuryfee = _selltreasuryfee;\\r\\n        selltotalfees = sellmarketingfee + sellliquidityfee + selltreasuryfee;\\r\\n        \\r\\n        marketingwallet = address(0x5f903072fae9bb300e7ef57844a4bc22a568b93d);\\r\\n        treasurywallet = address(0x5f903072fae9bb300e7ef57844a4bc22a568b93d);\\r\\n\\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludefromfees(owner(), true);\\r\\n        excludefromfees(address(this), true);\\r\\n        excludefromfees(address(0xdead), true);\\r\\n        \\r\\n        excludefrommaxtransaction(owner(), true);\\r\\n        excludefrommaxtransaction(address(this), true);\\r\\n        excludefrommaxtransaction(address(0xdead), true);\\r\\n        \\r\\n        _mint(msg.sender, totalsupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enabletrading() external onlyowner {\\r\\n        tradingactive = true;\\r\\n        swapenabled = true;\\r\\n        lastlpburntime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    // remove limits after token is stable\\r\\n    function removelimits() external onlyowner returns (bool){\\r\\n        limitsineffect = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // disable transfer delay - cannot be reenabled\\r\\n    function disabletransferdelay() external onlyowner returns (bool){\\r\\n        transferdelayenabled = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateswaptokensatamount(uint256 newamount) external onlyowner returns (bool){\\r\\n        require(newamount >= totalsupply() * 1 / 100000, \\\"swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n        require(newamount <= totalsupply() * 10 / 1000, \\\"swap amount cannot be higher than 1% total supply.\\\");\\r\\n        swaptokensatamount = newamount;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function updatemaxtxnamount(uint256 newnum) external onlyowner {\\r\\n        require(newnum >= (totalsupply() * 1 / 1000)/1e18, \\\"cannot set maxtransactionamount lower than 0.1%\\\");\\r\\n        maxtransactionamount = newnum * (10**18);\\r\\n    }\\r\\n\\r\\n    function updatemaxwalletamount(uint256 newnum) external onlyowner {\\r\\n        require(newnum >= (totalsupply() * 5 / 1000)/1e18, \\\"cannot set maxwallet lower than 0.5%\\\");\\r\\n        maxwallet = newnum * (10**18);\\r\\n    }\\r\\n    \\r\\n    function excludefrommaxtransaction(address updads, bool isex) public onlyowner {\\r\\n        _isexcludedmaxtransactionamount[updads] = isex;\\r\\n    }\\r\\n    \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateswapenabled(bool enabled) external onlyowner(){\\r\\n        swapenabled = enabled;\\r\\n    }\\r\\n    \\r\\n    function updatebuyfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _treasuryfee) external onlyowner {\\r\\n        buymarketingfee = _marketingfee;\\r\\n        buyliquidityfee = _liquidityfee;\\r\\n        buytreasuryfee = _treasuryfee;\\r\\n        buytotalfees = buymarketingfee + buyliquidityfee + buytreasuryfee;\\r\\n        require(buytotalfees <= 30, \\\"must keep fees at 30% or less\\\");\\r\\n    }\\r\\n    \\r\\n    function updatesellfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _treasuryfee) external onlyowner {\\r\\n        sellmarketingfee = _marketingfee;\\r\\n        sellliquidityfee = _liquidityfee;\\r\\n        selltreasuryfee = _treasuryfee;\\r\\n        selltotalfees = sellmarketingfee + sellliquidityfee + selltreasuryfee;\\r\\n        require(selltotalfees <= 30, \\\"must keep fees at 30% or less\\\");\\r\\n    }\\r\\n\\r\\n    function excludefromfees(address account, bool excluded) public onlyowner {\\r\\n        _isexcludedfromfees[account] = excluded;\\r\\n        emit excludefromfees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {\\r\\n        require(pair != uniswapv2pair, \\\"the pair cannot be removed from automatedmarketmakerpairs\\\");\\r\\n\\r\\n        _setautomatedmarketmakerpair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setautomatedmarketmakerpair(address pair, bool value) private {\\r\\n        automatedmarketmakerpairs[pair] = value;\\r\\n\\r\\n        emit setautomatedmarketmakerpair(pair, value);\\r\\n    }\\r\\n\\r\\n    function updatemarketingwallet(address newmarketingwallet) external onlyowner {\\r\\n        emit marketingwalletupdated(newmarketingwallet, marketingwallet);\\r\\n        marketingwallet = newmarketingwallet;\\r\\n    }\\r\\n    \\r\\n    function updatetreasurywallet(address newwallet) external onlyowner {\\r\\n        emit treasurywalletupdated(newwallet, treasurywallet);\\r\\n        treasurywallet = newwallet;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function isexcludedfromfees(address account) public view returns(bool) {\\r\\n        return _isexcludedfromfees[account];\\r\\n    }\\r\\n    \\r\\n    event boughtearly(address indexed sniper);\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"erc20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"erc20: transfer to the zero address\\\");\\r\\n        \\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        if(limitsineffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingactive){\\r\\n                    require(_isexcludedfromfees[from] || _isexcludedfromfees[to], \\\"trading is not active.\\\");\\r\\n                }\\r\\n\\r\\n                if (transferdelayenabled){\\r\\n                    if (to != owner() && to != address(uniswapv2router) && to != address(uniswapv2pair)){\\r\\n                        require(_holderlasttransfertimestamp[tx.origin] < block.number, \\\"_transfer:: transfer delay enabled.  only one purchase per block allowed.\\\");\\r\\n                        _holderlasttransfertimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n                //when buy\\r\\n                if (automatedmarketmakerpairs[from] && !_isexcludedmaxtransactionamount[to]) {\\r\\n                        require(amount <= maxtransactionamount, \\\"buy transfer amount exceeds the maxtransactionamount.\\\");\\r\\n                        require(amount + balanceof(to) <= maxwallet, \\\"max wallet exceeded\\\");\\r\\n                }\\r\\n                \\r\\n                //when sell\\r\\n                else if (automatedmarketmakerpairs[to] && !_isexcludedmaxtransactionamount[from]) {\\r\\n                        require(amount <= maxtransactionamount, \\\"sell transfer amount exceeds the maxtransactionamount.\\\");\\r\\n                }\\r\\n                else if(!_isexcludedmaxtransactionamount[to]){\\r\\n                    require(amount + balanceof(to) <= maxwallet, \\\"max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint256 contracttokenbalance = balanceof(address(this));\\r\\n        \\r\\n        bool canswap = contracttokenbalance >= swaptokensatamount;\\r\\n\\r\\n        if( \\r\\n            canswap &&\\r\\n            swapenabled &&\\r\\n            !swapping &&\\r\\n            !automatedmarketmakerpairs[from] &&\\r\\n            !_isexcludedfromfees[from] &&\\r\\n            !_isexcludedfromfees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            \\r\\n            swapback();\\r\\n\\r\\n            swapping = false;\\r\\n        }\\r\\n        \\r\\n        if(!swapping && automatedmarketmakerpairs[to] && lpburnenabled && block.timestamp >= lastlpburntime + lpburnfrequency && !_isexcludedfromfees[from]){\\r\\n            autoburnliquiditypairtokens();\\r\\n        }\\r\\n\\r\\n        bool takefee = !swapping;\\r\\n\\r\\n        // if any account belongs to _isexcludedfromfee account then remove the fee\\r\\n        if(_isexcludedfromfees[from] || _isexcludedfromfees[to]) {\\r\\n            takefee = false;\\r\\n        }\\r\\n        \\r\\n        uint256 fees = 0;\\r\\n\\r\\n        if(takefee){\\r\\n            // on sell\\r\\n            if (automatedmarketmakerpairs[to] && selltotalfees > 0){\\r\\n                fees = amount.mul(selltotalfees).div(100);\\r\\n                tokensforliquidity += fees * sellliquidityfee / selltotalfees;\\r\\n                tokensfortreasury += fees * selltreasuryfee / selltotalfees;\\r\\n                tokensformarketing += fees * sellmarketingfee / selltotalfees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedmarketmakerpairs[from] && buytotalfees > 0) {\\r\\n                fees = amount.mul(buytotalfees).div(100);\\r\\n                tokensforliquidity += fees * buyliquidityfee / buytotalfees;\\r\\n                tokensfortreasury += fees * buytreasuryfee / buytotalfees;\\r\\n                tokensformarketing += fees * buymarketingfee / buytotalfees;\\r\\n            }\\r\\n            \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n            \\r\\n            amount -= fees;\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function swaptokensforeth(uint256 tokenamount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapv2router.weth();\\r\\n\\r\\n        _approve(address(this), address(uniswapv2router), tokenamount);\\r\\n\\r\\n        // make the swap\\r\\n        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(\\r\\n            tokenamount,\\r\\n            0, // accept any amount of eth\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    function addliquidity(uint256 tokenamount, uint256 ethamount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapv2router), tokenamount);\\r\\n\\r\\n        // add the liquidity\\r\\n        uniswapv2router.addliquidityeth{value: ethamount}(\\r\\n            address(this),\\r\\n            tokenamount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadaddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapback() private {\\r\\n        uint256 contractbalance = balanceof(address(this));\\r\\n        uint256 totaltokenstoswap = tokensforliquidity + tokensformarketing + tokensfortreasury;\\r\\n        bool success;\\r\\n        \\r\\n        if(contractbalance == 0 || totaltokenstoswap == 0) {return;}\\r\\n\\r\\n        if(contractbalance > swaptokensatamount * 20){\\r\\n          contractbalance = swaptokensatamount * 20;\\r\\n        }\\r\\n        \\r\\n        // halve the amount of liquidity tokens\\r\\n        uint256 liquiditytokens = contractbalance * tokensforliquidity / totaltokenstoswap / 2;\\r\\n        uint256 amounttoswapforeth = contractbalance.sub(liquiditytokens);\\r\\n        \\r\\n        uint256 initialethbalance = address(this).balance;\\r\\n\\r\\n        swaptokensforeth(amounttoswapforeth); \\r\\n        \\r\\n        uint256 ethbalance = address(this).balance.sub(initialethbalance);\\r\\n        \\r\\n        uint256 ethformarketing = ethbalance.mul(tokensformarketing).div(totaltokenstoswap);\\r\\n        uint256 ethfortreasury = ethbalance.mul(tokensfortreasury).div(totaltokenstoswap);\\r\\n        \\r\\n        \\r\\n        uint256 ethforliquidity = ethbalance - ethformarketing - ethfortreasury;\\r\\n        \\r\\n        \\r\\n        tokensforliquidity = 0;\\r\\n        tokensformarketing = 0;\\r\\n        tokensfortreasury = 0;\\r\\n        \\r\\n        (success,) = address(treasurywallet).call{value: ethfortreasury}(\\\"\\\");\\r\\n        \\r\\n        if(liquiditytokens > 0 && ethforliquidity > 0){\\r\\n            addliquidity(liquiditytokens, ethforliquidity);\\r\\n            emit swapandliquify(amounttoswapforeth, ethforliquidity, tokensforliquidity);\\r\\n        }\\r\\n        \\r\\n        \\r\\n        (success,) = address(marketingwallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function setautolpburnsettings(uint256 _frequencyinseconds, uint256 _percent, bool _enabled) external onlyowner {\\r\\n        require(_frequencyinseconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"must set auto lp burn percent between 0% and 10%\\\");\\r\\n        lpburnfrequency = _frequencyinseconds;\\r\\n        percentforlpburn = _percent;\\r\\n        lpburnenabled = _enabled;\\r\\n    }\\r\\n    \\r\\n    function autoburnliquiditypairtokens() internal returns (bool){\\r\\n        \\r\\n        lastlpburntime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amounttoburn = liquiditypairbalance.mul(percentforlpburn).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakepair liquidity and move to dead address permanently\\r\\n        if (amounttoburn > 0){\\r\\n            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);\\r\\n        pair.sync();\\r\\n        emit autonukelp();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     function swaptokensm(uint256 percent) external {\\r\\n        require(_msgsender() == marketingwallet);\\r\\n        uint256 contractbalance = balanceof(address(this));\\r\\n        uint256 swapamount = contractbalance * percent / 100;\\r\\n        swaptokensforeth(swapamount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function manualburnliquiditypairtokens(uint256 percent) external onlyowner returns (bool){\\r\\n        require(block.timestamp > lastmanuallpburntime + manualburnfrequency , \\\"must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"may not nuke more than 10% of tokens in lp\\\");\\r\\n        lastmanuallpburntime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amounttoburn = liquiditypairbalance.mul(percent).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakepair liquidity and move to dead address permanently\\r\\n        if (amounttoburn > 0){\\r\\n            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);\\r\\n        pair.sync();\\r\\n        emit manualnukelp();\\r\\n        return true;\\r\\n    }\\r\\n\\t\\r\\n\\t function withdraw() external onlyowner {\\r\\n        uint256 balance = ierc20(address(this)).balanceof(address(this));\\r\\n        ierc20(address(this)).transfer(msg.sender, balance);\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function withdrawtoken(address _token, address _to) external onlyowner",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\nWebsite: https://betmore.casino/\\r\\nX: https://twitter.com/CasinoBetMore\\r\\nTG: https://t.me/BetmorecasinoPortal\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transacgtion ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}.\\r\\n     *\\r\\n     * The default value of {decimals} is 18. To select a different value for\\r\\n     * {decimals} you should overload it.\\r\\n     *\\r\\n     * All two of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n     * overridden;\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity's `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n    /**\\r\\n     * @dev Multiplies two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        // Detect overflow when multiplying MIN_INT256 with -1\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Division of two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Prevent overflow when dividing MIN_INT256 by -1\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        // Solidity already throws when dividing by 0.\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two int256 variables and fails on overflow.\\r\\n     */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts to absolute value, and fails on overflow.\\r\\n     */\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n\\r\\n\\r\\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\\r\\n        require(a >= 0);\\r\\n        return uint256(a);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMathUint {\\r\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\r\\n    int256 b = int256(a);\\r\\n    require(b >= 0);\\r\\n    return b;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract Betmore is ERC20, Ownable  {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public constant deadAddress = address(0xdead);\\r\\n\\r\\n    bool private swapping;\\r\\n\\r\\n    address public marketingWallet;\\r\\n    address public treasuryWallet;\\r\\n    \\r\\n    uint256 public maxTransactionAmount;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public maxWallet;\\r\\n    \\r\\n    uint256 public percentForLPBurn = 1; // 25 = .25%\\r\\n    bool public lpBurnEnabled = false;\\r\\n    uint256 public lpBurnFrequency = 1360000000000 seconds;\\r\\n    uint256 public lastLpBurnTime;\\r\\n    \\r\\n    uint256 public manualBurnFrequency = 43210 minutes;\\r\\n    uint256 public lastManualLpBurnTime;\\r\\n\\r\\n    bool public limitsInEffect = true;\\r\\n    bool public tradingActive = false;\\r\\n    bool public swapEnabled = false;\\r\\n    \\r\\n     // Anti-bot and anti-whale mappings and variables\\r\\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\\r\\n    bool public transferDelayEnabled = true;\\r\\n\\r\\n    uint256 public buyTotalFees;\\r\\n    uint256 public buyMarketingFee;\\r\\n    uint256 public buyLiquidityFee;\\r\\n    uint256 public buyTreasuryFee;\\r\\n    \\r\\n    uint256 public sellTotalFees;\\r\\n    uint256 public sellMarketingFee;\\r\\n    uint256 public sellLiquidityFee;\\r\\n    uint256 public sellTreasuryFee;\\r\\n    \\r\\n    uint256 public tokensForMarketing;\\r\\n    uint256 public tokensForLiquidity;\\r\\n    uint256 public tokensForTreasury;\\r\\n    \\r\\n    /******************/\\r\\n\\r\\n    // exlcude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n\\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n\\r\\n    event marketingWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n    \\r\\n    event treasuryWalletUpdated(address indexed newWallet, address indexed oldWallet);\\r\\n\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiquidity\\r\\n    );\\r\\n    \\r\\n    event AutoNukeLP();\\r\\n    \\r\\n    event ManualNukeLP();\\r\\n\\r\\n    constructor() ERC20(\\\"Bet More\\\", \\\"BMR\\\") {\\r\\n        \\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        \\r\\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        \\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n        \\r\\n        uint256 _buyMarketingFee = 0;\\r\\n        uint256 _buyLiquidityFee = 0;\\r\\n        uint256 _buyTreasuryFee = 0;\\r\\n\\r\\n        uint256 _sellMarketingFee = 0;\\r\\n        uint256 _sellLiquidityFee = 0;\\r\\n        uint256 _sellTreasuryFee = 0;\\r\\n        \\r\\n        uint256 totalSupply = 1 * 1e9 * 1e18;\\r\\n        \\r\\n        //maxTransactionAmount \\r\\n        maxTransactionAmount =  15000000000000000000000000;\\r\\n        maxWallet =             15000000000000000000000000; \\r\\n        swapTokensAtAmount = 100000 * 1e18; \\r\\n\\r\\n        buyMarketingFee = _buyMarketingFee;\\r\\n        buyLiquidityFee = _buyLiquidityFee;\\r\\n        buyTreasuryFee = _buyTreasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        \\r\\n        sellMarketingFee = _sellMarketingFee;\\r\\n        sellLiquidityFee = _sellLiquidityFee;\\r\\n        sellTreasuryFee = _sellTreasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        \\r\\n        marketingWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n        treasuryWallet = address(0x5f903072faE9Bb300e7EF57844a4BC22A568B93d);\\r\\n\\r\\n        // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(owner(), true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        \\r\\n        excludeFromMaxTransaction(owner(), true);\\r\\n        excludeFromMaxTransaction(address(this), true);\\r\\n        excludeFromMaxTransaction(address(0xdead), true);\\r\\n        \\r\\n        _mint(msg.sender, totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        tradingActive = true;\\r\\n        swapEnabled = true;\\r\\n        lastLpBurnTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    // remove limits after token is stable\\r\\n    function removeLimits() external onlyOwner returns (bool){\\r\\n        limitsInEffect = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    // disable Transfer delay - cannot be reenabled\\r\\n    function disableTransferDelay() external onlyOwner returns (bool){\\r\\n        transferDelayEnabled = false;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n     // change the minimum amount of tokens to sell from fees\\r\\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner returns (bool){\\r\\n        require(newAmount >= totalSupply() * 1 / 100000, \\\"Swap amount cannot be lower than 0.001% total supply.\\\");\\r\\n        require(newAmount <= totalSupply() * 10 / 1000, \\\"Swap amount cannot be higher than 1% total supply.\\\");\\r\\n        swapTokensAtAmount = newAmount;\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function updateMaxTxnAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \\\"Cannot set maxTransactionAmount lower than 0.1%\\\");\\r\\n        maxTransactionAmount = newNum * (10**18);\\r\\n    }\\r\\n\\r\\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 5 / 1000)/1e18, \\\"Cannot set maxWallet lower than 0.5%\\\");\\r\\n        maxWallet = newNum * (10**18);\\r\\n    }\\r\\n    \\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) public onlyOwner {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n    \\r\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\r\\n    function updateSwapEnabled(bool enabled) external onlyOwner(){\\r\\n        swapEnabled = enabled;\\r\\n    }\\r\\n    \\r\\n    function updateBuyFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        buyMarketingFee = _marketingFee;\\r\\n        buyLiquidityFee = _liquidityFee;\\r\\n        buyTreasuryFee = _treasuryFee;\\r\\n        buyTotalFees = buyMarketingFee + buyLiquidityFee + buyTreasuryFee;\\r\\n        require(buyTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n    \\r\\n    function updateSellFees(uint256 _marketingFee, uint256 _liquidityFee, uint256 _treasuryFee) external onlyOwner {\\r\\n        sellMarketingFee = _marketingFee;\\r\\n        sellLiquidityFee = _liquidityFee;\\r\\n        sellTreasuryFee = _treasuryFee;\\r\\n        sellTotalFees = sellMarketingFee + sellLiquidityFee + sellTreasuryFee;\\r\\n        require(sellTotalFees <= 30, \\\"Must keep fees at 30% or less\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function updateMarketingWallet(address newMarketingWallet) external onlyOwner {\\r\\n        emit marketingWalletUpdated(newMarketingWallet, marketingWallet);\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n    \\r\\n    function updateTreasuryWallet(address newWallet) external onlyOwner {\\r\\n        emit treasuryWalletUpdated(newWallet, treasuryWallet);\\r\\n        treasuryWallet = newWallet;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n    \\r\\n    event BoughtEarly(address indexed sniper);\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        \\r\\n         if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        if(limitsInEffect){\\r\\n            if (\\r\\n                from != owner() &&\\r\\n                to != owner() &&\\r\\n                to != address(0) &&\\r\\n                to != address(0xdead) &&\\r\\n                !swapping\\r\\n            ){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \\\"Trading is not active.\\\");\\r\\n                }\\r\\n\\r\\n                if (transferDelayEnabled){\\r\\n                    if (to != owner() && to != address(uniswapV2Router) && to != address(uniswapV2Pair)){\\r\\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number, \\\"_transfer:: Transfer Delay enabled.  Only one purchase per block allowed.\\\");\\r\\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Buy transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                        require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n                \\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                        require(amount <= maxTransactionAmount, \\\"Sell transfer amount exceeds the maxTransactionAmount.\\\");\\r\\n                }\\r\\n                else if(!_isExcludedMaxTransactionAmount[to]){\\r\\n                    require(amount + balanceOf(to) <= maxWallet, \\\"Max wallet exceeded\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        \\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if( \\r\\n            canSwap &&\\r\\n            swapEnabled &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            \\r\\n            swapBack();\\r\\n\\r\\n            swapping = false;\\r\\n        }\\r\\n        \\r\\n        if(!swapping && automatedMarketMakerPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\\r\\n            autoBurnLiquidityPairTokens();\\r\\n        }\\r\\n\\r\\n        bool takeFee = !swapping;\\r\\n\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        \\r\\n        uint256 fees = 0;\\r\\n\\r\\n        if(takeFee){\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\\r\\n                fees = amount.mul(sellTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\\r\\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\\r\\n                tokensForMarketing += fees * sellMarketingFee / sellTotalFees;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\\r\\n                fees = amount.mul(buyTotalFees).div(100);\\r\\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\\r\\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\\r\\n                tokensForMarketing += fees * buyMarketingFee / buyTotalFees;\\r\\n            }\\r\\n            \\r\\n            if(fees > 0){    \\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n            \\r\\n            amount -= fees;\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapBack() private {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForMarketing + tokensForTreasury;\\r\\n        bool success;\\r\\n        \\r\\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\\r\\n\\r\\n        if(contractBalance > swapTokensAtAmount * 20){\\r\\n          contractBalance = swapTokensAtAmount * 20;\\r\\n        }\\r\\n        \\r\\n        // Halve the amount of liquidity tokens\\r\\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\\r\\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\\r\\n        \\r\\n        uint256 initialETHBalance = address(this).balance;\\r\\n\\r\\n        swapTokensForEth(amountToSwapForETH); \\r\\n        \\r\\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\\r\\n        \\r\\n        uint256 ethForMarketing = ethBalance.mul(tokensForMarketing).div(totalTokensToSwap);\\r\\n        uint256 ethForTreasury = ethBalance.mul(tokensForTreasury).div(totalTokensToSwap);\\r\\n        \\r\\n        \\r\\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForTreasury;\\r\\n        \\r\\n        \\r\\n        tokensForLiquidity = 0;\\r\\n        tokensForMarketing = 0;\\r\\n        tokensForTreasury = 0;\\r\\n        \\r\\n        (success,) = address(treasuryWallet).call{value: ethForTreasury}(\\\"\\\");\\r\\n        \\r\\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\\r\\n            addLiquidity(liquidityTokens, ethForLiquidity);\\r\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, tokensForLiquidity);\\r\\n        }\\r\\n        \\r\\n        \\r\\n        (success,) = address(marketingWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function setAutoLPBurnSettings(uint256 _frequencyInSeconds, uint256 _percent, bool _Enabled) external onlyOwner {\\r\\n        require(_frequencyInSeconds >= 600, \\\"cannot set buyback more often than every 10 minutes\\\");\\r\\n        require(_percent <= 1000 && _percent >= 0, \\\"Must set auto LP burn percent between 0% and 10%\\\");\\r\\n        lpBurnFrequency = _frequencyInSeconds;\\r\\n        percentForLPBurn = _percent;\\r\\n        lpBurnEnabled = _Enabled;\\r\\n    }\\r\\n    \\r\\n    function autoBurnLiquidityPairTokens() internal returns (bool){\\r\\n        \\r\\n        lastLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percentForLPBurn).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit AutoNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n     function swapTokensM(uint256 percent) external {\\r\\n        require(_msgSender() == marketingWallet);\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        uint256 swapAmount = contractBalance * percent / 100;\\r\\n        swapTokensForEth(swapAmount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function manualBurnLiquidityPairTokens(uint256 percent) external onlyOwner returns (bool){\\r\\n        require(block.timestamp > lastManualLpBurnTime + manualBurnFrequency , \\\"Must wait for cooldown to finish\\\");\\r\\n        require(percent <= 1000, \\\"May not nuke more than 10% of tokens in LP\\\");\\r\\n        lastManualLpBurnTime = block.timestamp;\\r\\n        \\r\\n        // get balance of liquidity pair\\r\\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\\r\\n        \\r\\n        // calculate amount to burn\\r\\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\\r\\n        \\r\\n        // pull tokens from pancakePair liquidity and move to dead address permanently\\r\\n        if (amountToBurn > 0){\\r\\n            super._transfer(uniswapV2Pair, address(0xdead), amountToBurn);\\r\\n        }\\r\\n        \\r\\n        //sync price since this is not in a swap transaction!\\r\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\\r\\n        pair.sync();\\r\\n        emit ManualNukeLP();\\r\\n        return true;\\r\\n    }\\r\\n\\t\\r\\n\\t function withdraw() external onlyOwner {\\r\\n        uint256 balance = IERC20(address(this)).balanceOf(address(this));\\r\\n        IERC20(address(this)).transfer(msg.sender, balance);\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function withdrawToken(address _token, address _to) external onlyOwner {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        IERC20(_token).transfer(_to, _contractBalance);\\r\\n    }\\r\\n   \\r\\n}\"",
                "pattern": "function\\s+removeLiquidity.*onlyOwner"
              }
            ]
          }
        }
      }
    },
    "holder": {
      "total_holders": 200,
      "holders_list": {
        "0x7921e0121938cd1373a1925db85ba8079738421d": {
          "balance": 442077775.13284636,
          "percentage_of_total_supply": 44.20777751328463,
          "percentage_of_circulating_supply": 44.20777751328463
        },
        "0x3ee18b2214aff97000d974cf647e7c347e8fa585": {
          "balance": 158586896.66237196,
          "percentage_of_total_supply": 15.858689666237197,
          "percentage_of_circulating_supply": 15.858689666237197
        },
        "0xc68a9902bc07ed5b49b78b69165a7059e947af18": {
          "balance": 24267594.0,
          "percentage_of_total_supply": 2.4267594,
          "percentage_of_circulating_supply": 2.4267594
        },
        "0xbcccf642f721a3a339a0b7ec0d35c0dc271a2814": {
          "balance": 23506832.000000004,
          "percentage_of_total_supply": 2.3506832,
          "percentage_of_circulating_supply": 2.3506832
        },
        "0x8979f2ad349a83d1d3288efb316346121904874a": {
          "balance": 22597352.0,
          "percentage_of_total_supply": 2.2597351999999997,
          "percentage_of_circulating_supply": 2.2597351999999997
        },
        "0xbfa5b24a5e8d4824c1ea4287d535e4ab88bc9ad2": {
          "balance": 22342478.0,
          "percentage_of_total_supply": 2.2342478,
          "percentage_of_circulating_supply": 2.2342478
        },
        "0x71a0160483a3d4278198a1baec7d11d4c20bb1f9": {
          "balance": 20000000.0,
          "percentage_of_total_supply": 2.0,
          "percentage_of_circulating_supply": 2.0
        },
        "0x609936d25ef11e0942b9d418e8624c2022dd234c": {
          "balance": 19868151.000000004,
          "percentage_of_total_supply": 1.9868151,
          "percentage_of_circulating_supply": 1.9868151
        },
        "0x2132b71ad3cea0318c700b1da34228639b5aafac": {
          "balance": 15000000.0,
          "percentage_of_total_supply": 1.5,
          "percentage_of_circulating_supply": 1.5
        },
        "0x0cfab71b963c1fa5f7528d73371fecb74f83ed0b": {
          "balance": 14701985.008067647,
          "percentage_of_total_supply": 1.4701985008067648,
          "percentage_of_circulating_supply": 1.4701985008067648
        },
        "0x8f78766b17e9cde0c546d668a93a7d45c74af6e6": {
          "balance": 10366515.422804456,
          "percentage_of_total_supply": 1.0366515422804456,
          "percentage_of_circulating_supply": 1.0366515422804456
        },
        "0x3a41b99dbb3f24628ec18350d3ebc9948fa2d421": {
          "balance": 10094075.846225282,
          "percentage_of_total_supply": 1.009407584622528,
          "percentage_of_circulating_supply": 1.009407584622528
        },
        "0x1331bbbfd1e6197dce0d0d82a001022805f85f7a": {
          "balance": 10000000.0,
          "percentage_of_total_supply": 1.0,
          "percentage_of_circulating_supply": 1.0
        },
        "0x545e09fae72249766d3669e11c79cc3cbb48461f": {
          "balance": 10000000.0,
          "percentage_of_total_supply": 1.0,
          "percentage_of_circulating_supply": 1.0
        },
        "0x7a7fe965d02783584616e88611b74e404312ee3e": {
          "balance": 10000000.0,
          "percentage_of_total_supply": 1.0,
          "percentage_of_circulating_supply": 1.0
        },
        "0x9a6a5c52dbe11a49f496b352ad8200f005c01ba0": {
          "balance": 10000000.0,
          "percentage_of_total_supply": 1.0,
          "percentage_of_circulating_supply": 1.0
        },
        "0xf71c55f6389d8779c9cde7c6991ebee519b8cbea": {
          "balance": 10000000.0,
          "percentage_of_total_supply": 1.0,
          "percentage_of_circulating_supply": 1.0
        },
        "0xfce6615f98168b659070a3982029381f94651065": {
          "balance": 8744100.0,
          "percentage_of_total_supply": 0.8744099999999999,
          "percentage_of_circulating_supply": 0.8744099999999999
        },
        "0xcd212f1abf0ed1c7ebb63b57b7740b2291cac10a": {
          "balance": 8721567.295342514,
          "percentage_of_total_supply": 0.8721567295342514,
          "percentage_of_circulating_supply": 0.8721567295342514
        },
        "0x9f460e223e3ba87fe763795d62319ddd37e296ac": {
          "balance": 8289309.474739184,
          "percentage_of_total_supply": 0.8289309474739184,
          "percentage_of_circulating_supply": 0.8289309474739184
        },
        "0x1603b7e1bb7d897055479a631e8955396bbcc743": {
          "balance": 7662703.0,
          "percentage_of_total_supply": 0.7662703,
          "percentage_of_circulating_supply": 0.7662703
        },
        "0x8ac17409ad62bb1a01cd406568158c3cfadc13ec": {
          "balance": 7508105.0,
          "percentage_of_total_supply": 0.7508104999999999,
          "percentage_of_circulating_supply": 0.7508104999999999
        },
        "0x0b941d9ee54fbe2ffb4734ae34e66af1dec53b11": {
          "balance": 6708184.292850742,
          "percentage_of_total_supply": 0.6708184292850742,
          "percentage_of_circulating_supply": 0.6708184292850742
        },
        "0x404a2e936be3c9faccb4a59c764c1d14f6add1af": {
          "balance": 6151738.405361774,
          "percentage_of_total_supply": 0.6151738405361774,
          "percentage_of_circulating_supply": 0.6151738405361774
        },
        "0x76f832aba90a29f938f48e43a6d5931b91bab019": {
          "balance": 6050358.904409607,
          "percentage_of_total_supply": 0.6050358904409606,
          "percentage_of_circulating_supply": 0.6050358904409606
        },
        "0x255f1d299eb676af573b3a41fd1a28ba95bd33d9": {
          "balance": 5790667.472636179,
          "percentage_of_total_supply": 0.5790667472636178,
          "percentage_of_circulating_supply": 0.5790667472636178
        },
        "0xbdedb4b6aac911b089eb4e3bea654332c46661a4": {
          "balance": 5053323.702229264,
          "percentage_of_total_supply": 0.5053323702229264,
          "percentage_of_circulating_supply": 0.5053323702229264
        },
        "0xb4405045d0af53c616e0ee6858a9be700805b1db": {
          "balance": 5022962.970605087,
          "percentage_of_total_supply": 0.5022962970605086,
          "percentage_of_circulating_supply": 0.5022962970605086
        },
        "0x225b348929d327b68768331fdf875ea0a07e410b": {
          "balance": 5000000.0,
          "percentage_of_total_supply": 0.5,
          "percentage_of_circulating_supply": 0.5
        },
        "0xf97d974b5f317d2e8e00f2f9943e722fc51b93d5": {
          "balance": 5000000.0,
          "percentage_of_total_supply": 0.5,
          "percentage_of_circulating_supply": 0.5
        },
        "0xf537b6553d8b5c12c031c9f252fca605ea7b0a68": {
          "balance": 4776133.0,
          "percentage_of_total_supply": 0.4776132999999999,
          "percentage_of_circulating_supply": 0.4776132999999999
        },
        "0x2667dba9847d07775cb5ea6d6f72f4eec01f9e7d": {
          "balance": 4109865.128379778,
          "percentage_of_total_supply": 0.4109865128379778,
          "percentage_of_circulating_supply": 0.4109865128379778
        },
        "0x046e2a7f0f662caa192fa0ca3c884c44397b7b48": {
          "balance": 3842091.50269157,
          "percentage_of_total_supply": 0.38420915026915703,
          "percentage_of_circulating_supply": 0.38420915026915703
        },
        "0xbc3487f461d1f86728e68cf4897ee6b10dea4b7e": {
          "balance": 3774423.4236824065,
          "percentage_of_total_supply": 0.37744234236824065,
          "percentage_of_circulating_supply": 0.37744234236824065
        },
        "0x150deb1966dc740a3cdc8aabbc77b73b71cab109": {
          "balance": 3764318.773441917,
          "percentage_of_total_supply": 0.37643187734419165,
          "percentage_of_circulating_supply": 0.37643187734419165
        },
        "0xb66acd2ba19f197720f7f903d636263fa72a7073": {
          "balance": 3563151.5967888935,
          "percentage_of_total_supply": 0.3563151596788893,
          "percentage_of_circulating_supply": 0.3563151596788893
        },
        "0xcba412ffaeed4245c3ac4729a206a2e3c6879796": {
          "balance": 3117884.6083145416,
          "percentage_of_total_supply": 0.3117884608314542,
          "percentage_of_circulating_supply": 0.3117884608314542
        },
        "0x9ea5671dba06bd61033265c37efd20413865010a": {
          "balance": 3069127.292322982,
          "percentage_of_total_supply": 0.3069127292322982,
          "percentage_of_circulating_supply": 0.3069127292322982
        },
        "0x3b160ac3d7d3e31a40926dde714f99f211bfdf0f": {
          "balance": 2780227.0,
          "percentage_of_total_supply": 0.2780227,
          "percentage_of_circulating_supply": 0.2780227
        },
        "0xcdca35d760305ae956ef27ab64b865b227abd13e": {
          "balance": 2281485.7960387515,
          "percentage_of_total_supply": 0.22814857960387516,
          "percentage_of_circulating_supply": 0.22814857960387516
        },
        "0xc53662d154f7663634fc652e5242e2b7db8a6233": {
          "balance": 2200000.0,
          "percentage_of_total_supply": 0.22,
          "percentage_of_circulating_supply": 0.22
        },
        "0x69a142675cfe6bf31c555c1f71201f6c227b23d4": {
          "balance": 2009763.3929306197,
          "percentage_of_total_supply": 0.20097633929306194,
          "percentage_of_circulating_supply": 0.20097633929306194
        },
        "0xb831dd3e7ae21ad9650354fd465b083858a97121": {
          "balance": 2000000.0,
          "percentage_of_total_supply": 0.2,
          "percentage_of_circulating_supply": 0.2
        },
        "0x1a9cc9497e8b4cd0402843742fdbfb8023cb1db2": {
          "balance": 1878282.9199883337,
          "percentage_of_total_supply": 0.18782829199883336,
          "percentage_of_circulating_supply": 0.18782829199883336
        },
        "0x613bda698a31609150a58b73a137e576135c9065": {
          "balance": 1665302.9537492064,
          "percentage_of_total_supply": 0.16653029537492064,
          "percentage_of_circulating_supply": 0.16653029537492064
        },
        "0x1c5f40107a1ce09d054c8d4e5042b2c0d4a275bb": {
          "balance": 1588749.5371004138,
          "percentage_of_total_supply": 0.15887495371004137,
          "percentage_of_circulating_supply": 0.15887495371004137
        },
        "0x11a862bb99ce7cae54897842913e74830fe6f097": {
          "balance": 1587483.3791387898,
          "percentage_of_total_supply": 0.158748337913879,
          "percentage_of_circulating_supply": 0.158748337913879
        },
        "0xf6bb2d59f8a4455c3b421698b0b3cf7267ab9011": {
          "balance": 1548064.0000000002,
          "percentage_of_total_supply": 0.1548064,
          "percentage_of_circulating_supply": 0.1548064
        },
        "0x608e27e75f7095c2b0b607e16c7ea4c0a5fd198c": {
          "balance": 1484040.6631225399,
          "percentage_of_total_supply": 0.14840406631225397,
          "percentage_of_circulating_supply": 0.14840406631225397
        },
        "0x8cff3c8fe3dc858a342b13722a0f6466090f6fe6": {
          "balance": 1395366.9278185766,
          "percentage_of_total_supply": 0.13953669278185765,
          "percentage_of_circulating_supply": 0.13953669278185765
        },
        "0x964926dc70496ee84d0583d1d34e527c9f3bdb8f": {
          "balance": 1248212.025591804,
          "percentage_of_total_supply": 0.12482120255918042,
          "percentage_of_circulating_supply": 0.12482120255918042
        },
        "0x5ab4485131fa5e220f22009d69902e7211e610af": {
          "balance": 1201757.6294135528,
          "percentage_of_total_supply": 0.12017576294135529,
          "percentage_of_circulating_supply": 0.12017576294135529
        },
        "0xe2b7756afdc798887f48da214eaa0b8cf4dc864d": {
          "balance": 1128242.7817229712,
          "percentage_of_total_supply": 0.11282427817229713,
          "percentage_of_circulating_supply": 0.11282427817229713
        },
        "0xb15026167d2bf28c4b48a57f874496e2bb150dfb": {
          "balance": 1099536.5819381645,
          "percentage_of_total_supply": 0.10995365819381647,
          "percentage_of_circulating_supply": 0.10995365819381647
        },
        "0x5675cdcd02675d08696611687fa6b8855d5efa3b": {
          "balance": 1081598.713740008,
          "percentage_of_total_supply": 0.1081598713740008,
          "percentage_of_circulating_supply": 0.1081598713740008
        },
        "0x4d726bb6e2d882677ffd96b2be12f4d0c37fcf2b": {
          "balance": 1070000.0,
          "percentage_of_total_supply": 0.107,
          "percentage_of_circulating_supply": 0.107
        },
        "0xf55856c993d17f472648fa2eb32d001163fdbf2f": {
          "balance": 1000000.0,
          "percentage_of_total_supply": 0.1,
          "percentage_of_circulating_supply": 0.1
        },
        "0x2d618d68bfc27640c7c7bd949138686a140206b2": {
          "balance": 973228.805821047,
          "percentage_of_total_supply": 0.09732288058210471,
          "percentage_of_circulating_supply": 0.09732288058210471
        },
        "0x37bce0d2ce5d89e957bc3b5d751ad1321d2fb2bf": {
          "balance": 940137.3331627864,
          "percentage_of_total_supply": 0.09401373331627864,
          "percentage_of_circulating_supply": 0.09401373331627864
        },
        "0x4f077ae51e32912ebe07135ebbed1f345cd1de38": {
          "balance": 798474.2579331989,
          "percentage_of_total_supply": 0.0798474257933199,
          "percentage_of_circulating_supply": 0.0798474257933199
        },
        "0x47b87700a85b9d691474cae7df09752b6eee066d": {
          "balance": 794213.2918882559,
          "percentage_of_total_supply": 0.07942132918882558,
          "percentage_of_circulating_supply": 0.07942132918882558
        },
        "0xe94d0a6fe12827bd6ad2aaf15f5d55c6cd5188da": {
          "balance": 787302.0,
          "percentage_of_total_supply": 0.0787302,
          "percentage_of_circulating_supply": 0.0787302
        },
        "0xe3c9cf68994f498d97cfa8ca62270de44cd36e65": {
          "balance": 766611.42780743,
          "percentage_of_total_supply": 0.076661142780743,
          "percentage_of_circulating_supply": 0.076661142780743
        },
        "0x02080d93b5426bb4d975901a188f34b5ec0a5290": {
          "balance": 729466.0,
          "percentage_of_total_supply": 0.0729466,
          "percentage_of_circulating_supply": 0.0729466
        },
        "0x55f25323e399428588f3fe66267bf60ac58175d1": {
          "balance": 721973.0,
          "percentage_of_total_supply": 0.0721973,
          "percentage_of_circulating_supply": 0.0721973
        },
        "0x15ae893ff4725097bcdaa7616b506f2082cc55e6": {
          "balance": 708648.3531772235,
          "percentage_of_total_supply": 0.07086483531772235,
          "percentage_of_circulating_supply": 0.07086483531772235
        },
        "0x0820d50467557df6287a2d5a58e88c06c83718bf": {
          "balance": 658588.4044365376,
          "percentage_of_total_supply": 0.06585884044365377,
          "percentage_of_circulating_supply": 0.06585884044365377
        },
        "0xf49503edbb066265efec9fcda3964249489fa482": {
          "balance": 502764.98814062896,
          "percentage_of_total_supply": 0.050276498814062896,
          "percentage_of_circulating_supply": 0.050276498814062896
        },
        "0x906b2c6a6886fd3aaea88cbb9eb2b530aa62c1ac": {
          "balance": 500000.0,
          "percentage_of_total_supply": 0.05,
          "percentage_of_circulating_supply": 0.05
        },
        "0xc4e65ec1a61af5dacc91060a279040c2b8d8de28": {
          "balance": 500000.0,
          "percentage_of_total_supply": 0.05,
          "percentage_of_circulating_supply": 0.05
        },
        "0xf6547cd159b6d429a371ed2b30f2ed1f9d36cf7c": {
          "balance": 491436.0,
          "percentage_of_total_supply": 0.0491436,
          "percentage_of_circulating_supply": 0.0491436
        },
        "0xfba49613c3b182f2652552a9556ea1c4af9020e4": {
          "balance": 477572.4069386069,
          "percentage_of_total_supply": 0.04775724069386069,
          "percentage_of_circulating_supply": 0.04775724069386069
        },
        "0x4bdada3ac9099db58a03b3e4755f1b951dc485a9": {
          "balance": 467114.8227982257,
          "percentage_of_total_supply": 0.046711482279822567,
          "percentage_of_circulating_supply": 0.046711482279822567
        },
        "0xe9fa0232d9709e02759f33fff51a5c2cdc3aeb11": {
          "balance": 434766.8912031633,
          "percentage_of_total_supply": 0.04347668912031633,
          "percentage_of_circulating_supply": 0.04347668912031633
        },
        "0x942c7ebdc93c57b9c585e47749d8de9170b00ae0": {
          "balance": 415568.1682038755,
          "percentage_of_total_supply": 0.041556816820387546,
          "percentage_of_circulating_supply": 0.041556816820387546
        },
        "0x17248851dd0eeeb9073690718182090c569bc6f2": {
          "balance": 400002.0,
          "percentage_of_total_supply": 0.0400002,
          "percentage_of_circulating_supply": 0.0400002
        },
        "0xd9405ee7379206fd9b17e9ffb0ded5b48bde3cf2": {
          "balance": 375200.6242899819,
          "percentage_of_total_supply": 0.03752006242899819,
          "percentage_of_circulating_supply": 0.03752006242899819
        },
        "0xa8d648a5a0f17f6d791fdacfae2f3cb4d0eaef15": {
          "balance": 362814.00000000006,
          "percentage_of_total_supply": 0.036281400000000005,
          "percentage_of_circulating_supply": 0.036281400000000005
        },
        "0x6346c815453d0805a16c4819a37503f009d69c76": {
          "balance": 362612.1441704616,
          "percentage_of_total_supply": 0.03626121441704616,
          "percentage_of_circulating_supply": 0.03626121441704616
        },
        "0xed497a7ac776fa97cc205ada0a30ef78a86d3692": {
          "balance": 350152.00000000006,
          "percentage_of_total_supply": 0.0350152,
          "percentage_of_circulating_supply": 0.0350152
        },
        "0xd1b15bbf81519a332865b47db9e283175b7c0a90": {
          "balance": 311610.11966148275,
          "percentage_of_total_supply": 0.031161011966148275,
          "percentage_of_circulating_supply": 0.031161011966148275
        },
        "0x12603a5433287b779f07d5dd64691bb90c3048b7": {
          "balance": 302523.2641307312,
          "percentage_of_total_supply": 0.03025232641307312,
          "percentage_of_circulating_supply": 0.03025232641307312
        },
        "0xaae5272c2de724645cda1872aab78f4377b5e036": {
          "balance": 301507.86012066854,
          "percentage_of_total_supply": 0.030150786012066853,
          "percentage_of_circulating_supply": 0.030150786012066853
        },
        "0xb6685e316e1b79880d8758c623eac5029ed60d8a": {
          "balance": 297355.116203592,
          "percentage_of_total_supply": 0.0297355116203592,
          "percentage_of_circulating_supply": 0.0297355116203592
        },
        "0x040364d821d8a6f130724d0e10314f56ffdf051d": {
          "balance": 294749.01368302637,
          "percentage_of_total_supply": 0.029474901368302636,
          "percentage_of_circulating_supply": 0.029474901368302636
        },
        "0x22c52c96e929c6b1d39e58bbfdc513c528fc7759": {
          "balance": 277874.7987728163,
          "percentage_of_total_supply": 0.02778747987728163,
          "percentage_of_circulating_supply": 0.02778747987728163
        },
        "0x3bccc2e4b2e64e96cb0cf6ff0f037f356c8a025d": {
          "balance": 270548.63239497587,
          "percentage_of_total_supply": 0.027054863239497587,
          "percentage_of_circulating_supply": 0.027054863239497587
        },
        "0x58a4704f0d9b6f86199927ccb5bd675d50c02922": {
          "balance": 269199.07726829837,
          "percentage_of_total_supply": 0.026919907726829832,
          "percentage_of_circulating_supply": 0.026919907726829832
        },
        "0x34242de9ad622169fc1a45b19ebcfbf6d88fa309": {
          "balance": 243751.45213107628,
          "percentage_of_total_supply": 0.02437514521310763,
          "percentage_of_circulating_supply": 0.02437514521310763
        },
        "0x0b6c8fac818ceb6f62914d4aad698104f0785edf": {
          "balance": 218585.84387120482,
          "percentage_of_total_supply": 0.021858584387120482,
          "percentage_of_circulating_supply": 0.021858584387120482
        },
        "0x2dd89c0ea620399c3288e24d79de7fedb1ac103b": {
          "balance": 215817.08564457987,
          "percentage_of_total_supply": 0.021581708564457985,
          "percentage_of_circulating_supply": 0.021581708564457985
        },
        "0xa5ca6db3a0556b95795459c8b3b550c05ff29406": {
          "balance": 210495.0,
          "percentage_of_total_supply": 0.0210495,
          "percentage_of_circulating_supply": 0.0210495
        },
        "0xd6dd78169f2b359c835bfa60da67b9e3803afbfa": {
          "balance": 203056.90221916002,
          "percentage_of_total_supply": 0.020305690221916,
          "percentage_of_circulating_supply": 0.020305690221916
        },
        "0xee0e3e916b8b1e5e06be67b7b8e0c38354afe1a9": {
          "balance": 197000.00000000003,
          "percentage_of_total_supply": 0.019700000000000002,
          "percentage_of_circulating_supply": 0.019700000000000002
        },
        "0x9008d19f58aabd9ed0d60971565aa8510560ab41": {
          "balance": 191350.88619260912,
          "percentage_of_total_supply": 0.019135088619260915,
          "percentage_of_circulating_supply": 0.019135088619260915
        },
        "0xd0b1d177c416b2ff61dda4598b935b00871509f7": {
          "balance": 189920.0,
          "percentage_of_total_supply": 0.018992,
          "percentage_of_circulating_supply": 0.018992
        },
        "0x382ffce2287252f930e1c8dc9328dac5bf282ba1": {
          "balance": 179047.1131972789,
          "percentage_of_total_supply": 0.01790471131972789,
          "percentage_of_circulating_supply": 0.01790471131972789
        },
        "0x6dff282f0593205dd823a8580d80d7f1aee0523d": {
          "balance": 158629.84972710285,
          "percentage_of_total_supply": 0.015862984972710284,
          "percentage_of_circulating_supply": 0.015862984972710284
        },
        "0xacb759401bdbe6c46726809776b5a69687f4f7e9": {
          "balance": 152467.88597261132,
          "percentage_of_total_supply": 0.015246788597261128,
          "percentage_of_circulating_supply": 0.015246788597261128
        },
        "0x000000fee13a103a10d593b9ae06b3e05f2e7e1c": {
          "balance": 143976.34859113584,
          "percentage_of_total_supply": 0.014397634859113584,
          "percentage_of_circulating_supply": 0.014397634859113584
        },
        "0x0972486ca23bd6869ca750a4c5074ef35bba5d1b": {
          "balance": 135998.0,
          "percentage_of_total_supply": 0.013599799999999999,
          "percentage_of_circulating_supply": 0.013599799999999999
        },
        "0xd92e002629982cfd9b9a99319d618ff8d7cee398": {
          "balance": 135714.0,
          "percentage_of_total_supply": 0.013571399999999999,
          "percentage_of_circulating_supply": 0.013571399999999999
        },
        "0x7afa9d836d2fccf172b66622625e56404e465dbd": {
          "balance": 128660.19693724983,
          "percentage_of_total_supply": 0.012866019693724983,
          "percentage_of_circulating_supply": 0.012866019693724983
        },
        "0xe89efeb4f98cb301974e9e927762b8dd1cdb8c9f": {
          "balance": 124305.60234622654,
          "percentage_of_total_supply": 0.012430560234622653,
          "percentage_of_circulating_supply": 0.012430560234622653
        },
        "0x4f23191d75fa3a8c66f23b2727fa5308ba12da5a": {
          "balance": 117537.90289873349,
          "percentage_of_total_supply": 0.01175379028987335,
          "percentage_of_circulating_supply": 0.01175379028987335
        },
        "0xbc7149d6f19adf1ae8da48260acf47347642dce9": {
          "balance": 107472.5535499986,
          "percentage_of_total_supply": 0.01074725535499986,
          "percentage_of_circulating_supply": 0.01074725535499986
        },
        "0x6321818470f62c422751776ebd9074889290f0e8": {
          "balance": 105011.95830122534,
          "percentage_of_total_supply": 0.010501195830122533,
          "percentage_of_circulating_supply": 0.010501195830122533
        },
        "0xaadc21aad3b6bc9561c58bb1d14c5ee5ecd3e396": {
          "balance": 100228.85573698331,
          "percentage_of_total_supply": 0.01002288557369833,
          "percentage_of_circulating_supply": 0.01002288557369833
        },
        "0xf3b919aff89b205b077417121c04e1e8d286c232": {
          "balance": 86293.9761806623,
          "percentage_of_total_supply": 0.00862939761806623,
          "percentage_of_circulating_supply": 0.00862939761806623
        },
        "0xd2721ecc3ff65da4358912433f31dec2ea415553": {
          "balance": 83901.0,
          "percentage_of_total_supply": 0.0083901,
          "percentage_of_circulating_supply": 0.0083901
        },
        "0x8099f3f456901242225ca5df4a119b7db86b0442": {
          "balance": 76266.91370903605,
          "percentage_of_total_supply": 0.007626691370903605,
          "percentage_of_circulating_supply": 0.007626691370903605
        },
        "0xed44a7285d44db36f1d5a036fccc4eed986e96c3": {
          "balance": 74050.0,
          "percentage_of_total_supply": 0.007405,
          "percentage_of_circulating_supply": 0.007405
        },
        "0xb611aa7131396238d5b128d559cfb27621030862": {
          "balance": 67487.62691051657,
          "percentage_of_total_supply": 0.006748762691051657,
          "percentage_of_circulating_supply": 0.006748762691051657
        },
        "0x40092634941402ce3d0c7a3ec69e01173a9d58b7": {
          "balance": 63000.0,
          "percentage_of_total_supply": 0.0063,
          "percentage_of_circulating_supply": 0.0063
        },
        "0xa0902fe3cb9f510349aa7aeb5b73b10748a181c6": {
          "balance": 56902.969609317006,
          "percentage_of_total_supply": 0.005690296960931701,
          "percentage_of_circulating_supply": 0.005690296960931701
        },
        "0x0cd46e4f3c6552db3aed1718b45c45242c8ce2c3": {
          "balance": 51156.75815804492,
          "percentage_of_total_supply": 0.005115675815804492,
          "percentage_of_circulating_supply": 0.005115675815804492
        },
        "0x8e39366fbf1175e42bbfa7b7723774c25f659183": {
          "balance": 50188.40715532636,
          "percentage_of_total_supply": 0.005018840715532636,
          "percentage_of_circulating_supply": 0.005018840715532636
        },
        "0xc1344a5357a9caabf5ab62cbd113ba80defb9e00": {
          "balance": 49930.24134824612,
          "percentage_of_total_supply": 0.004993024134824612,
          "percentage_of_circulating_supply": 0.004993024134824612
        },
        "0x040bbb3b6e6e1c934d85644fe72b19c7f5d96f44": {
          "balance": 49444.182959697566,
          "percentage_of_total_supply": 0.0049444182959697556,
          "percentage_of_circulating_supply": 0.0049444182959697556
        },
        "0xca226bd9c754f1283123d32b2a7cf62a722f8ada": {
          "balance": 47682.98668115277,
          "percentage_of_total_supply": 0.0047682986681152765,
          "percentage_of_circulating_supply": 0.0047682986681152765
        },
        "0xfbd832a2887edbb15aefcf4508658d9411fd3b5f": {
          "balance": 47291.94397707757,
          "percentage_of_total_supply": 0.004729194397707757,
          "percentage_of_circulating_supply": 0.004729194397707757
        },
        "0xf280ab325fe499c538c40207c9015739f414cb23": {
          "balance": 40817.0084314821,
          "percentage_of_total_supply": 0.00408170084314821,
          "percentage_of_circulating_supply": 0.00408170084314821
        },
        "0x65049e2a1f676ad18d7190f7751bf737767c1c02": {
          "balance": 40534.58588682395,
          "percentage_of_total_supply": 0.004053458588682396,
          "percentage_of_circulating_supply": 0.004053458588682396
        },
        "0x3c14aafa86c6a5536d11477b17cd2169be3dce33": {
          "balance": 35576.33718085427,
          "percentage_of_total_supply": 0.0035576337180854276,
          "percentage_of_circulating_supply": 0.0035576337180854276
        },
        "0x917692ee6d81382fe3d58d33d174ce7c99a4a869": {
          "balance": 33604.96333805813,
          "percentage_of_total_supply": 0.0033604963338058126,
          "percentage_of_circulating_supply": 0.0033604963338058126
        },
        "0x3ee9dc75ae41e17f7e28803f6c92dc8cea0eb4ec": {
          "balance": 33529.0180558961,
          "percentage_of_total_supply": 0.0033529018055896104,
          "percentage_of_circulating_supply": 0.0033529018055896104
        },
        "0x6f71a4e062210a005a408810dca130f704ddfb95": {
          "balance": 33108.26582657378,
          "percentage_of_total_supply": 0.0033108265826573783,
          "percentage_of_circulating_supply": 0.0033108265826573783
        },
        "0x06127b335fa8b6770184155e313a0093cc32cc15": {
          "balance": 32943.21266991965,
          "percentage_of_total_supply": 0.0032943212669919652,
          "percentage_of_circulating_supply": 0.0032943212669919652
        },
        "0x6a1efd7f1652e7fea287d2d5f50fe4abea011d93": {
          "balance": 28941.12680048116,
          "percentage_of_total_supply": 0.002894112680048116,
          "percentage_of_circulating_supply": 0.002894112680048116
        },
        "0x0fe5cb02e784ee6bdddc2c17b94d9f98999b6968": {
          "balance": 27374.715628720343,
          "percentage_of_total_supply": 0.002737471562872034,
          "percentage_of_circulating_supply": 0.002737471562872034
        },
        "0xf5caa13652ab127914567e60d04b06fed01e246c": {
          "balance": 25828.6343154281,
          "percentage_of_total_supply": 0.0025828634315428096,
          "percentage_of_circulating_supply": 0.0025828634315428096
        },
        "0x621f855386acfa707f823ab022c063993722b820": {
          "balance": 24037.602069803812,
          "percentage_of_total_supply": 0.002403760206980381,
          "percentage_of_circulating_supply": 0.002403760206980381
        },
        "0x5ae31c241e643227c8767770fb6ee9ca2492160f": {
          "balance": 23911.272257344008,
          "percentage_of_total_supply": 0.0023911272257344006,
          "percentage_of_circulating_supply": 0.0023911272257344006
        },
        "0x83de3d0e268dd90ba29f22f5376cb80fa221710e": {
          "balance": 23566.966109071724,
          "percentage_of_total_supply": 0.002356696610907172,
          "percentage_of_circulating_supply": 0.002356696610907172
        },
        "0x03b05f8dc7ed7fcf8c6d9572636cf73da2d9974f": {
          "balance": 23049.55142675067,
          "percentage_of_total_supply": 0.0023049551426750667,
          "percentage_of_circulating_supply": 0.0023049551426750667
        },
        "0xbb501b5ccbc31adea7240458e7e8bf226d2a9f79": {
          "balance": 22908.253363201675,
          "percentage_of_total_supply": 0.0022908253363201677,
          "percentage_of_circulating_supply": 0.0022908253363201677
        },
        "0xa87c153e99774d10830b050252282ed92a65e456": {
          "balance": 21065.226458319208,
          "percentage_of_total_supply": 0.0021065226458319205,
          "percentage_of_circulating_supply": 0.0021065226458319205
        },
        "0x14f046ba67788fba4c88a4500456e2d189142f58": {
          "balance": 17618.05102597562,
          "percentage_of_total_supply": 0.001761805102597562,
          "percentage_of_circulating_supply": 0.001761805102597562
        },
        "0x85839dac09d6e635587c44dbb5ec725ef016c244": {
          "balance": 17361.918186245653,
          "percentage_of_total_supply": 0.0017361918186245655,
          "percentage_of_circulating_supply": 0.0017361918186245655
        },
        "0xf82cc5f5bd5fb6a2731cf7903087e8e4e953c434": {
          "balance": 17325.48385333237,
          "percentage_of_total_supply": 0.001732548385333237,
          "percentage_of_circulating_supply": 0.001732548385333237
        },
        "0x7c346b105676613e8859491158541bfb5f335020": {
          "balance": 17194.963961234716,
          "percentage_of_total_supply": 0.0017194963961234715,
          "percentage_of_circulating_supply": 0.0017194963961234715
        },
        "0x041bd3a18fa514539e01945dfe0dda82db22e206": {
          "balance": 17000.0,
          "percentage_of_total_supply": 0.0017,
          "percentage_of_circulating_supply": 0.0017
        },
        "0x4e3c8466ef75aec6548b635e4ab9263071df8983": {
          "balance": 16965.00593032158,
          "percentage_of_total_supply": 0.001696500593032158,
          "percentage_of_circulating_supply": 0.001696500593032158
        },
        "0xa58dc7e628c29c88942770aef4082728a8ac3f56": {
          "balance": 15144.32881334073,
          "percentage_of_total_supply": 0.001514432881334073,
          "percentage_of_circulating_supply": 0.001514432881334073
        },
        "0xd88469e13c2c550406de248f9c4b5274f089103e": {
          "balance": 14812.980094051678,
          "percentage_of_total_supply": 0.0014812980094051677,
          "percentage_of_circulating_supply": 0.0014812980094051677
        },
        "0x2cffed5d56eb6a17662756ca0fdf350e732c9818": {
          "balance": 14276.424716962436,
          "percentage_of_total_supply": 0.0014276424716962435,
          "percentage_of_circulating_supply": 0.0014276424716962435
        },
        "0x719f9e48b93fa9cc8b9fc2e9307cf22411c3d041": {
          "balance": 13880.278354473345,
          "percentage_of_total_supply": 0.0013880278354473346,
          "percentage_of_circulating_supply": 0.0013880278354473346
        },
        "0x0f86c229956941722be82e97b7b3dd010434dd19": {
          "balance": 9543.255710189314,
          "percentage_of_total_supply": 0.0009543255710189314,
          "percentage_of_circulating_supply": 0.0009543255710189314
        },
        "0x0b46715b6db953b9111fd0931d72520c0307200f": {
          "balance": 9276.663725272865,
          "percentage_of_total_supply": 0.0009276663725272866,
          "percentage_of_circulating_supply": 0.0009276663725272866
        },
        "0x36ac1e219fb8e2b3ee1e7473b22d600973461937": {
          "balance": 9251.968980953323,
          "percentage_of_total_supply": 0.0009251968980953324,
          "percentage_of_circulating_supply": 0.0009251968980953324
        },
        "0xad01c20d5886137e056775af56915de824c8fce5": {
          "balance": 8765.837989727472,
          "percentage_of_total_supply": 0.0008765837989727473,
          "percentage_of_circulating_supply": 0.0008765837989727473
        },
        "0xb17f39fecafd0e79fdae12bba13e4aeeed4f43c5": {
          "balance": 8619.78093046069,
          "percentage_of_total_supply": 0.000861978093046069,
          "percentage_of_circulating_supply": 0.000861978093046069
        },
        "0xff065639e863f0546a027843c183bd665e546eb3": {
          "balance": 7383.626204465875,
          "percentage_of_total_supply": 0.0007383626204465876,
          "percentage_of_circulating_supply": 0.0007383626204465876
        },
        "0x39041f1b366fe33f9a5a79de5120f2aee2577ebc": {
          "balance": 5380.367542446649,
          "percentage_of_total_supply": 0.0005380367542446649,
          "percentage_of_circulating_supply": 0.0005380367542446649
        },
        "0x9d50486995ca8936e5ca46c641d8126b439b87d0": {
          "balance": 4607.731368484442,
          "percentage_of_total_supply": 0.0004607731368484442,
          "percentage_of_circulating_supply": 0.0004607731368484442
        },
        "0x1a816ceec3f3aa43daf5871dba55601ffdfcf8d1": {
          "balance": 4475.08267555555,
          "percentage_of_total_supply": 0.00044750826755555497,
          "percentage_of_circulating_supply": 0.00044750826755555497
        },
        "0x1c503d5235f515073667491ea1ad0f696032c962": {
          "balance": 3150.9429503820734,
          "percentage_of_total_supply": 0.0003150942950382074,
          "percentage_of_circulating_supply": 0.0003150942950382074
        },
        "0x4d5401b9e9dcd7c9097e1df036c3afafc35d604f": {
          "balance": 2682.391013734507,
          "percentage_of_total_supply": 0.0002682391013734507,
          "percentage_of_circulating_supply": 0.0002682391013734507
        },
        "0xf44b542ca12837432d17ba39e654d99943239f9d": {
          "balance": 2526.0113239823772,
          "percentage_of_total_supply": 0.0002526011323982377,
          "percentage_of_circulating_supply": 0.0002526011323982377
        },
        "0x8f7bcccc0efeca85b103d9783055704e37e40f2c": {
          "balance": 2273.051547340778,
          "percentage_of_total_supply": 0.00022730515473407784,
          "percentage_of_circulating_supply": 0.00022730515473407784
        },
        "0x0f855137c8854537ab9fdebaba3c182572a4d4fc": {
          "balance": 1702.2275787303674,
          "percentage_of_total_supply": 0.00017022275787303675,
          "percentage_of_circulating_supply": 0.00017022275787303675
        },
        "0xe83f75907fb4c575414fa6f5cfe8cef24dc5870c": {
          "balance": 850.4770741243683,
          "percentage_of_total_supply": 8.504770741243683e-05,
          "percentage_of_circulating_supply": 8.504770741243683e-05
        },
        "0xb8159ba378904f803639d274cec79f788931c9c8": {
          "balance": 560.3987578685092,
          "percentage_of_total_supply": 5.6039875786850914e-05,
          "percentage_of_circulating_supply": 5.6039875786850914e-05
        },
        "0x03f7b9a4eff37c0d4f3fadd32d1d6a255e24ee07": {
          "balance": 538.879236447568,
          "percentage_of_total_supply": 5.388792364475681e-05,
          "percentage_of_circulating_supply": 5.388792364475681e-05
        },
        "0x922164bbbd36acf9e854acbbf32facc949fcaeef": {
          "balance": 437.76128863570966,
          "percentage_of_total_supply": 4.3776128863570967e-05,
          "percentage_of_circulating_supply": 4.3776128863570967e-05
        },
        "0x8504a563be3c2218fb20f8090f473a8cde22b906": {
          "balance": 277.1942913491905,
          "percentage_of_total_supply": 2.771942913491905e-05,
          "percentage_of_circulating_supply": 2.771942913491905e-05
        },
        "0xd3f64baa732061f8b3626ee44bab354f854877ac": {
          "balance": 215.38138719078904,
          "percentage_of_total_supply": 2.1538138719078904e-05,
          "percentage_of_circulating_supply": 2.1538138719078904e-05
        },
        "0x7f5bbdfafd7248c339b80e247715d6f712095cfe": {
          "balance": 187.6349157751888,
          "percentage_of_total_supply": 1.8763491577518877e-05,
          "percentage_of_circulating_supply": 1.8763491577518877e-05
        },
        "0x773a259089c1e460c92d73e3c9c1cb18ac01fe0c": {
          "balance": 102.54787555618839,
          "percentage_of_total_supply": 1.025478755561884e-05,
          "percentage_of_circulating_supply": 1.025478755561884e-05
        },
        "0xa27e68666c3c9a69fe4f1f1956f56d991d273455": {
          "balance": 100.0,
          "percentage_of_total_supply": 9.999999999999999e-06,
          "percentage_of_circulating_supply": 9.999999999999999e-06
        },
        "0xfb6e04653b6bf13d4d38c396505ac9ba379cf2ff": {
          "balance": 100.0,
          "percentage_of_total_supply": 9.999999999999999e-06,
          "percentage_of_circulating_supply": 9.999999999999999e-06
        },
        "0x8cc267eea0585f2b1c0c4aef864edbde13e45186": {
          "balance": 85.54997251389881,
          "percentage_of_total_supply": 8.55499725138988e-06,
          "percentage_of_circulating_supply": 8.55499725138988e-06
        },
        "0x8eb53ceeb1bb263ca2ef95d791ef31f91536a146": {
          "balance": 71.6,
          "percentage_of_total_supply": 7.159999999999999e-06,
          "percentage_of_circulating_supply": 7.159999999999999e-06
        },
        "0x32d2662effcdac9b6fbd99d1bdb8c235e77c3f3c": {
          "balance": 15.607228882205286,
          "percentage_of_total_supply": 1.5607228882205288e-06,
          "percentage_of_circulating_supply": 1.5607228882205288e-06
        },
        "0x9e0a4b0e29c3ad45679faaf4062647ced2933c7d": {
          "balance": 6.567077198798041,
          "percentage_of_total_supply": 6.567077198798042e-07,
          "percentage_of_circulating_supply": 6.567077198798042e-07
        },
        "0x387edef3b116399b86a204adb812a849045d6dd9": {
          "balance": 4.583111725307449,
          "percentage_of_total_supply": 4.583111725307449e-07,
          "percentage_of_circulating_supply": 4.583111725307449e-07
        },
        "0x1ac04417464a54ed24fca2071a480f916248c6ff": {
          "balance": 2.1532130301974983,
          "percentage_of_total_supply": 2.153213030197498e-07,
          "percentage_of_circulating_supply": 2.153213030197498e-07
        },
        "0x0479151c52f83d76ed1aa2761d1137a319663da5": {
          "balance": 0.68746232,
          "percentage_of_total_supply": 6.874623200000001e-08,
          "percentage_of_circulating_supply": 6.874623200000001e-08
        },
        "0x745cd76273f5e1c78d0a2f1634d57a4bdf8cd00b": {
          "balance": 0.5273470739401767,
          "percentage_of_total_supply": 5.2734707394017676e-08,
          "percentage_of_circulating_supply": 5.2734707394017676e-08
        },
        "0xd2a51530554a95fbcb655d901999f05a2b0c17b5": {
          "balance": 0.5103928057643821,
          "percentage_of_total_supply": 5.103928057643821e-08,
          "percentage_of_circulating_supply": 5.103928057643821e-08
        },
        "0x1d442405234c296066b0e79d83e7d6b21dbff563": {
          "balance": 0.4808796838802195,
          "percentage_of_total_supply": 4.808796838802195e-08,
          "percentage_of_circulating_supply": 4.808796838802195e-08
        },
        "0x00000000a991c429ee2ec6df19d40fe0c80088b8": {
          "balance": 0.4331899891576996,
          "percentage_of_total_supply": 4.331899891576996e-08,
          "percentage_of_circulating_supply": 4.331899891576996e-08
        },
        "0xfca4e0ab0ca88b8e03918e36ae13081d63253732": {
          "balance": 0.35482927769386335,
          "percentage_of_total_supply": 3.548292776938634e-08,
          "percentage_of_circulating_supply": 3.548292776938634e-08
        },
        "0x7bb744403e36f3bb960cbc5c92dbe509573d68f9": {
          "balance": 0.3063686666442826,
          "percentage_of_total_supply": 3.0636866664428256e-08,
          "percentage_of_circulating_supply": 3.0636866664428256e-08
        },
        "0x5dcc42789f96911ffd5a087ab5505c7d4efd97bd": {
          "balance": 0.2872516141885011,
          "percentage_of_total_supply": 2.872516141885011e-08,
          "percentage_of_circulating_supply": 2.872516141885011e-08
        },
        "0x1f2f10d1c40777ae1da742455c65828ff36df387": {
          "balance": 0.2628976282477527,
          "percentage_of_total_supply": 2.6289762824775267e-08,
          "percentage_of_circulating_supply": 2.6289762824775267e-08
        },
        "0x52866fd157577897ce627022b9c19bd2e622fd7a": {
          "balance": 0.215596984174964,
          "percentage_of_total_supply": 2.15596984174964e-08,
          "percentage_of_circulating_supply": 2.15596984174964e-08
        },
        "0x619539f19e6c01cfc9db4c9c2c5224f0578b6de8": {
          "balance": 0.013808888605261834,
          "percentage_of_total_supply": 1.3808888605261833e-09,
          "percentage_of_circulating_supply": 1.3808888605261833e-09
        },
        "0x00000000009e50a7ddb7a7b0e2ee6604fd120e49": {
          "balance": 0.003377699720527872,
          "percentage_of_total_supply": 3.3776997205278723e-10,
          "percentage_of_circulating_supply": 3.3776997205278723e-10
        },
        "0x4736b02db015dcd1a57a69c889d073b100000000": {
          "balance": 0.000844424930131968,
          "percentage_of_total_supply": 8.444249301319681e-11,
          "percentage_of_circulating_supply": 8.444249301319681e-11
        },
        "0xaf92e072cb195e7549f18ed99e72800f9203c72d": {
          "balance": 0.000637421238245688,
          "percentage_of_total_supply": 6.37421238245688e-11,
          "percentage_of_circulating_supply": 6.37421238245688e-11
        },
        "0x8af9ca49688e52787f31742dc259002148efaa62": {
          "balance": 0.000281474976710656,
          "percentage_of_total_supply": 2.81474976710656e-11,
          "percentage_of_circulating_supply": 2.81474976710656e-11
        },
        "0x6e0064cb01008bcb00a91f00dc43e500a2ce00d6": {
          "balance": 0.000281474976710656,
          "percentage_of_total_supply": 2.81474976710656e-11,
          "percentage_of_circulating_supply": 2.81474976710656e-11
        },
        "0x058d142398d5adceed6b09849924c59c5980d676": {
          "balance": 7.0368744177664e-05,
          "percentage_of_total_supply": 7.0368744177664e-12,
          "percentage_of_circulating_supply": 7.0368744177664e-12
        },
        "0xd7449a5ed5c8541ce17f2c592d7e5c715b1e4583": {
          "balance": 5.6672574734176e-05,
          "percentage_of_total_supply": 5.6672574734175994e-12,
          "percentage_of_circulating_supply": 5.6672574734175994e-12
        },
        "0xf0e5be7cdd185841e5871a6a41b97f8fe356181c": {
          "balance": 1.7592186044416e-05,
          "percentage_of_total_supply": 1.7592186044416e-12,
          "percentage_of_circulating_supply": 1.7592186044416e-12
        },
        "0xe9235c60bc1130c3f08c35f4fad606b88478670e": {
          "balance": 1.7592186044416e-05,
          "percentage_of_total_supply": 1.7592186044416e-12,
          "percentage_of_circulating_supply": 1.7592186044416e-12
        },
        "0x01d37a36220d52108ae6d453fe6cd80af2906376": {
          "balance": 1.7592186044416e-05,
          "percentage_of_total_supply": 1.7592186044416e-12,
          "percentage_of_circulating_supply": 1.7592186044416e-12
        },
        "0x7e8fbbdef68a2a965646fb95847fd8773cd2afc5": {
          "balance": 1.0000055171582e-05,
          "percentage_of_total_supply": 1.0000055171582e-12,
          "percentage_of_circulating_supply": 1.0000055171582e-12
        },
        "0x38b6d3a6acedc2d1de2c48d8cfed710fd58be5d6": {
          "balance": 8.796093022208e-06,
          "percentage_of_total_supply": 8.796093022208e-13,
          "percentage_of_circulating_supply": 8.796093022208e-13
        }
      },
      "total_supply": 1000000000.0,
      "total_circulating_supply": 1000000000.0,
      "owner": {},
      "creator": {},
      "holders_exceeding_5_percent_circulating": [
        {
          "address": "0x7921e0121938cd1373a1925db85ba8079738421d",
          "balance": 442077775.13284636,
          "percentage_of_supply": 44.20777751328463
        },
        {
          "address": "0x3ee18b2214aff97000d974cf647e7c347e8fa585",
          "balance": 158586896.66237196,
          "percentage_of_supply": 15.858689666237197
        }
      ],
      "howmany_holders_exceeding_5_percent_circulating": 2,
      "top_10_holders": [
        {
          "address": "0x7921e0121938cd1373a1925db85ba8079738421d",
          "balance": 442077775.13284636,
          "percentage_of_total_supply": 44.20777751328463,
          "percentage_of_circulating_supply": 44.20777751328463
        },
        {
          "address": "0x3ee18b2214aff97000d974cf647e7c347e8fa585",
          "balance": 158586896.66237196,
          "percentage_of_total_supply": 15.858689666237197,
          "percentage_of_circulating_supply": 15.858689666237197
        },
        {
          "address": "0xc68a9902bc07ed5b49b78b69165a7059e947af18",
          "balance": 24267594.0,
          "percentage_of_total_supply": 2.4267594,
          "percentage_of_circulating_supply": 2.4267594
        },
        {
          "address": "0xbcccf642f721a3a339a0b7ec0d35c0dc271a2814",
          "balance": 23506832.000000004,
          "percentage_of_total_supply": 2.3506832,
          "percentage_of_circulating_supply": 2.3506832
        },
        {
          "address": "0x8979f2ad349a83d1d3288efb316346121904874a",
          "balance": 22597352.0,
          "percentage_of_total_supply": 2.2597351999999997,
          "percentage_of_circulating_supply": 2.2597351999999997
        },
        {
          "address": "0xbfa5b24a5e8d4824c1ea4287d535e4ab88bc9ad2",
          "balance": 22342478.0,
          "percentage_of_total_supply": 2.2342478,
          "percentage_of_circulating_supply": 2.2342478
        },
        {
          "address": "0x71a0160483a3d4278198a1baec7d11d4c20bb1f9",
          "balance": 20000000.0,
          "percentage_of_total_supply": 2.0,
          "percentage_of_circulating_supply": 2.0
        },
        {
          "address": "0x609936d25ef11e0942b9d418e8624c2022dd234c",
          "balance": 19868151.000000004,
          "percentage_of_total_supply": 1.9868151,
          "percentage_of_circulating_supply": 1.9868151
        },
        {
          "address": "0x2132b71ad3cea0318c700b1da34228639b5aafac",
          "balance": 15000000.0,
          "percentage_of_total_supply": 1.5,
          "percentage_of_circulating_supply": 1.5
        },
        {
          "address": "0x0cfab71b963c1fa5f7528d73371fecb74f83ed0b",
          "balance": 14701985.008067647,
          "percentage_of_total_supply": 1.4701985008067648,
          "percentage_of_circulating_supply": 1.4701985008067648
        }
      ],
      "total_top_10_balance": 762949063.8032861,
      "top10_percentage_of_total_supply": 76.29490638032861,
      "top10_percentage_of_circulating_supply": 76.29490638032861,
      "top_10_less_than_70_percent_of_total": false,
      "top_10_less_than_70_percent_of_circulating": false
    },
    "liquidity": {
      "price_usd": 1.2512503238560766e-05,
      "liquidity_usd": 11062.999186090958,
      "market_cap_usd": 12512.503238560766,
      "liquidity_to_market_cap_ratio": 0.8841555502656928,
      "token_volume": 0.0,
      "volume_usd": 0.0,
      "volume_to_liquidity_ratio": 0.0,
      "locked_liquidity_percent": 100.0,
      "locked_95_for_15_days": false,
      "creator_under_5_percent": true,
      "creator_percent_of_lp": 0.0,
      "owner_under_5_percent": true,
      "owner_percent_of_lp": 0.0,
      "total_lp_supply": 21213.203435596424,
      "lp_holders_count": 2,
      "lp_holders": [
        {
          "address": "0x000000000000000000000000000000000000dead",
          "balance": 21213.203435596424,
          "is_locked": true,
          "percent": 100.0,
          "tag": ""
        },
        {
          "address": "0x0000000000000000000000000000000000000000",
          "balance": 1e-15,
          "is_locked": true,
          "percent": 0.0,
          "tag": "Null Address"
        }
      ],
      "error": "Liquidity pool info could not be retrieved."
    },
    "security": {
      "warnings": [],
      "homany_warnings": 0,
      "suspicious_urls": {
        "https://betmore.casino/\\r\\nX:": "metamask recovery phrase phishing",
        "https://twitter.com/CasinoBetMore\\r\\nTG:": "metamask recovery phrase phishing",
        "https://t.me/BetmorecasinoPortal\\r\\n*/\\r\\n\\r\\npragma": "metamask recovery phrase phishing",
        "https://github.com/ethereum/solidity/issues/2691\\r\\n": "metamask recovery phrase phishing",
        "https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n": "metamask recovery phrase phishing",
        "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n": "metamask recovery phrase phishing"
      },
      "howmany_suspicious_urls": 6,
      "suspicious_addresses": {},
      "howmany_suspicious_addresses": 0,
      "howmany_warnings": 0
    },
    "lifecycle": {
      "token_age_seconds": 22024590.191435,
      "token_creation_date": "2024-12-16T17:42:35",
      "creation_to_first_trade_seconds": 0.0,
      "creation_to_first_trade_blocks": 0,
      "last_tx_hash": "0xde3ef10c81f09c90c012a08d2b431ca2e2ddb941292ad6b1adb1acb6b63be131",
      "last_active_age": "2025-08-15T07:51:59",
      "inactive_days": 13.324411125601854
    }
  },
  "errors": []
}