{
    "token_address": "0xe5ba47fd94cb645ba4119222e34fb33f59c7cd90",
    "chain": "bsc",
    "token_name": "Safuu",
    "analyses": {
        "contract": {
            "contract_name": "Safuu",
            "compiler_version": "v0.7.4+commit.3f05b770",
            "license_type": "None",
            "implementation": "",
            "source_code": "// SPDX-License-Identifier: Unlicensed\r\n//\r\n// SAFUU PROTOCOL COPYRIGHT (C) 2022 \r\n\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IPancakeSwapPair {\r\n\t\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\r\n\t\tfunction name() external pure returns (string memory);\r\n\t\tfunction symbol() external pure returns (string memory);\r\n\t\tfunction decimals() external pure returns (uint8);\r\n\t\tfunction totalSupply() external view returns (uint);\r\n\t\tfunction balanceOf(address owner) external view returns (uint);\r\n\t\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\t\tfunction approve(address spender, uint value) external returns (bool);\r\n\t\tfunction transfer(address to, uint value) external returns (bool);\r\n\t\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n\t\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\t\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\t\tfunction nonces(address owner) external view returns (uint);\r\n\r\n\t\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n\t\tevent Mint(address indexed sender, uint amount0, uint amount1);\r\n\t\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n\t\tevent Swap(\r\n\t\t\t\taddress indexed sender,\r\n\t\t\t\tuint amount0In,\r\n\t\t\t\tuint amount1In,\r\n\t\t\t\tuint amount0Out,\r\n\t\t\t\tuint amount1Out,\r\n\t\t\t\taddress indexed to\r\n\t\t);\r\n\t\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n\t\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\t\tfunction factory() external view returns (address);\r\n\t\tfunction token0() external view returns (address);\r\n\t\tfunction token1() external view returns (address);\r\n\t\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\t\tfunction price0CumulativeLast() external view returns (uint);\r\n\t\tfunction price1CumulativeLast() external view returns (uint);\r\n\t\tfunction kLast() external view returns (uint);\r\n\r\n\t\tfunction mint(address to) external returns (uint liquidity);\r\n\t\tfunction burn(address to) external returns (uint amount0, uint amount1);\r\n\t\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\t\tfunction skim(address to) external;\r\n\t\tfunction sync() external;\r\n\r\n\t\tfunction initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeSwapRouter{\r\n\t\tfunction factory() external pure returns (address);\r\n\t\tfunction WETH() external pure returns (address);\r\n\r\n\t\tfunction addLiquidity(\r\n\t\t\t\taddress tokenA,\r\n\t\t\t\taddress tokenB,\r\n\t\t\t\tuint amountADesired,\r\n\t\t\t\tuint amountBDesired,\r\n\t\t\t\tuint amountAMin,\r\n\t\t\t\tuint amountBMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n\t\tfunction addLiquidityETH(\r\n\t\t\t\taddress token,\r\n\t\t\t\tuint amountTokenDesired,\r\n\t\t\t\tuint amountTokenMin,\r\n\t\t\t\tuint amountETHMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\t\tfunction removeLiquidity(\r\n\t\t\t\taddress tokenA,\r\n\t\t\t\taddress tokenB,\r\n\t\t\t\tuint liquidity,\r\n\t\t\t\tuint amountAMin,\r\n\t\t\t\tuint amountBMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint amountA, uint amountB);\r\n\t\tfunction removeLiquidityETH(\r\n\t\t\t\taddress token,\r\n\t\t\t\tuint liquidity,\r\n\t\t\t\tuint amountTokenMin,\r\n\t\t\t\tuint amountETHMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint amountToken, uint amountETH);\r\n\t\tfunction removeLiquidityWithPermit(\r\n\t\t\t\taddress tokenA,\r\n\t\t\t\taddress tokenB,\r\n\t\t\t\tuint liquidity,\r\n\t\t\t\tuint amountAMin,\r\n\t\t\t\tuint amountBMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline,\r\n\t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t\t) external returns (uint amountA, uint amountB);\r\n\t\tfunction removeLiquidityETHWithPermit(\r\n\t\t\t\taddress token,\r\n\t\t\t\tuint liquidity,\r\n\t\t\t\tuint amountTokenMin,\r\n\t\t\t\tuint amountETHMin,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline,\r\n\t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t\t) external returns (uint amountToken, uint amountETH);\r\n\t\tfunction swapExactTokensForTokens(\r\n\t\t\t\tuint amountIn,\r\n\t\t\t\tuint amountOutMin,\r\n\t\t\t\taddress[] calldata path,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint[] memory amounts);\r\n\t\tfunction swapTokensForExactTokens(\r\n\t\t\t\tuint amountOut,\r\n\t\t\t\tuint amountInMax,\r\n\t\t\t\taddress[] calldata path,\r\n\t\t\t\taddress to,\r\n\t\t\t\tuint deadline\r\n\t\t) external returns (uint[] memory amounts);\r\n\t\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n\t\t\t\texternal\r\n\t\t\t\tpayable\r\n\t\t\t\treturns (uint[] memory amounts);\r\n\t\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n\t\t\t\texternal\r\n\t\t\t\treturns (uint[] memory amounts);\r\n\t\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n\t\t\t\texternal\r\n\t\t\t\treturns (uint[] memory amounts);\r\n\t\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n\t\t\t\texternal\r\n\t\t\t\tpayable\r\n\t\t\t\treturns (uint[] memory amounts);\r\n\r\n\t\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\t\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\t\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\t\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\t\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\t\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\n\t\t\taddress token,\r\n\t\t\tuint liquidity,\r\n\t\t\tuint amountTokenMin,\r\n\t\t\tuint amountETHMin,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline\r\n\t\t) external returns (uint amountETH);\r\n\t\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n\t\t\taddress token,\r\n\t\t\tuint liquidity,\r\n\t\t\tuint amountTokenMin,\r\n\t\t\tuint amountETHMin,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline,\r\n\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n\t\t) external returns (uint amountETH);\r\n\t\r\n\t\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n\t\t\tuint amountIn,\r\n\t\t\tuint amountOutMin,\r\n\t\t\taddress[] calldata path,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline\r\n\t\t) external;\r\n\t\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n\t\t\tuint amountOutMin,\r\n\t\t\taddress[] calldata path,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline\r\n\t\t) external payable;\r\n\t\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n\t\t\tuint amountIn,\r\n\t\t\tuint amountOutMin,\r\n\t\t\taddress[] calldata path,\r\n\t\t\taddress to,\r\n\t\t\tuint deadline\r\n\t\t) external;\r\n}\r\n\r\ninterface IPancakeSwapFactory {\r\n\t\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n\t\tfunction feeTo() external view returns (address);\r\n\t\tfunction feeToSetter() external view returns (address);\r\n\r\n\t\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\t\tfunction allPairs(uint) external view returns (address pair);\r\n\t\tfunction allPairsLength() external view returns (uint);\r\n\r\n\t\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n\t\tfunction setFeeTo(address) external;\r\n\t\tfunction setFeeToSetter(address) external;\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(_owner);\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract Safuu is ERC20Detailed, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\r\n\r\n    string public _name = \"Safuu\";\r\n    string public _symbol = \"SAFUU\";\r\n    uint8 public _decimals = 5;\r\n\r\n    IPancakeSwapPair public pairContract;\r\n    mapping(address => bool) _isFeeExempt;\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        _;\r\n    }\r\n\r\n    uint256 public constant DECIMALS = 5;\r\n    uint256 public constant MAX_UINT256 = ~uint256(0);\r\n    uint8 public constant RATE_DECIMALS = 7;\r\n\r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY =\r\n        325 * 10**3 * 10**DECIMALS;\r\n\r\n    uint256 public liquidityFee = 40;\r\n    uint256 public treasuryFee = 25;\r\n    uint256 public safuuInsuranceFundFee = 50;\r\n    uint256 public sellFee = 20;\r\n    uint256 public firePitFee = 25;\r\n    uint256 public totalFee =\r\n        liquidityFee.add(treasuryFee).add(safuuInsuranceFundFee).add(\r\n            firePitFee\r\n        );\r\n    uint256 public feeDenominator = 1000;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    address public autoLiquidityReceiver;\r\n    address public treasuryReceiver;\r\n    address public safuuInsuranceFundReceiver;\r\n    address public firePit;\r\n    address public pairAddress;\r\n    bool public swapEnabled = true;\r\n    IPancakeSwapRouter public router;\r\n    address public pair;\r\n    bool inSwap = false;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    uint256 private constant TOTAL_GONS =\r\n        MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n\r\n    uint256 private constant MAX_SUPPLY = 325 * 10**7 * 10**DECIMALS;\r\n\r\n    bool public _autoRebase;\r\n    bool public _autoAddLiquidity;\r\n    uint256 public _initRebaseStartTime;\r\n    uint256 public _lastRebasedTime;\r\n    uint256 public _lastAddLiquidityTime;\r\n    uint256 public _totalSupply;\r\n    uint256 private _gonsPerFragment;\r\n\r\n    mapping(address => uint256) private _gonBalances;\r\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\r\n    mapping(address => bool) public blacklist;\r\n\r\n    constructor() ERC20Detailed(\"Safuu\", \"SAFUU\", uint8(DECIMALS)) Ownable() {\r\n\r\n        router = IPancakeSwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n        pair = IPancakeSwapFactory(router.factory()).createPair(\r\n            router.WETH(),\r\n            address(this)\r\n        );\r\n      \r\n        autoLiquidityReceiver = 0x5562640B953b6c2f79a655E930aFa68b2a65C627;\r\n        treasuryReceiver = 0xa9c6d0cc785569b450393A69599E97fAED5D9dd9; \r\n        safuuInsuranceFundReceiver = 0x082D0FbCA3D80b2d4A05E20bFc227523bE8EFEF3;\r\n        firePit = 0xaA32C984AfDfa6B95e88B8aB7faBfa65De89b98C;\r\n\r\n        _allowedFragments[address(this)][address(router)] = uint256(-1);\r\n        pairAddress = pair;\r\n        pairContract = IPancakeSwapPair(pair);\r\n\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n        _gonBalances[treasuryReceiver] = TOTAL_GONS;\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n        _initRebaseStartTime = block.timestamp;\r\n        _lastRebasedTime = block.timestamp;\r\n        _autoRebase = true;\r\n        _autoAddLiquidity = true;\r\n        _isFeeExempt[treasuryReceiver] = true;\r\n        _isFeeExempt[address(this)] = true;\r\n\r\n        _transferOwnership(treasuryReceiver);\r\n        emit Transfer(address(0x0), treasuryReceiver, _totalSupply);\r\n    }\r\n\r\n    function rebase() internal {\r\n        \r\n        if ( inSwap ) return;\r\n        uint256 rebaseRate;\r\n        uint256 deltaTimeFromInit = block.timestamp - _initRebaseStartTime;\r\n        uint256 deltaTime = block.timestamp - _lastRebasedTime;\r\n        uint256 times = deltaTime.div(15 minutes);\r\n        uint256 epoch = times.mul(15);\r\n\r\n        if (deltaTimeFromInit < (365 days)) {\r\n            rebaseRate = 2355;\r\n        } else if (deltaTimeFromInit >= (365 days)) {\r\n            rebaseRate = 211;\r\n        } else if (deltaTimeFromInit >= ((15 * 365 days) / 10)) {\r\n            rebaseRate = 14;\r\n        } else if (deltaTimeFromInit >= (7 * 365 days)) {\r\n            rebaseRate = 2;\r\n        }\r\n\r\n        for (uint256 i = 0; i < times; i++) {\r\n            _totalSupply = _totalSupply\r\n                .mul((10**RATE_DECIMALS).add(rebaseRate))\r\n                .div(10**RATE_DECIMALS);\r\n        }\r\n\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n        _lastRebasedTime = _lastRebasedTime.add(times.mul(15 minutes));\r\n\r\n        pairContract.sync();\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n    }\r\n\r\n    function transfer(address to, uint256 value)\r\n        external\r\n        override\r\n        validRecipient(to)\r\n        returns (bool)\r\n    {\r\n        _transferFrom(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override validRecipient(to) returns (bool) {\r\n        \r\n        if (_allowedFragments[from][msg.sender] != uint256(-1)) {\r\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][\r\n                msg.sender\r\n            ].sub(value, \"Insufficient Allowance\");\r\n        }\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\r\n        _gonBalances[from] = _gonBalances[from].sub(gonAmount);\r\n        _gonBalances[to] = _gonBalances[to].add(gonAmount);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n\r\n        require(!blacklist[sender] && !blacklist[recipient], \"in_blacklist\");\r\n\r\n        if (inSwap) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n        if (shouldRebase()) {\r\n           rebase();\r\n        }\r\n\r\n        if (shouldAddLiquidity()) {\r\n            addLiquidity();\r\n        }\r\n\r\n        if (shouldSwapBack()) {\r\n            swapBack();\r\n        }\r\n\r\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\r\n        _gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\r\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\r\n            ? takeFee(sender, recipient, gonAmount)\r\n            : gonAmount;\r\n        _gonBalances[recipient] = _gonBalances[recipient].add(\r\n            gonAmountReceived\r\n        );\r\n\r\n\r\n        emit Transfer(\r\n            sender,\r\n            recipient,\r\n            gonAmountReceived.div(_gonsPerFragment)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function takeFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 gonAmount\r\n    ) internal  returns (uint256) {\r\n        uint256 _totalFee = totalFee;\r\n        uint256 _treasuryFee = treasuryFee;\r\n\r\n        if (recipient == pair) {\r\n            _totalFee = totalFee.add(sellFee);\r\n            _treasuryFee = treasuryFee.add(sellFee);\r\n        }\r\n\r\n        uint256 feeAmount = gonAmount.div(feeDenominator).mul(_totalFee);\r\n       \r\n        _gonBalances[firePit] = _gonBalances[firePit].add(\r\n            gonAmount.div(feeDenominator).mul(firePitFee)\r\n        );\r\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(\r\n            gonAmount.div(feeDenominator).mul(_treasuryFee.add(safuuInsuranceFundFee))\r\n        );\r\n        _gonBalances[autoLiquidityReceiver] = _gonBalances[autoLiquidityReceiver].add(\r\n            gonAmount.div(feeDenominator).mul(liquidityFee)\r\n        );\r\n        \r\n        emit Transfer(sender, address(this), feeAmount.div(_gonsPerFragment));\r\n        return gonAmount.sub(feeAmount);\r\n    }\r\n\r\n    function addLiquidity() internal swapping {\r\n        uint256 autoLiquidityAmount = _gonBalances[autoLiquidityReceiver].div(\r\n            _gonsPerFragment\r\n        );\r\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(\r\n            _gonBalances[autoLiquidityReceiver]\r\n        );\r\n        _gonBalances[autoLiquidityReceiver] = 0;\r\n        uint256 amountToLiquify = autoLiquidityAmount.div(2);\r\n        uint256 amountToSwap = autoLiquidityAmount.sub(amountToLiquify);\r\n\r\n        if( amountToSwap == 0 ) {\r\n            return;\r\n        }\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETHLiquidity = address(this).balance.sub(balanceBefore);\r\n\r\n        if (amountToLiquify > 0&&amountETHLiquidity > 0) {\r\n            router.addLiquidityETH{value: amountETHLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n        }\r\n        _lastAddLiquidityTime = block.timestamp;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n\r\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\r\n\r\n        if( amountToSwap == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        \r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETHToTreasuryAndSIF = address(this).balance.sub(\r\n            balanceBefore\r\n        );\r\n\r\n        (bool success, ) = payable(treasuryReceiver).call{\r\n            value: amountETHToTreasuryAndSIF.mul(treasuryFee).div(\r\n                treasuryFee.add(safuuInsuranceFundFee)\r\n            ),\r\n            gas: 30000\r\n        }(\"\");\r\n        (success, ) = payable(safuuInsuranceFundReceiver).call{\r\n            value: amountETHToTreasuryAndSIF.mul(safuuInsuranceFundFee).div(\r\n                treasuryFee.add(safuuInsuranceFundFee)\r\n            ),\r\n            gas: 30000\r\n        }(\"\");\r\n    }\r\n\r\n    function withdrawAllToTreasury() external swapping onlyOwner {\r\n\r\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\r\n        require( amountToSwap > 0,\"There is no Safuu token deposited in token contract\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            treasuryReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function shouldTakeFee(address from, address to)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return \r\n            (pair == from || pair == to) &&\r\n            !_isFeeExempt[from];\r\n    }\r\n\r\n    function shouldRebase() internal view returns (bool) {\r\n        return\r\n            _autoRebase &&\r\n            (_totalSupply < MAX_SUPPLY) &&\r\n            msg.sender != pair  &&\r\n            !inSwap &&\r\n            block.timestamp >= (_lastRebasedTime + 15 minutes);\r\n    }\r\n\r\n    function shouldAddLiquidity() internal view returns (bool) {\r\n        return\r\n            _autoAddLiquidity && \r\n            !inSwap && \r\n            msg.sender != pair &&\r\n            block.timestamp >= (_lastAddLiquidityTime + 2 days);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return \r\n            !inSwap &&\r\n            msg.sender != pair  ; \r\n    }\r\n\r\n    function setAutoRebase(bool _flag) external onlyOwner {\r\n        if (_flag) {\r\n            _autoRebase = _flag;\r\n            _lastRebasedTime = block.timestamp;\r\n        } else {\r\n            _autoRebase = _flag;\r\n        }\r\n    }\r\n\r\n    function setAutoAddLiquidity(bool _flag) external onlyOwner {\r\n        if(_flag) {\r\n            _autoAddLiquidity = _flag;\r\n            _lastAddLiquidityTime = block.timestamp;\r\n        } else {\r\n            _autoAddLiquidity = _flag;\r\n        }\r\n    }\r\n\r\n    function allowance(address owner_, address spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\r\n                subtractedValue\r\n            );\r\n        }\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\r\n            spender\r\n        ].add(addedValue);\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function checkFeeExempt(address _addr) external view returns (bool) {\r\n        return _isFeeExempt[_addr];\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return\r\n            (TOTAL_GONS.sub(_gonBalances[DEAD]).sub(_gonBalances[ZERO])).div(\r\n                _gonsPerFragment\r\n            );\r\n    }\r\n\r\n    function isNotInSwap() external view returns (bool) {\r\n        return !inSwap;\r\n    }\r\n\r\n    function manualSync() external {\r\n        IPancakeSwapPair(pair).sync();\r\n    }\r\n\r\n    function setFeeReceivers(\r\n        address _autoLiquidityReceiver,\r\n        address _treasuryReceiver,\r\n        address _safuuInsuranceFundReceiver,\r\n        address _firePit\r\n    ) external onlyOwner {\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        treasuryReceiver = _treasuryReceiver;\r\n        safuuInsuranceFundReceiver = _safuuInsuranceFundReceiver;\r\n        firePit = _firePit;\r\n    }\r\n\r\n    function getLiquidityBacking(uint256 accuracy)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 liquidityBalance = _gonBalances[pair].div(_gonsPerFragment);\r\n        return\r\n            accuracy.mul(liquidityBalance.mul(2)).div(getCirculatingSupply());\r\n    }\r\n\r\n    function setWhitelist(address _addr) external onlyOwner {\r\n        _isFeeExempt[_addr] = true;\r\n    }\r\n\r\n    function setBotBlacklist(address _botAddress, bool _flag) external onlyOwner {\r\n        require(isContract(_botAddress), \"only contract address, not allowed exteranlly owned account\");\r\n        blacklist[_botAddress] = _flag;    \r\n    }\r\n    \r\n    function setPairAddress(address _pairAddress) public onlyOwner {\r\n        pairAddress = _pairAddress;\r\n    }\r\n\r\n    function setLP(address _address) external onlyOwner {\r\n        pairContract = IPancakeSwapPair(_address);\r\n    }\r\n    \r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n   \r\n    function balanceOf(address who) external view override returns (uint256) {\r\n        return _gonBalances[who].div(_gonsPerFragment);\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    receive() external payable {}\r\n}",
            "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_initRebaseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebasedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firePit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firePitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotInSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safuuInsuranceFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safuuInsuranceFundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_botAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setBotBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safuuInsuranceFundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_firePit\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
            "verified": true,
            "owner": null,
            "creator": "0xc38511a85d8fbf2c859e0bce7e831afd4b569939",
            "is_hidden_owner": true,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "ownership_renounced": {
                    "found": true,
                    "snippets": [
                        "    function renounceownership() public onlyowner {\n        emit ownershiprenounced(_owner);\n        _owner = address(0);\n    }"
                    ],
                    "snippets_number": 1
                },
                "is_honeypot_suspected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": true,
                    "snippets": [
                        "\t\tfunction swapexacttokensfortokens(\n\t\t\t\tuint amountin,",
                        "\t\tfunction swaptokensforexacttokens(\n\t\t\t\tuint amountout,",
                        "\t\tfunction swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)\n\t\t\t\texternal",
                        "\t\tfunction swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)\n\t\t\t\texternal",
                        "\t\tfunction swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)\n\t\t\t\texternal",
                        "\t\tfunction swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)\n\t\t\t\texternal",
                        "\t\tfunction removeliquidityethsupportingfeeontransfertokens(\n\t\t\taddress token,",
                        "\t\tfunction removeliquidityethwithpermitsupportingfeeontransfertokens(\n\t\t\taddress token,",
                        "\t\tfunction swapexacttokensfortokenssupportingfeeontransfertokens(\n\t\t\tuint amountin,",
                        "\t\tfunction swapexactethfortokenssupportingfeeontransfertokens(\n\t\t\tuint amountoutmin,",
                        "\t\tfunction swapexacttokensforethsupportingfeeontransfertokens(\n\t\t\tuint amountin,",
                        "\t\tfunction feetosetter() external view returns (address);\n",
                        "\t\tfunction setfeetosetter(address) external;\n}",
                        "    function rebase() internal {\n        \n        if ( inswap ) return;\n        uint256 rebaserate;\n        uint256 deltatimefrominit = block.timestamp - _initrebasestarttime;\n        uint256 deltatime = block.timestamp - _lastrebasedtime;\n        uint256 times = deltatime.div(15 minutes);\n        uint256 epoch = times.mul(15);\n\n        if (deltatimefrominit < (365 days)) {\n            rebaserate = 2355;\n        } else if (deltatimefrominit >= (365 days)) {\n            rebaserate = 211;\n        } else if (deltatimefrominit >= ((15 * 365 days) / 10)) {\n            rebaserate = 14;\n        } else if (deltatimefrominit >= (7 * 365 days)) {\n            rebaserate = 2;\n        }\n\n        for (uint256 i = 0; i < times; i++) {\n            _totalsupply = _totalsupply\n                .mul((10**rate_decimals).add(rebaserate))\n                .div(10**rate_decimals);\n        }\n\n        _gonsperfragment = total_gons.div(_totalsupply);\n        _lastrebasedtime = _lastrebasedtime.add(times.mul(15 minutes));\n\n        paircontract.sync();\n\n        emit logrebase(epoch, _totalsupply);\n    }",
                        "    function takefee(\n        address sender,",
                        "    function addliquidity() internal swapping {\n        uint256 autoliquidityamount = _gonbalances[autoliquidityreceiver].div(\n            _gonsperfragment\n        );\n        _gonbalances[address(this)] = _gonbalances[address(this)].add(\n            _gonbalances[autoliquidityreceiver]\n        );\n        _gonbalances[autoliquidityreceiver] = 0;\n        uint256 amounttoliquify = autoliquidityamount.div(2);\n        uint256 amounttoswap = autoliquidityamount.sub(amounttoliquify);\n\n        if( amounttoswap == 0 ) {\n            return;\n        }\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.weth();\n\n        uint256 balancebefore = address(this).balance;\n\n\n        router.swapexacttokensforethsupportingfeeontransfertokens(\n            amounttoswap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountethliquidity = address(this).balance.sub(balancebefore);\n\n        if (amounttoliquify > 0&&amountethliquidity > 0) {\n            router.addliquidityeth{value: amountethliquidity}(\n                address(this),\n                amounttoliquify,\n                0,\n                0,\n                autoliquidityreceiver,\n                block.timestamp\n            );\n        }\n        _lastaddliquiditytime = block.timestamp;\n    }",
                        "    function swapback() internal swapping {\n\n        uint256 amounttoswap = _gonbalances[address(this)].div(_gonsperfragment);\n\n        if( amounttoswap == 0) {\n            return;\n        }\n\n        uint256 balancebefore = address(this).balance;\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.weth();\n\n        \n        router.swapexacttokensforethsupportingfeeontransfertokens(\n            amounttoswap,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 amountethtotreasuryandsif = address(this).balance.sub(\n            balancebefore\n        );\n\n        (bool success, ) = payable(treasuryreceiver).call{\n            value: amountethtotreasuryandsif.mul(treasuryfee).div(\n                treasuryfee.add(safuuinsurancefundfee)\n            ),\n            gas: 30000\n        }(\"\");\n        (success, ) = payable(safuuinsurancefundreceiver).call{\n            value: amountethtotreasuryandsif.mul(safuuinsurancefundfee).div(\n                treasuryfee.add(safuuinsurancefundfee)\n            ),\n            gas: 30000\n        }(\"\");\n    }",
                        "    function withdrawalltotreasury() external swapping onlyowner {\n\n        uint256 amounttoswap = _gonbalances[address(this)].div(_gonsperfragment);\n        require( amounttoswap > 0,\"there is no safuu token deposited in token contract\");\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = router.weth();\n        router.swapexacttokensforethsupportingfeeontransfertokens(\n            amounttoswap,\n            0,\n            path,\n            treasuryreceiver,\n            block.timestamp\n        );\n    }",
                        "    function shouldtakefee(address from, address to)\n        internal",
                        "    function shouldrebase() internal view returns (bool) {\n        return\n            _autorebase &&\n            (_totalsupply < max_supply) &&\n            msg.sender != pair  &&\n            !inswap &&\n            block.timestamp >= (_lastrebasedtime + 15 minutes);\n    }",
                        "    function shouldaddliquidity() internal view returns (bool) {\n        return\n            _autoaddliquidity && \n            !inswap && \n            msg.sender != pair &&\n            block.timestamp >= (_lastaddliquiditytime + 2 days);\n    }",
                        "    function shouldswapback() internal view returns (bool) {\n        return \n            !inswap &&\n            msg.sender != pair  ; \n    }",
                        "    function checkfeeexempt(address _addr) external view returns (bool) {\n        return _isfeeexempt[_addr];\n    }",
                        "    function isnotinswap() external view returns (bool) {\n        return !inswap;\n    }",
                        "    function manualsync() external {\n        ipancakeswappair(pair).sync();\n    }",
                        "    function setfeereceivers(\n        address _autoliquidityreceiver,",
                        "    function setwhitelist(address _addr) external onlyowner {\n        _isfeeexempt[_addr] = true;\n    }",
                        "    function setlp(address _address) external onlyowner {\n        paircontract = ipancakeswappair(_address);\n    }"
                    ],
                    "snippets_number": 28
                },
                "blacklist_or_whitelist_detected": {
                    "found": true,
                    "snippets": [
                        "    function setwhitelist(address _addr) external onlyowner {\n        _isfeeexempt[_addr] = true;\n    }",
                        "    function setbotblacklist(address _botaddress, bool _flag) external onlyowner {\n        require(iscontract(_botaddress), \"only contract address, not allowed exteranlly owned account\");\n        blacklist[_botaddress] = _flag;    \n    }"
                    ],
                    "snippets_number": 2
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 0,
            "holders_list": null,
            "total_circulating_supply": 0,
            "owner": null,
            "creator": null,
            "holders_exceeding_5_percent": null,
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": null,
            "total_top_10_balance": null,
            "top10_percentage_of_total_supply": null,
            "top10_percentage_of_circulating_supply": null,
            "top_10_less_than_70_percent_of_total": null,
            "top_10_less_than_70_percent_of_circulating": null
        },
        "liquidity": {
            "price_usd": 0.1644,
            "liquidity_usd": 2952215.99,
            "market_cap_usd": 0.0,
            "liquidity_to_market_cap_ratio": 0,
            "token_volume": 38.60653,
            "volume_usd": 6.346913531999999,
            "volume_to_liquidity_ratio": 2.1498811582549552e-06,
            "locked_liquidity_percent": 99.95,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 0.0001,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 0.0,
            "total_lp_supply": 0.005958830787734527,
            "lp_holders_count": 10,
            "lp_holders": [
                {
                    "address": "0x7ee058420e5937496f5a2096f04caa7721cf70cc",
                    "balance": 0.005956139897670981,
                    "is_locked": true,
                    "percent": 0.9995484197891498,
                    "tag": "PinkSale: PinkLock"
                },
                {
                    "address": "0x3bfd3cbf64a0d4755f0560ce019fa603954ba1a1",
                    "balance": 1.815362204534e-06,
                    "is_locked": false,
                    "percent": 0.000304650739247485,
                    "tag": ""
                },
                {
                    "address": "0x40b51ca1aa212a64011ae73ed60972c181cbf275",
                    "balance": 2.11969879197e-07,
                    "is_locked": false,
                    "percent": 3.5572394442431e-05,
                    "tag": ""
                },
                {
                    "address": "0x659ec1e3c6c8c302a8c647d55bc2686d0b6ad532",
                    "balance": 7.9285031899e-08,
                    "is_locked": false,
                    "percent": 1.3305467922028e-05,
                    "tag": ""
                },
                {
                    "address": "0xc565047fb8fbf7e5b943d3ab7551738d85697bca",
                    "balance": 7.3980497806e-08,
                    "is_locked": false,
                    "percent": 1.2415270787396e-05,
                    "tag": ""
                },
                {
                    "address": "0x44e26c70c0484ef3365338fcebe28f1bac3cbc26",
                    "balance": 7.2355869042e-08,
                    "is_locked": false,
                    "percent": 1.2142628582596e-05,
                    "tag": ""
                },
                {
                    "address": "0xdba09b856fdc410fb83ba6c63ca9ac8186bbf4aa",
                    "balance": 5.7215736487e-08,
                    "is_locked": false,
                    "percent": 9.601839442189e-06,
                    "tag": ""
                },
                {
                    "address": "0x687d3d156b80c8c1f01fd5b440b4bab95dfd6e40",
                    "balance": 5.1209343915e-08,
                    "is_locked": false,
                    "percent": 8.593857711215e-06,
                    "tag": ""
                },
                {
                    "address": "0x2b747fc927c549be2a7eb1a480473a4368686afa",
                    "balance": 4.0737738013e-08,
                    "is_locked": false,
                    "percent": 6.836532109093e-06,
                    "tag": ""
                },
                {
                    "address": "0x0ed943ce24baebf257488771759f9bf482c39706",
                    "balance": 3.1814763481e-08,
                    "is_locked": false,
                    "percent": 5.339094969181e-06,
                    "tag": ""
                }
            ]
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {},
            "howmany_suspicious_urls": 0,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 110328020.469733,
            "token_creation_date": "2022-02-18T20:33:34",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x955f1d6e23a10af6f042985db4fada23726ad4695abdfb1636f2d95e23c85ec8",
            "last_active_age": "2025-08-18T18:57:58",
            "inactive_days": 0.011097496990740741
        },
        "holders": {
            "error": "Exception during holder analysis in owner_circulating_supply_analysis: float division by zero"
        }
    },
    "errors": []
}