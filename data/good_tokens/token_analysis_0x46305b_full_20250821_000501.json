{
    "token_address": "0x46305b2ebcd92809d5fcef577c20c28a185af03c",
    "chain": "eth",
    "token_name": "Shadowladys DN404",
    "analyses": {
        "contract": {
            "contract_name": "Shadowladys",
            "compiler_version": "v0.8.24+commit.e11b9ed9",
            "license_type": "",
            "implementation": "",
            "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Shadowladys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"dn404/src/DN404.sol\\\";\\nimport \\\"dn404/src/DN404Mirror.sol\\\";\\nimport {Ownable} from \\\"solady/src/auth/Ownable.sol\\\";\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {SafeTransferLib} from \\\"solady/src/utils/SafeTransferLib.sol\\\";\\n\\ncontract Shadowladys is DN404, Ownable {\\n    string private _name;\\n    string private _symbol;\\n    string private _baseURI;\\n\\n    constructor() {\\n        _initializeOwner(msg.sender);\\n\\n        _name = \\\"Shadowladys DN404\\\";\\n        _symbol = \\\"SHADOW\\\";\\n        _baseURI = \\\"https://shadowladys.xyz/api/token/\\\";\\n\\n        address mirror = address(new DN404Mirror(msg.sender));\\n        _initializeDN404(10_000 * 10 ** 18, msg.sender, mirror);\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override returns (string memory result) {\\n        if (bytes(_baseURI).length != 0) {\\n            result = string(\\n                abi.encodePacked(_baseURI, LibString.toString(tokenId))\\n            );\\n        }\\n    }\\n\\n    function setBaseURI(string calldata baseURI_) public onlyOwner {\\n        _baseURI = baseURI_;\\n    }\\n\\n    function withdraw() public onlyOwner {\\n        SafeTransferLib.safeTransferAllETH(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"dn404/src/DN404.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"dn404/src/DN404Mirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) {\\n            return toString(uint256(value));\\n        }\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            // Allocate the memory.\\n            mstore(0x40, add(str, 0x20))\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                // Allocate the memory.\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 0x1f), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n)\\n            let o := add(result, 0x20)\\n            mstore(o, s)\\n            mstore(add(o, n), 0)\\n            mstore(0x40, add(result, 0x40))\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
            "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DNAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkMirrorContractFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MirrorAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotMirror\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SkipNFTSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getSkipNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirrorERC721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"skipNFT\",\"type\":\"bool\"}],\"name\":\"setSkipNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
            "verified": true,
            "owner": "0x9429e4bb931c45b8d0236d17872611f74f8ccaaa",
            "creator": "0x9429e4bb931c45b8d0236d17872611f74f8ccaaa",
            "is_hidden_owner": false,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "ownership_renounced": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "is_honeypot_suspected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "blacklist_or_whitelist_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 200,
            "holders_list": {
                "0x30aa8b956a4b0ada346d5cb0e6c4b17ca457bfda": {
                    "balance": 2361706348816801202176,
                    "percentage_of_total_supply": 23.61706348816801,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x97ea97e9c5b8baa35f7ad39a23b9919a2251b100": {
                    "balance": 1535203259637172535296,
                    "percentage_of_total_supply": 15.352032596371727,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x834df5e667817f6bfa2ab059dc35c72333f040b0": {
                    "balance": 600000000000000000000,
                    "percentage_of_total_supply": 6.0,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x90767e40e82f43d0cc3b35a0e9159aa89d66e7f2": {
                    "balance": 515426333049662603264,
                    "percentage_of_total_supply": 5.154263330496626,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf8fbd685eb7f60eafbdd5944608fb190bf918ab7": {
                    "balance": 428000000000000000000,
                    "percentage_of_total_supply": 4.279999999999999,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x76bdde956164b80b09963aa5fba5dfdd51dd5d1f": {
                    "balance": 309000000000000000000,
                    "percentage_of_total_supply": 3.09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4ecdec1c8746534a57c625bb6abd21594ad1e9de": {
                    "balance": 301006850685639852032,
                    "percentage_of_total_supply": 3.0100685068563986,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x374534de1dfd0b0f965600d887f452f7035ea08b": {
                    "balance": 201500000000000000000,
                    "percentage_of_total_supply": 2.015,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4a8ab8f9e8e2b23f86eb12688d71e260060f1d4e": {
                    "balance": 197501508491973296128,
                    "percentage_of_total_supply": 1.9750150849197328,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x984c5d268b220784e87fbe8edbb5c6b9f7ba9fc4": {
                    "balance": 149154727048001257472,
                    "percentage_of_total_supply": 1.4915472704800126,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2a3e5508c8f0d1fa7c3e33df1a0b4ea692977a87": {
                    "balance": 146590284958862852096,
                    "percentage_of_total_supply": 1.4659028495886284,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf0f7f632b7193c27e27183b1d6e8db9e2a107b3a": {
                    "balance": 116000000000000000000,
                    "percentage_of_total_supply": 1.16,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x05e78da45263e36b88a95ba6f938b9418530dae0": {
                    "balance": 90000000000000000000,
                    "percentage_of_total_supply": 0.8999999999999999,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xb59bd0f95268b52bfa553525e1ea76b2423b71f5": {
                    "balance": 72388108753560756224,
                    "percentage_of_total_supply": 0.7238810875356075,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5e54279af83ad9f56bba947204d1cef617c689dc": {
                    "balance": 71306919257612255232,
                    "percentage_of_total_supply": 0.7130691925761226,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc48d912c6596a0138e058323fd9929209a66cfd8": {
                    "balance": 69000000000000000000,
                    "percentage_of_total_supply": 0.69,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbd336b75d1beed3c33296292c5ef1057fd5d3b47": {
                    "balance": 63847493270907002880,
                    "percentage_of_total_supply": 0.6384749327090701,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7e744b70a3bc965a5c127ad63a98aa2393466984": {
                    "balance": 60788649783297908736,
                    "percentage_of_total_supply": 0.6078864978329791,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x645044ac0e7e3cd1ba3d83aa6badba0dca6234b9": {
                    "balance": 51000000064466083840,
                    "percentage_of_total_supply": 0.5100000006446609,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6f5ce4039a89915aede563c6952870105477bdbc": {
                    "balance": 50858137506010832896,
                    "percentage_of_total_supply": 0.5085813750601084,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc71fcd7b8db747b2db06d17955d89a749e5f81f6": {
                    "balance": 50239975638603571200,
                    "percentage_of_total_supply": 0.5023997563860357,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf81b0304c9f29ecd3bee025d33df1e0d244bd727": {
                    "balance": 47568036047878610944,
                    "percentage_of_total_supply": 0.4756803604787861,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe12ccb3a894e748ba5bbc957660663d846189c25": {
                    "balance": 47000000000000000000,
                    "percentage_of_total_supply": 0.47000000000000003,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd2875d12a5b4990c683aba0da09f81896082f922": {
                    "balance": 45041718722143313920,
                    "percentage_of_total_supply": 0.45041718722143315,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1ed32639c95053d6d63b2d923a04faaa8f649a55": {
                    "balance": 41000000000000000000,
                    "percentage_of_total_supply": 0.41000000000000003,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6b6ca48da27304eeeb1d15d355d948f68b852733": {
                    "balance": 38500000000000000000,
                    "percentage_of_total_supply": 0.385,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x59ea3fcce97f50f44d2fe92c8eb52850cb96a1fd": {
                    "balance": 37000000000000000000,
                    "percentage_of_total_supply": 0.37,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7bb68d56ec7a33749acc75ba2308b67e0dbf1c78": {
                    "balance": 36006977922143272960,
                    "percentage_of_total_supply": 0.36006977922143274,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6f4fdfdf5fddfb5de2e14a38feb9df16b2819223": {
                    "balance": 36000000000000000000,
                    "percentage_of_total_supply": 0.36,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfef6c09dde2cda0fe6db04f02384016d9842edfc": {
                    "balance": 34484536461455372288,
                    "percentage_of_total_supply": 0.34484536461455373,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x375538f22dac68f99311a730419a2637f72cc398": {
                    "balance": 33741394112985186304,
                    "percentage_of_total_supply": 0.33741394112985185,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf9b205640ab5a45762b3e3a2a29ce0b56d941533": {
                    "balance": 33571947522503204864,
                    "percentage_of_total_supply": 0.33571947522503204,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8254658d9cde2c270afb03374f0fa5a415592894": {
                    "balance": 31113810285563535360,
                    "percentage_of_total_supply": 0.3111381028556353,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5327145780d29de9373b314088ea27450702ef0f": {
                    "balance": 30000000000000000000,
                    "percentage_of_total_supply": 0.3,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xeb26a5b3e8ab9f24ccc8a05a4299f3d6acc5dcc1": {
                    "balance": 28000000000000000000,
                    "percentage_of_total_supply": 0.27999999999999997,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf0a1003ec54bd889ba3cf22fe0179a32f51affd8": {
                    "balance": 27000000000000000000,
                    "percentage_of_total_supply": 0.27,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdc6795abcdc9a1a69115f806189f7955dfffd115": {
                    "balance": 25373126004020961280,
                    "percentage_of_total_supply": 0.2537312600402096,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd1e8fd37e062b2337dac47e823115d3810f9f55a": {
                    "balance": 25218552981553045504,
                    "percentage_of_total_supply": 0.25218552981553044,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x49904a5e936be031f7879102e070e305dc3563e9": {
                    "balance": 25000000000000000000,
                    "percentage_of_total_supply": 0.25,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfb78e40e8c6f8a02df319f6524b66a814b804d49": {
                    "balance": 25000000000000000000,
                    "percentage_of_total_supply": 0.25,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x57b9033b0b6813c58ef10459df8f4d68ae47329a": {
                    "balance": 25000000000000000000,
                    "percentage_of_total_supply": 0.25,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8b864ea84b4f6b2dbd2f3eb16db5920071c823b7": {
                    "balance": 24955480518029185024,
                    "percentage_of_total_supply": 0.24955480518029186,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc640090dd17970456e5592af08e6d3d3fa5749e9": {
                    "balance": 24214905782314708992,
                    "percentage_of_total_supply": 0.2421490578231471,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x934efd8f5d06be98ea69d9d680c62fb50bbe01cf": {
                    "balance": 24058580774158192640,
                    "percentage_of_total_supply": 0.24058580774158192,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x79726f70487d78a38cc8ed708749986bf5daec0a": {
                    "balance": 22098252526102831104,
                    "percentage_of_total_supply": 0.22098252526102832,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe511c7774e41300cf4dc898f3fe1916ffe746a68": {
                    "balance": 19484131483652726784,
                    "percentage_of_total_supply": 0.19484131483652728,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2ed3e1467caf57759b17808c8f76b104cdc9e03c": {
                    "balance": 18000000000000000000,
                    "percentage_of_total_supply": 0.18,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xba0c18277a5b2fc5526365c44b1ffa16023dd09d": {
                    "balance": 17997667133535817728,
                    "percentage_of_total_supply": 0.17997667133535816,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x02c2dc242a1117dcf5930f26600b1ddb0b9cda95": {
                    "balance": 17088875238009513984,
                    "percentage_of_total_supply": 0.17088875238009515,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x663f812d12daf6c8ddb01e0d709492131b8c9b3d": {
                    "balance": 16734676413514422272,
                    "percentage_of_total_supply": 0.16734676413514424,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcbf6c1298eada251ba01023426914d6ba1a72e9b": {
                    "balance": 16289311961813837824,
                    "percentage_of_total_supply": 0.16289311961813838,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcd47341a89411f6cdf14ffe909b94084a216bf55": {
                    "balance": 16189004060756475904,
                    "percentage_of_total_supply": 0.16189004060756476,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x04bda42de3bc32abb00df46004204424d4cf8287": {
                    "balance": 15740608704009482240,
                    "percentage_of_total_supply": 0.15740608704009484,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa05750e98d2fcf8b6ff28c7ba3c22d65ef1a407a": {
                    "balance": 15533851579204782080,
                    "percentage_of_total_supply": 0.15533851579204783,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4c014cdc43cff32f58224d7177a7e63b779dea97": {
                    "balance": 15385118662742464512,
                    "percentage_of_total_supply": 0.15385118662742464,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0cf3d0915b65f7b3360844c4c44883aca881d1f5": {
                    "balance": 15038582876349155328,
                    "percentage_of_total_supply": 0.15038582876349155,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbb7436cec9f07e024220f175ed7fb2b151e3d0f5": {
                    "balance": 14636972662896527360,
                    "percentage_of_total_supply": 0.14636972662896527,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9519d2aafc4fd42192e757b4fddb0c234b5532f1": {
                    "balance": 14217679169346514944,
                    "percentage_of_total_supply": 0.14217679169346514,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7280a0ba35f611a2cc65ef63e59dac4a5a558171": {
                    "balance": 13627713973124726784,
                    "percentage_of_total_supply": 0.13627713973124728,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xebaebceafd51e878bfaa2d8ab59818338059c2f2": {
                    "balance": 13290212687744606208,
                    "percentage_of_total_supply": 0.13290212687744607,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcca083c80eea0033e1f897402e3959be8547d372": {
                    "balance": 13000000000000000000,
                    "percentage_of_total_supply": 0.13,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x698663063293d4a7d0a9b757116e1ba2d14b5028": {
                    "balance": 12895609930083545088,
                    "percentage_of_total_supply": 0.12895609930083546,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xee698037cbb563c23e2045dfaec98ead9ef846ec": {
                    "balance": 12790166884464537600,
                    "percentage_of_total_supply": 0.12790166884464538,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9daec7c962d9808c710ffb8996e03b64f84a60d7": {
                    "balance": 12750000000000000000,
                    "percentage_of_total_supply": 0.1275,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa5b499da8244acabc29e0caa5f4cc65b17d51406": {
                    "balance": 12344951575877177344,
                    "percentage_of_total_supply": 0.12344951575877178,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7aaf7b9f55ffe8fcafc2da5baa6721363a4306fc": {
                    "balance": 12228607197690738688,
                    "percentage_of_total_supply": 0.12228607197690738,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd957db2cca68db9763859de35cd352e919bc5b88": {
                    "balance": 12086411272352247808,
                    "percentage_of_total_supply": 0.12086411272352249,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x09020cf073eac09c9c6d63166a482d0a75137fd5": {
                    "balance": 12000000000000000000,
                    "percentage_of_total_supply": 0.12,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc8037f5b03bae71714eb7d8f225866398f3a6d75": {
                    "balance": 12000000000000000000,
                    "percentage_of_total_supply": 0.12,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x60463f5bdd45fe000b9730c10b8568e46cbd06f6": {
                    "balance": 11905143646409869312,
                    "percentage_of_total_supply": 0.11905143646409869,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x446504819a921736ef5dd034d2c9e45bb698fcef": {
                    "balance": 11899300976288026624,
                    "percentage_of_total_supply": 0.11899300976288027,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd4ec223c6fe65fe62d4e58a46c83bc880a0cbf74": {
                    "balance": 11713182148571248640,
                    "percentage_of_total_supply": 0.1171318214857125,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1884e47c3b735a9c8ec44325dc15b5c299d03613": {
                    "balance": 11390267467368402944,
                    "percentage_of_total_supply": 0.11390267467368403,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x37ba2355ad5059f71b7c4389bff3aa726d467e40": {
                    "balance": 11099957699418929152,
                    "percentage_of_total_supply": 0.11099957699418929,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x55dfeb4b375c95efff8e191f538f0322d0d31809": {
                    "balance": 11085885008244359168,
                    "percentage_of_total_supply": 0.11085885008244359,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x48b62c3e5c0027a214c64f7d69a2201639e7b426": {
                    "balance": 11000000000000000000,
                    "percentage_of_total_supply": 0.11,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf12e2ea6eaeded185502afcb72fcd2668fdf8eb4": {
                    "balance": 10738879481120493568,
                    "percentage_of_total_supply": 0.10738879481120493,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xabd8c0136815980413821031e3ab24eb56cdb12c": {
                    "balance": 10476313624087175168,
                    "percentage_of_total_supply": 0.10476313624087175,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xda6068e204f500be8ddaf58f48e71761f5aeb3d8": {
                    "balance": 10363382799845072896,
                    "percentage_of_total_supply": 0.10363382799845072,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x09e0c63f1cddc2b60ceb65e9782c8ca9da9bac57": {
                    "balance": 10266025437226379264,
                    "percentage_of_total_supply": 0.10266025437226381,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x480dce73d6c9137934fa690f1f2aab68b8614ad5": {
                    "balance": 10042011610105690112,
                    "percentage_of_total_supply": 0.10042011610105689,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x03e28314ad54cead6a1c719c52d862935c3ad663": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.1,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x147d79f1c9244b85cba959262fb71ad38069febb": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.1,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xda8b43d5da504a3a418aeedce1ece868536807fa": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.1,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2db8c0d207033f8e48067115b9b9a30be7556f7e": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 0.1,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x983edb2c9a31c2549fb8d8b33b5724a85ae99423": {
                    "balance": 9999968201914562560,
                    "percentage_of_total_supply": 0.09999968201914562,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x21f292633031113759d34904b37eae27cd000000": {
                    "balance": 9833219884251727872,
                    "percentage_of_total_supply": 0.09833219884251727,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x486c7a6785188fc0ebef7a740d2526c24c1a2056": {
                    "balance": 9748604661731565568,
                    "percentage_of_total_supply": 0.09748604661731565,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x51da89fc9b723fa88c8fb6b56efbd42e7b080875": {
                    "balance": 9502630911808968704,
                    "percentage_of_total_supply": 0.09502630911808968,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf3b6b0f2b4cc6c05146cdcb1466e9e1140f92c55": {
                    "balance": 9045399340642379776,
                    "percentage_of_total_supply": 0.0904539934064238,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc43aef91953c4d6716ef60e02e6eafb596ec9e03": {
                    "balance": 9000000000000000000,
                    "percentage_of_total_supply": 0.09,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc795af5e5faab22c8c17ba8b5383ff25e601af64": {
                    "balance": 8500000000000000000,
                    "percentage_of_total_supply": 0.08499999999999999,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe75502ecc75e1baf37dd65251e547613c5137307": {
                    "balance": 8190722930762729472,
                    "percentage_of_total_supply": 0.08190722930762728,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x82c2bcefebd9d59b321d5d1d935e217fb1d1a990": {
                    "balance": 8150638404627318784,
                    "percentage_of_total_supply": 0.08150638404627318,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x23b921b4e3993c492b35ea463c47ee251bc6b1c8": {
                    "balance": 8048917304642656256,
                    "percentage_of_total_supply": 0.08048917304642657,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe1a520d08e153692c203321a6dc6d2d8e3b647f9": {
                    "balance": 8000000000000000000,
                    "percentage_of_total_supply": 0.08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7f1dd28cdfe779582578d387f9cc65f8a4e535ce": {
                    "balance": 8000000000000000000,
                    "percentage_of_total_supply": 0.08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x86bfb79503460a7b6a9c111ac5d8c6ae28a1acbb": {
                    "balance": 8000000000000000000,
                    "percentage_of_total_supply": 0.08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbc5c45ff59dc92cd848a7c0adb5de30ac41c956f": {
                    "balance": 8000000000000000000,
                    "percentage_of_total_supply": 0.08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa8221ec7d72d1edd5d4bbadda0375f018572a22e": {
                    "balance": 8000000000000000000,
                    "percentage_of_total_supply": 0.08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xed1781c7ca946a97bd87437bb9bbd296f4f4c33e": {
                    "balance": 7917178708191096832,
                    "percentage_of_total_supply": 0.07917178708191097,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0d2bee6c2214bf9617c5a9ff3720264be055fb63": {
                    "balance": 7746044056759820288,
                    "percentage_of_total_supply": 0.0774604405675982,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa869cf3aeed80c2f800d6de265eb8cd4eac7ea4e": {
                    "balance": 7494811311620532224,
                    "percentage_of_total_supply": 0.07494811311620532,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x25d1bf803f77d7639bf8b4af7ac8c1d64759e777": {
                    "balance": 7492771803592881152,
                    "percentage_of_total_supply": 0.0749277180359288,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3feb9298170a751e4e6c81195912fb6a5784139c": {
                    "balance": 7458728090802839552,
                    "percentage_of_total_supply": 0.0745872809080284,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe76dca15b6435ec60140eb06e74261f098425ed1": {
                    "balance": 7068887285116233728,
                    "percentage_of_total_supply": 0.07068887285116233,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x71334c1ba5c475fb0965de3f975e0fc8bb079a23": {
                    "balance": 7059064667847751680,
                    "percentage_of_total_supply": 0.07059064667847752,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x05a4448597935c508e4ad0d2cf56d56bedb246ce": {
                    "balance": 7016615478451144704,
                    "percentage_of_total_supply": 0.07016615478451145,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa4ca04fe74e81732063c3490a46399349b61aa55": {
                    "balance": 6992621148805655552,
                    "percentage_of_total_supply": 0.06992621148805656,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe2d5fbae83a8239189e13fb44aab5ae130f09f5b": {
                    "balance": 6960265635102029824,
                    "percentage_of_total_supply": 0.0696026563510203,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x000000fee13a103a10d593b9ae06b3e05f2e7e1c": {
                    "balance": 6821872398441305088,
                    "percentage_of_total_supply": 0.06821872398441305,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x31511dd8d86db53c3d6df7aa1a4b7582405a006b": {
                    "balance": 6674668584285023232,
                    "percentage_of_total_supply": 0.06674668584285023,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xaac6ce2fe6b7c56b1e135b14da9f1b2be0485083": {
                    "balance": 6607853120786016256,
                    "percentage_of_total_supply": 0.06607853120786017,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x02947b1f9818d68f906b1767842aaa09fdb5e2e1": {
                    "balance": 6572914123824615424,
                    "percentage_of_total_supply": 0.06572914123824616,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4190933181132e7f11d6566d96e31d51497c3c10": {
                    "balance": 6388399240292237312,
                    "percentage_of_total_supply": 0.06388399240292238,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9008d19f58aabd9ed0d60971565aa8510560ab41": {
                    "balance": 6194782688722695168,
                    "percentage_of_total_supply": 0.06194782688722695,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xff2fc046cb25331971769dbe7c7796f67f4f1e07": {
                    "balance": 6088967821612421120,
                    "percentage_of_total_supply": 0.060889678216124205,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x5966e242a8a9ed2c6e064ea7f6523c24177e7efa": {
                    "balance": 6063169815049963520,
                    "percentage_of_total_supply": 0.06063169815049964,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x22bd4182718edccf26717e6847d8e9eb17d3d049": {
                    "balance": 6058754265536401408,
                    "percentage_of_total_supply": 0.060587542655364014,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x62aaf3bbaeb7e299fda0f7d2812692b6769af0c9": {
                    "balance": 6053456018731301888,
                    "percentage_of_total_supply": 0.06053456018731302,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4ed5a8d05364c226967db66f30962ef59096d042": {
                    "balance": 6046454601893069824,
                    "percentage_of_total_supply": 0.060464546018930705,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd014f6760c662c407d5c9d3bf65039c0742f8982": {
                    "balance": 6000000000000004096,
                    "percentage_of_total_supply": 0.06000000000000004,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3b3251ebeeee7484cfe04e80acd4869ab0a113bc": {
                    "balance": 6000000000000000000,
                    "percentage_of_total_supply": 0.06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa838fa36f61e82971fe92afa07cd35a0cab8c691": {
                    "balance": 6000000000000000000,
                    "percentage_of_total_supply": 0.06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe02c799cd00bae35fb05d294dbcc8b834df4fab0": {
                    "balance": 5500000000000000000,
                    "percentage_of_total_supply": 0.055,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc9cb86b2c2c1b1a2625e7f901288dc63c9e34152": {
                    "balance": 5500000000000000000,
                    "percentage_of_total_supply": 0.055,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa85c8cba5fcb69616158b071e7ddad61a243692e": {
                    "balance": 5500000000000000000,
                    "percentage_of_total_supply": 0.055,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcf5ab63a93dcbdd9bd46128cdeb7b4d8c760da67": {
                    "balance": 5230379822650334208,
                    "percentage_of_total_supply": 0.052303798226503335,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4497714fb2df95b104d568877b994e10153f8f14": {
                    "balance": 5203009568770423808,
                    "percentage_of_total_supply": 0.05203009568770423,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe62da247ecd63a812f10d87d06819645e823fcad": {
                    "balance": 5173690915252198400,
                    "percentage_of_total_supply": 0.051736909152521986,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8df41db2282b455e9768a927ff22f2c65ad5c55d": {
                    "balance": 5069714569382812672,
                    "percentage_of_total_supply": 0.05069714569382813,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd77c6bb30cee69c435948709838eb99d60b33bf2": {
                    "balance": 5040373214112342016,
                    "percentage_of_total_supply": 0.05040373214112341,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa7a980c91efc570a8cf3835e93eb1f042abff1cc": {
                    "balance": 5010000000000000000,
                    "percentage_of_total_supply": 0.050100000000000006,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfd6d28ed53ce7a6114d06f54927f697b14c857db": {
                    "balance": 5005920010767715328,
                    "percentage_of_total_supply": 0.05005920010767715,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x53b4fb24d2f509a0643a9089c7e7a68011f93118": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x994cc164ddb6d6fdbda640d7998a593e78b0001f": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x064d225d3313182aaf635b4b1167a3e2882c18a5": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1010d6626677ec3ef5c88fbfe9c4d62cdd04cccf": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x84f8ab5504af184c64e1024863cff5e24d7a53ae": {
                    "balance": 5000000000000000000,
                    "percentage_of_total_supply": 0.05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe8ffc48dc2c0436eb07f0b8badd24a8bbc6ba9fb": {
                    "balance": 4936202885651558400,
                    "percentage_of_total_supply": 0.04936202885651559,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x90bb1daa4150a27b2328a1f630a874301aa232b8": {
                    "balance": 4835000000000000000,
                    "percentage_of_total_supply": 0.04835,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1693414cfbc6ac17e3a8b74f63be480fb8732db0": {
                    "balance": 4571832554437194240,
                    "percentage_of_total_supply": 0.04571832554437194,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7a262c8b3896b994ddef9b42605adf6644b78c18": {
                    "balance": 4371827522407044608,
                    "percentage_of_total_supply": 0.043718275224070444,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa72dd288b659c8f9c8279751b25af28a2b4e631a": {
                    "balance": 4266014826229296640,
                    "percentage_of_total_supply": 0.04266014826229297,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x79b10883c20efa4eac55c60f98499126adda2377": {
                    "balance": 4206005299475874304,
                    "percentage_of_total_supply": 0.04206005299475874,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4a8d0ef4e0fcf7e8e8a5e7dae69b0de66a760470": {
                    "balance": 4200161346101963776,
                    "percentage_of_total_supply": 0.04200161346101964,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf3d9281fa183b74f32b96e1c5244596045f4ede8": {
                    "balance": 4184553622722966016,
                    "percentage_of_total_supply": 0.04184553622722966,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8c76e1f978ffc54c3b5ba1821193b190893a8ccd": {
                    "balance": 4027122763848249856,
                    "percentage_of_total_supply": 0.040271227638482496,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x082fde4bf7b73e7364fe53257cef92a431f2362c": {
                    "balance": 4000000000000061952,
                    "percentage_of_total_supply": 0.04000000000000062,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc1a958e09203fccd713ebe26552032d30193a098": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7b786c1a21f9be8ce1c2e107c86a5ccde52ca902": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdff34fce6628353995be019187a6905b38846061": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6898d2ddcf395ce724c430329b3c1ae489431572": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1bce0701f553594189bbeed07a230bf88a74e7a8": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x01f19e970a1253230b23c7657b4799ef22a6b62f": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xee74363938c9e3093d2de39b23e9744a74689b8b": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd5f5902901bbe4221c633a4a491a21ab7e4ac091": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdae9cd51da204a57f67ceb75bdd7071b365d8df3": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x073b89283c06c1eb3c4b4fdc6bcb337ef7cbb077": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xf88ec8634909875a662a1416981ce16b6c8f3b22": {
                    "balance": 4000000000000000000,
                    "percentage_of_total_supply": 0.04,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7cb158d3afe100d7bb4933cb5b4c5b16f5ef937b": {
                    "balance": 3996426572313518592,
                    "percentage_of_total_supply": 0.03996426572313519,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x40903584f46e4e59a16f726deb2f3088ff7d6306": {
                    "balance": 3975445377744363008,
                    "percentage_of_total_supply": 0.03975445377744363,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x11cb3e89afd44626ee7671f8abda53e8cd817f82": {
                    "balance": 3966650295422577152,
                    "percentage_of_total_supply": 0.039666502954225774,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x40e0b0de47588cb688cd7b8f4887e934ee45e3e6": {
                    "balance": 3788747404703116800,
                    "percentage_of_total_supply": 0.03788747404703117,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa89c876be69223295a0925d7a62cb6868dec4ac8": {
                    "balance": 3730527088781299200,
                    "percentage_of_total_supply": 0.03730527088781299,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfdcfb6e689a9c021f9d74a519fccf80718398c5e": {
                    "balance": 3533842408771675136,
                    "percentage_of_total_supply": 0.03533842408771675,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x62ad941e4a1e7cf16150972ea8ba315737a5f390": {
                    "balance": 3522940962477438976,
                    "percentage_of_total_supply": 0.03522940962477439,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3269ab03fe74c05947e7cc25154d06af6966eb98": {
                    "balance": 3500000000000000000,
                    "percentage_of_total_supply": 0.034999999999999996,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1166ae53a4d8779532260dfdd84dc065bcc5b1a4": {
                    "balance": 3500000000000000000,
                    "percentage_of_total_supply": 0.034999999999999996,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xdc57f61232f456e201e55162c51134e7e84088a5": {
                    "balance": 3500000000000000000,
                    "percentage_of_total_supply": 0.034999999999999996,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x94e668252ff49ae32a2e07a03df6ed43f2c2eb70": {
                    "balance": 3332675578172790784,
                    "percentage_of_total_supply": 0.033326755781727904,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x965f2225bc4657ad9e1a892e6299db312f2d5588": {
                    "balance": 3305849850359238656,
                    "percentage_of_total_supply": 0.03305849850359238,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc1b133d122bc08497797de006a91e4f45644c272": {
                    "balance": 3257763299400072704,
                    "percentage_of_total_supply": 0.03257763299400073,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfd29443f1ac0ae64f6a6cd228d3fc0826580654a": {
                    "balance": 3200000000000000000,
                    "percentage_of_total_supply": 0.032,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfa7d670302fb7629e968e20cecbc6be498f788bf": {
                    "balance": 3146335332010617856,
                    "percentage_of_total_supply": 0.03146335332010618,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x202ffccd386b6cf95de0a47b036f1e98be480e0d": {
                    "balance": 3104674933371276800,
                    "percentage_of_total_supply": 0.03104674933371277,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x723ce602c7e8ca6f8a5420a490d70f9498bf3cef": {
                    "balance": 3100000000000000000,
                    "percentage_of_total_supply": 0.031,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3ede9d710a53f61585cc815f212a33f39d7118ee": {
                    "balance": 3040529944884557312,
                    "percentage_of_total_supply": 0.030405299448845576,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xbdabc66f5996b75fde2e26a2c7bc124c989f06ee": {
                    "balance": 3033627191624610304,
                    "percentage_of_total_supply": 0.0303362719162461,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd28e5ddbc4c7f8651bbed08083b9d5bd21473cff": {
                    "balance": 3024046316048838656,
                    "percentage_of_total_supply": 0.03024046316048839,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xaae4a7258e81d49aebaeb3b364e7342376786883": {
                    "balance": 3004499807791675904,
                    "percentage_of_total_supply": 0.030044998077916756,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1e957a10796552cbd7d5c31439a5e8345db569a4": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x78815067c3926cc33f7790d87460bec779f42d4d": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc1e5f8f617e52d3ec2acdb39f71bad1416568904": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x98d39ad8c4d6a852921f30eb734c36fcc4f7acc9": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xcdf633e4365cd3b7d67df122721e5746eae4a98b": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x622d3419d4b452a239b3d1068cdae96d8617dcd7": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa571e25149bf5026336e165e6f1b6b9d8f03fc97": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x06e340ae19612b68fc1115c3cdd5b2859a4ca65d": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x8ecc8dd60239aa4dae948d1b41f23aea03e724b7": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xee97809d32d791849b445e8397abcfaccfa40ffb": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe317c793ebc9d4a3732ca66e5a8fc4ffc213b989": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xd0bff38f017462c72bf1895340a6803734e331a6": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7d689b8ba22ef84be2eede08f9f28a84ec587770": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x0bc25ffa6a0a383b427e542226daf9ef72f54c02": {
                    "balance": 3000000000000000000,
                    "percentage_of_total_supply": 0.03,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x2fae74cf06a60d3940fbcf6176dca2ed200da8cd": {
                    "balance": 2963447814444775424,
                    "percentage_of_total_supply": 0.02963447814444775,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x91709062a5a7aae7271178b668e78319de8241f3": {
                    "balance": 2915000000000000000,
                    "percentage_of_total_supply": 0.02915,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1f916bbf39ab189a9e3d9e1823a7b1a8e9e5f204": {
                    "balance": 2839263204987176448,
                    "percentage_of_total_supply": 0.02839263204987176,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xab2d8c6168d14cb27f6c0b5c0a8ffd1d585be558": {
                    "balance": 2836777721322330624,
                    "percentage_of_total_supply": 0.028367777213223307,
                    "percentage_of_circulating_supply": 0.0
                }
            },
            "total_supply": 10000000000000000000000,
            "total_circulating_supply": 0.0,
            "owner": {
                "address": "0x9429e4bb931c45b8d0236d17872611f74f8ccaaa",
                "balance": 457020794386551406592,
                "percentage_of_supply": 0.0,
                "exceeds_5_percent": false
            },
            "creator": {},
            "holders_exceeding_5_percent": [],
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": [
                {
                    "address": "0x30aa8b956a4b0ada346d5cb0e6c4b17ca457bfda",
                    "balance": 2361706348816801202176,
                    "percentage_of_total_supply": 23.61706348816801,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x97ea97e9c5b8baa35f7ad39a23b9919a2251b100",
                    "balance": 1535203259637172535296,
                    "percentage_of_total_supply": 15.352032596371727,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x834df5e667817f6bfa2ab059dc35c72333f040b0",
                    "balance": 600000000000000000000,
                    "percentage_of_total_supply": 6.0,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x90767e40e82f43d0cc3b35a0e9159aa89d66e7f2",
                    "balance": 515426333049662603264,
                    "percentage_of_total_supply": 5.154263330496626,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x9429e4bb931c45b8d0236d17872611f74f8ccaaa",
                    "balance": 457020794386551406592,
                    "percentage_of_total_supply": 4.570207943865514,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xf8fbd685eb7f60eafbdd5944608fb190bf918ab7",
                    "balance": 428000000000000000000,
                    "percentage_of_total_supply": 4.279999999999999,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x76bdde956164b80b09963aa5fba5dfdd51dd5d1f",
                    "balance": 309000000000000000000,
                    "percentage_of_total_supply": 3.09,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x4ecdec1c8746534a57c625bb6abd21594ad1e9de",
                    "balance": 301006850685639852032,
                    "percentage_of_total_supply": 3.0100685068563986,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x374534de1dfd0b0f965600d887f452f7035ea08b",
                    "balance": 201500000000000000000,
                    "percentage_of_total_supply": 2.015,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x4a8ab8f9e8e2b23f86eb12688d71e260060f1d4e",
                    "balance": 197501508491973296128,
                    "percentage_of_total_supply": 1.9750150849197328,
                    "percentage_of_circulating_supply": 0
                }
            ],
            "total_top_10_balance": 6906365095067800895488,
            "top10_percentage_of_total_supply": 69.06365095067801,
            "top10_percentage_of_circulating_supply": 0,
            "top_10_less_than_70_percent_of_total": true,
            "top_10_less_than_70_percent_of_circulating": true
        },
        "liquidity": {
            "price_usd": 2.673576169040403,
            "liquidity_usd": 8208.965699198183,
            "market_cap_usd": 0.0,
            "liquidity_to_market_cap_ratio": 0,
            "token_volume": 0.0,
            "volume_usd": 0.0,
            "volume_to_liquidity_ratio": 0.0,
            "locked_liquidity_percent": 99.0,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 4.5702,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 4.5702,
            "total_lp_supply": 34.16934481373619,
            "lp_holders_count": 3,
            "lp_holders": [
                {
                    "address": "0x663a5c229c09b049e36dcc11a9b0d4a8eb9db214",
                    "balance": 33.827651365598825,
                    "is_locked": true,
                    "percent": 0.99,
                    "tag": "UNCX"
                },
                {
                    "address": "0xd45dd91df475bfd944335160f538c1a14888dc1c",
                    "balance": 0.34169344813736185,
                    "is_locked": false,
                    "percent": 0.009999999999999998,
                    "tag": ""
                },
                {
                    "address": "0x0000000000000000000000000000000000000000",
                    "balance": 1e-15,
                    "is_locked": true,
                    "percent": 2.9e-17,
                    "tag": "Null Address"
                }
            ],
            "error": "Liquidity pool info could not be retrieved."
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://shadowladys.xyz/api/token/\\": "metamask recovery phrase phishing",
                "https://eips.ethereum.org/EIPS/eip-165\\n": "metamask recovery phrase phishing",
                "https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n///": "metamask recovery phrase phishing",
                "https://eips.ethereum.org/EIPS/eip-173)": "metamask recovery phrase phishing",
                "https://eips.ethereum.org/EIPS/eip-173),\\n": "metamask recovery phrase phishing",
                "https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n///": "metamask recovery phrase phishing",
                "https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n///": "metamask recovery phrase phishing",
                "https://eips.ethereum.org/EIPS/eip-55\\n": "metamask recovery phrase phishing",
                "https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n///": "metamask recovery phrase phishing",
                "https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n///": "metamask recovery phrase phishing",
                "https://eips.ethereum.org/EIPS/eip-4758.\\n": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 11,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 47873496.1632,
            "token_creation_date": "2024-02-13T21:53:23",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x5a9a4c8376f8f0f88b8fb8b6aa5176f61910f142b2247503b0240ea6304c6f68",
            "last_active_age": "2025-08-14T23:19:11",
            "inactive_days": 6.031836408113426
        }
    },
    "errors": []
}