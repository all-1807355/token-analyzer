{
    "token_address": "0x8f0fb159380176d324542b3a7933f0c2fd0c2bbf",
    "chain": "bsc",
    "token_name": "TFT on BSC",
    "analyses": {
        "contract": {
            "contract_name": "Proxy",
            "compiler_version": "v0.8.4+commit.c7e474f2",
            "license_type": "Apache-2.0",
            "implementation": "0xe160c705696f89277d06f26215a799bb068f61cb",
            "source_code": "{\"owned.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./storage.sol\\\";\\n\\ncontract Owned is Storage {\\n    \\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // mapping(address =\\u003e bool) public owner;\\n\\n    // -----------------------------------------------------\\n    // Events\\n    // -----------------------------------------------------\\n\\n    event AddedOwner(address newOwner);\\n    event RemovedOwner(address removedOwner);\\n\\n    // -----------------------------------------------------\\n    // storage utilities\\n    // -----------------------------------------------------\\n\\n    function _isOwner(address _caller) internal view returns (bool) {\\n        return getBool(keccak256(abi.encode(\\\"owner\\\",_caller)));\\n    }\\n\\n    function _addOwner(address _newOwner) internal {\\n        // Add owner to list\\n        address[] storage owners = getOwners();\\n        owners.push(_newOwner);\\n        setOwners(owners);\\n\\n        // Set owner bool in storage\\n        setBool(keccak256(abi.encode(\\\"owner\\\", _newOwner)), true);\\n    }\\n\\n    function _deleteOwner(address _owner) internal {\\n        // Remove owner from list\\n        address[] storage owners = getOwners();\\n        for (uint i=0; i\\u003cowners.length - 1; i++)\\n            if (owners[i] == _owner) {\\n                owners[i] = owners[owners.length - 1];\\n                break;\\n            }\\n        owners.pop();\\n        setOwners(owners);\\n\\n        // Delete owner bool from storage\\n        deleteBool(keccak256(abi.encode(\\\"owner\\\", _owner)));\\n    }\\n\\n    function setOwners(address[] storage _addresses) internal {\\n        setAddresses(keccak256(abi.encode(\\\"owners\\\")), _addresses);\\n    }\\n\\n    function getOwners() internal view returns (address[] storage) {\\n        return getAddresses(keccak256(abi.encode(\\\"owners\\\")));\\n    }\\n\\n    // -----------------------------------------------------\\n    // Main contract\\n    // -----------------------------------------------------\\n\\n    constructor() {\\n        _addOwner(msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_isOwner(msg.sender));\\n        _;\\n    }\\n\\n    function addOwner(address _newOwner) onlyOwner public {\\n        require(!_isOwner(_newOwner));\\n        require(_newOwner != address(0));\\n        _addOwner(_newOwner);\\n        emit AddedOwner(_newOwner);\\n    }\\n\\n    function removeOwner(address _toRemove) onlyOwner public {\\n        require(_isOwner(_toRemove));\\n        require(_toRemove != address(0));\\n        require(_toRemove != msg.sender);\\n        _deleteOwner(_toRemove);\\n        emit RemovedOwner(_toRemove);\\n    }\\n\\n    function owners_list() public view returns (address[] memory) {\\n        return getOwners();\\n    }\\n\\n    function is_owner(address owner) public view returns (bool) {\\n        return _isOwner(owner);\\n    }\\n}\"},\"owned_upgradeable_token_storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./token_storage.sol\\\";\\nimport \\\"./upgradeable.sol\\\";\\n\\ncontract OwnedUpgradeableTokenStorage is TokenStorage, Upgradeable {}\"},\"proxy.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./token_storage.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\n// inherit from TokenStorage so we have the constructor, since the token variables need to be stored in the\\n// proxy\\u0027s storage\\ncontract Proxy is TokenStorage, Owned {\\n    fallback () external payable {\\n        // directly get the implementation contract address from the storage. This way we don\\u0027t need to depend\\n        // on the upgradeable contract\\n        address _impl = getAddress(keccak256(abi.encode(\\\"implementation\\\")));\\n        require(_impl != address(0), \\\"The implementation address can\\u0027t be the zero address\\\");\\n        bytes memory data = msg.data;\\n\\n        assembly {\\n            let result := delegatecall(gas(), _impl, add(data, 0x20), mload(data), 0, 0)\\n            let size := returndatasize()\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            switch result\\n            case 0 { revert(ptr, size) }\\n            default { return(ptr, size) }\\n        }\\n    }\\n\\n    constructor() {\\n        //set initial contract address, needs to be hardcoded\\n        // TODO: Set correct address\\n        address impl_addr = address(0xE160c705696F89277d06F26215A799bb068F61CB);\\n        require(impl_addr != address(0), \\\"implementation address can not be the zero address\\\");\\n        setAddress(keccak256(abi.encode(\\\"implementation\\\")), impl_addr);\\n        setString(keccak256(abi.encode(\\\"version\\\")),\\\"0\\\");\\n\\n        // set initial owner\\n        setBool(keccak256(abi.encode(\\\"owner\\\", msg.sender)), true);\\n    }\\n}\"},\"storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ncontract Storage {\\n\\n\\n    /**** Storage Types *******/\\n\\n    mapping(bytes32 =\\u003e uint256)    private uIntStorage;\\n    mapping(bytes32 =\\u003e string)     private stringStorage;\\n    mapping(bytes32 =\\u003e address)    private addressStorage;\\n    mapping(bytes32 =\\u003e address[])  private addressesStorage;\\n    mapping(bytes32 =\\u003e bytes)      private bytesStorage;\\n    mapping(bytes32 =\\u003e bool)       private boolStorage;\\n    mapping(bytes32 =\\u003e int256)     private intStorage;\\n\\n    /**** Get Methods ***********/\\n\\n    /// @param _key The key for the record\\n    function getAddress(bytes32 _key) internal view returns (address) {\\n        return addressStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getAddresses(bytes32 _key) internal view returns (address[] storage) {\\n        return addressesStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getUint(bytes32 _key) internal view returns (uint) {\\n        return uIntStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getString(bytes32 _key) internal view returns (string memory) {\\n        return stringStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getBytes(bytes32 _key) internal view returns (bytes memory) {\\n        return bytesStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getBool(bytes32 _key) internal view returns (bool) {\\n        return boolStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function getInt(bytes32 _key) internal view returns (int) {\\n        return intStorage[_key];\\n    }\\n\\n\\n    /**** Set Methods ***********/\\n\\n\\n    /// @param _key The key for the record\\n    function setAddress(bytes32 _key, address _value) internal {\\n        addressStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setAddresses(bytes32 _key, address[] storage _value) internal {\\n        addressesStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setUint(bytes32 _key, uint _value) internal {\\n        uIntStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setString(bytes32 _key, string memory _value) internal {\\n        stringStorage[_key] = _value;\\n    }\\n\\n    /// @param _key The key for the record\\n    function setBytes(bytes32 _key, bytes memory _value) internal {\\n        bytesStorage[_key] = _value;\\n    }\\n    \\n    /// @param _key The key for the record\\n    function setBool(bytes32 _key, bool _value) internal {\\n        boolStorage[_key] = _value;\\n    }\\n    \\n    /// @param _key The key for the record\\n    function setInt(bytes32 _key, int _value) internal {\\n        intStorage[_key] = _value;\\n    }\\n\\n\\n    /**** Delete Methods ***********/\\n    \\n    /// @param _key The key for the record\\n    function deleteAddress(bytes32 _key) internal {\\n        delete addressStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteUint(bytes32 _key) internal {\\n        delete uIntStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteString(bytes32 _key) internal {\\n        delete stringStorage[_key];\\n    }\\n\\n    /// @param _key The key for the record\\n    function deleteBytes(bytes32 _key) internal {\\n        delete bytesStorage[_key];\\n    }\\n    \\n    /// @param _key The key for the record\\n    function deleteBool(bytes32 _key) internal {\\n        delete boolStorage[_key];\\n    }\\n    \\n    /// @param _key The key for the record\\n    function deleteInt(bytes32 _key) internal {\\n        delete intStorage[_key];\\n    }\\n\\n}\"},\"tokenV0.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./owned_upgradeable_token_storage.sol\\\";\\n\\n// ----------------------------------------------------------------------------\\n// Safe maths\\n// ----------------------------------------------------------------------------\\nlibrary SafeMath {\\n    function add(uint a, uint b) internal pure returns (uint c) {\\n        c = a + b;\\n        require(c \\u003e= a);\\n    }\\n    function sub(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003c= a);\\n        c = a - b;\\n    }\\n    function mul(uint a, uint b) internal pure returns (uint c) {\\n        c = a * b;\\n        require(a == 0 || c / a == b);\\n    }\\n    function div(uint a, uint b) internal pure returns (uint c) {\\n        require(b \\u003e 0);\\n        c = a / b;\\n    }\\n}\\n\\n// ----------------------------------------------------------------------------\\n// ERC20 Token, with the addition of a symbol, name and decimals \\n// ----------------------------------------------------------------------------\\ncontract TFT is OwnedUpgradeableTokenStorage {\\n    using SafeMath for uint;\\n\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n    // Lets mint some tokens, also index the TFT tx id\\n    event Mint(address indexed receiver, uint tokens, string indexed txid);\\n    // Burn tokens in a withdrawal, user chooses how much tokens\\n    event Withdraw(address indexed receiver, uint tokens, string blockchain_address, string network);\\n\\n    // name, symbol and decimals getters are optional per the ERC20 spec. Normally auto generated from public variables\\n    // but that is obviously not going to work for us\\n\\n    function name() public view returns (string memory) {\\n        return getName();\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return getSymbol();\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return getDecimals();\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Total supply\\n    // ------------------------------------------------------------------------\\n    function totalSupply() public view returns (uint) {\\n        return getTotalSupply().sub(getBalance(address(0)));\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Get the token balance for account `tokenOwner`\\n    // ------------------------------------------------------------------------\\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\\n        return getBalance(tokenOwner);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer the balance from token owner\\u0027s account to `to` account\\n    // - Owner\\u0027s account must have sufficient balance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transfer(address to, uint tokens) public returns (bool success) {\\n        setBalance(msg.sender, getBalance(msg.sender).sub(tokens));\\n        setBalance(to, getBalance(to).add(tokens));\\n        emit Transfer(msg.sender, to, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Token owner can approve for `spender` to transferFrom(...) `tokens`\\n    // from the token owner\\u0027s account\\n    //\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n    // recommends that there are no checks for the approval double-spend attack\\n    // as this should be implemented in user interfaces \\n    // ------------------------------------------------------------------------\\n    function approve(address spender, uint tokens) public returns (bool success) {\\n        setAllowed(msg.sender, spender, tokens);\\n        emit Approval(msg.sender, spender, tokens);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Transfer `tokens` from the `from` account to the `to` account\\n    // \\n    // The calling account must already have sufficient tokens approve(...)-d\\n    // for spending from the `from` account and\\n    // - From account must have sufficient balance to transfer\\n    // - Spender must have sufficient allowance to transfer\\n    // - 0 value transfers are allowed\\n    // ------------------------------------------------------------------------\\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\\n        setAllowed(from, msg.sender, getAllowed(from, msg.sender).sub(tokens));\\n        setBalance(from, getBalance(from).sub(tokens));\\n        setBalance(to, getBalance(to).add(tokens));\\n        emit Transfer(from, to, tokens);\\n        return true;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // Owner can withdraw and amount of tokens to another network, these tokens will be burned.\\n    // -----------------------------------------------------------------------\\n    function withdraw(uint tokens, string memory blockchain_address, string memory network) public returns (bool success) {\\n        setBalance(msg.sender, getBalance(msg.sender).sub(tokens));\\n        setTotalSupply(getTotalSupply().sub(tokens));\\n        emit Withdraw(msg.sender, tokens, blockchain_address, network);\\n        return true;\\n    }\\n\\n\\n    // ------------------------------------------------------------------------\\n    // Returns the amount of tokens approved by the owner that can be\\n    // transferred to the spender\\u0027s account\\n    // ------------------------------------------------------------------------\\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\\n        return getAllowed(tokenOwner, spender);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Don\\u0027t accept ETH\\n    // ------------------------------------------------------------------------\\n    receive() external payable { }\\n\\n    // -----------------------------------------------------------------------\\n    // Owner can mint tokens. Although minting tokens to a withdraw address\\n    // is just an expensive tft transaction, it is possible, so after minting\\n    // attemt to withdraw.\\n    // -----------------------------------------------------------------------\\n    function mintTokens(address receiver, uint tokens, string memory txid) public onlyOwner {\\n        // check if the txid is already known\\n        require(!_isMintID(txid), \\\"TFT transacton ID already known\\\");\\n        _setMintID(txid);\\n        setBalance(receiver, getBalance(receiver).add(tokens));\\n        setTotalSupply(getTotalSupply().add(tokens));\\n        emit Mint(receiver, tokens, txid);\\n    }\\n\\n    function isMintID(string memory _txid) public view returns (bool) {\\n        return _isMintID(_txid);\\n    }\\n\\n    function _setMintID(string memory _txid) internal {\\n        setBool(keccak256(abi.encode(\\\"mint\\\",\\\"transaction\\\",\\\"id\\\",_txid)), true);\\n    }\\n\\n    function _isMintID(string memory _txid) internal view returns (bool) {\\n        return getBool(keccak256(abi.encode(\\\"mint\\\",\\\"transaction\\\",\\\"id\\\", _txid)));\\n    }\\n}\"},\"token_storage.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./storage.sol\\\";\\n\\ncontract TokenStorage is Storage {\\n\\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // string public symbol;\\n    // string public  name;\\n    // uint8 public decimals;\\n    // uint _totalSupply;\\n\\n    // mapping(address =\\u003e uint) balances;\\n    // mapping(address =\\u003e mapping(address =\\u003e uint)) allowed;\\n\\n    // -----------------------------------------------------\\n    // getter utilities\\n    // -----------------------------------------------------\\n    function getSymbol() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"symbol\\\")));\\n    }\\n\\n    function getName() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"name\\\")));\\n    }\\n\\n    function getDecimals() internal view returns (uint8) {\\n        return uint8(getUint(keccak256(abi.encode(\\\"decimals\\\"))))    ;\\n    }\\n\\n    function getTotalSupply() internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"totalSupply\\\")));\\n    }\\n\\n    function getBalance(address _account) internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"balance\\\", _account)));\\n    }\\n\\n    function getAllowed(address _account, address _spender) internal view returns (uint) {\\n        return getUint(keccak256(abi.encode(\\\"allowed\\\", _account, _spender)));\\n    }\\n\\n    // -----------------------------------------------------\\n    // setter utilities\\n    // -----------------------------------------------------\\n    function setSymbol(string memory _symbol) internal {\\n        setString(keccak256(abi.encode(\\\"symbol\\\")), _symbol);\\n    }\\n\\n    function setName(string memory _name) internal {\\n        setString(keccak256(abi.encode(\\\"name\\\")), _name);\\n    }\\n\\n    function setDecimals(uint8 _decimals) internal {\\n        setUint(keccak256(abi.encode(\\\"decimals\\\")), _decimals);\\n    }\\n\\n    function setTotalSupply(uint _totalSupply) internal {\\n        setUint(keccak256(abi.encode(\\\"totalSupply\\\")), _totalSupply);\\n    }\\n\\n    function setBalance(address _account, uint _balance) internal {\\n        setUint(keccak256(abi.encode(\\\"balance\\\", _account)), _balance);\\n    }\\n\\n    function setAllowed(address _account, address _spender, uint _allowance) internal {\\n        setUint(keccak256(abi.encode(\\\"allowed\\\", _account, _spender)), _allowance);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Constructor\\n    // ------------------------------------------------------------------------\\n    // Token constructor here so it is also inheritted by our proxy. Needed to set some constants\\n    constructor() {\\n        setSymbol(\\\"TFT\\\");\\n        setName(\\\"TFT on BSC\\\");\\n\\n        // Use 7 decimals instead of 9, this way we have the same amount of decimals in both TFT and this Token\\n        uint8 _decimals = 7;\\n        setDecimals(_decimals);\\n\\n        // Set initial supply to 0\\n        setTotalSupply(0);\\n    }\\n}\"},\"upgradeable.sol\":{\"content\":\"pragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./owned.sol\\\";\\n\\ncontract Upgradeable is Owned {\\n    // -----------------------------------------------------\\n    // Usual storage\\n    // -----------------------------------------------------\\n\\n    // string internal _version;\\n    // address internal _implementation;\\n\\n    // -----------------------------------------------------\\n    // Events\\n    // -----------------------------------------------------\\n\\n    event Upgraded(string indexed version, address indexed implementation);\\n\\n    // -----------------------------------------------------\\n    // storage utilities\\n    // -----------------------------------------------------\\n\\n    function _getVersion() internal view returns (string memory) {\\n        return getString(keccak256(abi.encode(\\\"version\\\")));\\n    }\\n\\n    function _setVersion(string memory _version) internal {\\n        setString(keccak256(abi.encode(\\\"version\\\")), _version);\\n    }\\n\\n    function _getImplementation() internal view returns (address) {\\n        return getAddress(keccak256(abi.encode(\\\"implementation\\\")));\\n    }\\n\\n    function _setImplementation(address _implementation) internal {\\n        setAddress(keccak256(abi.encode(\\\"implementation\\\")), _implementation);\\n    }\\n\\n    // -----------------------------------------------------\\n    // Main contract\\n    // -----------------------------------------------------\\n\\n    function version() public view returns (string memory) {\\n        return _getVersion();\\n    }\\n\\n    function implementation() public view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n\\n    function upgradeTo(string memory _version, address _implementation) public onlyOwner {\\n        require(_getImplementation() != _implementation);\\n        _setVersion(_version);\\n        _setImplementation(_implementation);\\n        emit Upgraded(_version, _implementation);\\n    }\\n}\"}}",
            "abi": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedOwner\",\"type\":\"address\"}],\"name\":\"RemovedOwner\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"is_owner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners_list\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toRemove\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
            "verified": true,
            "owner": null,
            "creator": "0x65e491d7b985f77e60c85105834a0332ff3002ce",
            "is_hidden_owner": true,
            "is_proxy": true,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "ownership_renounced": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "is_honeypot_suspected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "blacklist_or_whitelist_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 0,
            "holders_list": null,
            "total_circulating_supply": 0,
            "owner": null,
            "creator": null,
            "holders_exceeding_5_percent": null,
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": null,
            "total_top_10_balance": null,
            "top10_percentage_of_total_supply": null,
            "top10_percentage_of_circulating_supply": null,
            "top_10_less_than_70_percent_of_total": null,
            "top_10_less_than_70_percent_of_circulating": null
        },
        "liquidity": {
            "price_usd": 0.004533,
            "liquidity_usd": 72809.68,
            "market_cap_usd": 0.0,
            "liquidity_to_market_cap_ratio": 0,
            "token_volume": 115783.9647011,
            "volume_usd": 524.8487119900863,
            "volume_to_liquidity_ratio": 0.007208501836432825,
            "locked_liquidity_percent": 0.0,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 0.0452,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 0.0,
            "total_lp_supply": 1.2033729643436755,
            "lp_holders_count": 10,
            "lp_holders": [
                {
                    "address": "0x1262c2754c6f6a86fdeade2bf85511ac150606a9",
                    "balance": 0.620454379477606,
                    "is_locked": false,
                    "percent": 0.5155960769120356,
                    "tag": ""
                },
                {
                    "address": "0x360259ed5db9f8874c24515fdad381dd0ffea1c3",
                    "balance": 0.3139722520484352,
                    "is_locked": false,
                    "percent": 0.2609101761062722,
                    "tag": ""
                },
                {
                    "address": "0x5c110d45cdf3242707b1e913cee61379cd25e672",
                    "balance": 0.104769742,
                    "is_locked": false,
                    "percent": 0.08706340021286903,
                    "tag": ""
                },
                {
                    "address": "0x083918d42e9c9727edcf58269e53673431fb7258",
                    "balance": 0.060714213683686756,
                    "is_locked": false,
                    "percent": 0.05045336357278106,
                    "tag": ""
                },
                {
                    "address": "0x48bb805841265e4c07500150557217dfa05de14e",
                    "balance": 0.049968248,
                    "is_locked": false,
                    "percent": 0.041523492284250285,
                    "tag": ""
                },
                {
                    "address": "0x594c95604960f60a98fb9ba115af4d41f7ec6d6e",
                    "balance": 0.04941969,
                    "is_locked": false,
                    "percent": 0.04106764192342787,
                    "tag": ""
                },
                {
                    "address": "0xdeeca0bdaa37ee00fa1adea371369e7904c0723f",
                    "balance": 0.001868460369902721,
                    "is_locked": false,
                    "percent": 0.001552686012787221,
                    "tag": ""
                },
                {
                    "address": "0x14d84bd51765e9d3e38ac21f8bef82faf93a9b9d",
                    "balance": 0.000808944246680609,
                    "is_locked": false,
                    "percent": 0.000672230697090498,
                    "tag": ""
                },
                {
                    "address": "0x2c86dc1a7e8141e18d56b6ba5edfef90ebe583e9",
                    "balance": 0.000699185419756058,
                    "is_locked": false,
                    "percent": 0.000581021379466836,
                    "tag": ""
                },
                {
                    "address": "0x1453c6d543a03a572830508219f5dad3a206f279",
                    "balance": 0.000219127265665999,
                    "is_locked": false,
                    "percent": 0.000182094223618786,
                    "tag": ""
                }
            ]
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 1,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 135576271.990447,
            "token_creation_date": "2021-05-02T16:29:18",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x78c2436bdbf229ce52be06754aa5f75d9ebb208d041f922971ae307bac8303a5",
            "last_active_age": "2025-08-18T15:07:29",
            "inactive_days": 0.22665787877314814
        },
        "holders": {
            "error": "Exception during holder analysis in owner_circulating_supply_analysis: float division by zero"
        }
    },
    "errors": []
}