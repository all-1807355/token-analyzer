{
  "token_address": "0x0000000000c5dc95539589fbd24be07c6c14eca4",
  "chain": "eth",
  "token_name": "Milady Cult Coin",
  "analyses": {
    "contract": {
      "contract_name": "Cult",
      "compiler_version": "v0.8.25+commit.b61c2a91",
      "license_type": "",
      "implementation": "",
      "source_code": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Cult.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-VPL WITH AGPL-3.0-only\\npragma solidity ^0.8.25;\\n\\nimport {\\n  ERC20\\n} from \\\"solady/tokens/ERC20.sol\\\";\\nimport {\\n  Ownable\\n} from \\\"solady/auth/Ownable.sol\\\";\\nimport {\\n  FixedPointMathLib\\n} from \\\"solady/utils/FixedPointMathLib.sol\\\";\\nimport {\\n  SafeTransferLib\\n} from \\\"solady/utils/SafeTransferLib.sol\\\";\\nimport {\\n  ReentrancyGuard\\n} from \\\"soledge/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n  @custom:benediction DEVS BENEDICAT ET PROTEGAT CONTRACTVM MEVM\\n  @title The Remilia ERC-20 token.\\n  @author Tim Clancy <tim-clancy.eth>\\n  @custom:terry \\\"God is just. Work is rewarded with blessing if not money. Luck\\n    is the most important thing, but really it's God.\\\"\\n\\n  -----------------------------------------------------------------------------\\n  The Remilia ERC-20 token.\\n\\n  No seed raise, no investors,\\n  no burdens, no promises,\\n  just conviction.\\n\\n  I love you.\\n  -----------------------------------------------------------------------------\\n\\n  A note from the author: Milady, you will always have within you a beautiful\\n  kernel of our collective net history. No matter what happens, no matter who\\n  fails, no matter who succeeds, no matter what success does to you, no matter\\n  where your network spirits go: behind those neochibi eyes is a memory of the\\n  old ways. A memory of whitepilled anticorporate post-authorship. A flag for\\n  unapologetic radicals on a holy mission.\\n  \\n  I long for network spirituality.\\n\\n  @custom:date July 22nd, 2024.\\n*/\\ncontract Cult is ERC20, Ownable, ReentrancyGuard {\\n  bytes32 constant MESSAGE =\\n    0xe07fc590053cce006bcf1908510532bf0bddbb779b1b5e78855f2229ef4e5de9;\\n\\n  /**\\n    An error emitted if trying to use `transferToken` on the Cult token. The\\n    only way to remove the Cult token from its own contract is using the vest\\n    mechanic. See notes on its fallibility later.\\n  */\\n  error MustVest ();\\n\\n  /// An error emitted if trying to push a concluded or invalid vest amount.\\n  error InvalidVest ();\\n\\n  /**\\n    This struct records details about existing token vests. All vests using\\n    this contract for distribution will be concluded well before 2106. No\\n    single vest will exceed 10B tokens in `amount`.\\n\\n    @param recipient The address that receives the vested tokens.\\n    @param amount The amount of tokens to vest to the `recipient`.\\n    @param amountClaimed The amount of tokens already claimed by `recipient`.\\n    @param start The time when the vest starts.\\n    @param end The time when the vest ends.\\n    @param lastClaimTime The time when `recipient` last claimed.\\n  */\\n  struct Vest {\\n    address recipient;\\n    uint96 amount;\\n    uint96 amountClaimed;\\n    uint32 start;\\n    uint32 end;\\n    uint32 lastClaimTime;\\n  }\\n\\n  /**\\n    A mapping of addresses to their `vestId`-identified `Vest`s.\\n\\n    @custom:param recipient The recipient of the `Vest`.\\n    @custom:param id The ID of some specific `Vest` details.\\n  */\\n  mapping (\\n    address recipient => mapping ( uint96 id => Vest )\\n  ) public vests;\\n\\n  /**\\n    This struct encodes the input for creating or modifying a token vest.\\n    \\n    @param recipient The address that receives the vested tokens. This is\\n      really only here for nice padding. :)\\n    @param amount The amount of tokens to vest to the `recipient`.\\n    @param start The time when the vest starts.\\n    @param end The time when the vest ends.\\n    @param id Different `id` values may create multiple vests to the same\\n      `recipient`.\\n  */\\n  struct SetVest {\\n    address recipient;\\n    uint96 amount;\\n    uint32 start;\\n    uint32 end;\\n    uint96 id;\\n  }\\n\\n  /**\\n    This event is emitted whenever a token vest is created or modified.\\n\\n    @param recipient The beneficiary of the token vest.\\n    @param id The specific ID of the `Vest` being set.\\n  */\\n  event VestSet (\\n    address indexed recipient,\\n    uint96 indexed id\\n  );\\n\\n  /**\\n    Our very simple constructor mints the entire token supply to the owner\\n    from whence it is distributed to claims and vests and vaults.\\n\\n    @param _owner The initial owner.\\n  */\\n  constructor (\\n    address _owner\\n  ) {\\n    _initializeOwner(_owner);\\n    _mint(_owner, 100_000000000_000000000000000000);\\n  }\\n\\n  /**\\n    Returns the name of the token.\\n\\n    @return _ The name of the token.\\n  */\\n  function name () override public pure returns (string memory) {\\n    return \\\"Milady Cult Coin\\\";\\n  }\\n\\n  /**\\n    Returns the symbol of the token.\\n\\n    @return _ The symbol used as the token ticker.\\n  */\\n  function symbol () override public pure returns (string memory) {\\n    return \\\"CULT\\\";\\n  }\\n\\n  /**\\n    Allow the owner to transfer Ether out of this contract.\\n    We only need this to rescue anyone dumb.\\n\\n    @param _to The address to transfer Ether to.\\n    @param _amount The amount of Ether to transfer.\\n  */\\n  function transferEther (\\n    address _to,\\n    uint256 _amount\\n  ) external payable onlyOwner {\\n    bool success = SafeTransferLib.trySafeTransferETH(\\n      _to,\\n      _amount,\\n      SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES\\n    );\\n    if (!success) {\\n      SafeTransferLib.forceSafeTransferETH(_to, _amount);\\n    }\\n  }\\n\\n  /**\\n    Allow the owner to transfer ERC-20 tokens out of this contract.\\n    We only need this to rescue anyone dumb.\\n\\n    @param _token The address of the ERC-20 token to transfer.\\n    @param _to The address to transfer the ERC-20 `_token` to.\\n    @param _amount The amount of `_token` to transfer.\\n  */\\n  function transferToken (\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external payable onlyOwner {\\n    if (_token == address(this)) {\\n      revert MustVest();\\n    }\\n    SafeTransferLib.safeTransfer(_token, _to, _amount);\\n  }\\n\\n  /**\\n    Allow the owner to set vests for this token. The owner must take care not\\n    to create invalid vests.\\n\\n    @param _vests An array of `CreateVest` inputs to create vests with.\\n  */\\n  function setVest (\\n    SetVest[] memory _vests\\n  ) external onlyOwner {\\n    for (uint i = 0; i < _vests.length; i++) {\\n      address recipient = _vests[i].recipient;\\n      uint96 id = _vests[i].id;\\n      Vest memory vest = Vest({\\n        recipient: _vests[i].recipient,\\n        amount: _vests[i].amount,\\n        amountClaimed: 0,\\n        start: _vests[i].start,\\n        end: _vests[i].end,\\n        lastClaimTime: _vests[i].start\\n      });\\n      vests[recipient][id] = vest;\\n      emit VestSet(recipient, id);\\n    }\\n  }\\n\\n  /**\\n    A function allowing vested tokens to be pushed to the `msg.sender`.\\n\\n    @param _id The ID of the specific `msg.sender` `Vest` to push.\\n    @param _amount The amount of the vest to push.\\n  */\\n  function pushVest (\\n    uint96 _id,\\n    uint256 _amount\\n  ) external nonReentrant {\\n    Vest memory vest = vests[msg.sender][_id];\\n\\n    // Verify that the vest is active.\\n    if (vest.amount < 1) {\\n      revert InvalidVest();\\n    }\\n\\n    // Calculate the current releasable token amount.\\n    uint96 vestedAmount = uint96(FixedPointMathLib.lerp(\\n      0, vest.amount, block.timestamp, vest.start, vest.end\\n    ));\\n\\n    // Reduce the unclaimed amount by the amount already claimed.\\n    uint256 unclaimedAmount = vestedAmount - vest.amountClaimed;\\n\\n    // Prevent overclaiming a vest.\\n    if (_amount > unclaimedAmount) {\\n      revert InvalidVest();\\n    }\\n\\n    // Update the vest being tracked.\\n    vest.amountClaimed = vest.amountClaimed + uint96(_amount);\\n    vest.lastClaimTime = uint32(block.timestamp);\\n    vests[msg.sender][_id] = vest;\\n\\n    // Transfer the unclaimed tokens to the beneficiary.\\n    SafeTransferLib.safeTransfer(address(this), msg.sender, _amount);\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"lib/solady/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /// @dev The allowance of Permit2 is fixed at infinity.\\n    error Permit2AllowanceIsFixedAtInfinity();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    /// If you need to use a different version, override `_versionHash`.\\n    bytes32 private constant _DEFAULT_VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// To enable, override `_givePermit2InfiniteAllowance()`.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return type(uint256).max;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        // Code duplication is for zero-cost abstraction if possible.\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                if iszero(eq(caller(), _PERMIT2)) {\\n                    // Compute the allowance slot and load its value.\\n                    mstore(0x20, caller())\\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                    let allowanceSlot := keccak256(0x0c, 0x34)\\n                    let allowance_ := sload(allowanceSlot)\\n                    // If the allowance is not the maximum uint256 value.\\n                    if not(allowance_) {\\n                        // Revert if the amount to be transferred exceeds the allowance.\\n                        if gt(amount, allowance_) {\\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        // Subtract and store the updated allowance.\\n                        sstore(allowanceSlot, sub(allowance_, amount))\\n                    }\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                // Compute the allowance slot and load its value.\\n                mstore(0x20, caller())\\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                let allowanceSlot := keccak256(0x0c, 0x34)\\n                let allowance_ := sload(allowanceSlot)\\n                // If the allowance is not the maximum uint256 value.\\n                if not(allowance_) {\\n                    // Revert if the amount to be transferred exceeds the allowance.\\n                    if gt(amount, allowance_) {\\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Subtract and store the updated allowance.\\n                    sstore(allowanceSlot, sub(allowance_, amount))\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev If you need a different value, override this function.\\n    function _versionHash() internal view virtual returns (bytes32 result) {\\n        result = _DEFAULT_VERSION_HASH;\\n    }\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if not(allowance_) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          PERMIT2                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\\n    ///\\n    /// This value should be kept constant after contract initialization,\\n    /// or else the actual allowance values may not match with the {Approval} events.\\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an overflow.\\n    error RPowOverflow();\\n\\n    /// @dev The mantissa is too big to fit.\\n    error MantissaOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error SMulWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error SDivWadFailed();\\n\\n    /// @dev The operation failed, either due to a multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The input outside the acceptable domain.\\n    error OutOfDomain();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if gt(x, div(not(0), y)) {\\n                if y {\\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(z, WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down, but without overflow checks.\\n    function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if iszero(eq(div(z, y), x)) {\\n                if y {\\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up, but without overflow checks.\\n    function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, WAD)\\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := sdiv(z, y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down, but without overflow and divide by zero checks.\\n    function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up, but without overflow and divide by zero checks.\\n    function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    /// Note: This function is an approximation.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\\n    /// Note: This function is an approximation. Monotonically increasing.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is less than 0.5 we return zero.\\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\\n            if (x <= -41446531673892822313) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // `k` is in the range `[-61, 195]`.\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // `p` is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already `2**96` too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range `(0.09, 0.25) * 2**96`.\\n\\n            // We now need to multiply r by:\\n            // - The scale factor `s \u2248 6.031367120`.\\n            // - The `2**k` factor from the range reduction.\\n            // - The `1e18 / 2**96` factor for base conversion.\\n            // We do this all at once, with an intermediate result in `2**213`\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256(\\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\\n            );\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/22/exp-ln\\n    /// Note: This function is an approximation. Monotonically increasing.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\\n            // We do this by multiplying by `2**96 / 10**18`. But since\\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\\n            // and add `ln(2**96 / 10**18)` at the end.\\n\\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // We place the check here for more optimal stack operations.\\n            if iszero(sgt(x, 0)) {\\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // forgefmt: disable-next-item\\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x := shr(159, shl(r, x))\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // `p` is made monic, we will multiply by a scale factor later.\\n            // forgefmt: disable-next-item\\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\\n                sar(96, mul(add(43456485725739037958740375743393,\\n                sar(96, mul(add(24828157081833163892658089445524,\\n                sar(96, mul(add(3273285459638523848632254066296,\\n                    x), x))), x))), x)), 11111509109440967052023855526967)\\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\\n\\n            // `q` is monic by convention.\\n            let q := add(5573035233440673466300451813936, x)\\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\\n\\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\\n\\n            // Finalization, we need to:\\n            // - Multiply by the scale factor `s = 5.549\u2026`.\\n            // - Add `ln(2**96 / 10**18)`.\\n            // - Add `k * ln(2)`.\\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\\n\\n            // The q polynomial is known not to have zeros in the domain.\\n            // No scaling required because p is already `2**96` too large.\\n            p := sdiv(p, q)\\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\\n            p := mul(1677202110996718588342820967067443963516166, p)\\n            // Add `ln(2) * k * 5**18 * 2**192`.\\n            // forgefmt: disable-next-item\\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\\n            // Base conversion: mul `2**18 / 2**192`.\\n            r := sar(174, p)\\n        }\\n    }\\n\\n    /// @dev Returns `W_0(x)`, denominated in `WAD`.\\n    /// See: https://en.wikipedia.org/wiki/Lambert_W_function\\n    /// a.k.a. Product log function. This is an approximation of the principal branch.\\n    /// Note: This function is an approximation. Monotonically increasing.\\n    function lambertW0Wad(int256 x) internal pure returns (int256 w) {\\n        // forgefmt: disable-next-item\\n        unchecked {\\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\\n            (int256 wad, int256 p) = (int256(WAD), x);\\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\\n            uint256 i = 4; // Number of iterations.\\n            if (w <= 0x1ffffffffffff) {\\n                if (-0x4000000000000 <= w) {\\n                    i = 1; // Inputs near zero only take one step to converge.\\n                } else if (w <= -0x3ffffffffffffff) {\\n                    i = 32; // Inputs near `-1/e` take very long to converge.\\n                }\\n            } else if (uint256(w >> 63) == uint256(0)) {\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // Inline log2 for more performance, since the range is small.\\n                    let v := shr(49, w)\\n                    let l := shl(3, lt(0xff, v))\\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\\n                    c := gt(l, 60)\\n                    i := add(2, add(gt(l, 53), c))\\n                }\\n            } else {\\n                int256 ll = lnWad(w = lnWad(w));\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\\n                    i := add(3, iszero(shr(68, x)))\\n                    c := iszero(shr(143, x))\\n                }\\n                if (c == uint256(0)) {\\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\\n                        int256 e = expWad(w);\\n                        /// @solidity memory-safe-assembly\\n                        assembly {\\n                            let t := mul(w, div(e, wad))\\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\\n                        }\\n                        if (p <= w) break;\\n                        p = w;\\n                    } while (--i != uint256(0));\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        w := sub(w, sgt(w, 2))\\n                    }\\n                    return w;\\n                }\\n            }\\n            do { // Otherwise, use Halley's for faster convergence.\\n                int256 e = expWad(w);\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let t := add(w, wad)\\n                    let s := sub(mul(w, e), mul(x, wad))\\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\\n                }\\n                if (p <= w) break;\\n                p = w;\\n            } while (--i != c);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                w := sub(w, sgt(w, 2))\\n            }\\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\\n            if (c == uint256(0)) return w;\\n            int256 t = w | 1;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                x := sdiv(mul(x, wad), t)\\n            }\\n            x = (t * (wad + lnWad(x)));\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                w := sdiv(x, add(wad, t))\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // 512-bit multiply `[p1 p0] = x * y`.\\n            // Compute the product mod `2**256` and mod `2**256 - 1`\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that `product = p1 * 2**256 + p0`.\\n\\n            // Temporarily use `result` as `p0` to save gas.\\n            result := mul(x, y) // Lower 256 bits of `x * y`.\\n            for {} 1 {} {\\n                // If overflows.\\n                if iszero(mul(or(iszero(x), eq(div(result, x), y)), d)) {\\n                    let mm := mulmod(x, y, not(0))\\n                    let p1 := sub(mm, add(result, lt(mm, result))) // Upper 256 bits of `x * y`.\\n\\n                    /*------------------- 512 by 256 division --------------------*/\\n\\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\\n                    // Make sure the result is less than `2**256`. Also prevents `d == 0`.\\n                    // Placing the check here seems to give more optimal stack operations.\\n                    if iszero(gt(d, p1)) {\\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\\n                    // Invert `d mod 2**256`\\n                    // Now that `d` is an odd number, it has an inverse\\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                    // Compute the inverse by starting with a seed that is correct\\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                    let inv := xor(2, mul(3, d))\\n                    // Now use Newton-Raphson iteration to improve the precision.\\n                    // Thanks to Hensel's lifting lemma, this also works in modular\\n                    // arithmetic, doubling the correct bits in each step.\\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                    result :=\\n                        mul(\\n                            // Divide [p1 p0] by the factors of two.\\n                            // Shift in bits from `p1` into `p0`. For this we need\\n                            // to flip `t` such that it is `2**256 / t`.\\n                            or(\\n                                mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)),\\n                                div(sub(result, r), t)\\n                            ),\\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\\n                        )\\n                    break\\n                }\\n                result := div(result, d)\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision.\\n    /// Behavior is undefined if `d` is zero or the final result cannot fit in 256 bits.\\n    /// Performs the full 512 bit calculation regardless.\\n    function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mul(x, y)\\n            let mm := mulmod(x, y, not(0))\\n            let p1 := sub(mm, add(result, lt(mm, result)))\\n            let t := and(d, sub(0, d))\\n            let r := mulmod(x, y, d)\\n            d := div(d, t)\\n            let inv := xor(2, mul(3, d))\\n            inv := mul(inv, sub(2, mul(d, inv)))\\n            inv := mul(inv, sub(2, mul(d, inv)))\\n            inv := mul(inv, sub(2, mul(d, inv)))\\n            inv := mul(inv, sub(2, mul(d, inv)))\\n            inv := mul(inv, sub(2, mul(d, inv)))\\n            result :=\\n                mul(\\n                    or(mul(sub(p1, gt(r, result)), add(div(sub(0, t), t), 1)), div(sub(result, r), t)),\\n                    mul(sub(2, mul(d, inv)), inv)\\n                )\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                result := add(result, 1)\\n                if iszero(result) {\\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(z, d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(x, y)\\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `condition ? x : y`, without branching.\\n    function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := xor(x, mul(xor(x, y), iszero(condition)))\\n        }\\n    }\\n\\n    /// @dev Exponentiate `x` to `y` by squaring, denominated in base `b`.\\n    /// Reverts if the computation overflows.\\n    function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\\n            if x {\\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\\n                let half := shr(1, b) // Divide `b` by 2.\\n                // Divide `y` by 2 every iteration.\\n                for { y := shr(1, y) } y { y := shr(1, y) } {\\n                    let xx := mul(x, x) // Store x squared.\\n                    let xxRound := add(xx, half) // Round to the nearest number.\\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\\n                    if or(lt(xxRound, xx), shr(128, x)) {\\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\\n                    // If `y` is odd:\\n                    if and(y, 1) {\\n                        let zx := mul(z, x) // Compute `z * x`.\\n                        let zxRound := add(zx, half) // Round to the nearest number.\\n                        // If `z * x` overflowed or `zx + half` overflowed:\\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\\n                            // Revert if `x` is non-zero.\\n                            if x {\\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\\n                                revert(0x1c, 0x04)\\n                            }\\n                        }\\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`, rounded down.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`, rounded down.\\n    /// Credit to bout3fiddy and pcaversaccio under AGPLv3 license:\\n    /// https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n    /// Formally verified by xuwinnie:\\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\\n    function cbrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // Makeshift lookup table to nudge the approximate log2 result.\\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\\n            // Newton-Raphson's.\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\\n            // Round down.\\n            z := sub(z, lt(div(x, mul(z, z)), z))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`, denominated in `WAD`, rounded down.\\n    function sqrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\\n            z = (1 + sqrt(x)) * 10 ** 9;\\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\\n        }\\n    }\\n\\n    /// @dev Returns the cube root of `x`, denominated in `WAD`, rounded down.\\n    /// Formally verified by xuwinnie:\\n    /// https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\\n    function cbrtWad(uint256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\\n            z = (1 + cbrt(x)) * 10 ** 12;\\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let p := x\\n            for {} 1 {} {\\n                if iszero(shr(229, p)) {\\n                    if iszero(shr(199, p)) {\\n                        p := mul(p, 100000000000000000) // 10 ** 17.\\n                        break\\n                    }\\n                    p := mul(p, 100000000) // 10 ** 8.\\n                    break\\n                }\\n                if iszero(shr(249, p)) { p := mul(p, 100) }\\n                break\\n            }\\n            let t := mulmod(mul(z, z), z, p)\\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            if iszero(lt(x, 58)) {\\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            for {} x { x := sub(x, 1) } { result := mul(result, x) }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\\n                0x0706060506020504060203020504030106050205030304010505030400000000))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log2(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(r, 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log10(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\\n                x := div(x, 100000000000000000000000000000000000000)\\n                r := 38\\n            }\\n            if iszero(lt(x, 100000000000000000000)) {\\n                x := div(x, 100000000000000000000)\\n                r := add(r, 20)\\n            }\\n            if iszero(lt(x, 10000000000)) {\\n                x := div(x, 10000000000)\\n                r := add(r, 10)\\n            }\\n            if iszero(lt(x, 100000)) {\\n                x := div(x, 100000)\\n                r := add(r, 5)\\n            }\\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\\n        }\\n    }\\n\\n    /// @dev Returns the log10 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log10Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log10(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(exp(10, r), x))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`.\\n    /// Returns 0 if `x` is zero.\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the log256 of `x`, rounded up.\\n    /// Returns 0 if `x` is zero.\\n    function log256Up(uint256 x) internal pure returns (uint256 r) {\\n        r = log256(x);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r := add(r, lt(shl(shl(3, r), 1), x))\\n        }\\n    }\\n\\n    /// @dev Returns the scientific notation format `mantissa * 10 ** exponent` of `x`.\\n    /// Useful for compressing prices (e.g. using 25 bit mantissa and 7 bit exponent).\\n    function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mantissa := x\\n            if mantissa {\\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\\n                    exponent := 33\\n                }\\n                if iszero(mod(mantissa, 10000000000000000000)) {\\n                    mantissa := div(mantissa, 10000000000000000000)\\n                    exponent := add(exponent, 19)\\n                }\\n                if iszero(mod(mantissa, 1000000000000)) {\\n                    mantissa := div(mantissa, 1000000000000)\\n                    exponent := add(exponent, 12)\\n                }\\n                if iszero(mod(mantissa, 1000000)) {\\n                    mantissa := div(mantissa, 1000000)\\n                    exponent := add(exponent, 6)\\n                }\\n                if iszero(mod(mantissa, 10000)) {\\n                    mantissa := div(mantissa, 10000)\\n                    exponent := add(exponent, 4)\\n                }\\n                if iszero(mod(mantissa, 100)) {\\n                    mantissa := div(mantissa, 100)\\n                    exponent := add(exponent, 2)\\n                }\\n                if iszero(mod(mantissa, 10)) {\\n                    mantissa := div(mantissa, 10)\\n                    exponent := add(exponent, 1)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function for packing `x` into a smaller number using `sci`.\\n    /// The `mantissa` will be in bits [7..255] (the upper 249 bits).\\n    /// The `exponent` will be in bits [0..6] (the lower 7 bits).\\n    /// Use `SafeCastLib` to safely ensure that the `packed` number is small\\n    /// enough to fit in the desired unsigned integer type:\\n    /// ```\\n    ///     uint32 packed = SafeCastLib.toUint32(FixedPointMathLib.packSci(777 ether));\\n    /// ```\\n    function packSci(uint256 x) internal pure returns (uint256 packed) {\\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if shr(249, x) {\\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            packed := or(shl(7, x), packed)\\n        }\\n    }\\n\\n    /// @dev Convenience function for unpacking a packed number from `packSci`.\\n    function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\\n        unchecked {\\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`. Rounds towards zero.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`. Rounds towards negative infinity.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue)\\n        internal\\n        pure\\n        returns (uint256 z)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\\n        }\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { z := x } y {} {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`,\\n    /// with `t` clamped between `begin` and `end` (inclusive).\\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\\n    /// If `begins == end`, returns `t <= begin ? a : b`.\\n    function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\\n        if (t <= begin) return a;\\n        if (t >= end) return b;\\n        unchecked {\\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\\n            return a - fullMulDiv(a - b, t - begin, end - begin);\\n        }\\n    }\\n\\n    /// @dev Returns `a + (b - a) * (t - begin) / (end - begin)`.\\n    /// with `t` clamped between `begin` and `end` (inclusive).\\n    /// Agnostic to the order of (`a`, `b`) and (`end`, `begin`).\\n    /// If `begins == end`, returns `t <= begin ? a : b`.\\n    function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\\n        if (t <= begin) return a;\\n        if (t >= end) return b;\\n        // forgefmt: disable-next-item\\n        unchecked {\\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\\n                uint256(t - begin), uint256(end - begin)));\\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\\n                uint256(t - begin), uint256(end - begin)));\\n        }\\n    }\\n\\n    /// @dev Returns if `x` is an even number. Some people may need this.\\n    function isEven(uint256 x) internal pure returns (bool) {\\n        return x & uint256(1) == uint256(0);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/soledge/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\n/// @notice Reentrancy guard mixin.\\n/// @author Soledge (https://github.com/vectorized/soledge/blob/main/src/utils/ReentrancyGuard.sol)\\n///\\n/// @dev Note: This implementation utilizes the `TSTORE` and `TLOAD` opcodes.\\n/// Please ensure that the chain you are deploying on supports them.\\nabstract contract ReentrancyGuard {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Unauthorized reentrant call.\\n    error Reentrancy();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Equivalent to: `uint72(bytes9(keccak256(\\\"_REENTRANCY_GUARD_SLOT\\\")))`.\\n    /// 9 bytes is large enough to avoid collisions in practice,\\n    /// but not too large to result in excessive bytecode bloat.\\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      REENTRANCY GUARD                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Guards a function from reentrancy.\\n    modifier nonReentrant() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if tload(_REENTRANCY_GUARD_SLOT) {\\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\\n                revert(0x1c, 0x04)\\n            }\\n            tstore(_REENTRANCY_GUARD_SLOT, address())\\n        }\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            tstore(_REENTRANCY_GUARD_SLOT, 0)\\n        }\\n    }\\n\\n    /// @dev Guards a view function from read-only reentrancy.\\n    modifier nonReadReentrant() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if tload(_REENTRANCY_GUARD_SLOT) {\\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"soledge/=lib/soledge/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"cancun\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}",
      "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustVest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Permit2AllowanceIsFixedAtInfinity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"}],\"name\":\"VestSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_id\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"pushVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"}],\"internalType\":\"struct Cult.SetVest[]\",\"name\":\"_vests\",\"type\":\"tuple[]\"}],\"name\":\"setVest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"}],\"name\":\"vests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"amountClaimed\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"end\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastClaimTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
      "verified": true,
      "owner": "0xd5cd18d3cb65fdab15076618401ff79097f9d780",
      "creator": "0x1ec7e0b7cd1a79a4afb873aeffe50ddca6446563",
      "is_hidden_owner": false,
      "is_proxy": false,
      "is_sellable": true,
      "is_hardcoded_owner": false,
      "code_analysis": {
        "total_matches": 10,
        "patterns_found": {
          "honeypot_mechanics": {
            "count": 10,
            "snippets": [
              {
                "matched_code": "assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ethtransferfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            // transfer all the eth and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ethtransferfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            if iszero(call(gasstipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // store the address in scratch space.\\n                mstore8(0x0b, 0x73) // opcode `push20`.\\n                mstore8(0x20, 0xff) // opcode `selfdestruct`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(gas_stipend_no_grief, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // store the address in scratch space.\\n                mstore8(0x0b, 0x73) // opcode `push20`.\\n                mstore8(0x20, 0xff) // opcode `selfdestruct`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            let m := mload(0x40) // cache the free memory pointer.\\n            mstore(0x60, amount) // store the `amount` argument.\\n            mstore(0x40, to) // store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferfrom(address,address,uint256)`.\\n            // perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `transferfromfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            let m := mload(0x40) // cache the free memory pointer.\\n            mstore(0x40, to) // store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceof(address)`.\\n            // read the balance, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // at least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `transferfromfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `transferfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            mstore(0x00, 0x70a08231) // store the function selector of `balanceof(address)`.\\n            mstore(0x20, address()) // store the address of the current contract.\\n            // read the balance, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // at least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `transferfailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `approvefailed()`.\\n                revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              },
              {
                "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // reset the approval.\\n                mstore(0x34, amount) // store back the original `amount`.\\n                // retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `approvefailed()`.\\n                    revert",
                "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /// @dev The Permit2 operation has failed.\\n    error Permit2Failed();\\n\\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\\n    error Permit2AmountOverflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\\n\\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            success :=\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul( // The arguments of `mul` are evaluated from right to left.\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\\n        if (!trySafeTransferFrom(token, from, to, amount)) {\\n            permit2TransferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\\n    /// Reverts upon failure.\\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\\n        internal\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\\n            mstore(add(m, 0x54), amount)\\n            mstore(add(m, 0x34), to)\\n            mstore(add(m, 0x20), shl(96, from))\\n            // `transferFrom(address,address,uint160,address)`.\\n            mstore(m, 0x36c78516000000000000000000000000)\\n            let p := PERMIT2\\n            let exists := eq(chainid(), 1)\\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Permit a user to spend a given amount of\\n    /// another user's tokens via native EIP-2612 permit if possible, falling\\n    /// back to Permit2 if native permit fails or is not implemented on the token.\\n    function permit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        bool success;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} shl(96, xor(token, WETH9)) {} {\\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\\n                if iszero(\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\\n                    )\\n                ) { break }\\n                // After here, we can be sure that token is a contract.\\n                let m := mload(0x40)\\n                mstore(add(m, 0x34), spender)\\n                mstore(add(m, 0x20), shl(96, owner))\\n                mstore(add(m, 0x74), deadline)\\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\\n                    mstore(0x14, owner)\\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\\n                    // `nonces` is already at `add(m, 0x54)`.\\n                    // `1` is already stored at `add(m, 0x94)`.\\n                    mstore(add(m, 0xb4), and(0xff, v))\\n                    mstore(add(m, 0xd4), r)\\n                    mstore(add(m, 0xf4), s)\\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\\n                    break\\n                }\\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\\n                mstore(add(m, 0x54), amount)\\n                mstore(add(m, 0x94), and(0xff, v))\\n                mstore(add(m, 0xb4), r)\\n                mstore(add(m, 0xd4), s)\\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\\n                break\\n            }\\n        }\\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\\n    }\\n\\n    /// @dev Simple permit on the Permit2 contract.\\n    function simplePermit2(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\\n            {\\n                let addressMask := shr(96, not(0))\\n                mstore(add(m, 0x20), and(addressMask, owner))\\n                mstore(add(m, 0x40), and(addressMask, token))\\n                mstore(add(m, 0x60), and(addressMask, spender))\\n                mstore(add(m, 0xc0), and(addressMask, spender))\\n            }\\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\\n                )\\n            ) {\\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\\n            }\\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\\n            // `owner` is already `add(m, 0x20)`.\\n            // `token` is already at `add(m, 0x40)`.\\n            mstore(add(m, 0x60), amount)\\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\\n            // `nonce` is already at `add(m, 0xa0)`.\\n            // `spender` is already at `add(m, 0xc0)`.\\n            mstore(add(m, 0xe0), deadline)\\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\\n            mstore(add(m, 0x120), 0x41) // `signature` length.\\n            mstore(add(m, 0x140), r)\\n            mstore(add(m, 0x160), s)\\n            mstore(add(m, 0x180), shl(248, v))\\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
                "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
              }
            ]
          }
        }
      }
    },
    "holder": {
      "total_holders": 200,
      "holders_list": {
        "0x0000000000c5dc95539589fbd24be07c6c14eca4": {
          "balance": 54167723101.7926,
          "percentage_of_total_supply": 54.16772310179261,
          "percentage_of_circulating_supply": 118.18684727817057
        },
        "0x000000f534caa75bd1a3950ab32d6bd24d2e6b76": {
          "balance": 5879519336.183425,
          "percentage_of_total_supply": 5.879519336183425,
          "percentage_of_circulating_supply": 12.82833787472904
        },
        "0xc4ce8e63921b8b6cbdb8fcb6bd64cc701fb926f2": {
          "balance": 4697469387.944212,
          "percentage_of_total_supply": 4.697469387944213,
          "percentage_of_circulating_supply": 10.249260359412654
        },
        "0xf766e3c30c09be842244fd32864a811d06b314e1": {
          "balance": 599999960.4300001,
          "percentage_of_total_supply": 0.59999996043,
          "percentage_of_circulating_supply": 1.3091209973324884
        },
        "0x2933782b5a8d72f2754103d1489614f29bfa4625": {
          "balance": 462491856.43925905,
          "percentage_of_total_supply": 0.4624918564392591,
          "percentage_of_circulating_supply": 1.0090964004831025
        },
        "0x7a7428d466a18fe41f74cbcce0635ad468432f73": {
          "balance": 423000000.0,
          "percentage_of_total_supply": 0.42300000000000004,
          "percentage_of_circulating_supply": 0.9229303639866617
        },
        "0x713388239281bb11ed72a9a449c066a184d1f603": {
          "balance": 420935559.0,
          "percentage_of_total_supply": 0.420935559,
          "percentage_of_circulating_supply": 0.9184260252548436
        },
        "0xfb94d3404c1d3d9d6f08f79e58041d5ea95accfa": {
          "balance": 404221981.9750266,
          "percentage_of_total_supply": 0.4042219819750266,
          "percentage_of_circulating_supply": 0.8819591984766457
        },
        "0xbbbbbbbbbb9cc5e90e3b3af64bdaf62c37eeffcb": {
          "balance": 397899487.8540407,
          "percentage_of_total_supply": 0.3978994878540408,
          "percentage_of_circulating_supply": 0.8681643478847189
        },
        "0x0b5305f909b57f483e0b2c9614cc625943c4bc9a": {
          "balance": 365753456.76152164,
          "percentage_of_total_supply": 0.3657534567615217,
          "percentage_of_circulating_supply": 0.798025936118891
        },
        "0x898f7810615f85d89735b95eec898ee532f4cb08": {
          "balance": 363724539.2822502,
          "percentage_of_total_supply": 0.36372453928225024,
          "percentage_of_circulating_supply": 0.793599105036993
        },
        "0xaf8dce0cd3616767d728ac3cda5e452963a8c758": {
          "balance": 324099566.4071685,
          "percentage_of_total_supply": 0.3240995664071685,
          "percentage_of_circulating_supply": 0.7071426259860218
        },
        "0x1a50d5059d7500c87ceb40b134d3bda3ab1f65df": {
          "balance": 303997509.62655026,
          "percentage_of_total_supply": 0.30399750962655026,
          "percentage_of_circulating_supply": 0.6632825820583232
        },
        "0x049271d4e63f0d02fbd06fba057a566baf6699c1": {
          "balance": 270000000.0,
          "percentage_of_total_supply": 0.27,
          "percentage_of_circulating_supply": 0.5891044876510607
        },
        "0x1af331dc34dd7c5c62af28b5685328318b61888a": {
          "balance": 265491074.61374643,
          "percentage_of_total_supply": 0.2654910746137465,
          "percentage_of_circulating_supply": 0.5792666055046689
        },
        "0xf9564e199a2001b1c0336d80619740894f8fc3cd": {
          "balance": 260949412.80437368,
          "percentage_of_total_supply": 0.2609494128043737,
          "percentage_of_circulating_supply": 0.5693572967887618
        },
        "0x15e4da227ff823f9872c8fab78b8217191958fb5": {
          "balance": 246843717.07584795,
          "percentage_of_total_supply": 0.24684371707584798,
          "percentage_of_circulating_supply": 0.53858052399204
        },
        "0x790697ecf8c670b42d95024bab0afc099d5b30b3": {
          "balance": 243418016.48242742,
          "percentage_of_total_supply": 0.24341801648242747,
          "percentage_of_circulating_supply": 0.5311060958700662
        },
        "0xa996d391f64158fb17fb71d6a4fad67df7410895": {
          "balance": 241535383.70781562,
          "percentage_of_total_supply": 0.24153538370781566,
          "percentage_of_circulating_supply": 0.5269984387733151
        },
        "0x41f5970e4792d9ad022f0182a58a97f18d3fa019": {
          "balance": 227540431.09476382,
          "percentage_of_total_supply": 0.22754043109476382,
          "percentage_of_circulating_supply": 0.4964632928888234
        },
        "0x38b2f8e61952ef3bfdfbb100b5774f70a30766ec": {
          "balance": 218329110.99999997,
          "percentage_of_total_supply": 0.218329111,
          "percentage_of_circulating_supply": 0.4763654039813576
        },
        "0x1a9a0b97ce419891f67468f81c91bc82497956e8": {
          "balance": 206403005.1482943,
          "percentage_of_total_supply": 0.2064030051482943,
          "percentage_of_circulating_supply": 0.4503442096204635
        },
        "0x4a2c786651229175407d3a2d405d1998bcf40614": {
          "balance": 202335991.2695481,
          "percentage_of_total_supply": 0.2023359912695481,
          "percentage_of_circulating_supply": 0.4414705202600615
        },
        "0x4ee00a27aed7bd527c130ee24d174521983c3bff": {
          "balance": 201597385.86976016,
          "percentage_of_total_supply": 0.20159738586976017,
          "percentage_of_circulating_supply": 0.4398589804244379
        },
        "0x3cc936b795a188f0e246cbb2d74c5bd190aecf18": {
          "balance": 192806338.06958163,
          "percentage_of_total_supply": 0.19280633806958164,
          "percentage_of_circulating_supply": 0.4206780703865114
        },
        "0xa580bfa51f601abaf1ac4d95c4979a9a8490503a": {
          "balance": 190522058.77145144,
          "percentage_of_total_supply": 0.19052205877145145,
          "percentage_of_circulating_supply": 0.41569407340289327
        },
        "0x805c305211f62d92aa3a1430ae7f79a27886fbe8": {
          "balance": 185808026.0,
          "percentage_of_total_supply": 0.18580802600000002,
          "percentage_of_circulating_supply": 0.4054086739192036
        },
        "0x9642b23ed1e01df1092b92641051881a322f5d4e": {
          "balance": 184703974.8731729,
          "percentage_of_total_supply": 0.18470397487317292,
          "percentage_of_circulating_supply": 0.4029997795732404
        },
        "0x24cbe3da6ebe242e3637cc8d2f8873cc41bf350d": {
          "balance": 183563283.0,
          "percentage_of_total_supply": 0.18356328300000002,
          "percentage_of_circulating_supply": 0.4005109399380062
        },
        "0xfd32fb200e3f24fe5ac8e847c5d379f1039d0b4a": {
          "balance": 180941904.37813058,
          "percentage_of_total_supply": 0.1809419043781306,
          "percentage_of_circulating_supply": 0.39479143656772525
        },
        "0xc8b8bc9a92fb3fa5bc6906907502c2070d503b28": {
          "balance": 179559497.48760036,
          "percentage_of_total_supply": 0.17955949748760036,
          "percentage_of_circulating_supply": 0.3917752065567212
        },
        "0x6f05baa156ad2367a5015e73af0a5c77a1e25ed2": {
          "balance": 177480932.52981013,
          "percentage_of_total_supply": 0.17748093252981018,
          "percentage_of_circulating_supply": 0.3872400512066899
        },
        "0x9fbb12ea7dc6de6503b35da4389db3aecf8e4282": {
          "balance": 176663333.00000894,
          "percentage_of_total_supply": 0.17666333300000897,
          "percentage_of_circulating_supply": 0.3854561565692556
        },
        "0x0d0707963952f2fba59dd06f2b425ace40b492fe": {
          "balance": 175683848.96516523,
          "percentage_of_total_supply": 0.17568384896516526,
          "percentage_of_circulating_supply": 0.38331905123403703
        },
        "0xbe4f0cdf3834bd876813a1037137dcfad79acd99": {
          "balance": 167381163.32057226,
          "percentage_of_total_supply": 0.16738116332057226,
          "percentage_of_circulating_supply": 0.36520368318668234
        },
        "0xe353c56796c04acb3588b860d879937b40ff4965": {
          "balance": 165119189.97794563,
          "percentage_of_total_supply": 0.1651191899779456,
          "percentage_of_circulating_supply": 0.3602683548641326
        },
        "0x2e6b28fda29e5328acd9cadaf6b5900daf5cb576": {
          "balance": 163245678.77399212,
          "percentage_of_total_supply": 0.16324567877399215,
          "percentage_of_circulating_supply": 0.3561805998348232
        },
        "0x3b7443cc9a4e4c4ce435b873f4e1dde36929ce71": {
          "balance": 158686913.8967423,
          "percentage_of_total_supply": 0.15868691389674233,
          "percentage_of_circulating_supply": 0.3462339744743273
        },
        "0x65050a14305b0c93145fc764447f0e54994b823a": {
          "balance": 158014455.0,
          "percentage_of_total_supply": 0.158014455,
          "percentage_of_circulating_supply": 0.3447667576082836
        },
        "0x6b6786222550dcb832ec0f503c7f972d2671f6ae": {
          "balance": 156939139.1241118,
          "percentage_of_total_supply": 0.1569391391241118,
          "percentage_of_circulating_supply": 0.34242055980040154
        },
        "0x1f6b79d81f03cb7dd4250e9cce0187102b0e52d4": {
          "balance": 156800298.0,
          "percentage_of_total_supply": 0.156800298,
          "percentage_of_circulating_supply": 0.34211762672897644
        },
        "0x1f5f902be1f635b30425b690aa9fd5fa2b6fa79c": {
          "balance": 155989862.09015396,
          "percentage_of_total_supply": 0.15598986209015397,
          "percentage_of_circulating_supply": 0.3403493621680732
        },
        "0x3478ba8727a585e2cbd2a4ea3eb8ba44c1c95a2e": {
          "balance": 153053841.79642,
          "percentage_of_total_supply": 0.15305384179642004,
          "percentage_of_circulating_supply": 0.33394335205372777
        },
        "0x994a6888ac0b3c7e2fd0d502eaf9e08d9cf931fa": {
          "balance": 151309408.3414161,
          "percentage_of_total_supply": 0.15130940834141612,
          "percentage_of_circulating_supply": 0.3301372276953891
        },
        "0xd6216fc19db775df9774a6e33526131da7d19a2c": {
          "balance": 149377516.39558664,
          "percentage_of_total_supply": 0.14937751639558663,
          "percentage_of_circulating_supply": 0.3259220935659629
        },
        "0xdcf5429cb1433a3433bd827046b10b65e3c0fb15": {
          "balance": 146515051.72273323,
          "percentage_of_total_supply": 0.1465150517227332,
          "percentage_of_circulating_supply": 0.31967657214181266
        },
        "0x536f751573658a51dc0af997c26804e1c66e4b56": {
          "balance": 145772781.30409956,
          "percentage_of_total_supply": 0.1457727813040996,
          "percentage_of_circulating_supply": 0.3180570357171174
        },
        "0xb8ba28f614d229d5a26e14ecd3f059b63826e15e": {
          "balance": 142469015.4041673,
          "percentage_of_total_supply": 0.14246901540416732,
          "percentage_of_circulating_supply": 0.3108486530586038
        },
        "0x7c01aa3783577e15fd7e272443d44b92d5b21056": {
          "balance": 141481480.42666665,
          "percentage_of_total_supply": 0.14148148042666667,
          "percentage_of_circulating_supply": 0.30869398162542605
        },
        "0x446b86a33e2a438f569b15855189e3da28d027ba": {
          "balance": 140911271.17000002,
          "percentage_of_total_supply": 0.14091127117000002,
          "percentage_of_circulating_supply": 0.30744986002541674
        },
        "0x22f6215b40434d9135b06f1c676fd9291936aac3": {
          "balance": 138480170.87111306,
          "percentage_of_total_supply": 0.13848017087111306,
          "percentage_of_circulating_supply": 0.3021455189291052
        },
        "0x2167d3755f0ea4235b60ddc57162d6b913ce2ad7": {
          "balance": 133499151.56708679,
          "percentage_of_total_supply": 0.1334991515670868,
          "percentage_of_circulating_supply": 0.2912775899473332
        },
        "0x316072523fc37c2530ba75a5f6962e6470c3c9e8": {
          "balance": 132743866.55782528,
          "percentage_of_total_supply": 0.1327438665578253,
          "percentage_of_circulating_supply": 0.28962965739766083
        },
        "0xc835d6a8473d4e4f6807a9192b8d90c694a2021f": {
          "balance": 132145010.06099766,
          "percentage_of_total_supply": 0.1321450100609977,
          "percentage_of_circulating_supply": 0.2883230312875122
        },
        "0x0cf47d8a190e8fe7025c5a254d099e6455eee706": {
          "balance": 132040436.49132018,
          "percentage_of_total_supply": 0.1320404364913202,
          "percentage_of_circulating_supply": 0.28809486551274666
        },
        "0xc8c9771b59f9f217e8285889b9cdd7b9ddce0e86": {
          "balance": 131363673.47106142,
          "percentage_of_total_supply": 0.13136367347106143,
          "percentage_of_circulating_supply": 0.2866182576152995
        },
        "0x6b34dd13ce75a1ab05b9bde8c3b31aca77184329": {
          "balance": 125248345.93873958,
          "percentage_of_total_supply": 0.1252483459387396,
          "percentage_of_circulating_supply": 0.27327541727179255
        },
        "0xf96f2a7581c809be943b4ee1685480e71aeefce4": {
          "balance": 123704498.0,
          "percentage_of_total_supply": 0.12370449800000001,
          "percentage_of_circulating_supply": 0.2699069441274876
        },
        "0x58edf78281334335effa23101bbe3371b6a36a51": {
          "balance": 122934531.45511134,
          "percentage_of_total_supply": 0.12293453145511136,
          "percentage_of_circulating_supply": 0.2682269783980984
        },
        "0xae2ba60c729370a5c0ac48ff03304fcf08311f15": {
          "balance": 122395306.0,
          "percentage_of_total_supply": 0.12239530600000001,
          "percentage_of_circulating_supply": 0.2670504593778696
        },
        "0xc7119d682728894f5f76b909a43040e33ac6d651": {
          "balance": 120892566.00300917,
          "percentage_of_total_supply": 0.12089256600300918,
          "percentage_of_circulating_supply": 0.2637716783556473
        },
        "0x2d50bf6334152dbda8bed2f50e5a0d8456bd47b3": {
          "balance": 120590659.38674338,
          "percentage_of_total_supply": 0.12059065938674338,
          "percentage_of_circulating_supply": 0.26311295782789274
        },
        "0x22b98bd46a95ba46a7d53845b3ff252c15b5870f": {
          "balance": 119759364.90397981,
          "percentage_of_total_supply": 0.11975936490397983,
          "percentage_of_circulating_supply": 0.26129918260435353
        },
        "0xb50e09340f46cb4bcaefd5b646f845c2b3300429": {
          "balance": 118184433.1458332,
          "percentage_of_total_supply": 0.11818443314583321,
          "percentage_of_circulating_supply": 0.2578628886544707
        },
        "0xee8311fe397e2464f78b3732e74dcd65087e7187": {
          "balance": 116422905.5755592,
          "percentage_of_total_supply": 0.1164229055755592,
          "percentage_of_circulating_supply": 0.25401946718495416
        },
        "0x5a9da404ce14b4fa2c7332854bb6a2eb005bce61": {
          "balance": 115945180.32958305,
          "percentage_of_total_supply": 0.11594518032958306,
          "percentage_of_circulating_supply": 0.2529771335321069
        },
        "0xbb636c9f92a61b47241ec034924191e9275c4ef1": {
          "balance": 114198337.11184226,
          "percentage_of_total_supply": 0.11419833711184227,
          "percentage_of_circulating_supply": 0.24916575138842573
        },
        "0x4a4d944301507a175824de2dae490e9aeca5c347": {
          "balance": 111234166.18548445,
          "percentage_of_total_supply": 0.11123416618548446,
          "percentage_of_circulating_supply": 0.24269832029626945
        },
        "0x743b9ea659d813ebd16cc432ac44c8b5b4344ce2": {
          "balance": 111009739.10230097,
          "percentage_of_total_supply": 0.11100973910230097,
          "percentage_of_circulating_supply": 0.2422086499190331
        },
        "0xe83350a2ae1fb31cfda1223e1e2ce59dd2b02cba": {
          "balance": 110588479.78494248,
          "percentage_of_total_supply": 0.11058847978494249,
          "percentage_of_circulating_supply": 0.24128951749562305
        },
        "0xb35248feeb246b850fac690a1beaf5130dc71894": {
          "balance": 110339521.41723658,
          "percentage_of_total_supply": 0.11033952141723659,
          "percentage_of_circulating_supply": 0.24074632308209035
        },
        "0xc2d875d553fe9600bd4904f062f613394c9af8eb": {
          "balance": 107168777.50671558,
          "percentage_of_total_supply": 0.1071687775067156,
          "percentage_of_circulating_supply": 0.23382817690846
        },
        "0xcff8b61528f0f0feaf00c45e4a14e43ab240275e": {
          "balance": 105549860.16452245,
          "percentage_of_total_supply": 0.10554986016452245,
          "percentage_of_circulating_supply": 0.23029591219948928
        },
        "0xe420a18a8fb5878efbaea538646bcf2da7529890": {
          "balance": 104785268.48103112,
          "percentage_of_total_supply": 0.10478526848103113,
          "percentage_of_circulating_supply": 0.22862767371072842
        },
        "0x46e8e4bc4915e9eb7371fb4dd69145f3d03f70ea": {
          "balance": 100580078.5403718,
          "percentage_of_total_supply": 0.10058007854037182,
          "percentage_of_circulating_supply": 0.21945250235714509
        },
        "0x64c7894c901e4ab98655b1425c31f9e91a153862": {
          "balance": 100000000.0,
          "percentage_of_total_supply": 0.10000000000000002,
          "percentage_of_circulating_supply": 0.21818684727817061
        },
        "0xca7606f9adc246735c8ac5a7c5e9de10639c0a27": {
          "balance": 96767653.50308006,
          "percentage_of_total_supply": 0.09676765350308006,
          "percentage_of_circulating_supply": 0.21113429236343462
        },
        "0x4d1572ea399cfcb0a4b25b364df2c5ba68697e18": {
          "balance": 96482051.42612956,
          "percentage_of_total_supply": 0.09648205142612956,
          "percentage_of_circulating_supply": 0.21051114619597536
        },
        "0xe52060793969d61f4b4c218ead36f4d80b39bc9b": {
          "balance": 94547497.83138683,
          "percentage_of_total_supply": 0.09454749783138684,
          "percentage_of_circulating_supply": 0.2062902046986997
        },
        "0xfc6bbf4763845e3fe68cad2368f9e1b45f231d32": {
          "balance": 92404225.918883,
          "percentage_of_total_supply": 0.09240422591888302,
          "percentage_of_circulating_supply": 0.201613867284209
        },
        "0x67d21ebd269d61ef8cd9f0f3698869b3d818a4b5": {
          "balance": 88257060.7581283,
          "percentage_of_total_supply": 0.08825706075812831,
          "percentage_of_circulating_supply": 0.19256529836853964
        },
        "0xca695144ed80d2e5f10c8938c08dffbf2516a170": {
          "balance": 86440259.4647455,
          "percentage_of_total_supply": 0.08644025946474551,
          "percentage_of_circulating_supply": 0.1886012769051987
        },
        "0xcbc44e0850fa7819184bfe379bc46f3c84fcf468": {
          "balance": 83973889.75573331,
          "percentage_of_total_supply": 0.08397388975573332,
          "percentage_of_circulating_supply": 0.1832199825948812
        },
        "0x6d7cf6091d4d24c76f594b7b61c771f1aefd5dcc": {
          "balance": 80920791.06258823,
          "percentage_of_total_supply": 0.08092079106258825,
          "percentage_of_circulating_supply": 0.17655852281201692
        },
        "0x0e442c7d7db830276ecc7292bc57456309fe1522": {
          "balance": 80520618.83079892,
          "percentage_of_total_supply": 0.08052061883079893,
          "percentage_of_circulating_supply": 0.17568539963579313
        },
        "0x5845002c17eab202ad17caca7652d33cd46e4dc9": {
          "balance": 80000000.0,
          "percentage_of_total_supply": 0.08000000000000002,
          "percentage_of_circulating_supply": 0.17454947782253652
        },
        "0x7bfdfa0471abf3028122e4be3818bf7abfb81984": {
          "balance": 80000000.0,
          "percentage_of_total_supply": 0.08000000000000002,
          "percentage_of_circulating_supply": 0.17454947782253652
        },
        "0x8c204451184259598631d770f192b66909ce94bd": {
          "balance": 79155537.37327498,
          "percentage_of_total_supply": 0.07915553737327499,
          "percentage_of_circulating_supply": 0.17270697144084277
        },
        "0x1ac08405e96e3561893eef86f194acdb9a24d38d": {
          "balance": 79147388.92317666,
          "percentage_of_total_supply": 0.07914738892317666,
          "percentage_of_circulating_supply": 0.17268919259447119
        },
        "0xb4d7b67215fbf3b44acbc8a660004b1ada5f6229": {
          "balance": 77593838.81771316,
          "percentage_of_total_supply": 0.07759383881771316,
          "percentage_of_circulating_supply": 0.16929955059847368
        },
        "0x378f9daf862c152eb21f14d2c39e10f3ad9b5575": {
          "balance": 77107355.7629605,
          "percentage_of_total_supply": 0.0771073557629605,
          "percentage_of_circulating_supply": 0.1682381085587663
        },
        "0x73d8bd54f7cf5fab43fe4ef40a62d390644946db": {
          "balance": 74981861.68444477,
          "percentage_of_total_supply": 0.07498186168444478,
          "percentage_of_circulating_supply": 0.16360056003976864
        },
        "0x08a312e32c4753509ad7c5cac2aa287013c60792": {
          "balance": 74332591.28301379,
          "percentage_of_total_supply": 0.0743325912830138,
          "percentage_of_circulating_supply": 0.16218393742057607
        },
        "0x217c7970e0946a4b3228fad6bc6f3b6ee0a5c922": {
          "balance": 72437091.83407769,
          "percentage_of_total_supply": 0.07243709183407769,
          "percentage_of_circulating_supply": 0.1580482069327673
        },
        "0x8857d8364867daf23b7ddc370bbdcfc317e1b054": {
          "balance": 71862471.18235187,
          "percentage_of_total_supply": 0.07186247118235188,
          "percentage_of_circulating_supply": 0.15679446024895746
        },
        "0x61ce3b30554d3e0913ed645a51205f47d8208117": {
          "balance": 71641095.03805694,
          "percentage_of_total_supply": 0.07164109503805695,
          "percentage_of_circulating_supply": 0.15631144661909438
        },
        "0x9ed2af9d4ab71740e4d63fab593be7e8701ea169": {
          "balance": 71460328.07642671,
          "percentage_of_total_supply": 0.07146032807642672,
          "percentage_of_circulating_supply": 0.15591703688459282
        },
        "0x40962b448aa899196906646340cb4eb61a8d49b4": {
          "balance": 71185924.80617493,
          "percentage_of_total_supply": 0.07118592480617493,
          "percentage_of_circulating_supply": 0.15531832504040227
        },
        "0x95378eeec67b08755e5859522cad78b0d8543622": {
          "balance": 70485351.82357979,
          "percentage_of_total_supply": 0.0704853518235798,
          "percentage_of_circulating_supply": 0.15378976693679527
        },
        "0x1b14376ee2d46ae5c27a43d902d96d4f3f264b83": {
          "balance": 70455635.58,
          "percentage_of_total_supply": 0.07045563558000001,
          "percentage_of_circulating_supply": 0.15372493000179904
        },
        "0xaa10db8804d076601999c7cd769e02e44a99d5b2": {
          "balance": 70455635.58,
          "percentage_of_total_supply": 0.07045563558000001,
          "percentage_of_circulating_supply": 0.15372493000179904
        },
        "0xef710adc404f7d54b18986b83dd24c9b92440cd2": {
          "balance": 69133545.85512598,
          "percentage_of_total_supply": 0.06913354585512599,
          "percentage_of_circulating_supply": 0.15084030411290777
        },
        "0x45f037560374a81c1efa077674406e2ac5175fa1": {
          "balance": 68996587.87928475,
          "percentage_of_total_supply": 0.06899658787928477,
          "percentage_of_circulating_supply": 0.15054147982332383
        },
        "0xde505839240eab8f0a9fcc3d4d945170eddf777e": {
          "balance": 67138304.93768016,
          "percentage_of_total_supply": 0.06713830493768017,
          "percentage_of_circulating_supply": 0.1464869508595287
        },
        "0x0ce726d2149bbff7820fcda9484d8586d3850151": {
          "balance": 67045197.20526943,
          "percentage_of_total_supply": 0.06704519720526944,
          "percentage_of_circulating_supply": 0.14628380203360955
        },
        "0x33f61fd783a92f04352eed64c43219ef1e327a51": {
          "balance": 66040330.78643921,
          "percentage_of_total_supply": 0.06604033078643921,
          "percentage_of_circulating_supply": 0.14409131567500683
        },
        "0x00b614be96954a30990ffca01817ca63d4a60032": {
          "balance": 64643343.86036297,
          "percentage_of_total_supply": 0.06464334386036297,
          "percentage_of_circulating_supply": 0.14104327394411284
        },
        "0xdffc72801317d3050fdd4c381122dc424c53ea53": {
          "balance": 64285919.3946417,
          "percentage_of_total_supply": 0.0642859193946417,
          "percentage_of_circulating_supply": 0.14026342077095474
        },
        "0xd70d16cef02f72b0b53b2d82d13835dcd0d8c9d9": {
          "balance": 64184525.13535099,
          "percentage_of_total_supply": 0.06418452513535099,
          "percentage_of_circulating_supply": 0.1400421918332873
        },
        "0x14c00dbede6ac88349b20e8eed7c7f7689e11217": {
          "balance": 62536463.506598696,
          "percentage_of_total_supply": 0.0625364635065987,
          "percentage_of_circulating_supply": 0.13644633812431142
        },
        "0xe81078105003d885bbe47ce4bd02ed2cc1696e8a": {
          "balance": 62146983.585155904,
          "percentage_of_total_supply": 0.06214698358515591,
          "percentage_of_circulating_supply": 0.13559654416293387
        },
        "0x088fab6e7f4d007df11dfaed57322c951150da21": {
          "balance": 62139639.39441473,
          "percentage_of_total_supply": 0.062139639394414733,
          "percentage_of_circulating_supply": 0.13558052010469762
        },
        "0x557d36b2bf0177b7c1580315b59ae07b4d957a91": {
          "balance": 61821707.91240501,
          "percentage_of_total_supply": 0.06182170791240501,
          "percentage_of_circulating_supply": 0.13488683542759583
        },
        "0x75d7c724202edb878ceb03333f3fd683beec41eb": {
          "balance": 61108940.223139316,
          "percentage_of_total_supply": 0.06110894022313931,
          "percentage_of_circulating_supply": 0.13333167007796956
        },
        "0xfbfcfee2bf2529e9926e3b047a065cbcf3b907be": {
          "balance": 60574906.18344915,
          "percentage_of_total_supply": 0.06057490618344914,
          "percentage_of_circulating_supply": 0.1321664780433773
        },
        "0xe6715a80e62ba19196838caebacac18b788a5c7b": {
          "balance": 60183736.11000439,
          "percentage_of_total_supply": 0.060183736110004396,
          "percentage_of_circulating_supply": 0.1313129963926325
        },
        "0xbee02128e8364972d704f9f3bc267c54855f6642": {
          "balance": 60000000.0,
          "percentage_of_total_supply": 0.060000000000000005,
          "percentage_of_circulating_supply": 0.1309121083669024
        },
        "0x4b8e9905121861116f8ae70e4b66343eba9b9618": {
          "balance": 59439661.03117748,
          "percentage_of_total_supply": 0.059439661031177496,
          "percentage_of_circulating_supply": 0.12968952243675752
        },
        "0xfcb11f4f6749dd517aaa9f38035fecc1fd91291d": {
          "balance": 59425655.658759095,
          "percentage_of_total_supply": 0.059425655658759104,
          "percentage_of_circulating_supply": 0.12965896455622825
        },
        "0x47413f9b4267ed5e5eb6dfb334377a4bb3118ff4": {
          "balance": 58996262.488708,
          "percentage_of_total_supply": 0.05899626248870801,
          "percentage_of_circulating_supply": 0.12872208513606598
        },
        "0xb8e6d31e7b212b2b7250ee9c26c56cebbfbe6b23": {
          "balance": 58713029.65,
          "percentage_of_total_supply": 0.058713029650000005,
          "percentage_of_circulating_supply": 0.12810410833483254
        },
        "0xe8c15aad9d4cd3f59c9dfa18828b91a8b2c49596": {
          "balance": 58713029.65,
          "percentage_of_total_supply": 0.058713029650000005,
          "percentage_of_circulating_supply": 0.12810410833483254
        },
        "0xdd276dc5223d0120f9bf1776f38957cc8da23cb0": {
          "balance": 58713029.65,
          "percentage_of_total_supply": 0.058713029650000005,
          "percentage_of_circulating_supply": 0.12810410833483254
        },
        "0x9a31b14865918e2b6faa0c49f766a921f36ab977": {
          "balance": 58187704.234438926,
          "percentage_of_total_supply": 0.058187704234438926,
          "percentage_of_circulating_supply": 0.12695791737266887
        },
        "0x4c912a4017e6fbfe0b721bb036ab859a254579e8": {
          "balance": 57856810.06561649,
          "percentage_of_total_supply": 0.05785681006561649,
          "percentage_of_circulating_supply": 0.1262359498178879
        },
        "0x0bb454c2d4e642a5c18f1b3db4d020ba202907df": {
          "balance": 57012566.456595235,
          "percentage_of_total_supply": 0.05701256645659524,
          "percentage_of_circulating_supply": 0.12439392130401698
        },
        "0x0ca03053f859f8199cd1e4005b54fde8a88051ad": {
          "balance": 56627703.58165094,
          "percentage_of_total_supply": 0.05662770358165095,
          "percentage_of_circulating_supply": 0.12355420113083192
        },
        "0xdb2dd3b0645e8c8b3410d6732a3110bf8f9e07a2": {
          "balance": 56019617.96346705,
          "percentage_of_total_supply": 0.05601961796346705,
          "percentage_of_circulating_supply": 0.12222743829176448
        },
        "0x1511afbe08e6abbf4e78fb8a72877019500b7a2c": {
          "balance": 55536718.07563956,
          "percentage_of_total_supply": 0.05553671807563956,
          "percentage_of_circulating_supply": 0.12117381425100386
        },
        "0x6646aaf6430c6c4cfd79f3c164a1607893220e5d": {
          "balance": 55038021.56828745,
          "percentage_of_total_supply": 0.05503802156828745,
          "percentage_of_circulating_supply": 0.12008572406412593
        },
        "0xf86b359035208e4529686a1825f2d5bee38c28a8": {
          "balance": 55000000.0,
          "percentage_of_total_supply": 0.055,
          "percentage_of_circulating_supply": 0.12000276600299385
        },
        "0x21c66caa99be00468b36727072f1ae9d69e40ea6": {
          "balance": 54491745.47401161,
          "percentage_of_total_supply": 0.054491745474011616,
          "percentage_of_circulating_supply": 0.11889382147659117
        },
        "0x33ffa7d3f3c2aacb860be74562734ee2bd2137f0": {
          "balance": 52646443.544241495,
          "percentage_of_total_supply": 0.0526464435442415,
          "percentage_of_circulating_supply": 0.11486761537326251
        },
        "0x25be6c9cbf3b8ddda767ba6a597f8e6d211fc224": {
          "balance": 52173989.49254631,
          "percentage_of_total_supply": 0.05217398949254632,
          "percentage_of_circulating_supply": 0.1138367827730308
        },
        "0xd45ebe9c038f63a1689b9334ece9550972029b43": {
          "balance": 51909342.07654214,
          "percentage_of_total_supply": 0.05190934207654214,
          "percentage_of_circulating_supply": 0.11325935691964817
        },
        "0xeb7a12fe169c98748eb20ce8286eaccf4876643b": {
          "balance": 51456833.383088745,
          "percentage_of_total_supply": 0.05145683338308875,
          "percentage_of_circulating_supply": 0.11227204246774256
        },
        "0x192820ce84fa9eb457fb228c386fe0ed22f7e33c": {
          "balance": 51148517.097032756,
          "percentage_of_total_supply": 0.05114851709703276,
          "percentage_of_circulating_supply": 0.11159933688355186
        },
        "0x2bdf1a698d39a4358e2c162deacc038fadb8a9d5": {
          "balance": 50929150.25951163,
          "percentage_of_total_supply": 0.05092915025951163,
          "percentage_of_circulating_supply": 0.11112070729679067
        },
        "0x95d41776812c6ca222dd5fdea56c065b55ff7655": {
          "balance": 50926833.20778176,
          "percentage_of_total_supply": 0.05092683320778177,
          "percentage_of_circulating_supply": 0.11111565179467146
        },
        "0x4b2926d701810b487c9ca779997841c8d38bb1f5": {
          "balance": 50715104.77839811,
          "percentage_of_total_supply": 0.050715104778398114,
          "percentage_of_circulating_supply": 0.11065368820980771
        },
        "0x15eafc29816b34fb8b15dc6727a26de4c4cb2df0": {
          "balance": 50219302.56127851,
          "percentage_of_total_supply": 0.0502193025612785,
          "percentage_of_circulating_supply": 0.10957191298353916
        },
        "0x0da47666a8311250c7fa713250a828307fe933fe": {
          "balance": 50191044.04357551,
          "percentage_of_total_supply": 0.05019104404357552,
          "percentage_of_circulating_supply": 0.10951025661467546
        },
        "0xb4b6a076241c45e579246bbac2bad516ca3bf17f": {
          "balance": 50119247.35209285,
          "percentage_of_total_supply": 0.05011924735209285,
          "percentage_of_circulating_supply": 0.1093536056770794
        },
        "0x60b27e31e9e475f0b33488cf504acba8b4a71935": {
          "balance": 50000000.0,
          "percentage_of_total_supply": 0.05000000000000001,
          "percentage_of_circulating_supply": 0.10909342363908531
        },
        "0x07213aef29ff39beb0c44ef56d3f2d3432205aab": {
          "balance": 50000000.0,
          "percentage_of_total_supply": 0.05000000000000001,
          "percentage_of_circulating_supply": 0.10909342363908531
        },
        "0x3dc118a44e4bde24d2d62d8ead994c0acc97093f": {
          "balance": 49364521.83777237,
          "percentage_of_total_supply": 0.04936452183777237,
          "percentage_of_circulating_supply": 0.10770689387177958
        },
        "0x94db5f225a1f6968cd33c84580c0adae52a04edf": {
          "balance": 49355264.85580709,
          "percentage_of_total_supply": 0.049355264855807095,
          "percentage_of_circulating_supply": 0.10768669635467644
        },
        "0x7d396d66f3135179e18fd500522a1b8870baf886": {
          "balance": 48863867.49314081,
          "percentage_of_total_supply": 0.04886386749314082,
          "percentage_of_circulating_supply": 0.1066145319414668
        },
        "0x35b2095a0d31516acd5327218c4979be4b4a2207": {
          "balance": 48161710.02401003,
          "percentage_of_total_supply": 0.048161710024010033,
          "percentage_of_circulating_supply": 0.10508251669664216
        },
        "0x21283bd595b73cd5f40d7d88c31e4650cc815ca7": {
          "balance": 48154747.18633436,
          "percentage_of_total_supply": 0.04815474718633436,
          "percentage_of_circulating_supply": 0.1050673247006365
        },
        "0xd3474bd2f558b12e83810ec7d8af14f2d1d08137": {
          "balance": 47736952.46407735,
          "percentage_of_total_supply": 0.04773695246407736,
          "percentage_of_circulating_supply": 0.10415575156804936
        },
        "0xa7888f85bd76deef3bd03d4dbcf57765a49883b3": {
          "balance": 47000000.0,
          "percentage_of_total_supply": 0.04700000000000001,
          "percentage_of_circulating_supply": 0.1025478182207402
        },
        "0xc02595baf5e46519274d5aa4ee7971ade91033d8": {
          "balance": 46769948.0,
          "percentage_of_total_supply": 0.046769948,
          "percentage_of_circulating_supply": 0.10204587501483982
        },
        "0x0b6a06c07c58d13b6c725dbdb9cd1e2f6bac5527": {
          "balance": 45524806.81456702,
          "percentage_of_total_supply": 0.045524806814567026,
          "percentage_of_circulating_supply": 0.09932914071818157
        },
        "0x673a039f6a959fa9db65d16781e6defde30375d9": {
          "balance": 45440498.85392278,
          "percentage_of_total_supply": 0.04544049885392278,
          "percentage_of_circulating_supply": 0.09914519183684736
        },
        "0x29ab425288ea808160cc03a5f7d6503aefe82826": {
          "balance": 45026484.29402661,
          "percentage_of_total_supply": 0.045026484294026614,
          "percentage_of_circulating_supply": 0.09824186652133732
        },
        "0x369e330eadd29a3f48663b38b1607b27b9e5dfeb": {
          "balance": 44448998.14806818,
          "percentage_of_total_supply": 0.044448998148068186,
          "percentage_of_circulating_supply": 0.09698186770600241
        },
        "0x77c838915da2f65a921c589781ace23915ae6cea": {
          "balance": 43688813.839146234,
          "percentage_of_total_supply": 0.04368881383914623,
          "percentage_of_circulating_supply": 0.09532324552886226
        },
        "0xaf72fe65a628e7e0829d2ce0066c0ff964629183": {
          "balance": 43561292.93063866,
          "percentage_of_total_supply": 0.043561292930638665,
          "percentage_of_circulating_supply": 0.09504501167896912
        },
        "0x5392b53c77bb598fff1bdf79714b3be4a6909d19": {
          "balance": 43085597.417172454,
          "percentage_of_total_supply": 0.043085597417172466,
          "percentage_of_circulating_supply": 0.0940071066354935
        },
        "0x97da20dc2bd46174da79d71a385b7248527fbee6": {
          "balance": 42892581.39457087,
          "percentage_of_total_supply": 0.042892581394570875,
          "percentage_of_circulating_supply": 0.09358597106103739
        },
        "0xb026846b57f3f7e9f8da6d56f92e57e29c341603": {
          "balance": 42677506.67413557,
          "percentage_of_total_supply": 0.04267750667413558,
          "percentage_of_circulating_supply": 0.09311670630922725
        },
        "0xc8cef1c4161874efeb0f11d9b4c8b7b8e77924b0": {
          "balance": 42312811.36852884,
          "percentage_of_total_supply": 0.042312811368528845,
          "percentage_of_circulating_supply": 0.09232098911975244
        },
        "0xa376ec9e3705cb9e03be566997cc6ed7e5b8e884": {
          "balance": 42126321.980617866,
          "percentage_of_total_supply": 0.042126321980617866,
          "percentage_of_circulating_supply": 0.09191409380376113
        },
        "0xd9cb768e4e4d57d502556fe24fc1151f8637a6b5": {
          "balance": 42082740.15688376,
          "percentage_of_total_supply": 0.04208274015688376,
          "percentage_of_circulating_supply": 0.09181900399656935
        },
        "0x114925652ccf16d7cbde86691f207064028f8357": {
          "balance": 42000000.0,
          "percentage_of_total_supply": 0.042,
          "percentage_of_circulating_supply": 0.09163847585683166
        },
        "0x6e683f78dcce29844413acce67fd7c27719d19ee": {
          "balance": 41989787.93232296,
          "percentage_of_total_supply": 0.04198978793232296,
          "percentage_of_circulating_supply": 0.09161619446832522
        },
        "0x6bf83eefd5b6d73481644a3f049616b26b0257b4": {
          "balance": 41861919.78093132,
          "percentage_of_total_supply": 0.041861919780931324,
          "percentage_of_circulating_supply": 0.09133720298013091
        },
        "0xfa0ad27c1d9a3a68195571a3fae4758a990c7aa5": {
          "balance": 41788632.0,
          "percentage_of_total_supply": 0.041788632000000006,
          "percentage_of_circulating_supply": 0.09117729868147674
        },
        "0x2a54adc5a26ce16df2f654126bd27acba050e8dd": {
          "balance": 41014250.20966185,
          "percentage_of_total_supply": 0.04101425020966185,
          "percentage_of_circulating_supply": 0.08948769946724168
        },
        "0x605323e3648b562d8f4273b44006f507e9f092b9": {
          "balance": 40984762.3944706,
          "percentage_of_total_supply": 0.04098476239447061,
          "percentage_of_circulating_supply": 0.08942336093294469
        },
        "0x76d87a1bba52aa71d7fc271d4a9088b79bd9be1e": {
          "balance": 40911108.128089346,
          "percentage_of_total_supply": 0.04091110812808935,
          "percentage_of_circulating_supply": 0.08926265701124154
        },
        "0xdc2833bdcb68820dd8270714fe3056012f4b40d0": {
          "balance": 40633801.2484581,
          "percentage_of_total_supply": 0.04063380124845811,
          "percentage_of_circulating_supply": 0.08865760987328868
        },
        "0x6ae90c8a75dca0a2c67a05345b22e72eb64e761b": {
          "balance": 40458647.69761603,
          "percentage_of_total_supply": 0.04045864769761604,
          "percentage_of_circulating_supply": 0.0882754478628106
        },
        "0xc31d5de74c35674faaaa18887c3671ac5b07c72e": {
          "balance": 39364369.80290603,
          "percentage_of_total_supply": 0.03936436980290604,
          "percentage_of_circulating_supply": 0.08588787742388089
        },
        "0xcfd469fae83098f72ed8464cc36a006a2170698f": {
          "balance": 39322971.15163849,
          "percentage_of_total_supply": 0.0393229711516385,
          "percentage_of_circulating_supply": 0.08579755101186458
        },
        "0xa201c90419124cdebfb7fb7d2d289793c9bc5360": {
          "balance": 39263734.04357735,
          "percentage_of_total_supply": 0.03926373404357735,
          "percentage_of_circulating_supply": 0.0856683034333672
        },
        "0x0a7a29432241895997ce9ba9e450d68d971f77f9": {
          "balance": 38869732.60624559,
          "percentage_of_total_supply": 0.03886973260624559,
          "percentage_of_circulating_supply": 0.08480864411902235
        },
        "0x4fef654560d6ad788f4b35a5cd02ed185c12fbbf": {
          "balance": 38232750.26505342,
          "percentage_of_total_supply": 0.038232750265053426,
          "percentage_of_circulating_supply": 0.08341883243105648
        },
        "0x82ee15e7c0c923e512eb0c554a50e08254ebd660": {
          "balance": 38000000.63260818,
          "percentage_of_total_supply": 0.03800000063260819,
          "percentage_of_circulating_supply": 0.08291100334597269
        },
        "0x33c8566d9eeac4265900b6e3ad8aee2b99538a3c": {
          "balance": 37915163.603190355,
          "percentage_of_total_supply": 0.03791516360319036,
          "percentage_of_circulating_supply": 0.08272590010616147
        },
        "0x6442c1aad456f29e7631398283c6e87ff24942b8": {
          "balance": 37499917.98813887,
          "percentage_of_total_supply": 0.03749991798813887,
          "percentage_of_circulating_supply": 0.08181988879021979
        },
        "0x85074968d0ff84f4a0ccc6ee50327ed8f7a8ef32": {
          "balance": 37351419.07434834,
          "percentage_of_total_supply": 0.037351419074348344,
          "percentage_of_circulating_supply": 0.0814958836919779
        },
        "0x157799def165c794ed1939287e10b3b460880e28": {
          "balance": 37162252.804377556,
          "percentage_of_total_supply": 0.03716225280437756,
          "percentage_of_circulating_supply": 0.08108314777141494
        },
        "0x030c8e0a7575d7d4a808a95f845f8683dc242b0f": {
          "balance": 37138424.013463795,
          "percentage_of_total_supply": 0.0371384240134638,
          "percentage_of_circulating_supply": 0.08103115648377571
        },
        "0x7fbbcd7193bd24a187ed27473c3466fae646cdb5": {
          "balance": 37133114.80728824,
          "percentage_of_total_supply": 0.037133114807288245,
          "percentage_of_circulating_supply": 0.08101957249420576
        },
        "0x51640054ce9dd311c199701089b765a5390df1cf": {
          "balance": 36981334.793853246,
          "percentage_of_total_supply": 0.03698133479385325,
          "percentage_of_circulating_supply": 0.08068840846809357
        },
        "0x37eec60a6d731beb8bb08449d8aaf8a1671e6fcb": {
          "balance": 36352482.10283599,
          "percentage_of_total_supply": 0.03635248210283599,
          "percentage_of_circulating_supply": 0.07931633460753906
        },
        "0xb332c90b5346228c70941c6762badde857e1ef37": {
          "balance": 36158559.383351184,
          "percentage_of_total_supply": 0.03615855938335119,
          "percentage_of_circulating_supply": 0.07889322073973908
        },
        "0x700570ada3fefb97acb2388acaf425790b4f11a9": {
          "balance": 35769126.05711937,
          "percentage_of_total_supply": 0.03576912605711937,
          "percentage_of_circulating_supply": 0.07804352844298337
        },
        "0xb1d9080628628f29652e3ea18de97e94085a3833": {
          "balance": 35599406.40319627,
          "percentage_of_total_supply": 0.035599406403196275,
          "percentage_of_circulating_supply": 0.07767322248087713
        },
        "0xc46bfd225ad359f78c7fe84d50619977c6b7f318": {
          "balance": 35565984.02020021,
          "percentage_of_total_supply": 0.03556598402020021,
          "percentage_of_circulating_supply": 0.0776002992371328
        },
        "0xc0f556d00399b231344dc90d1bedcf55c1f23cc3": {
          "balance": 35487032.67070465,
          "percentage_of_total_supply": 0.03548703267070465,
          "percentage_of_circulating_supply": 0.07742803777678486
        },
        "0xe524f93e5dab234dfa56ef67f846119400df8cee": {
          "balance": 35471829.87889946,
          "percentage_of_total_supply": 0.035471829878899463,
          "percentage_of_circulating_supply": 0.07739486728464687
        },
        "0x7f65ec8d350fb9c890aecee078dbd17f35f00853": {
          "balance": 35296214.86014559,
          "percentage_of_total_supply": 0.0352962148601456,
          "percentage_of_circulating_supply": 0.07701169841188082
        },
        "0xdf49f03b61ba642257295c0dcc28c58411de5713": {
          "balance": 35082908.40356945,
          "percentage_of_total_supply": 0.03508290840356945,
          "percentage_of_circulating_supply": 0.07654629177923657
        },
        "0x890f1815a0935b10126bcfe6dd48ce37ed3064ed": {
          "balance": 34282657.33835608,
          "percentage_of_total_supply": 0.03428265733835608,
          "percentage_of_circulating_supply": 0.07480024920973752
        },
        "0x960550782966ee4aa1f6451569baab8f288434f4": {
          "balance": 33959224.328075185,
          "percentage_of_total_supply": 0.03395922432807519,
          "percentage_of_circulating_supply": 0.07409456092154877
        },
        "0x872188771f683b455f0cf215db0c4c81ae7c6015": {
          "balance": 33945415.90160381,
          "percentage_of_total_supply": 0.03394541590160382,
          "percentage_of_circulating_supply": 0.07406443275117215
        },
        "0xe819da56003d33b90d9a8ea667a7e6aaecbc5e5c": {
          "balance": 33789099.78931798,
          "percentage_of_total_supply": 0.03378909978931798,
          "percentage_of_circulating_supply": 0.0737233715539879
        }
      },
      "total_supply": 99999999999.99998,
      "total_circulating_supply": 45832276898.207375,
      "owner": {},
      "creator": {},
      "holders_exceeding_5_percent_circulating": [
        {
          "address": "0x0000000000c5dc95539589fbd24be07c6c14eca4",
          "balance": 54167723101.7926,
          "percentage_of_supply": 118.18684727817057
        },
        {
          "address": "0x000000f534caa75bd1a3950ab32d6bd24d2e6b76",
          "balance": 5879519336.183425,
          "percentage_of_supply": 12.82833787472904
        },
        {
          "address": "0xc4ce8e63921b8b6cbdb8fcb6bd64cc701fb926f2",
          "balance": 4697469387.944212,
          "percentage_of_supply": 10.249260359412654
        }
      ],
      "howmany_holders_exceeding_5_percent_circulating": 3,
      "top_10_holders": [
        {
          "address": "0x0000000000c5dc95539589fbd24be07c6c14eca4",
          "balance": 54167723101.7926,
          "percentage_of_total_supply": 54.16772310179261,
          "percentage_of_circulating_supply": 118.18684727817057
        },
        {
          "address": "0x000000f534caa75bd1a3950ab32d6bd24d2e6b76",
          "balance": 5879519336.183425,
          "percentage_of_total_supply": 5.879519336183425,
          "percentage_of_circulating_supply": 12.82833787472904
        },
        {
          "address": "0xc4ce8e63921b8b6cbdb8fcb6bd64cc701fb926f2",
          "balance": 4697469387.944212,
          "percentage_of_total_supply": 4.697469387944213,
          "percentage_of_circulating_supply": 10.249260359412654
        },
        {
          "address": "0xf766e3c30c09be842244fd32864a811d06b314e1",
          "balance": 599999960.4300001,
          "percentage_of_total_supply": 0.59999996043,
          "percentage_of_circulating_supply": 1.3091209973324884
        },
        {
          "address": "0x2933782b5a8d72f2754103d1489614f29bfa4625",
          "balance": 462491856.43925905,
          "percentage_of_total_supply": 0.4624918564392591,
          "percentage_of_circulating_supply": 1.0090964004831025
        },
        {
          "address": "0x7a7428d466a18fe41f74cbcce0635ad468432f73",
          "balance": 423000000.0,
          "percentage_of_total_supply": 0.42300000000000004,
          "percentage_of_circulating_supply": 0.9229303639866617
        },
        {
          "address": "0x713388239281bb11ed72a9a449c066a184d1f603",
          "balance": 420935559.0,
          "percentage_of_total_supply": 0.420935559,
          "percentage_of_circulating_supply": 0.9184260252548436
        },
        {
          "address": "0xfb94d3404c1d3d9d6f08f79e58041d5ea95accfa",
          "balance": 404221981.9750266,
          "percentage_of_total_supply": 0.4042219819750266,
          "percentage_of_circulating_supply": 0.8819591984766457
        },
        {
          "address": "0xbbbbbbbbbb9cc5e90e3b3af64bdaf62c37eeffcb",
          "balance": 397899487.8540407,
          "percentage_of_total_supply": 0.3978994878540408,
          "percentage_of_circulating_supply": 0.8681643478847189
        },
        {
          "address": "0x0b5305f909b57f483e0b2c9614cc625943c4bc9a",
          "balance": 365753456.76152164,
          "percentage_of_total_supply": 0.3657534567615217,
          "percentage_of_circulating_supply": 0.798025936118891
        }
      ],
      "total_top_10_balance": 67819014128.38009,
      "top10_percentage_of_total_supply": 67.81901412838009,
      "top10_percentage_of_circulating_supply": 147.97216878184963,
      "top_10_less_than_70_percent_of_total": true,
      "top_10_less_than_70_percent_of_circulating": false
    },
    "liquidity": {
      "price_usd": 0.001038,
      "liquidity_usd": 11682718.21,
      "market_cap_usd": 47573903.42033926,
      "liquidity_to_market_cap_ratio": 0.24556988958373535,
      "token_volume": 0.0,
      "volume_usd": 0.0,
      "volume_to_liquidity_ratio": 0.0,
      "locked_liquidity_percent": 0.0,
      "locked_95_for_15_days": false,
      "creator_under_5_percent": true,
      "creator_percent_of_lp": 0.0,
      "owner_under_5_percent": true,
      "owner_percent_of_lp": 0.0,
      "total_lp_supply": 1893167.5166553876,
      "lp_holders_count": 10,
      "lp_holders": [
        {
          "address": "0xd5cd18d3cb65fdab15076618401ff79097f9d780",
          "balance": 1855127.8767064407,
          "is_locked": false,
          "percent": 98.40759934006489,
          "tag": ""
        },
        {
          "address": "0x4258c08011d136191b0f5777b3b297331256c24e",
          "balance": 5936.13068986778,
          "is_locked": false,
          "percent": 0.36493713862879196,
          "tag": ""
        },
        {
          "address": "0xbcfd27639e8a3b47118439773ac35de7d6801ac2",
          "balance": 2847.2400906425523,
          "is_locked": false,
          "percent": 0.17504056193402628,
          "tag": ""
        },
        {
          "address": "0x66823a962551cc8a17eedfe1ef4f25018ef3dec2",
          "balance": 2702.5059215308515,
          "is_locked": false,
          "percent": 0.1661426996232125,
          "tag": ""
        },
        {
          "address": "0x5670d6fbf43877470a5e1295267adfb741408eb7",
          "balance": 2614.8099675457092,
          "is_locked": false,
          "percent": 0.160751391347051,
          "tag": ""
        },
        {
          "address": "0x2da32d38bf568fd8f21e15f69add0186f6642d0c",
          "balance": 2112.1508662009574,
          "is_locked": false,
          "percent": 0.129849279561746,
          "tag": ""
        },
        {
          "address": "0xe12e2bdfb39eecc25270ed301a1d66bfd60b7969",
          "balance": 2034.1256026974381,
          "is_locked": false,
          "percent": 0.1250524989833916,
          "tag": ""
        },
        {
          "address": "0x503d66ea74445af5e9ada4005f3826591f10b98e",
          "balance": 1704.617281462911,
          "is_locked": false,
          "percent": 0.1047952253167325,
          "tag": ""
        },
        {
          "address": "0xb910711151298056c1fc9fadc8310e7ef1f2731c",
          "balance": 1199.8414430154637,
          "is_locked": false,
          "percent": 0.0737629823025438,
          "tag": ""
        },
        {
          "address": "0x0cbecf33aa32a2241181dceca21fc636f6660f8a",
          "balance": 1082.4523182069406,
          "is_locked": false,
          "percent": 0.06654621879919259,
          "tag": ""
        }
      ],
      "error": "Liquidity pool info could not be retrieved."
    },
    "security": {
      "warnings": [],
      "homany_warnings": 0,
      "suspicious_urls": {
        "https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n///": "metamask recovery phrase phishing",
        "https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n///": "metamask recovery phrase phishing",
        "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n///": "metamask recovery phrase phishing",
        "https://github.com/Uniswap/permit2)\\n": "metamask recovery phrase phishing",
        "https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n": "metamask recovery phrase phishing",
        "https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n///": "metamask recovery phrase phishing",
        "https://eips.ethereum.org/EIPS/eip-173)": "metamask recovery phrase phishing",
        "https://eips.ethereum.org/EIPS/eip-173),\\n": "metamask recovery phrase phishing",
        "https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n///": "metamask recovery phrase phishing",
        "https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary": "metamask recovery phrase phishing",
        "https://2\u03c0.com/22/exp-ln\\n": "metamask recovery phrase phishing",
        "https://en.wikipedia.org/wiki/Lambert_W_function\\n": "metamask recovery phrase phishing",
        "https://2\u03c0.com/21/muldiv\\n": "metamask recovery phrase phishing",
        "https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol\\n": "metamask recovery phrase phishing",
        "https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n": "metamask recovery phrase phishing",
        "https://github.com/pcaversaccio/snekmate/blob/main/src/utils/Math.vy\\n": "metamask recovery phrase phishing",
        "https://github.com/vectorized/solady/blob/main/audits/xuwinnie-solady-cbrt-proof.pdf\\n": "metamask recovery phrase phishing",
        "https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n///": "metamask recovery phrase phishing",
        "https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///": "metamask recovery phrase phishing",
        "https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\\n///\\n///": "metamask recovery phrase phishing",
        "https://eips.ethereum.org/EIPS/eip-4758.\\n": "metamask recovery phrase phishing",
        "https://github.com/vectorized/soledge/blob/main/src/utils/ReentrancyGuard.sol)\\n///\\n///": "metamask recovery phrase phishing"
      },
      "howmany_suspicious_urls": 22,
      "suspicious_addresses": {},
      "howmany_suspicious_addresses": 0,
      "howmany_warnings": 0
    },
    "lifecycle": {
      "token_age_seconds": 23194493.071881,
      "token_creation_date": null,
      "creation_to_first_trade_seconds": null,
      "creation_to_first_trade_blocks": null,
      "last_tx_hash": "0xd22367163cf04720cda80a8c9a68efe1a5e58bd0702940baf66d498f9d42c12c",
      "last_active_age": "2025-08-28T13:02:23",
      "inactive_days": 0.006891511828703703
    }
  },
  "errors": []
}