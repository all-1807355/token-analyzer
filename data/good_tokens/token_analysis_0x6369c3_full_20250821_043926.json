{
    "token_address": "0x6369c3dadfc00054a42ba8b2c09c48131dd4aa38",
    "chain": "eth",
    "token_name": "Morpher",
    "analyses": {
        "contract": {
            "contract_name": "MorpherToken",
            "compiler_version": "v0.5.16+commit.9c3226ce",
            "license_type": "GNU GPLv2",
            "implementation": "",
            "source_code": "{\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see {ERC20Detailed}.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IMorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\ninterface IMorpherToken {\\r\\n    /**\\r\\n     * Emits a {Transfer} event in ERC-20 token contract.\\r\\n     */\\r\\n    function emitTransfer(address _from, address _to, uint256 _amount) external;\\r\\n}\"},\"MorpherState.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IMorpherToken.sol\\\";\\r\\n\\r\\n// ----------------------------------------------------------------------------------\\r\\n// Data and token balance storage of the Morpher platform\\r\\n// Writing access is only granted to platform contracts. The contract can be paused\\r\\n// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\\r\\n// ----------------------------------------------------------------------------------\\r\\n\\r\\ncontract MorpherState is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    bool public mainChain;\\r\\n    uint256 public totalSupply;\\r\\n    uint256 public totalToken;\\r\\n    uint256 public totalInPositions;\\r\\n    uint256 public totalOnOtherChain;\\r\\n    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\\r\\n    uint256 constant PRECISION = 10**8;\\r\\n    uint256 constant DECIMALS = 18;\\r\\n    uint256 constant REWARDPERIOD = 1 days;\\r\\n    bool public paused = false;\\r\\n\\r\\n    address public morpherGovernance;\\r\\n    address public morpherRewards;\\r\\n    address public administrator;\\r\\n    address public oracleContract;\\r\\n    address public sideChainOperator;\\r\\n    address public morpherBridge;\\r\\n    address public morpherToken;\\r\\n\\r\\n    uint256 public rewardBasisPoints;\\r\\n    uint256 public lastRewardTime;\\r\\n\\r\\n    bytes32 public sideChainMerkleRoot;\\r\\n    uint256 public sideChainMerkleRootWrittenAtTime;\\r\\n\\r\\n    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\\r\\n    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\\r\\n\\r\\n    mapping(address =\\u003e bool) private stateAccess;\\r\\n    mapping(address =\\u003e bool) private transferAllowed;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowed;\\r\\n\\r\\n    mapping(bytes32 =\\u003e bool) private marketActive;\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Position struct records virtual futures\\r\\n    // ----------------------------------------------------------------------------\\r\\n    struct position {\\r\\n        uint256 lastUpdated;\\r\\n        uint256 longShares;\\r\\n        uint256 shortShares;\\r\\n        uint256 meanEntryPrice;\\r\\n        uint256 meanEntrySpread;\\r\\n        uint256 meanEntryLeverage;\\r\\n        uint256 liquidationPrice;\\r\\n        bytes32 positionHash;\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // A portfolio is an address specific collection of postions\\r\\n    // ----------------------------------------------------------------------------\\r\\n    mapping(address =\\u003e mapping(bytes32 =\\u003e position)) private portfolio;\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Record all addresses that hold a position of a market, needed for clean stock splits\\r\\n    // ----------------------------------------------------------------------------\\r\\n    struct hasExposure {\\r\\n        uint256 maxMappingIndex;\\r\\n        mapping(address =\\u003e uint256) index;\\r\\n        mapping(uint256 =\\u003e address) addy;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 =\\u003e hasExposure) private exposureByMarket;\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Bridge Variables\\r\\n    // ----------------------------------------------------------------------------\\r\\n    mapping (address =\\u003e uint256) private tokenClaimedOnThisChain;\\r\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChain;\\r\\n    mapping (address =\\u003e uint256) private tokenSentToLinkedChainTime;\\r\\n    mapping (bytes32 =\\u003e bool) private positionClaimedOnMainChain;\\r\\n\\r\\n    uint256 public lastWithdrawLimitReductionTime;\\r\\n    uint256 public last24HoursAmountWithdrawn;\\r\\n    uint256 public withdrawLimit24Hours;\\r\\n    uint256 public inactivityPeriod = 3 days;\\r\\n    uint256 public transferNonce;\\r\\n    bool public fastTransfersEnabled;\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Sidechain spam protection\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    mapping(address =\\u003e uint256) private lastRequestBlock;\\r\\n    mapping(address =\\u003e uint256) private numberOfRequests;\\r\\n    uint256 public numberOfRequestsLimit;\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Events\\r\\n    // ----------------------------------------------------------------------------\\r\\n    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\\r\\n    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\\r\\n\\r\\n    event TransfersEnabled(address indexed whiteList);\\r\\n    event TransfersDisabled(address indexed blackList);\\r\\n\\r\\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\\r\\n    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\\r\\n    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\\r\\n    event NewTotalSupply(uint256 newTotalSupply);\\r\\n    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\\r\\n    event NewTotalInPositions(uint256 newTotalOnOtherChain);\\r\\n    event OperatingRewardMinted(address indexed recipient, uint256 amount);\\r\\n\\r\\n    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\\r\\n    event LastRewardTime(uint256 indexed rewardsTime);\\r\\n    event GovernanceChange(address indexed governanceAddress);\\r\\n    event TokenChange(address indexed tokenAddress);\\r\\n    event AdministratorChange(address indexed administratorAddress);\\r\\n    event OracleChange(address indexed oracleContract);\\r\\n    event MaximumLeverageChange(uint256 maxLeverage);\\r\\n    event MarketActivated(bytes32 indexed activateMarket);\\r\\n    event MarketDeActivated(bytes32 indexed deActivateMarket);\\r\\n    event BridgeChange(address _bridgeAddress);\\r\\n    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\\r\\n    event NewSideChainOperator(address indexed sideChainOperator);\\r\\n    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\\r\\n\\r\\n    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\\r\\n    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\\r\\n    event TransferredTokenClaimed(address _address, uint256 _token);\\r\\n    event LastWithdrawAt();\\r\\n    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\\r\\n    event WithdrawLimitUpdated(uint256 _amount);\\r\\n    event InactivityPeriodUpdated(uint256 _periodLength);\\r\\n    event FastWithdrawsDisabled();\\r\\n    event NewBridgeNonce(uint256 _transferNonce);\\r\\n    event Last24HoursAmountWithdrawnReset();\\r\\n\\r\\n    event StatePaused(address administrator, bool _paused);\\r\\n\\r\\n    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\\r\\n    event SetPosition(bytes32 indexed positionHash,\\r\\n        address indexed sender,\\r\\n        bytes32 indexed marketId,\\r\\n        uint256 timeStamp,\\r\\n        uint256 longShares,\\r\\n        uint256 shortShares,\\r\\n        uint256 meanEntryPrice,\\r\\n        uint256 meanEntrySpread,\\r\\n        uint256 meanEntryLeverage,\\r\\n        uint256 liquidationPrice\\r\\n    );\\r\\n    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\\r\\n    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\\r\\n\\r\\n    modifier notPaused {\\r\\n        require(paused == false, \\\"MorpherState: Contract paused, aborting\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPlatform {\\r\\n        require(stateAccess[msg.sender] == true, \\\"MorpherState: Only Platform is allowed to execute operation.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyGovernance {\\r\\n        require(msg.sender == getGovernance(), \\\"MorpherState: Calling contract not the Governance Contract. Aborting.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdministrator {\\r\\n        require(msg.sender == getAdministrator(), \\\"MorpherState: Caller is not the Administrator. Aborting.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySideChainOperator {\\r\\n        require(msg.sender == sideChainOperator, \\\"MorpherState: Caller is not the Sidechain Operator. Aborting.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier canTransfer {\\r\\n        require(getCanTransfer(msg.sender), \\\"MorpherState: Caller may not transfer token. Aborting.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyBridge {\\r\\n        require(msg.sender == getMorpherBridge(), \\\"MorpherState: Caller is not the Bridge. Aborting.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMainChain {\\r\\n        require(mainChain == true, \\\"MorpherState: Can only be called on mainchain.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySideChain {\\r\\n        require(mainChain == false, \\\"MorpherState: Can only be called on mainchain.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\\r\\n        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\\r\\n        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\\r\\n        setLastRewardTime(now);\\r\\n        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\\r\\n        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\\r\\n        grantAccess(owner());\\r\\n        setSideChainOperator(owner());\\r\\n        if (mainChain == false) { // Create token only on sidechain\\r\\n            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\\r\\n            totalToken = _sideChainMint;\\r\\n            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\\r\\n            setRewardBasisPoints(0); // Reward is minted on mainchain\\r\\n            setRewardAddress(address(0));\\r\\n            setTotalOnOtherChain(_mainChainMint);\\r\\n        } else {\\r\\n            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\\r\\n            totalToken = _mainChainMint;\\r\\n            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\\r\\n            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\\r\\n            setRewardAddress(_morpherTreasury);\\r\\n            setTotalOnOtherChain(_sideChainMint);\\r\\n        }\\r\\n        fastTransfersEnabled = true;\\r\\n        setNumberOfRequestsLimit(3);\\r\\n        setMainChainWithdrawLimit(totalSupply / 50);\\r\\n        setSideChainOperator(_sideChainOperator);\\r\\n        denyAccess(owner());\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for market wise exposure\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\\r\\n        return exposureByMarket[_marketId].maxMappingIndex;\\r\\n    }\\r\\n\\r\\n    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\\r\\n        return exposureByMarket[_marketId].index[_address];\\r\\n    }\\r\\n\\r\\n    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\\r\\n        return exposureByMarket[_marketId].addy[_mappingIndex];\\r\\n    }\\r\\n\\r\\n    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\\r\\n        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\\r\\n    }\\r\\n\\r\\n    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\\r\\n        setExposureMappingIndex(_marketId, _address, _index);\\r\\n        setExposureMappingAddress(_marketId, _address, _index);\\r\\n    }\\r\\n\\r\\n    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\r\\n        exposureByMarket[_marketId].index[_address] = _index;\\r\\n    }\\r\\n\\r\\n    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\\r\\n        exposureByMarket[_marketId].addy[_index] = _address;\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for bridge variables\\r\\n    // ----------------------------------------------------------------------------\\r\\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\\r\\n        tokenClaimedOnThisChain[_address] = _token;\\r\\n        emit TransferredTokenClaimed(_address, _token);\\r\\n    }\\r\\n\\r\\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\\r\\n        return tokenClaimedOnThisChain[_address];\\r\\n    }\\r\\n\\r\\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\\r\\n        tokenSentToLinkedChain[_address] = _token;\\r\\n        tokenSentToLinkedChainTime[_address] = now;\\r\\n        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\\r\\n    }\\r\\n\\r\\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\\r\\n        return tokenSentToLinkedChain[_address];\\r\\n    }\\r\\n\\r\\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\\r\\n        return tokenSentToLinkedChainTime[_address];\\r\\n    }\\r\\n\\r\\n    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\\r\\n        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\\r\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\r\\n    }\\r\\n\\r\\n    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\\r\\n        if (last24HoursAmountWithdrawn \\u003e _amount) {\\r\\n            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\\r\\n        } else {\\r\\n            last24HoursAmountWithdrawn = 0;\\r\\n        }\\r\\n        lastWithdrawLimitReductionTime = now;\\r\\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\\r\\n    }\\r\\n\\r\\n    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\\r\\n        withdrawLimit24Hours = _limit;\\r\\n        emit WithdrawLimitUpdated(_limit);\\r\\n    }\\r\\n\\r\\n    function resetLast24HoursAmountWithdrawn() public onlyBridge {\\r\\n        last24HoursAmountWithdrawn = 0;\\r\\n        emit Last24HoursAmountWithdrawnReset();\\r\\n    }\\r\\n\\r\\n    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\\r\\n        inactivityPeriod = _periodLength;\\r\\n        emit InactivityPeriodUpdated(_periodLength);\\r\\n    }\\r\\n\\r\\n    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\\r\\n        transferNonce++;\\r\\n        emit NewBridgeNonce(transferNonce);\\r\\n        return transferNonce;\\r\\n    }\\r\\n\\r\\n    function disableFastWithdraws() public onlyBridge {\\r\\n        fastTransfersEnabled = false;\\r\\n        emit FastWithdrawsDisabled();\\r\\n    }\\r\\n\\r\\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\\r\\n        positionClaimedOnMainChain[_positionHash] = true;\\r\\n    }\\r\\n\\r\\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\\r\\n        return positionClaimedOnMainChain[_positionHash];\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for spam protection\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function setLastRequestBlock(address _address) public onlyPlatform {\\r\\n        lastRequestBlock[_address] = block.number;\\r\\n    }\\r\\n\\r\\n    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\\r\\n        return lastRequestBlock[_address];\\r\\n    }\\r\\n\\r\\n    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\\r\\n        numberOfRequests[_address] = _numberOfRequests;\\r\\n    }\\r\\n\\r\\n    function increaseNumberOfRequests(address _address) public onlyPlatform{\\r\\n        numberOfRequests[_address]++;\\r\\n    }\\r\\n\\r\\n    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\\r\\n        return numberOfRequests[_address];\\r\\n    }\\r\\n\\r\\n    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\\r\\n        numberOfRequestsLimit = _numberOfRequestsLimit;\\r\\n        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\\r\\n    }\\r\\n\\r\\n    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\\r\\n        return numberOfRequestsLimit;\\r\\n    }\\r\\n\\r\\n    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyOwner {\\r\\n        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\\r\\n        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\\r\\n    }\\r\\n\\r\\n    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\\r\\n        return mainChainWithdrawLimit24;\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for state access\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function grantAccess(address _address) public onlyOwner {\\r\\n        stateAccess[_address] = true;\\r\\n        emit StateAccessGranted(_address, block.number);\\r\\n    }\\r\\n\\r\\n    function denyAccess(address _address) public onlyOwner {\\r\\n        stateAccess[_address] = false;\\r\\n        emit StateAccessDenied(_address, block.number);\\r\\n    }\\r\\n\\r\\n    function getStateAccess(address _address) public view returns(bool _hasAccess) {\\r\\n        return stateAccess[_address];\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function enableTransfers(address _address) public onlyOwner {\\r\\n        transferAllowed[_address] = true;\\r\\n        emit TransfersEnabled(_address);\\r\\n    }\\r\\n\\r\\n    function disableTransfers(address _address) public onlyOwner {\\r\\n        transferAllowed[_address] = false;\\r\\n        emit TransfersDisabled(_address);\\r\\n    }\\r\\n\\r\\n    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\\r\\n        return transferAllowed[_address];\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Minting/burning/transfer of token\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\\r\\n        require(balances[_from] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\r\\n        balances[_from] = balances[_from].sub(_token);\\r\\n        balances[_to] = balances[_to].add(_token);\\r\\n        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\\r\\n        emit Transfer(_from, _to, _token);\\r\\n        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\\r\\n        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\\r\\n    }\\r\\n\\r\\n    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\\r\\n        balances[_address] = balances[_address].add(_token);\\r\\n        totalToken = totalToken.add(_token);\\r\\n        updateTotalSupply();\\r\\n        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\\r\\n        emit Mint(_address, _token, totalToken);\\r\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\r\\n    }\\r\\n\\r\\n    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\\r\\n        require(balances[_address] \\u003e= _token, \\\"MorpherState: Not enough token.\\\");\\r\\n        balances[_address] = balances[_address].sub(_token);\\r\\n        totalToken = totalToken.sub(_token);\\r\\n        updateTotalSupply();\\r\\n        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\\r\\n        emit Burn(_address, _token, totalToken);\\r\\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for balance and token functions (ERC20)\\r\\n    // ----------------------------------------------------------------------------\\r\\n    function updateTotalSupply() private {\\r\\n        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\\r\\n        emit NewTotalSupply(totalSupply);\\r\\n    }\\r\\n\\r\\n    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\\r\\n        totalInPositions = _totalInPositions;\\r\\n        updateTotalSupply();\\r\\n        emit NewTotalInPositions(_totalInPositions);\\r\\n    }\\r\\n\\r\\n    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\\r\\n        totalOnOtherChain = _newTotalOnOtherChain;\\r\\n        updateTotalSupply();\\r\\n        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\\r\\n        return balances[_tokenOwner];\\r\\n    }\\r\\n\\r\\n    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\\r\\n        allowed[_from][_spender] = _tokens;\\r\\n        emit SetAllowance(_from, _spender, _tokens);\\r\\n    }\\r\\n\\r\\n    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\\r\\n        return allowed[_tokenOwner][spender];\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for platform roles\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function setGovernanceContract(address _newGovernanceContractAddress) public onlyOwner {\\r\\n        morpherGovernance = _newGovernanceContractAddress;\\r\\n        emit GovernanceChange(_newGovernanceContractAddress);\\r\\n    }\\r\\n\\r\\n    function getGovernance() public view returns (address _governanceContract) {\\r\\n        return morpherGovernance;\\r\\n    }\\r\\n\\r\\n    function setMorpherBridge(address _newBridge) public onlyOwner {\\r\\n        morpherBridge = _newBridge;\\r\\n        emit BridgeChange(_newBridge);\\r\\n    }\\r\\n\\r\\n    function getMorpherBridge() public view returns (address _currentBridge) {\\r\\n        return morpherBridge;\\r\\n    }\\r\\n\\r\\n    function setOracleContract(address _newOracleContract) public onlyGovernance {\\r\\n        oracleContract = _newOracleContract;\\r\\n        emit OracleChange(_newOracleContract);\\r\\n    }\\r\\n\\r\\n    function getOracleContract() public view returns(address) {\\r\\n        return oracleContract;\\r\\n    }\\r\\n\\r\\n    function setTokenContract(address _newTokenContract) public onlyOwner {\\r\\n        morpherToken = _newTokenContract;\\r\\n        emit TokenChange(_newTokenContract);\\r\\n    }\\r\\n\\r\\n    function getTokenContract() public view returns(address) {\\r\\n        return morpherToken;\\r\\n    }\\r\\n\\r\\n    function setAdministrator(address _newAdministrator) public onlyGovernance {\\r\\n        administrator = _newAdministrator;\\r\\n        emit AdministratorChange(_newAdministrator);\\r\\n    }\\r\\n\\r\\n    function getAdministrator() public view returns(address) {\\r\\n        return administrator;\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for platform operating rewards\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function setRewardAddress(address _newRewardsAddress) public onlyOwner {\\r\\n        morpherRewards = _newRewardsAddress;\\r\\n        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\\r\\n    }\\r\\n\\r\\n    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyOwner {\\r\\n        if (mainChain == true) {\\r\\n            require(_newRewardBasisPoints \\u003c= 15000, \\\"MorpherState: Reward basis points need to be less or equal to 15000.\\\");\\r\\n        } else {\\r\\n            require(_newRewardBasisPoints == 0, \\\"MorpherState: Reward basis points can only be set on Ethereum.\\\");\\r\\n        }\\r\\n        rewardBasisPoints = _newRewardBasisPoints;\\r\\n        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\\r\\n    }\\r\\n\\r\\n    function setLastRewardTime(uint256 _lastRewardTime) private {\\r\\n        lastRewardTime = _lastRewardTime;\\r\\n        emit LastRewardTime(_lastRewardTime);\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for platform administration\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\\r\\n        marketActive[_activateMarket] = true;\\r\\n        emit MarketActivated(_activateMarket);\\r\\n    }\\r\\n\\r\\n    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\\r\\n        marketActive[_deActivateMarket] = false;\\r\\n        emit MarketDeActivated(_deActivateMarket);\\r\\n    }\\r\\n\\r\\n    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\\r\\n        return marketActive[_marketId];\\r\\n    }\\r\\n\\r\\n    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\\r\\n        require(_newMaximumLeverage \\u003e PRECISION, \\\"MorpherState: Leverage precision is 1e8\\\");\\r\\n        maximumLeverage = _newMaximumLeverage;\\r\\n        emit MaximumLeverageChange(_newMaximumLeverage);\\r\\n    }\\r\\n\\r\\n    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\\r\\n        return maximumLeverage;\\r\\n    }\\r\\n\\r\\n    function pauseState() public onlyAdministrator {\\r\\n        paused = true;\\r\\n        emit StatePaused(msg.sender, true);\\r\\n    }\\r\\n\\r\\n    function unPauseState() public onlyAdministrator {\\r\\n        paused = false;\\r\\n        emit StatePaused(msg.sender, false);\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter for side chain state\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\\r\\n        sideChainMerkleRoot = _sideChainMerkleRoot;\\r\\n        sideChainMerkleRootWrittenAtTime = now;\\r\\n        payOperatingReward;\\r\\n        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\\r\\n    }\\r\\n\\r\\n    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\\r\\n        return sideChainMerkleRoot;\\r\\n    }\\r\\n\\r\\n    function setSideChainOperator(address _address) public onlyOwner {\\r\\n        sideChainOperator = _address;\\r\\n        emit NewSideChainOperator(_address);\\r\\n    }\\r\\n\\r\\n    function getSideChainOperator() public view returns (address _address) {\\r\\n        return sideChainOperator;\\r\\n    }\\r\\n\\r\\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\\r\\n        return sideChainMerkleRootWrittenAtTime;\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Setter/Getter functions for portfolio\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function setPosition(\\r\\n        address _address,\\r\\n        bytes32 _marketId,\\r\\n        uint256 _timeStamp,\\r\\n        uint256 _longShares,\\r\\n        uint256 _shortShares,\\r\\n        uint256 _meanEntryPrice,\\r\\n        uint256 _meanEntrySpread,\\r\\n        uint256 _meanEntryLeverage,\\r\\n        uint256 _liquidationPrice\\r\\n    ) public onlyPlatform {\\r\\n        portfolio[_address][_marketId].lastUpdated = _timeStamp;\\r\\n        portfolio[_address][_marketId].longShares = _longShares;\\r\\n        portfolio[_address][_marketId].shortShares = _shortShares;\\r\\n        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\\r\\n        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\\r\\n        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\\r\\n        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\\r\\n        portfolio[_address][_marketId].positionHash = getPositionHash(\\r\\n            _address,\\r\\n            _marketId,\\r\\n            _timeStamp,\\r\\n            _longShares,\\r\\n            _shortShares,\\r\\n            _meanEntryPrice,\\r\\n            _meanEntrySpread,\\r\\n            _meanEntryLeverage,\\r\\n            _liquidationPrice\\r\\n        );\\r\\n        if (_longShares \\u003e 0 || _shortShares \\u003e 0) {\\r\\n            addExposureByMarket(_marketId, _address);\\r\\n        } else {\\r\\n            deleteExposureByMarket(_marketId, _address);\\r\\n        }\\r\\n        emit SetPosition(\\r\\n            portfolio[_address][_marketId].positionHash,\\r\\n            _address,\\r\\n            _marketId,\\r\\n            _timeStamp,\\r\\n            _longShares,\\r\\n            _shortShares,\\r\\n            _meanEntryPrice,\\r\\n            _meanEntrySpread,\\r\\n            _meanEntryLeverage,\\r\\n            _liquidationPrice\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getPosition(\\r\\n        address _address,\\r\\n        bytes32 _marketId\\r\\n    ) public view returns (\\r\\n        uint256 _longShares,\\r\\n        uint256 _shortShares,\\r\\n        uint256 _meanEntryPrice,\\r\\n        uint256 _meanEntrySpread,\\r\\n        uint256 _meanEntryLeverage,\\r\\n        uint256 _liquidationPrice\\r\\n    ) {\\r\\n        return(\\r\\n        portfolio[_address][_marketId].longShares,\\r\\n        portfolio[_address][_marketId].shortShares,\\r\\n        portfolio[_address][_marketId].meanEntryPrice,\\r\\n        portfolio[_address][_marketId].meanEntrySpread,\\r\\n        portfolio[_address][_marketId].meanEntryLeverage,\\r\\n        portfolio[_address][_marketId].liquidationPrice\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getPositionHash(\\r\\n        address _address,\\r\\n        bytes32 _marketId,\\r\\n        uint256 _timeStamp,\\r\\n        uint256 _longShares,\\r\\n        uint256 _shortShares,\\r\\n        uint256 _meanEntryPrice,\\r\\n        uint256 _meanEntrySpread,\\r\\n        uint256 _meanEntryLeverage,\\r\\n        uint256 _liquidationPrice\\r\\n    ) public pure returns (bytes32 _hash) {\\r\\n        return keccak256(\\r\\n            abi.encodePacked(\\r\\n                _address,\\r\\n                _marketId,\\r\\n                _timeStamp,\\r\\n                _longShares,\\r\\n                _shortShares,\\r\\n                _meanEntryPrice,\\r\\n                _meanEntrySpread,\\r\\n                _meanEntryLeverage,\\r\\n                _liquidationPrice\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\\r\\n        return keccak256(abi.encodePacked(_address, _balance));\\r\\n    }\\r\\n\\r\\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\\r\\n        return(portfolio[_address][_marketId].lastUpdated);\\r\\n    }\\r\\n\\r\\n    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\\r\\n        return(portfolio[_address][_marketId].longShares);\\r\\n    }\\r\\n\\r\\n    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\\r\\n        return(portfolio[_address][_marketId].shortShares);\\r\\n    }\\r\\n\\r\\n    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\\r\\n        return(portfolio[_address][_marketId].meanEntryPrice);\\r\\n    }\\r\\n\\r\\n    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\\r\\n        return(portfolio[_address][_marketId].meanEntrySpread);\\r\\n    }\\r\\n\\r\\n    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\\r\\n        return(portfolio[_address][_marketId].meanEntryLeverage);\\r\\n    }\\r\\n\\r\\n    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\\r\\n        return(portfolio[_address][_marketId].liquidationPrice);\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Record positions by market by address. Needed for exposure aggregations\\r\\n    // and spits and dividends.\\r\\n    // ----------------------------------------------------------------------------\\r\\n    function addExposureByMarket(bytes32 _symbol, address _address) private {\\r\\n        // Address must not be already recored\\r\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\r\\n        if (_myExposureIndex == 0) {\\r\\n            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\\r\\n            setMaxMappingIndex(_symbol, _maxMappingIndex);\\r\\n            setExposureMapping(_symbol, _address, _maxMappingIndex);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\\r\\n        // Get my index in mapping\\r\\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\\r\\n        // Get last element of mapping\\r\\n        uint256 _lastIndex = getMaxMappingIndex(_symbol);\\r\\n        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\\r\\n        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\\r\\n        if (_myExposureIndex \\u003e 0) {\\r\\n            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\\r\\n            // deleted elements position.\\r\\n            if (_myExposureIndex \\u003c _lastIndex) {\\r\\n                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\\r\\n                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\\r\\n            }\\r\\n            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\\r\\n            setExposureMappingAddress(_symbol, address(0), _lastIndex);\\r\\n            setExposureMappingIndex(_symbol, _address, 0);\\r\\n            // Shouldn\\u0027t happen, but check that not empty\\r\\n            if (_lastIndex \\u003e 0) {\\r\\n                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ----------------------------------------------------------------------------\\r\\n    // Calculate and send operating reward\\r\\n    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\\r\\n    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\\r\\n    // day.\\r\\n    // ----------------------------------------------------------------------------\\r\\n\\r\\n    function payOperatingReward() public onlyMainChain {\\r\\n        if (now \\u003e lastRewardTime.add(REWARDPERIOD)) {\\r\\n            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\\r\\n            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\\r\\n            mint(morpherRewards, _reward);\\r\\n            emit OperatingRewardMinted(morpherRewards, _reward);\\r\\n        }\\r\\n    }\\r\\n}\"},\"MorpherToken.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./MorpherState.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20Mintable}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract MorpherToken is IERC20, Ownable {\\r\\n\\r\\n    MorpherState state;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    string public constant name     = \\\"Morpher\\\";\\r\\n    string public constant symbol   = \\\"MPH\\\";\\r\\n    uint8  public constant decimals = 18;\\r\\n    \\r\\n    modifier onlyState {\\r\\n        require(msg.sender == address(state), \\\"ERC20: caller must be MorpherState contract.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier canTransfer {\\r\\n        require(state.mainChain() == true || state.getCanTransfer(msg.sender), \\\"ERC20: token transfers disabled on sidechain.\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    event LinkState(address _address);\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Constructor\\r\\n    // ------------------------------------------------------------------------\\r\\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\\r\\n        setMorpherState(_stateAddress);\\r\\n        transferOwnership(_coldStorageOwnerAddress);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Links Token Contract with State\\r\\n    // ------------------------------------------------------------------------\\r\\n    function setMorpherState(address _stateAddress) public onlyOwner {\\r\\n        state = MorpherState(_stateAddress);\\r\\n        emit LinkState(_stateAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return state.totalSupply();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address _account) public view returns (uint256) {\\r\\n        return state.balanceOf(_account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     * \\r\\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\r\\n     */\\r\\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\\r\\n        _transfer(msg.sender, _recipient, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address _owner, address _spender) public view returns (uint256) {\\r\\n        return state.getAllowance(_owner, _spender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address _spender, uint256 _amount) public returns (bool) {\\r\\n        _approve(msg.sender, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `_sender` and `_recipient` cannot be the zero address.\\r\\n     * - `_sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for `_sender`\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address _sender, address _recipient, uint256 amount) public returns (bool) {\\r\\n        _transfer(_sender, _recipient, amount);\\r\\n        _approve(_sender, msg.sender, state.getAllowance(_sender, msg.sender).sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\\r\\n        _approve(msg.sender, _spender, state.getAllowance(msg.sender, _spender).add(_addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\\r\\n        _approve(msg.sender, _spender,  state.getAllowance(msg.sender, _spender).sub(_subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Caller destroys `_amount` tokens permanently\\r\\n     *\\r\\n     * Emits a {Transfer} event to zero address called by MorpherState via emitTransfer.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Caller must have token balance of at least `_amount`\\r\\n     * \\r\\n     */\\r\\n     function burn(uint256 _amount) public returns (bool) {\\r\\n        state.burn(msg.sender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Emits a {Transfer} event\\r\\n     *\\r\\n     * MorpherState emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Caller must be MorpherState\\r\\n     * \\r\\n     */\\r\\n     function emitTransfer(address _from, address _to, uint256 _amount) public onlyState {\\r\\n        emit Transfer(_from, _to, _amount);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Moves tokens `_amount` from `sender` to `_recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `_sender` cannot be the zero address.\\r\\n     * - `_recipient` cannot be the zero address.\\r\\n     * - `_sender` must have a balance of at least `_amount`.\\r\\n     */\\r\\n    function _transfer(address _sender, address _recipient, uint256 _amount) canTransfer internal {\\r\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(state.balanceOf(_sender) \\u003e= _amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        state.transfer(_sender, _recipient, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `_amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\\r\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        state.setAllowance(_owner, _spender, _amount);\\r\\n        emit Approval(_owner, _spender, _amount);\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Don\\u0027t accept ETH\\r\\n    // ------------------------------------------------------------------------\\r\\n    function () external payable {\\r\\n        revert(\\\"ERC20: You can\\u0027t deposit Ether here\\\");\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n    address public _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        _owner = msg.sender;\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return the address of the owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller should be owner.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return true if `msg.sender` is the owner of the contract.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to relinquish control of the contract.\\r\\n     * It will not be possible to call the functions with the `onlyOwner`\\r\\n     * modifier anymore.\\r\\n     * @notice Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: use renounce ownership instead.\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    // ------------------------------------------------------------------------\\r\\n    // Owner can transfer out any accidentally sent ERC20 tokens\\r\\n    // ------------------------------------------------------------------------\\r\\n    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) public onlyOwner returns (bool _success) {\\r\\n        return IERC20(_tokenAddress).transfer(owner(), _tokens);\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.16;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     *\\r\\n     * _Available since v2.4.0._\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}",
            "abi": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stateAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coldStorageOwnerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"LinkState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emitTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stateAddress\",\"type\":\"address\"}],\"name\":\"setMorpherState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
            "verified": true,
            "owner": "0x51c5ce7c4926d5ca74f4824e11a062f1ef491762",
            "creator": "0xb7528959e991f949e02d27ef133b99cfc85d737e",
            "is_hidden_owner": false,
            "is_proxy": false,
            "is_sellable": true,
            "is_hardcoded_owner": false,
            "code_analysis": {
                "mint_function_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "ownership_renounced": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "is_honeypot_suspected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "delayed_trading_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "transfer_cooldown_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "high_tax_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "blacklist_or_whitelist_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "trading_disabled_possible": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                },
                "other_suspicious_detected": {
                    "found": false,
                    "snippets": [],
                    "snippets_number": 0
                }
            }
        },
        "holder": {
            "total_holders": 28,
            "holders_list": {
                "0x4f6bdbd119e791a7bc7ce31734eaa68cff2e60af": {
                    "balance": 834630000000000000000,
                    "percentage_of_total_supply": 6.0680929668114865e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x161ba24a3f9f90b531f6c0a2e0abb392ddbb8f6c": {
                    "balance": 20000000000000000000000000,
                    "percentage_of_total_supply": 1.4540797639220941,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x98485eb5e35b7013cfbe0185364a8dc447cca8e3": {
                    "balance": 337200000000000000000,
                    "percentage_of_total_supply": 2.4515784819726505e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe261d68bda5bd518598e31320ede6e1e2d53682f": {
                    "balance": 43438494538281780026954911,
                    "percentage_of_total_supply": 3.158151794167797,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe1596a07907c3fbc95f1933a8c924961b5edb4e5": {
                    "balance": 100000000000000000000,
                    "percentage_of_total_supply": 7.270398819610471e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xfa1693bc8838965c7316a7196b52e5aadad2f4b8": {
                    "balance": 500000000000000000000,
                    "percentage_of_total_supply": 3.635199409805235e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4b9186d13a610bc941ca1c676ca3f903ab9e6cd6": {
                    "balance": 500000000000000000000,
                    "percentage_of_total_supply": 3.635199409805235e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3b521806c0ff52e813101af63e4a85e2e3b83a25": {
                    "balance": 15370000000000000000,
                    "percentage_of_total_supply": 1.1174602985741292e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x151260e0f3c8c41f2c1e7a9ed4b038c0ee5b01b9": {
                    "balance": 3195854198561772,
                    "percentage_of_total_supply": 2.3235134592870674e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x7b959c51ea25df8887774805f04423ebb5630f2a": {
                    "balance": 303006851306256131496,
                    "percentage_of_total_supply": 2.20298065407089e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3afb232f1e6b8349a4411595b8eedeb5958e3448": {
                    "balance": 118994290046406750088755477,
                    "percentage_of_total_supply": 8.651359458937815,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xaf37632edba403d15cb8545e368ffb55c774ffa5": {
                    "balance": 125000000000000000000000000,
                    "percentage_of_total_supply": 9.087998524513088,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1a01af6238b4142e38817cceea4ea12b5834f645": {
                    "balance": 385920000000000000000,
                    "percentage_of_total_supply": 2.805792312464073e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4fae187eda2b299e42dff378050de4a721e6c8e8": {
                    "balance": 7532428030688943657,
                    "percentage_of_total_supply": 5.476375586312171e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x1a5394942652a7ecef9d9a531f70e71cb2b86761": {
                    "balance": 500000000000000000000,
                    "percentage_of_total_supply": 3.635199409805235e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xb4e7780901ea50e6e5bf317943be95590e5788dd": {
                    "balance": 80000000000000000000,
                    "percentage_of_total_supply": 5.816319055688376e-06,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe0eb6034adc0ebeb5f9be0fdb05d080dc92b9198": {
                    "balance": 1260858174233193,
                    "percentage_of_total_supply": 9.166941781641219e-11,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x3273b47cd24f798735e9d6e4a0fb853055873ecb": {
                    "balance": 9999999999934464,
                    "percentage_of_total_supply": 7.270398819562823e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x9de9773a77a9b51330736e73429622cc32f51926": {
                    "balance": 100000000000000000000000000,
                    "percentage_of_total_supply": 7.27039881961047,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x6306037ead1fc236f4aabc8c826f351c9f45d409": {
                    "balance": 10000000000000000000,
                    "percentage_of_total_supply": 7.27039881961047e-07,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4d51eeb7e70ea22d74b2274080e43c457c31a9d6": {
                    "balance": 500000000000000000000,
                    "percentage_of_total_supply": 3.635199409805235e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xe1dabc245e75d7925a42e0143b52f9843546e25d": {
                    "balance": 1169279643873800150874029,
                    "percentage_of_total_supply": 0.08501129342614627,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x23d89fd56888b02df3ab68acce0d5fdf5e585dfb": {
                    "balance": 145000000000000007063,
                    "percentage_of_total_supply": 1.0542078288435181e-05,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x773fbb89698f92cbacefe15b8331028092500009": {
                    "balance": 12200850000000000000000,
                    "percentage_of_total_supply": 0.0008870504543824441,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xa73960bc5b3e034d77372969d0a8b3791cedf37d": {
                    "balance": 9999999998361600,
                    "percentage_of_total_supply": 7.270398818419289e-10,
                    "percentage_of_circulating_supply": 0.0
                },
                "0x4d0f7b04f81bca117fcab78e6e2364ae87f4175c": {
                    "balance": 1000000000000000000,
                    "percentage_of_total_supply": 7.27039881961047e-08,
                    "percentage_of_circulating_supply": 0.0
                },
                "0xc4f39ba15f5376732c594523408ea2e5149aa43d": {
                    "balance": 2659904883260108,
                    "percentage_of_total_supply": 1.9338569323530415e-10,
                    "percentage_of_circulating_supply": 0.0
                }
            },
            "total_supply": 1375440364155397851845355813,
            "total_circulating_supply": 0.0,
            "owner": {},
            "creator": {
                "address": "0xb7528959e991f949e02d27ef133b99cfc85d737e",
                "balance": 18850227753577797817406351,
                "percentage_of_supply": 0.0,
                "exceeds_5_percent": false
            },
            "holders_exceeding_5_percent": [],
            "howmany_holders_exceeding_5_percent": 0,
            "top_10_holders": [
                {
                    "address": "0xaf37632edba403d15cb8545e368ffb55c774ffa5",
                    "balance": 125000000000000000000000000,
                    "percentage_of_total_supply": 9.087998524513088,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x3afb232f1e6b8349a4411595b8eedeb5958e3448",
                    "balance": 118994290046406750088755477,
                    "percentage_of_total_supply": 8.651359458937815,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x9de9773a77a9b51330736e73429622cc32f51926",
                    "balance": 100000000000000000000000000,
                    "percentage_of_total_supply": 7.27039881961047,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xe261d68bda5bd518598e31320ede6e1e2d53682f",
                    "balance": 43438494538281780026954911,
                    "percentage_of_total_supply": 3.158151794167797,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x161ba24a3f9f90b531f6c0a2e0abb392ddbb8f6c",
                    "balance": 20000000000000000000000000,
                    "percentage_of_total_supply": 1.4540797639220941,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xb7528959e991f949e02d27ef133b99cfc85d737e",
                    "balance": 18850227753577797817406351,
                    "percentage_of_total_supply": 1.3704867360900055,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xe1dabc245e75d7925a42e0143b52f9843546e25d",
                    "balance": 1169279643873800150874029,
                    "percentage_of_total_supply": 0.08501129342614627,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x773fbb89698f92cbacefe15b8331028092500009",
                    "balance": 12200850000000000000000,
                    "percentage_of_total_supply": 0.0008870504543824441,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0x4f6bdbd119e791a7bc7ce31734eaa68cff2e60af",
                    "balance": 834630000000000000000,
                    "percentage_of_total_supply": 6.0680929668114865e-05,
                    "percentage_of_circulating_supply": 0
                },
                {
                    "address": "0xfa1693bc8838965c7316a7196b52e5aadad2f4b8",
                    "balance": 500000000000000000000,
                    "percentage_of_total_supply": 3.635199409805235e-05,
                    "percentage_of_circulating_supply": 0
                }
            ],
            "total_top_10_balance": 427465827462140128083990768,
            "top10_percentage_of_total_supply": 31.078470474045567,
            "top10_percentage_of_circulating_supply": 0,
            "top_10_less_than_70_percent_of_total": true,
            "top_10_less_than_70_percent_of_circulating": true
        },
        "liquidity": {
            "price_usd": 0.01491,
            "liquidity_usd": 34879.6,
            "market_cap_usd": 0.0,
            "liquidity_to_market_cap_ratio": 0,
            "token_volume": 0.0,
            "volume_usd": 0.0,
            "volume_to_liquidity_ratio": 0.0,
            "locked_liquidity_percent": 0.0,
            "locked_95_for_15_days": false,
            "creator_under_5_percent": true,
            "creator_percent_of_lp": 1.3705,
            "owner_under_5_percent": true,
            "owner_percent_of_lp": 0.0,
            "total_lp_supply": 1988.508896661529,
            "lp_holders_count": 3,
            "lp_holders": [
                {
                    "address": "0x00001a8ec45420e3366f8e020d2502b7a01a8935",
                    "balance": 1979.4179875706197,
                    "is_locked": false,
                    "percent": 0.9954282783918283,
                    "tag": ""
                },
                {
                    "address": "0xb7528959e991f949e02d27ef133b99cfc85d737e",
                    "balance": 9.09090909090909,
                    "is_locked": false,
                    "percent": 0.004571721608171656,
                    "tag": ""
                },
                {
                    "address": "0x0000000000000000000000000000000000000000",
                    "balance": 1e-15,
                    "is_locked": true,
                    "percent": 0.0,
                    "tag": "Null Address"
                }
            ],
            "error": "Liquidity pool info could not be retrieved."
        },
        "security": {
            "warnings": [],
            "homany_warnings": 0,
            "suspicious_urls": {
                "https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n": "metamask recovery phrase phishing",
                "https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n": "metamask recovery phrase phishing",
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n": "metamask recovery phrase phishing"
            },
            "howmany_suspicious_urls": 3,
            "suspicious_addresses": {},
            "howmany_suspicious_addresses": 0,
            "howmany_warnings": 0
        },
        "lifecycle": {
            "token_age_seconds": 164473631.747993,
            "token_creation_date": "2020-06-04T13:32:12",
            "creation_to_first_trade_seconds": 0.0,
            "creation_to_first_trade_blocks": 0,
            "last_tx_hash": "0x99e7ea22559c9f423e90f7a9fbdaf6d79e346a35be701eb166b85942da97ef8e",
            "last_active_age": "2025-08-20T22:11:11",
            "inactive_days": 0.26962012285879633
        }
    },
    "errors": []
}