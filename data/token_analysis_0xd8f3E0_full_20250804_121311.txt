Token Analysis Report
==================================================
Token: Museo (0xd8f3E0Fe6254010eE6D309607024d1B2bf378e6B)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if (from != owner() && to != owner())
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        if (from != owner() && to != owner())
            require(amount >= _mintxamount, "transfer amount cannot be smaller than mintxamount.");

        bool takefee = true;

        // do not take fee if the sender should be excluded
        if (_isexcludedfromfee[from]) {
            takefee = false;
        }

        // don't take any fees if marketing address or developer addresses aren't set.
        if (_marketingaddress == address(0) || _developeraddress == address(0)) {
            takefee = false;
        }

        if (
            takefee &&
            from != uniswapv2pair &&
            !takefeesmutexlock
        ) {
            // subtract the transfer amount left after fees
            uint256 totalfee = _developerfee.add(_marketingfee).add(_liqfee);
            uint256 totalfeeamount = amount.mul(totalfee).div(100);
            uint256 oldamount = amount;
            amount = amount.sub(totalfeeamount);

            // take fees
            _takefees(oldamount, from);
        }

        // transfer the amount left of the transfer (and also take reflection tax fee here)
        _tokentransfer(from, to, amount, takefee);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _transferownership(address(0));
    }

  Code Snippet:
    function verifycallresult(
        bool success,

WARNING: Is Honeypot Suspected
  Code Snippet:
    function verifycallresult(
        bool success,

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function createpancakeswappair() public onlyowner {
    
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x10ed43c718714eb63d5aa57b78b54704e256024e); // mainnet


         // create a uniswap pair for this new token
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory())
            .createpair(address(this), _uniswapv2router.weth());

        // set router contract variable
        uniswapv2router = _uniswapv2router;
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount, address partner) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            partner,
            block.timestamp
        );
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if (from != owner() && to != owner())
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        if (from != owner() && to != owner())
            require(amount >= _mintxamount, "transfer amount cannot be smaller than mintxamount.");

        bool takefee = true;

        // do not take fee if the sender should be excluded
        if (_isexcludedfromfee[from]) {
            takefee = false;
        }

        // don't take any fees if marketing address or developer addresses aren't set.
        if (_marketingaddress == address(0) || _developeraddress == address(0)) {
            takefee = false;
        }

        if (
            takefee &&
            from != uniswapv2pair &&
            !takefeesmutexlock
        ) {
            // subtract the transfer amount left after fees
            uint256 totalfee = _developerfee.add(_marketingfee).add(_liqfee);
            uint256 totalfeeamount = amount.mul(totalfee).div(100);
            uint256 oldamount = amount;
            amount = amount.sub(totalfeeamount);

            // take fees
            _takefees(oldamount, from);
        }

        // transfer the amount left of the transfer (and also take reflection tax fee here)
        _tokentransfer(from, to, amount, takefee);
    }

  Code Snippet:
    function _takefees(uint256 amount, address from) private locktakefees {
        // calculate the wallet fees to take (partnership and marketing) - don't
        // take reflect tax or liquidity here
        uint256 walletfee = _developerfee.add(_marketingfee);
        uint256 walletfeeamount = amount.mul(walletfee).div(100);

        // calculate liquidity fee amount, and split it into two halves, one for
        // the amount of tokens, and the other half will represent the amount of
        // tokens to be swapped into eth
        uint256 totalliqfeeamount = amount.mul(_liqfee).div(100);
        uint256 liqfeeamount = totalliqfeeamount.div(2);
        uint256 liqfeetobeswappedtoethamount = totalliqfeeamount.sub(liqfeeamount);

        // total fees that will have been taken away from the amount of tokens
        uint256 totalfeeamount = walletfeeamount.add(totalliqfeeamount);
        uint256 totalfeeamounttobeswappedforeth = walletfeeamount.add(liqfeetobeswappedtoethamount);
         

        // capture the contract's current eth balance
        uint256 initialbalance = address(this).balance;

        // send the tokens taken as fee to the contract to be able to swap
        // them for eth (the contract address needs the token balance)
        _tokentransfer(from, address(this), totalfeeamount, false);

        require(
            balanceof(address(this)) >= totalfeeamounttobeswappedforeth,
            "contract address does not have the available token balance to perform swap"
        );

        // swap the required amount of tokens for eth
        swaptokensforeth(totalfeeamounttobeswappedforeth);

        // how much eth did we just swap into?
        uint256 swappedeth = address(this).balance.sub(initialbalance);

        // this multiplies the liquidity fee by 10 to avoid halving imprecisions on odd integers
        uint256 totalfeetobeswappedforethmul10 = _liqfee.mul(10).div(2).add(walletfee.mul(10));
        // calculate developer and marketing portions of the swapped eth (also remember to multiply this factor by 10)
        uint256 developerethportion = swappedeth.div(totalfeetobeswappedforethmul10).mul(_developerfee.mul(10));
        uint256 marketingethportion = swappedeth.div(totalfeetobeswappedforethmul10).mul(_marketingfee.mul(10));
        // to avoid annoying halving errors, the rest of the eth portion
        // should be exactly what was supposed to be added to the liquidity
        // pool. thus we can just subtract from the remaining swappedeth
        // instead of calculating the exact fee percentage.
        uint256 totalethportionforwallets = developerethportion.add(marketingethportion);
        uint256 liquiditypoolethportion = swappedeth.sub(totalethportionforwallets);

        // transfer eth to fee wallets
        (bool sent, bytes memory data) = _developeraddress.call{value: developerethportion}("");
        require(sent, 'eth was not sent to developer');
        (sent, data) = _marketingaddress.call{value: marketingethportion}("");
        require(sent, 'eth was not sent to marketing');

        // liquidity pool eth was calculated from the swappedeth, and the
        // liqfeeamount was the tokens calculated earlier representing the
        // other half of the liquidity fee.
        addliquidity(liqfeeamount, liquiditypoolethportion, owner());
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
        if (!takefee) {
            removeallfees();
        }

        _transferstandard(sender, recipient, amount);

        if (!takefee) {
            restoreallfees();
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee);
        return (ttransferamount, tfee);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(100);
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liqfee).div(100);
    }

  Code Snippet:
    function calculatemarketingfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_marketingfee).div(100);
    }

  Code Snippet:
    function calculatedeveloperfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_developerfee).div(100);
    }

  Code Snippet:
    function removeallfees() private {
        if(_taxfee == 0 && _marketingfee == 0 && _developerfee == 0 && _liqfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousdeveloperfee = _developerfee;
        _previousmarketingfee = _marketingfee;
        _previousliqfee = _liqfee;
        
        _taxfee = 0;
        _liqfee = 0;
        _developerfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function restoreallfees() private {
        _taxfee = _previoustaxfee;
        _developerfee = _previousdeveloperfee;
        _marketingfee = _previousmarketingfee;
        _liqfee = _previousliqfee;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner {
        _previoustaxfee = _taxfee;
        _taxfee = taxfee;
    }

  Code Snippet:
    function setliqfeepercent(uint256 liqfee) external onlyowner {
        _previousliqfee = _liqfee;
        _liqfee = liqfee;
    }

  Code Snippet:
    function setdeveloperfeepercent(uint256 developerfee) external onlyowner {
        _previousdeveloperfee = _developerfee;
        _developerfee = developerfee;
    }

  Code Snippet:
    function setmarketingfeepercent(uint256 marketingfee) external onlyowner {
        _previousmarketingfee = _marketingfee;
        _marketingfee = marketingfee;
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function getpairaddress() public view returns (address) {
        return uniswapv2pair;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xd703b3a644f4f8ca79e532468d869d88d89e9769 — 597,032,563,444,040,736,922,664,960 tokens (66.96% of circulating supply)
  2. 0x1f3e928248663525f664b9111b2c032a9e99d28c — 22,258,270,587,393,249,053,245,440 tokens (2.50% of circulating supply)
  3. 0xa1ecb46c0be223dff23efda8bd553d17b938af47 — 9,802,053,463,150,423,630,151,680 tokens (1.10% of circulating supply)
  4. 0x17ff3344b8a59b102cf2869587db17539c4812b3 — 9,670,031,221,099,685,851,693,056 tokens (1.08% of circulating supply)
  5. 0xa55e8b63f06daabaed32a62f6b97ae4af340c609 — 8,026,941,959,286,645,271,298,048 tokens (0.90% of circulating supply)
  6. 0x8c5340563ca74ad044ead72823594e5bbde6d3d2 — 5,991,020,824,750,829,453,967,360 tokens (0.67% of circulating supply)
  7. 0x2d8824a7d8d6b467f3c47cd6e2e547d8587c1083 — 4,721,664,552,753,754,479,263,744 tokens (0.53% of circulating supply)
  8. 0x3883c129fbe671f47c13c3e7bb11b339aa6e3236 — 3,868,757,430,661,636,060,872,704 tokens (0.43% of circulating supply)
  9. 0xb3ac55a23a027e0e9cfc8510fd7fe710036dd9b8 — 3,822,449,542,010,322,225,725,440 tokens (0.43% of circulating supply)
  10. 0x1eb2f58af82c66911db07fef835e675d2e8f4b78 — 3,412,516,945,669,414,360,973,312 tokens (0.38% of circulating supply)

Top 10 Total Balance: 668,606,269,970,816,697,309,855,744 tokens
Top 10 Share of Circulating Supply: 74.99%
Top 10 Share of Total Supply: 66.86%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $15,440,065,210,864,582.00
Liquidity: $0.02
Liquidity/MCap Ratio: 0.0000
Token Volume: 41106.7161
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0000
Percentage of liquidity locked: 97.0600
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0112)
Total supply of LP tokens: 60948.395239327045
LP holders count: 6

Liquidity holders for 0xd8f3E0Fe6254010eE6D309607024d1B2bf378e6B, (Museo)

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 31590.270654111213 LP tokens

0x0000000000000000000000000000000000000000 holds 27568.320688516946 LP tokens

0x36e0af3e064ad2a13623c7166ecbbca556e004fe holds 1668.2737966851453 LP tokens

0x6c09b1ec43019739fe0975d6266ab9fdd8a44cbf holds 106.90998928432572 LP tokens

0x81264ec9934b7a9215418f34bc8d60da456f1fa7 holds 13.292895660083298 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 1.3272150693328049 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1340.37 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-03T03:20:41
Last Active: 2025-07-19T00:31:59
Days Since Last Activity: 16.486948284328705 days
Last Transaction Hash: 0x2450c1083205d6c94da19d4fafc652158abc3ec981f458be76119f00e2096c1b
