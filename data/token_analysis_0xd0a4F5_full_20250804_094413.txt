Token Analysis Report
==================================================
Token: PartyStarter (0xd0a4F585dDd9d49DE480bBD3186De66c537bdcC2)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function mint(address to) external returns (uint256 liquidity);


WARNING: Ownership Renounced
  Code Snippet:
  function renounceownership() public onlyowner {
    emit ownershiptransferred(_owner, address(0));
    _owner = address(0);
  }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _checkliquidityadd(address sender, address receiver) private {
        require(!_hasliqbeenadded, "liquidity already added and marked.");
        if (sender == liquidityholds && receiver == pcsv2pair) {
            _hasliqbeenadded = true;
            _liqaddblock = block.number;
            _liqaddtimestamp = block.timestamp;
        }
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
        address _whosends = sender;
        address _whoreceives = recipient;

        // check if a mempool bot is selling.
        if (has(_whosends)) {
            revert("mempooles closed.");
        }

        // check if this transfer falls under extra liquidity fee.
        bool applyextraliq = false;
        bool standardliq = false;
        if (takefee && _penaltiesenabled) {
            applyextraliq = _liqaddblock > 0 && _triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            standardliq = _liqaddblock > 0 && !_triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            if (applyextraliq) {
                _setantidumpmultiplier(2);
            } else if (standardliq) {
                _setantidumpmultiplier(1);
            }
        }

        // realise the transfer with or without taxes.
        if (!takefee || !_penaltiesenabled) {
            _liquidityfee = 0;
            _burnamount = 0;
        }
        _finalisetransfer(sender, recipient, amount);
        if (!takefee || !_penaltiesenabled) {
            _setbaselineliquidityfee();
            _setburnamount();
        }

        // check if this is the liquidity adding tx to startup.
        if (!_hasliqbeenadded) {
            _checkliquidityadd(_whosends, _whoreceives);
        } else {
            if (_liqaddblock > 0 && _whosends == pcsv2pair && _haslimits(_whosends, _whoreceives)) {
                if (block.number == _liqaddblock) {
                    add(_whoreceives);
                    emit mempoolcaught(_whoreceives);
                } else if (block.number - _liqaddblock < 3) {
                    earlyblockbuy(_whoreceives);
                    emit snipercaught(_whoreceives);
                }
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;


  Code Snippet:
    function swap(
        uint256 amount0out,

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        if (_liquidityfee == 0) {
            return 0;
        }
        return _amount.div(100).mul(_liquidityfee);
    }

  Code Snippet:
    function _setantidumpmultiplier(uint256 doublepenalty) private {
        uint256 time_since_start = block.timestamp - _liqaddtimestamp;
        uint256 hour = 60 * 60;
        //uint256 minute = 60;
        uint256 second = 1;
        if (_penaltiesenabled) {
            if (time_since_start < 5 * second) {
                revert("please try again after a minute.");
            }
            if (time_since_start < 2 * hour) {
                _liquidityfee = 20 * doublepenalty;
            } else {
                _liquidityfee = _baselineliqfee;
            }
        } else {
            _liquidityfee = _baselineliqfee;
        }
    }

  Code Snippet:
    function _setbaselineliquidityfee() private {
        _liquidityfee = _baselineliqfee;
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {

        uint256 liquidtyportion = contracttokenbalance.div(10**2).mul(30);
        uint256 devportion = contracttokenbalance - liquidtyportion;
        
        // split the contract balance into halves
        uint256 half = liquidtyportion.div(2);
        uint256 otherhalf = liquidtyportion.sub(half);

        // capture the contract's current bnb balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalanceforliquify = address(this).balance;

        // swap tokens for bnb
        swaptokensforbnb(half, address(this));

        // how much bnb did we just swap into?
        uint256 newbalancefromliquify = address(this).balance.sub(initialbalanceforliquify);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalancefromliquify);

        swaptokensforbnb(devportion, payable(liquiditywallet));
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount, address to) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsv2router.weth();

        _approve(address(this), address(pcsv2router), tokenamount);

        // make the swap
        pcsv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            to,
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
        address _whosends = sender;
        address _whoreceives = recipient;

        // check if a mempool bot is selling.
        if (has(_whosends)) {
            revert("mempooles closed.");
        }

        // check if this transfer falls under extra liquidity fee.
        bool applyextraliq = false;
        bool standardliq = false;
        if (takefee && _penaltiesenabled) {
            applyextraliq = _liqaddblock > 0 && _triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            standardliq = _liqaddblock > 0 && !_triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            if (applyextraliq) {
                _setantidumpmultiplier(2);
            } else if (standardliq) {
                _setantidumpmultiplier(1);
            }
        }

        // realise the transfer with or without taxes.
        if (!takefee || !_penaltiesenabled) {
            _liquidityfee = 0;
            _burnamount = 0;
        }
        _finalisetransfer(sender, recipient, amount);
        if (!takefee || !_penaltiesenabled) {
            _setbaselineliquidityfee();
            _setburnamount();
        }

        // check if this is the liquidity adding tx to startup.
        if (!_hasliqbeenadded) {
            _checkliquidityadd(_whosends, _whoreceives);
        } else {
            if (_liqaddblock > 0 && _whosends == pcsv2pair && _haslimits(_whosends, _whoreceives)) {
                if (block.number == _liqaddblock) {
                    add(_whoreceives);
                    emit mempoolcaught(_whoreceives);
                } else if (block.number - _liqaddblock < 3) {
                    earlyblockbuy(_whoreceives);
                    emit snipercaught(_whoreceives);
                }
            }
        }
    }

  Code Snippet:
    function _finalisetransfer(address sender, address recipient, uint256 amount) private {
        uint256 liquidity = calculateliquidityfee(amount);
        uint256 burn = calculateburnamount(amount);
        uint256 transferamount = amount.sub(liquidity).sub(burn);

        _owned[sender] = _owned[sender].sub(amount);
        _owned[recipient] = _owned[recipient].add(transferamount);
        _takeliquidity(liquidity);
        _burntokens(burn);

        emit transfer(sender, recipient, transferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 21
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x026aa4937fd4c9123873d11e689c25b4e126b9a2 — 377,672,566,338,818,560 tokens (50.76% of circulating supply)
  2. 0x7c2764466633c30c96ea89e2176e4d5d5da66600 — 19,167,865,456,287,308 tokens (2.58% of circulating supply)
  3. 0x9b028d0a61348ab83e3dbcf97609a15e490b7aa3 — 18,920,081,784,935,100 tokens (2.54% of circulating supply)
  4. 0x2229325193ef1494e56e9387c627fdfa1bc61951 — 15,439,665,287,795,794 tokens (2.07% of circulating supply)
  5. 0x65163f2f7be8d6e0a2f832fa75274101e07ab329 — 14,078,419,509,718,544 tokens (1.89% of circulating supply)
  6. 0x1e9f7cd89eedf046128579e881df2c5baf6f14fc — 9,782,761,722,338,054 tokens (1.31% of circulating supply)
  7. 0x258082d70665f12a69fff436b21bf34f3c67db3b — 7,079,010,099,000,000 tokens (0.95% of circulating supply)
  8. 0xa39ae8fa5e75e3ce9e089b17ef1223de67ee6a13 — 6,459,004,905,514,526 tokens (0.87% of circulating supply)
  9. 0xa738f82079f60a9fc7e71114430c6a1df36b0d46 — 6,015,060,099,000,000 tokens (0.81% of circulating supply)
  10. 0x5c6c37af3b76fd9b9c7fd77d22a625fecf554f9b — 4,017,775,442,162,356 tokens (0.54% of circulating supply)

Top 10 Total Balance: 478,632,210,645,570,242 tokens
Top 10 Share of Circulating Supply: 64.32%
Top 10 Share of Total Supply: 48.14%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $2,169,468,308,014,773.50
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 7746903.3493
USD Volume: 22586.6579
24h Volume/Liquidity Ratio: 10243608.4476
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.5577804025317704
LP holders count: 4

Liquidity holders for 0xd0a4F585dDd9d49DE480bBD3186De66c537bdcC2, (PartyStarter)

0x000000000000000000000000000000000000dead holds 0.5577583058577852 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.001281424802949686 LP tokens

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 1.9411441143127e-05 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1513.63 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-06-12T18:31:17
Last Active: 2024-10-13T03:10:20
Days Since Last Activity: 295.2735325267245 days
Last Transaction Hash: 0xd151a4aa38b4b786a26ce2884f854753ac30655ba1a920a0ce18ba8a1521e00b
