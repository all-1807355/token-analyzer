Token Analysis Report
==================================================
Token: ASTRONOMICAL (0xB510dfe279a79175F2bAceb03A2C951f417001f1)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
        function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function setwalletfeepercent(uint256 walletfee) external onlyowner() {
        _walletfee = walletfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
     function setrouter(address router) public onlyowner() {
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(router);
         // create a uniswap pair for this new token
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory())
            .createpair(address(this), _uniswapv2router.weth());

        // set the rest of the contract variables
        uniswapv2router = _uniswapv2router;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
       
        uint256 wallet = calculatewalletfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(wallet).sub(tliquidity);
        return (ttransferamount, wallet, tliquidity);
    }

  Code Snippet:
    function calculatewalletfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_walletfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_walletfee == 0 && _liquidityfee == 0) return;
        
  
        _previouswalletfee = _walletfee;
        _previousliquidityfee = _liquidityfee;
        
 
        _walletfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
   
        _walletfee = _previouswalletfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefees) private {
        if(!takefees)
            removeallfee();
        

            _transferstandard(sender, recipient, amount);
    
        
        if(!takefees)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 ttransferamount, uint256 wallet, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _wallet(wallet);
    
         if(takefee)
        emit transfer(sender, walletaddr, wallet);
        
        emit transfer(sender, recipient, ttransferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x35185f39bed4bb34bffcc6f06ae92111bf79ce65 — 9,974,366,195,598,894,502,510,592 tokens (73.07% of circulating supply)
  2. 0xe6c6b8c66b2abe6aef055e9a8f211d73d7df5895 — 1,322,170,622,500,000,078,233,600 tokens (9.69% of circulating supply)
  3. 0x8cc30616a65359aeac75f098d525e9a63414e2ad — 465,595,000,000,000,032,768,000 tokens (3.41% of circulating supply)
  4. 0x6dc1034d963bb3ab8534075f684fd76d1dfde05c — 403,562,482,214,336,632,717,312 tokens (2.96% of circulating supply)
  5. 0xabbf62df016844b38fba1d86b64fd7a2b3ed50f9 — 367,640,499,950,818,177,318,912 tokens (2.69% of circulating supply)
  6. 0xa5f5bbf736dff96b8a84cebdda125035feeffa4d — 361,256,621,872,356,425,465,856 tokens (2.65% of circulating supply)
  7. 0xce4354f5a31f3e31ae27c2e07c2452dee6df8d88 — 305,408,599,999,999,979,290,624 tokens (2.24% of circulating supply)
  8. 0x2353a2723b28adb69f311ac763faf83babb55b00 — 220,333,407,391,095,357,177,856 tokens (1.61% of circulating supply)
  9. 0x5c72c9afea0187ae2ce3e40c7e89524e6a808cba — 206,021,751,588,346,191,151,104 tokens (1.51% of circulating supply)
  10. 0x635b686e20316c29cff4f6367318b6cce0d07a69 — 177,352,565,815,801,116,884,992 tokens (1.30% of circulating supply)

Top 10 Total Balance: 13,803,707,746,931,648,493,518,848 tokens
Top 10 Share of Circulating Supply: 101.13%
Top 10 Share of Total Supply: 138.04%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $6,441,126,560,359,579.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 4729.9407
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0002
Percentage of liquidity locked: 98.9300
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 5524.757863534001
LP holders count: 5

Liquidity holders for 0xB510dfe279a79175F2bAceb03A2C951f417001f1, (ASTRONOMICAL)

0x0000000000000000000000000000000000000000 holds 5465.789602335004 LP tokens

0xcae5febfd25f4709f90cd63cd14d4a91e2b76b81 holds 57.718695224014475 LP tokens

0xc256a84b5b192072227efffeb70595dde01c7246 holds 0.6061478614663409 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.379941466969788 LP tokens

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 0.2634766465471741 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1533.80 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-23T17:16:25
Last Active: 2025-08-02T20:54:33
Days Since Last Activity: 1.6462721990277778 days
Last Transaction Hash: 0x25ececa9b36f4c817a848e5f51164f1b26ab36165aaa894f2433788e8264a53e
