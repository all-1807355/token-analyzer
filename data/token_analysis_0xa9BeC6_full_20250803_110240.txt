Token Analysis Report
==================================================
Token: Move Token (0xa9BeC68C93D8B69A6f006cd370d89b20222F977d)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function setbonus(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._taxfee = _addresstaxfee;
        _addressfees[_address]._liquidityfee = _addressliquidityfee;
    }

  Code Snippet:
    function setbonuswallet(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._selltaxfee = _addresstaxfee;
        _addressfees[_address]._sellliquidityfee = _addressliquidityfee;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function minimumtokensbeforeswapamount() public view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function swaptokens(uint256 contracttokenbalance) private locktheswap {
       
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(contracttokenbalance);
        uint256 transferredbalance = address(this).balance.sub(initialbalance);

        // send to marketing address
        transfertoaddresseth(marketingaddress, transferredbalance.mul(marketingdivisor).div(100));
        
    }

  Code Snippet:
    function buybacktokens(uint256 amount) private locktheswap {
    	if (amount > 0) {
    	    swapethfortokens(amount);
	    }
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this), // the contract
            block.timestamp
        );
        
        emit swaptokensforeth(tokenamount, path);
    }

  Code Snippet:
    function swapethfortokens(uint256 amount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = uniswapv2router.weth();
        path[1] = address(this);

      // make the swap
        uniswapv2router.swapexactethfortokenssupportingfeeontransfertokens{value: amount}(
            0, // accept any amount of tokens
            path,
            deadaddress, // burn address
            block.timestamp.add(300)
        );
        
        emit swapethfortokens(amount, path);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
	    _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function _getsellbnbamount(uint256 tokenamount) private view returns(uint256) {
        address[] memory path = new address[](2);

        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        uint[] memory amounts = uniswapv2router.getamountsout(tokenamount, path);

        return amounts[1];
    }

  Code Snippet:
    function getswapminutes() public view returns(uint256) {
        return _intervalminutesforswap.div(60);
    }

  Code Snippet:
    function setswapminutes(uint256 newminutes) external onlyowner {
        _intervalminutesforswap = newminutes * 1 minutes;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setbuyfee(uint256 buytaxfee, uint256 buyliquidityfee) external onlyowner {
        _buytaxfee = buytaxfee;
        _buyliquidityfee = buyliquidityfee;
    }

  Code Snippet:
    function giveaway(uint256 selltaxfee, uint256 sellliquidityfee) external onlyowner {
        _selltaxfee = selltaxfee;
        _sellliquidityfee = sellliquidityfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setnumtokensselltoaddtobuyback(uint256 _minimumtokensbeforeswap) external onlyowner {
        minimumtokensbeforeswap = _minimumtokensbeforeswap;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function prepareforpresale() external onlyowner {
        setswapandliquifyenabled(false);
        _taxfee = 0;
        _liquidityfee = 0;
        _maxtxamount = 1000000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function afterpresale() external onlyowner {
        setswapandliquifyenabled(true);
        _taxfee = 2;
        _liquidityfee = 10;
        _maxtxamount = 3000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function changerouterversion(address _router) public onlyowner returns(address _pair) {
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(_router);
        
        _pair = iuniswapv2factory(_uniswapv2router.factory()).getpair(address(this), _uniswapv2router.weth());
        if(_pair == address(0)){
            // pair doesn't exist
            _pair = iuniswapv2factory(_uniswapv2router.factory())
            .createpair(address(this), _uniswapv2router.weth());
        }
        uniswapv2pair = _pair;

        // set the router of the contract variables
        uniswapv2router = _uniswapv2router;
    }

  Code Snippet:
    function setbonus(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._taxfee = _addresstaxfee;
        _addressfees[_address]._liquidityfee = _addressliquidityfee;
    }

  Code Snippet:
    function setbuyaddressfee(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._buytaxfee = _addresstaxfee;
        _addressfees[_address]._buyliquidityfee = _addressliquidityfee;
    }

  Code Snippet:
    function setbonuswallet(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._selltaxfee = _addresstaxfee;
        _addressfees[_address]._sellliquidityfee = _addressliquidityfee;
    }


Holder Analysis
--------------
Total Unique Holders: 11
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x1c9b0161da1c124ae0c5c94daff1df41e74ecc61 — 975,958,298,571,288,084,480 tokens (97.62% of circulating supply)
  2. 0xbeec08888f8bfae5193279a2260c590ad3136844 — 19,183,325,971,638,087,680 tokens (1.92% of circulating supply)
  3. 0x8d5be9840c08a1724b2322d99b40913dd668815f — 1,669,510,000,000,000,000 tokens (0.17% of circulating supply)
  4. 0xaa749ebcbf14a680a9f513ca2c92afd873bd47e8 — 1,371,219,491,782,033,920 tokens (0.14% of circulating supply)
  5. 0x878477fcc0365fe3c156b4f41e52e4c0032836a6 — 732,493,714,689,314,048 tokens (0.07% of circulating supply)
  6. 0xe5e24aa6e44f340464ffe99d4e90d234d2e3e6f5 — 407,241,425,632,213,248 tokens (0.04% of circulating supply)
  7. 0xeb83a9a60c7bc218d70b1bafb3753ac8bccb25b4 — 147,544,157,244,169,664 tokens (0.01% of circulating supply)
  8. 0x3be1928c92a74da4546c82b491fcc148154ece47 — 100,000,000,000,000,000 tokens (0.01% of circulating supply)
  9. 0x74f34c11e32e3845abf6aa11e4ba45a745034ce7 — 8,241,085,286,350,858 tokens (0.00% of circulating supply)
  10. 0xd22752cb93751d6d732ee751448c45c72c37ded2 — 2,948,787,491,953,255 tokens (0.00% of circulating supply)

Top 10 Total Balance: 999,580,823,205,052,207,153 tokens
Top 10 Share of Circulating Supply: 99.98%
Top 10 Share of Total Supply: 99.96%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $279,876,611,077.71
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.4440084015647291
LP holders count: 6

Liquidity holders for 0xa9BeC68C93D8B69A6f006cd370d89b20222F977d, (Move Token)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.1644999043772544 LP tokens

0xf3801939cdd92d431c73ad21e5bf010baf1a397a holds 0.08725 LP tokens

0x7f46a73b8c2ba12187fe730498e76ca241b0bf25 holds 0.08725 LP tokens

0x465ef80341c7a94ceacdf3028d3b61ea8cc9c5a4 holds 0.08725 LP tokens

Owner 0x10316ffdfdba52a244c8461c7dfda420bcf7538b holds 0.01775849718747371 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1172.63 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-05-18T19:50:40
Last Active: 2022-05-19T20:02:40
Days Since Last Activity: 1171.625009661898 days
Last Transaction Hash: 0x5a3ea958e9f13133febfb3e27cc2696b8c60f13777b0da063707b6365c11c1ba
