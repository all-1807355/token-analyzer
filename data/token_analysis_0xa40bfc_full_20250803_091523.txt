Token Analysis Report
==================================================
Token: RISE2PROTOCOL (0xa40bfcCB879F26648D5c16Ce6205425068c10BC7)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function claimdividend() external {

        require(shoulddistribute(msg.sender), "too soon. need to wait!");
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;

        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
    }

  Code Snippet:
    function swapback() internal locktheswap {

        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));

        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}

        uint256 marketingshare = amountbnbmarketing.mul(3).div(4);

        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");

        // only to supress warning msg
        tmpsuccess = false;
       

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function changetxlimit(uint256 newlimit) external authorized {
        _maxtxamount = newlimit;
    }

  Code Snippet:
    function changewalletlimit(uint256 newlimit) external authorized {
        _walletmax  = newlimit;
    }

  Code Snippet:
    function changerestrictwhales(bool newvalue) external authorized {
       restrictwhales = newvalue;
    }

  Code Snippet:
    function changeisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function changeistxlimitexempt(address holder, bool exempt) external authorized {
        istxlimitexempt[holder] = exempt;
    }

  Code Snippet:
    function changeisdividendexempt(address holder, bool exempt) external authorized {
        require(holder != address(this) && holder != pair);
        isdividendexempt[holder] = exempt;

        if(exempt){
            dividenddistributor.setshare(holder, 0);
        }else{
            dividenddistributor.setshare(holder, _balances[holder]);
        }
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;

        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
    }

  Code Snippet:
    function changefeereceivers(address newliquidityreceiver, address newmarketingwallet) external authorized {
        autoliquidityreceiver = newliquidityreceiver;
        marketingwallet = newmarketingwallet;
    }

  Code Snippet:
    function changeswapbacksettings(bool enableswapback, uint256 newswapbacklimit, bool swapbylimitonly) external authorized {
        swapandliquifyenabled  = enableswapback;
        swapthreshold = newswapbacklimit;
        swapandliquifybylimitonly = swapbylimitonly;
    }

  Code Snippet:
    function changedistributioncriteria(uint256 newinperiod, uint256 newmindistribution) external authorized {
        dividenddistributor.setdistributioncriteria(newinperiod, newmindistribution);
    }

  Code Snippet:
    function changedistributorsettings(uint256 gas) external authorized {
        require(gas < 750000);
        distributorgas = gas;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {

        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {}
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;

        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
    }

  Code Snippet:
    function swapback() internal locktheswap {

        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));

        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}

        uint256 marketingshare = amountbnbmarketing.mul(3).div(4);

        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");

        // only to supress warning msg
        tmpsuccess = false;
       

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function launch() internal {
        launchedat = block.number;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {

        uint256 balancebefore = rewardtoken.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(rewardtoken);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rewardtoken.balanceof(address(this)).sub(balancebefore);
        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rewardtoken.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function changeisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function changefees(uint256 newliqfee, uint256 newrewardfee, uint256 newmarketingfee, uint256 newextrasellfee) external authorized {
        liquidityfee = newliqfee;
        rewardsfee = newrewardfee;
        marketingfee = newmarketingfee;
        extrafeeonsell = newextrasellfee;

        totalfee = liquidityfee.add(marketingfee).add(rewardsfee);
        totalfeeifselling = totalfee.add(extrafeeonsell);
    }

  Code Snippet:
    function changefeereceivers(address newliquidityreceiver, address newmarketingwallet) external authorized {
        autoliquidityreceiver = newliquidityreceiver;
        marketingwallet = newmarketingwallet;
    }

  Code Snippet:
    function changeswapbacksettings(bool enableswapback, uint256 newswapbacklimit, bool swapbylimitonly) external authorized {
        swapandliquifyenabled  = enableswapback;
        swapthreshold = newswapbacklimit;
        swapandliquifybylimitonly = swapbylimitonly;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {

        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {}
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

  Code Snippet:
    function takefee(address sender, address recipient, uint256 amount) internal returns (uint256) {

        uint256 feeapplicable = pair == recipient ? totalfeeifselling : totalfee;
        uint256 feeamount = amount.mul(feeapplicable).div(100);

        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function tradingstatus(bool newstatus) public onlyowner {
        tradingopen = newstatus;
    }

  Code Snippet:
    function swapback() internal locktheswap {

        uint256 tokenstoliquify = _balances[address(this)];
        uint256 amounttoliquify = tokenstoliquify.mul(liquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = tokenstoliquify.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance;

        uint256 totalbnbfee = totalfee.sub(liquidityfee.div(2));

        uint256 amountbnbliquidity = amountbnb.mul(liquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(rewardsfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.sub(amountbnbliquidity).sub(amountbnbreflection);

        try dividenddistributor.deposit{value: amountbnbreflection}() {} catch {}

        uint256 marketingshare = amountbnbmarketing.mul(3).div(4);

        (bool tmpsuccess,) = payable(marketingwallet).call{value: marketingshare, gas: 30000}("");

        // only to supress warning msg
        tmpsuccess = false;
       

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {

        if(inswapandliquify){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen, "trading not open yet");
        }

        require(amount <= _maxtxamount || istxlimitexempt[sender], "tx limit exceeded");

        if(msg.sender != pair && !inswapandliquify && swapandliquifyenabled && _balances[address(this)] >= swapthreshold){ swapback(); }

        if(!launched() && recipient == pair) {
            require(_balances[sender] > 0);
            launch();
        }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        if(!istxlimitexempt[recipient] && restrictwhales)
        {
            require(_balances[recipient].add(amount) <= _walletmax);
        }

        uint256 finalamount = !isfeeexempt[sender] && !isfeeexempt[recipient] ? takefee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(finalamount);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try dividenddistributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try dividenddistributor.setshare(recipient, _balances[recipient]) {} catch {}
        }

        try dividenddistributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, finalamount);
        return true;
    }

  Code Snippet:
    function tradingstatus(bool newstatus) public onlyowner {
        tradingopen = newstatus;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xf8d577fe84a08c6c5e5798e008eec9f10a19e1a2
Owner Balance: 3,320,666,907,202,498 tokens
Owner Share: 6.06% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xf8d577fe84a08c6c5e5798e008eec9f10a19e1a2 — 3,320,666,907,202,498 tokens (6.06% of circulating supply)
  2. 0xfacc90a5caaf95be61378c987737988543279d9c — 200,000,000,000,000 tokens (0.36% of circulating supply)
  3. 0xf4fa4465ddaa3cc3c2254bddc897e574becda17d — 198,268,276,896,417 tokens (0.36% of circulating supply)
  4. 0xdf683d115030b0f5a8c49bb5129aa2b48866477f — 192,709,768,662,828 tokens (0.35% of circulating supply)
  5. 0x20902d1a0c9bc8b8b0729bc90c1052125640d6db — 186,585,814,116,498 tokens (0.34% of circulating supply)
  6. 0x4c95152058f7986d8f65d20142e1385d26934a51 — 180,806,484,502,114 tokens (0.33% of circulating supply)
  7. 0xd1b5d01fabf3d8b92194e966c3123efde96e540d — 175,053,002,710,593 tokens (0.32% of circulating supply)
  8. 0x7035d620aaa0fd44de684ecdb7e37b7858533a25 — 174,861,497,885,606 tokens (0.32% of circulating supply)
  9. 0x9775e73391b994f3443be77f693bf008f35cca30 — 147,670,772,836,404 tokens (0.27% of circulating supply)
  10. 0x8c8839e378afd034cd19d8c4afd7584c741b2519 — 136,551,340,858,060 tokens (0.25% of circulating supply)

Top 10 Total Balance: 4,913,173,865,671,018 tokens
Top 10 Share of Circulating Supply: 8.96%
Top 10 Share of Total Supply: 4.91%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,498,279,466,690,341.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 117150.2192
USD Volume: 3201.0931
24h Volume/Liquidity Ratio: 295433593.9897
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (3.3207)
Total supply of LP tokens: 0.000848945473539219
LP holders count: 5

Liquidity holders for 0xa40bfcCB879F26648D5c16Ce6205425068c10BC7, (RISE2PROTOCOL)

0x20902d1a0c9bc8b8b0729bc90c1052125640d6db holds 0.000742170248340359 LP tokens

0x529c0c05dd19b80bcd1bac6efe3b354ebf34639a holds 5.5736710828461e-05 LP tokens

0x953d3c6d91a2b815ca830422980fb216ce76e8d4 holds 4.7829111677412e-05 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 3.209402691987e-06 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: http://t.me/Rise2ProtocolTokenofficial, Reason: metamask recovery phrase phishing
  URL: https://rise2protocol.com/, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1381.34 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-10-22T01:06:40
Last Active: 2025-07-05T13:52:16
Days Since Last Activity: 28.807730320995372 days
Last Transaction Hash: 0x3811ea070fb795b04fb72150acca76612435ff13a4315ab8cfeb3a2d34b15daa
