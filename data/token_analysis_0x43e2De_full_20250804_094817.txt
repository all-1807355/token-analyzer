Token Analysis Report
==================================================
Token: RafaleToken (0x43e2De970C0D69f809370C5B71b9587B3f23E4E3)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
        function geunlocktime() public view returns (uint256) {
            return _locktime;
        }

  Code Snippet:
        function unlock() public virtual {
            require(_previousowner == msg.sender, "you don't have permission to unlock");
            require(now > _locktime , "contract is locked until 7 days");
            emit ownershiptransferred(_owner, _previousowner);
            _owner = _previousowner;
        }

  Code Snippet:
        function _transfer(address sender, address recipient, uint256 amount) private {
            require(sender != address(0), "erc20: transfer from the zero address");
            require(recipient != address(0), "erc20: transfer to the zero address");
            require(amount > 0, "transfer amount must be greater than zero");
            require(!cooldownenabled || (cooldown[sender] < block.timestamp && cooldown[recipient] < block.timestamp), "cooldown is enabled. try again in a few minutes.");
            
            if(sender != owner() && recipient != owner())
                require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
           
            // is the token balance of this contract address over the min number of
            // tokens that we need to initiate a swap?
            // also, don't get caught in a circular charity event.
            // also, don't swap if sender is uniswap pair.
            uint256 contracttokenbalance = balanceof(address(this));
            
            if(contracttokenbalance >= _maxtxamount)
            {
                contracttokenbalance = _maxtxamount;
            }
            
            bool overmintokenbalance = contracttokenbalance >= _numoftokenstoexchangeforcharity;
            if (!inswap && swapenabled && overmintokenbalance && sender != uniswapv2pair) {
                // we need to swap the current tokens to eth and send to the charity wallet
                swaptokensforeth(contracttokenbalance);
                
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtocharity(address(this).balance);
                }
            }
            
            //indicates if fee should be deducted from transfer
            bool takefee = true;
            
            //if any account belongs to _isexcludedfromfee account then remove the fee
            if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
                takefee = false;
            }
            
            //transfer amount, it will take tax and charity fee
            _tokentransfer(sender,recipient,amount,takefee);

            if (!_isexcludedfromfee[sender]) {
                cooldown[sender] = block.timestamp + (60 seconds);
            }
            if (!_isexcludedfromfee[recipient]) {
                cooldown[recipient] = block.timestamp + (60 seconds);
            }
        }

WARNING: Ownership Renounced
  Code Snippet:
        function renounceownership() public virtual onlyowner {
            emit ownershiptransferred(_owner, address(0));
            _owner = address(0);
        }

  Code Snippet:
        function lock(uint256 time) public virtual onlyowner {
            _previousowner = _owner;
            _owner = address(0);
            _locktime = now + time;
            emit ownershiptransferred(_owner, address(0));
        }

WARNING: Transfer Cooldown Detected
  Code Snippet:
        function _transfer(address sender, address recipient, uint256 amount) private {
            require(sender != address(0), "erc20: transfer from the zero address");
            require(recipient != address(0), "erc20: transfer to the zero address");
            require(amount > 0, "transfer amount must be greater than zero");
            require(!cooldownenabled || (cooldown[sender] < block.timestamp && cooldown[recipient] < block.timestamp), "cooldown is enabled. try again in a few minutes.");
            
            if(sender != owner() && recipient != owner())
                require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
           
            // is the token balance of this contract address over the min number of
            // tokens that we need to initiate a swap?
            // also, don't get caught in a circular charity event.
            // also, don't swap if sender is uniswap pair.
            uint256 contracttokenbalance = balanceof(address(this));
            
            if(contracttokenbalance >= _maxtxamount)
            {
                contracttokenbalance = _maxtxamount;
            }
            
            bool overmintokenbalance = contracttokenbalance >= _numoftokenstoexchangeforcharity;
            if (!inswap && swapenabled && overmintokenbalance && sender != uniswapv2pair) {
                // we need to swap the current tokens to eth and send to the charity wallet
                swaptokensforeth(contracttokenbalance);
                
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtocharity(address(this).balance);
                }
            }
            
            //indicates if fee should be deducted from transfer
            bool takefee = true;
            
            //if any account belongs to _isexcludedfromfee account then remove the fee
            if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
                takefee = false;
            }
            
            //transfer amount, it will take tax and charity fee
            _tokentransfer(sender,recipient,amount,takefee);

            if (!_isexcludedfromfee[sender]) {
                cooldown[sender] = block.timestamp + (60 seconds);
            }
            if (!_isexcludedfromfee[recipient]) {
                cooldown[recipient] = block.timestamp + (60 seconds);
            }
        }

  Code Snippet:
        function setcooldownenabled(bool enabled) external onlyowner() {
            cooldownenabled = enabled;
        }

WARNING: High Tax Detected
  Code Snippet:
        function feetosetter() external view returns (address);


  Code Snippet:
        function setfeetosetter(address) external;
    } 

  Code Snippet:
        function swapexacttokensfortokens(
            uint amountin,

  Code Snippet:
        function swaptokensforexacttokens(
            uint amountout,

  Code Snippet:
        function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
            external

  Code Snippet:
        function removeliquidityethsupportingfeeontransfertokens(
            address token,

  Code Snippet:
        function removeliquidityethwithpermitsupportingfeeontransfertokens(
            address token,

  Code Snippet:
        function swapexacttokensfortokenssupportingfeeontransfertokens(
            uint amountin,

  Code Snippet:
        function swapexactethfortokenssupportingfeeontransfertokens(
            uint amountoutmin,

  Code Snippet:
        function swapexacttokensforethsupportingfeeontransfertokens(
            uint amountin,

  Code Snippet:
        function setexcludefromfee(address account, bool excluded) external onlyowner() {
            _isexcludedfromfee[account] = excluded;
        }

  Code Snippet:
        function totalfees() public view returns (uint256) {
            return _tfeetotal;
        }

  Code Snippet:
        function deliver(uint256 tamount) public {
            address sender = _msgsender();
            require(!_isexcluded[sender], "excluded addresses cannot call this function");
            (uint256 ramount,,,,,) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rtotal = _rtotal.sub(ramount);
            _tfeetotal = _tfeetotal.add(tamount);
        }

  Code Snippet:
        function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
            require(tamount <= _ttotal, "amount must be less than supply");
            if (!deducttransferfee) {
                (uint256 ramount,,,,,) = _getvalues(tamount);
                return ramount;
            } else {
                (,uint256 rtransferamount,,,,) = _getvalues(tamount);
                return rtransferamount;
            }
        }

  Code Snippet:
        function excludeaccount(address account) external onlyowner() {
            require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not exclude uniswap router.');
            require(!_isexcluded[account], "account is already excluded");
            if(_rowned[account] > 0) {
                _towned[account] = tokenfromreflection(_rowned[account]);
            }
            _isexcluded[account] = true;
            _excluded.push(account);
        }

  Code Snippet:
        function removeallfee() private {
            if(_taxfee == 0 && _charityfee == 0) return;
            
            _previoustaxfee = _taxfee;
            _previouscharityfee = _charityfee;
            
            _taxfee = 0;
            _charityfee = 0;
        }

  Code Snippet:
        function restoreallfee() private {
            _taxfee = _previoustaxfee;
            _charityfee = _previouscharityfee;
        }

  Code Snippet:
        function isexcludedfromfee(address account) public view returns(bool) {
            return _isexcludedfromfee[account];
        }

  Code Snippet:
        function _transfer(address sender, address recipient, uint256 amount) private {
            require(sender != address(0), "erc20: transfer from the zero address");
            require(recipient != address(0), "erc20: transfer to the zero address");
            require(amount > 0, "transfer amount must be greater than zero");
            require(!cooldownenabled || (cooldown[sender] < block.timestamp && cooldown[recipient] < block.timestamp), "cooldown is enabled. try again in a few minutes.");
            
            if(sender != owner() && recipient != owner())
                require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
           
            // is the token balance of this contract address over the min number of
            // tokens that we need to initiate a swap?
            // also, don't get caught in a circular charity event.
            // also, don't swap if sender is uniswap pair.
            uint256 contracttokenbalance = balanceof(address(this));
            
            if(contracttokenbalance >= _maxtxamount)
            {
                contracttokenbalance = _maxtxamount;
            }
            
            bool overmintokenbalance = contracttokenbalance >= _numoftokenstoexchangeforcharity;
            if (!inswap && swapenabled && overmintokenbalance && sender != uniswapv2pair) {
                // we need to swap the current tokens to eth and send to the charity wallet
                swaptokensforeth(contracttokenbalance);
                
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtocharity(address(this).balance);
                }
            }
            
            //indicates if fee should be deducted from transfer
            bool takefee = true;
            
            //if any account belongs to _isexcludedfromfee account then remove the fee
            if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
                takefee = false;
            }
            
            //transfer amount, it will take tax and charity fee
            _tokentransfer(sender,recipient,amount,takefee);

            if (!_isexcludedfromfee[sender]) {
                cooldown[sender] = block.timestamp + (60 seconds);
            }
            if (!_isexcludedfromfee[recipient]) {
                cooldown[recipient] = block.timestamp + (60 seconds);
            }
        }

  Code Snippet:
        function swaptokensforeth(uint256 tokenamount) private locktheswap{
            // generate the uniswap pair path of token -> weth
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = uniswapv2router.weth();

            _approve(address(this), address(uniswapv2router), tokenamount);

            // make the swap
            uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
                tokenamount,
                0, // accept any amount of eth
                path,
                address(this),
                block.timestamp
            );
        }

  Code Snippet:
        function manualswap() external onlyowner() {
            uint256 contractbalance = balanceof(address(this));
            swaptokensforeth(contractbalance);
        }

  Code Snippet:
        function setswapenabled(bool enabled) external onlyowner() {
            swapenabled = enabled;
        }

  Code Snippet:
        function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
            if(!takefee)
                removeallfee();

            if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _transferfromexcluded(sender, recipient, amount);
            } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _transfertoexcluded(sender, recipient, amount);
            } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
                _transferstandard(sender, recipient, amount);
            } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _transferbothexcluded(sender, recipient, amount);
            } else {
                _transferstandard(sender, recipient, amount);
            }

            if(!takefee)
                restoreallfee();
        }

  Code Snippet:
        function _transferstandard(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tcharity) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount); 
            _takecharity(tcharity); 
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tcharity) = _getvalues(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _towned[recipient] = _towned[recipient].add(ttransferamount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount);    
            _takecharity(tcharity);           
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tcharity) = _getvalues(tamount);
            _towned[sender] = _towned[sender].sub(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount); 
            _takecharity(tcharity);   
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
            (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tcharity) = _getvalues(tamount);
            _towned[sender] = _towned[sender].sub(tamount);
            _rowned[sender] = _rowned[sender].sub(ramount);
            _towned[recipient] = _towned[recipient].add(ttransferamount);
            _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
            _takecharity(tcharity);         
            _reflectfee(rfee, tfee);
            emit transfer(sender, recipient, ttransferamount);
        }

  Code Snippet:
        function _reflectfee(uint256 rfee, uint256 tfee) private {
            _rtotal = _rtotal.sub(rfee);
            _tfeetotal = _tfeetotal.add(tfee);
        }

  Code Snippet:
        function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
            (uint256 ttransferamount, uint256 tfee, uint256 tcharity) = _gettvalues(tamount, _taxfee, _charityfee);
            uint256 currentrate =  _getrate();
            (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, currentrate);
            return (ramount, rtransferamount, rfee, ttransferamount, tfee, tcharity);
        }

  Code Snippet:
        function _gettvalues(uint256 tamount, uint256 taxfee, uint256 charityfee) private pure returns (uint256, uint256, uint256) {
            uint256 tfee = tamount.mul(taxfee).div(100);
            uint256 tcharity = tamount.mul(charityfee).div(100);
            uint256 ttransferamount = tamount.sub(tfee).sub(tcharity);
            return (ttransferamount, tfee, tcharity);
        }

  Code Snippet:
        function _getrvalues(uint256 tamount, uint256 tfee, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
            uint256 ramount = tamount.mul(currentrate);
            uint256 rfee = tfee.mul(currentrate);
            uint256 rtransferamount = ramount.sub(rfee);
            return (ramount, rtransferamount, rfee);
        }

  Code Snippet:
        function _gettaxfee() private view returns(uint256) {
            return _taxfee;
        }

  Code Snippet:
        function _settaxfee(uint256 taxfee) external onlyowner() {
            require(taxfee >= 1 && taxfee <= 10, 'taxfee should be in 1 - 10');
            _taxfee = taxfee;
        }

  Code Snippet:
        function _setcharityfee(uint256 charityfee) external onlyowner() {
            require(charityfee >= 1 && charityfee <= 8, 'charityfee should be in 1 - 8');
            _charityfee = charityfee;
        }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xd206f06477c3b259e787893a4473236935b09ba4 — 53,334,963,159,192,270,012,416 tokens (59.98% of circulating supply)
  2. 0xa16643295ebfdec8407efd2e9767ab9f8b0aad06 — 7,819,666,285,757,075,554,304 tokens (8.79% of circulating supply)
  3. 0x0ed943ce24baebf257488771759f9bf482c39706 — 2,614,240,153,919,798,378,496 tokens (2.94% of circulating supply)
  4. 0xc72fed114603672fa95e3b7c8a847ce763ab30d7 — 2,055,840,396,749,962,215,424 tokens (2.31% of circulating supply)
  5. 0xfd7ef0aa93525732732866d2f66939ef9090622a — 1,744,022,738,183,069,892,608 tokens (1.96% of circulating supply)
  6. 0x86c70c4a3bc775fb4030448c9fdb73dc09dd8444 — 1,206,032,953,335,422,648,320 tokens (1.36% of circulating supply)
  7. 0xc6ab38cc1e90061c35028bfa7e4363d45cfe2a66 — 1,204,300,400,464,031,645,696 tokens (1.35% of circulating supply)
  8. 0x5d2348256debcbd916d2f72ba91b5b127193bcda — 1,150,876,459,796,227,817,472 tokens (1.29% of circulating supply)
  9. 0x817d9a62d1ad7b718eb30a497d4a444d319b5513 — 1,009,972,223,641,139,019,776 tokens (1.14% of circulating supply)
  10. 0x2ba1050cb3ff8446948ac9a67b9b276fe822dbf8 — 586,106,558,039,091,052,544 tokens (0.66% of circulating supply)

Top 10 Total Balance: 72,726,021,329,078,088,237,056 tokens
Top 10 Share of Circulating Supply: 81.78%
Top 10 Share of Total Supply: 72.73%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $2,636,181,953,317,355.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 57665477720.0657
USD Volume: 1709.4870
24h Volume/Liquidity Ratio: 540597.3334
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 223.60679774997897
LP holders count: 2

Liquidity holders for 0x43e2De970C0D69f809370C5B71b9587B3f23E4E3, (RafaleToken)

0x000000000000000000000000000000000000dead holds 223.60679774997897 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/RafaleToken, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1505.55 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-06-20T20:32:56
Last Active: 2025-07-26T20:18:14
Days Since Last Activity: 8.56254213582176 days
Last Transaction Hash: 0xaf13ef346495065b7840d29173229ecbc7b66d92fb54eb12300df33276631bc2
