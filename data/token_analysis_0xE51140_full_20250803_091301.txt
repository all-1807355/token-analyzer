Token Analysis Report
==================================================
Token: Weenie Inu (0xE51140053511c247daC9CD0867f4aB0805CdEEb9)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function _removesniper(address account) external onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not blacklist uniswap');
        require(!_issniper[account], "account is already blacklisted");
        _issniper[account] = true;
        _confirmedsnipers.push(account);
    }

  Code Snippet:
    function _amnestysniper(address account) external onlyowner() {
        require(_issniper[account], "account is not blacklisted");
        for (uint256 i = 0; i < _confirmedsnipers.length; i++) {
            if (_confirmedsnipers[i] == account) {
                _confirmedsnipers[i] = _confirmedsnipers[_confirmedsnipers.length - 1];
                _issniper[account] = false;
                _confirmedsnipers.pop();
                break;
            }
        }
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function initcontract() external onlyowner() {
        // pancakeswap: 0x10ed43c718714eb63d5aa57b78b54704e256024e
        // uniswap v2: 0x7a250d5630b4cf539739df2c5dacb4c659f2488d
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(0x10ed43c718714eb63d5aa57b78b54704e256024e);
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory())
        .createpair(address(this), _uniswapv2router.weth());

        uniswapv2router = _uniswapv2router;

        _isexcludedfromfee[owner()] = true;
        _isexcludedfromfee[address(this)] = true;
        
        
        marketingaddress = payable(0xe275507dd954a285eadc5b15a3dc3469dd8175d6);
    }

  Code Snippet:
    function opentrading() external onlyowner() {
        _liquidityfee=4;
        _taxfee=1;
        _marketingfee=5;
        tradingopen = true;
        launchtime = block.timestamp;
    }

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function swaptokens(uint256 contracttokenbalance) private locktheswap {
        swaptokensforeth(contracttokenbalance);
        
        //send to marketing address
        uint256 contractethbalance = address(this).balance;
        if(contractethbalance > 0) {
         sendethtofee(address(this).balance);
        }
    }

  Code Snippet:
    function sendethtofee(uint256 amount) private {
        marketingaddress.transfer(amount);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this), // the contract
            block.timestamp
        );
        
        emit swaptokensforeth(tokenamount, path);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        _takemarketing(sender, tmarketing);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        _takemarketing(sender, tmarketing);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        _takemarketing(sender, tmarketing);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        _takemarketing(sender, tmarketing);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, tmarketing, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity, tmarketing);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 tmarketing = calculatemarketingfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity, tmarketing);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity,uint256 tmarketing, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rmarketing = tmarketing.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity).sub(rmarketing);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculatemarketingfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 &&_marketingfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousmarketingfee = _marketingfee;
        _taxfee = 0;
        _liquidityfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
        _marketingfee = _previousmarketingfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setmarketingfeepercent(uint256 marketingfee) external onlyowner() {
        _marketingfee = marketingfee;
    }

  Code Snippet:
    function _removesniper(address account) external onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not blacklist uniswap');
        require(!_issniper[account], "account is already blacklisted");
        _issniper[account] = true;
        _confirmedsnipers.push(account);
    }

  Code Snippet:
     function setfeerate(uint256 rate) external  onlyowner() {
        _feerate = rate;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _removesniper(address account) external onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not blacklist uniswap');
        require(!_issniper[account], "account is already blacklisted");
        _issniper[account] = true;
        _confirmedsnipers.push(account);
    }

  Code Snippet:
    function _amnestysniper(address account) external onlyowner() {
        require(_issniper[account], "account is not blacklisted");
        for (uint256 i = 0; i < _confirmedsnipers.length; i++) {
            if (_confirmedsnipers[i] == account) {
                _confirmedsnipers[i] = _confirmedsnipers[_confirmedsnipers.length - 1];
                _issniper[account] = false;
                _confirmedsnipers.pop();
                break;
            }
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function opentrading() external onlyowner() {
        _liquidityfee=4;
        _taxfee=1;
        _marketingfee=5;
        tradingopen = true;
        launchtime = block.timestamp;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xe97892aa82d593f489ad5cebfaa1ed240e5897c1
Owner Balance: 74,947,603,276,834,422,784 tokens
Owner Share: 77.89% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xe97892aa82d593f489ad5cebfaa1ed240e5897c1 — 74,947,603,276,834,422,784 tokens (77.89% of circulating supply)
  2. 0xf3aef75cb03c14aa0c43272d40be093960cc401e — 1,386,523,066,553,221,888 tokens (1.44% of circulating supply)
  3. 0xf41f9b66809dcffc54eb5faf79bf89a44df3392f — 1,305,033,175,451,800,064 tokens (1.36% of circulating supply)
  4. 0x2e12979da9ad061ccc204c00d0e3a477a8cc4aea — 1,006,020,626,157,198,080 tokens (1.05% of circulating supply)
  5. 0x7e70ce12b0aee34947eee9714659c833a6a2b63b — 671,094,407,306,908,160 tokens (0.70% of circulating supply)
  6. 0x7619111eaad0ac0287f8b5775491f0610c2a89e0 — 538,658,199,976,411,136 tokens (0.56% of circulating supply)
  7. 0x19e91c4b5288eaed6269acc629f065ae585c9f51 — 497,487,489,766,542,144 tokens (0.52% of circulating supply)
  8. 0xbdfcb648cd1ea2e0e1bde7345ffb62ae6d3937ba — 455,760,231,080,672,128 tokens (0.47% of circulating supply)
  9. 0xea4653ba5e99e6370ac27560e2ce12f4be4564f0 — 441,037,335,060,327,232 tokens (0.46% of circulating supply)
  10. 0x4dc9814346a065af198e77ba3738d2f6c8cba64e — 430,761,996,439,031,488 tokens (0.45% of circulating supply)

Top 10 Total Balance: 81,679,979,804,626,535,104 tokens
Top 10 Share of Circulating Supply: 84.88%
Top 10 Share of Total Supply: 81.68%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $21,046,593,373,194,664.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (74.9476)
Total supply of LP tokens: 0.18774544465153076
LP holders count: 2

Liquidity holders for 0xE51140053511c247daC9CD0867f4aB0805CdEEb9, (Weenie Inu)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.18774544465152976 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1368.46 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-03T22:17:35
Last Active: 2025-07-29T17:09:34
Days Since Last Activity: 4.669071350219907 days
Last Transaction Hash: 0x771a088cb13995bb56fbbcb205a28c0e726ccdb065c31eea212e36e6c5839bec
