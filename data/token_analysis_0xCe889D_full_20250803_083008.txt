Token Analysis Report
==================================================
Token: MetaPirates (0xCe889D9367318f824b5C43D1C547562d25445809)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rwrd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function claimdividend() external {
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
function multitransfer(address from, address[] calldata addresses, uint256[] calldata tokens) external onlyowner {

    require(addresses.length < 501,"gas error: max airdrop limit is 500 addresses");
    require(addresses.length == tokens.length,"mismatch between address and token count");

    uint256 sccc = 0;

    for(uint i=0; i < addresses.length; i++){
        sccc = sccc + tokens[i];
    }

    require(balanceof(from) >= sccc, "not enough tokens in wallet");

    for(uint i=0; i < addresses.length; i++){
        _basictransfer(from,addresses[i],tokens[i]);
        if(!isdividendexempt[addresses[i]]) {
            try distributor.setshare(addresses[i], _balances[addresses[i]]) {} catch {} 
        }
    }

    // dividend tracker
    if(!isdividendexempt[from]) {
        try distributor.setshare(from, _balances[from]) {} catch {}
    }
}

  Code Snippet:
function multitransfer_fixed(address from, address[] calldata addresses, uint256 tokens) external onlyowner {

    require(addresses.length < 801,"gas error: max airdrop limit is 800 addresses");

    uint256 sccc = tokens * addresses.length;

    require(balanceof(from) >= sccc, "not enough tokens in wallet");

    for(uint i=0; i < addresses.length; i++){
        _basictransfer(from,addresses[i],tokens);
        if(!isdividendexempt[addresses[i]]) {
            try distributor.setshare(addresses[i], _balances[addresses[i]]) {} catch {} 
        }
    }

    // dividend tracker
    if(!isdividendexempt[from]) {
        try distributor.setshare(from, _balances[from]) {} catch {}
    }
}

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function settxlimit(uint256 amount) external authorized {
        _maxtxamount = amount;
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != devfeereceiver  && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount,(recipient == pair)) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function clearstuckbalance(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(marketingfeereceiver).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function clearstuckbalance_sender(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(msg.sender).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function setisdividendexempt(address holder, bool exempt) external authorized {
        require(holder != address(this) && holder != pair);
        isdividendexempt[holder] = exempt;
        if(exempt){
            distributor.setshare(holder, 0);
        }else{
            distributor.setshare(holder, _balances[holder]);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setistxlimitexempt(address holder, bool exempt) external authorized {
        istxlimitexempt[holder] = exempt;
    }

  Code Snippet:
    function setistimelockexempt(address holder, bool exempt) external authorized {
        istimelockexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingfee = _marketingfee;
        devfee = 2;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingfee).add(devfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/3, "fees cannot be more than 33%");
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver ) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingfeereceiver = _marketingfeereceiver;
        devfeereceiver = address(dev);
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

  Code Snippet:
    function settargetliquidity(uint256 _target, uint256 _denominator) external authorized {
        targetliquidity = _target;
        targetliquiditydenominator = _denominator;
    }

  Code Snippet:
    function setdistributioncriteria(uint256 _minperiod, uint256 _mindistribution) external authorized {
        distributor.setdistributioncriteria(_minperiod, _mindistribution);
    }

  Code Snippet:
    function setdistributorsettings(uint256 gas) external authorized {
        require(gas < 750000);
        distributorgas = gas;
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != devfeereceiver  && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount,(recipient == pair)) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function cooldownenabled(bool _status, uint8 _interval) public onlyowner {
        buycooldownenabled = _status;
        cooldowntimerinterval = _interval;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = rwrd.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = wbnb;
        path[1] = address(rwrd);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = rwrd.balanceof(address(this)).sub(balancebefore);

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            rwrd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != devfeereceiver  && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount,(recipient == pair)) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function shouldtakefee(address sender) internal view returns (bool) {
        return !isfeeexempt[sender];
    }

  Code Snippet:
    function takefee(address sender, uint256 amount, bool issell) internal returns (uint256) {
        
        uint256 multiplier = issell ? sellmultiplier : 100;
        uint256 feeamount = amount.mul(totalfee).mul(multiplier).div(feedenominator * 100);
        

        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function shouldswapback() internal view returns (bool) {
        return msg.sender != pair
        && !inswap
        && swapenabled
        && _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function clearstuckbalance(uint256 amountpercentage) external authorized {
        uint256 amountbnb = address(this).balance;
        payable(marketingfeereceiver).transfer(amountbnb * amountpercentage / 100);
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }

  Code Snippet:
    function swapback() internal swapping {
        uint256 dynamicliquidityfee = isoverliquified(targetliquidity, targetliquiditydenominator) ? 0 : liquidityfee;
        uint256 amounttoliquify = swapthreshold.mul(dynamicliquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = swapthreshold.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = wbnb;

        uint256 balancebefore = address(this).balance;

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance.sub(balancebefore);

        uint256 totalbnbfee = totalfee.sub(dynamicliquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(dynamicliquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(reflectionfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.mul(marketingfee).div(totalbnbfee);
        uint256 amountbnbdev = amountbnb.mul(devfee).div(totalbnbfee);

        try distributor.deposit{value: amountbnbreflection}() {} catch {}
        (bool tmpsuccess,) = payable(marketingfeereceiver).call{value: amountbnbmarketing, gas: 30000}("");
        (tmpsuccess,) = payable(devfeereceiver).call{value: amountbnbdev, gas: 30000}("");
        
        // supress warning msg
        tmpsuccess = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingfee = _marketingfee;
        devfee = 2;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingfee).add(devfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/3, "fees cannot be more than 33%");
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver ) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingfeereceiver = _marketingfeereceiver;
        devfeereceiver = address(dev);
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != devfeereceiver  && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount,(recipient == pair)) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function enable_blacklist(bool _status) public onlyowner {
        blacklistmode = _status;
    }

  Code Snippet:
    function manage_blacklist(address[] calldata addresses, bool status) public onlyowner {
        for (uint256 i; i < addresses.length; ++i) {
            isblacklisted[addresses[i]] = status;
        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        // blacklist
        if(blacklistmode){
            require(!isblacklisted[sender] && !isblacklisted[recipient],"blacklisted");    
        }


        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != devfeereceiver  && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        
        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for 1min between two buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }

        // checks max transaction limit
        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount,(recipient == pair)) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x15385f9b403a671305f39f378369dd80151d3fcb
Owner Balance: 331,296,668,295,392,329,728 tokens
Owner Share: 33.99% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x15385f9b403a671305f39f378369dd80151d3fcb — 331,296,668,295,392,329,728 tokens (33.99% of circulating supply)
  2. 0xa98288c90c09bcf5960280ab85e74daa7a44c098 — 199,757,462,806,621,618,176 tokens (20.50% of circulating supply)
  3. 0xce889d9367318f824b5c43d1c547562d25445809 — 53,992,206,477,522,067,456 tokens (5.54% of circulating supply)
  4. 0x5afec77d0f9380c67946bd24dbbd5110f821d6f4 — 19,998,351,718,865,698,816 tokens (2.05% of circulating supply)
  5. 0x50523e6219ff8e6c08320f6040f09967d669c204 — 19,959,153,032,479,080,448 tokens (2.05% of circulating supply)
  6. 0x01072aaec8e33c1078f75ffd1e564c143ec666d0 — 19,935,147,373,093,724,160 tokens (2.05% of circulating supply)
  7. 0x6215162d2fadcd6756b25642654b142abdd8fecd — 17,293,552,553,896,103,936 tokens (1.77% of circulating supply)
  8. 0xa42fcc6f922df2f1720499e6e487e46bb7cbaeed — 17,212,534,503,269,228,544 tokens (1.77% of circulating supply)
  9. 0xad91f382ba3b0e8d44a335fb23a2a11d7f16034f — 16,849,675,547,722,391,552 tokens (1.73% of circulating supply)
  10. 0xd8aaf6838e5096af235c23a55a2b62b4244adf0a — 16,230,854,519,316,860,928 tokens (1.67% of circulating supply)

Top 10 Total Balance: 712,525,606,828,179,103,744 tokens
Top 10 Share of Circulating Supply: 73.11%
Top 10 Share of Total Supply: 71.25%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $13,114,803,175,442,434.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 1718588604.9117
USD Volume: 23125.5994
24h Volume/Liquidity Ratio: 4181329.6029
Percentage of liquidity locked: 49.2600
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 18.75516488369978
LP holders count: 6

Liquidity holders for 0xCe889D9367318f824b5C43D1C547562d25445809, (MetaPirates)

Owner 0x15385f9b403a671305f39f378369dd80151d3fcb holds 9.36092867828471 LP tokens
WARNING: Owner holds over 5% of the liquidity
0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 9.237998526067232 LP tokens

0xa73dbab78f7a01fed4c5d9c3a155fae1823e1145 holds 0.15424504616953474 LP tokens

0xd353164ffffe9b8233a7d7a9f7d50b9114b1f375 holds 0.00119002795640972 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000802605221892902 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/metapiratesp2e, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/MetaPiratesP2E, Reason: metamask recovery phrase phishing
  URL: https://playmetapirates.com, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1318.34 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-24T00:26:31
Last Active: 2025-07-22T11:43:55
Days Since Last Activity: 11.865433901979166 days
Last Transaction Hash: 0x0a50b938c76c0a4d1778415a3c6a405e5ffe50f095f29c43c5fa1c95f98cc2ff
