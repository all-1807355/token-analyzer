Token Analysis Report
==================================================
Token: PEPECASH (0x2A5472268D5b176F5EF28D7a53C8258BBCE26313)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock the token contract");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded from reward");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function renounce(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded from reward");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function safeapprove(ierc20 token, address spender, uint256 value) internal {
        // safeapprove should only be called when setting an initial allowance,
        // or when resetting it to zero. to increase and decrease it, use
        // 'safeincreaseallowance' and 'safedecreaseallowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "safeerc20: approve from non-zero to non-zero allowance"
        );
        _calloptionalreturn(token, abi.encodewithselector(token.approve.selector, spender, value));
    }

  Code Snippet:
    function safedecreaseallowance(ierc20 token, address spender, uint256 value) internal {
        uint256 newallowance = token.allowance(address(this), spender).sub(value, "safeerc20: decreased allowance below zero");
        _calloptionalreturn(token, abi.encodewithselector(token.approve.selector, spender, newallowance));
    }

  Code Snippet:
    function _calloptionalreturn(ierc20 token, bytes memory data) private {
        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since
        // we're implementing it ourselves. we use {address.functioncall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functioncall(data, "safeerc20: low-level call failed");
        if (returndata.length > 0) { // return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "safeerc20: erc20 operation did not succeed");
        }
    }

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amt must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }   

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function includeinbfee(address account,bool _data) public onlyowner {
        _isexcludedfrombfee[account] = _data;
    }

  Code Snippet:
    function setallfeepercent(uint8 taxfee, uint8 liquidityfee, uint8 burnfee, uint8 walletfee, uint8 buybackfee, uint8 profitsfee) external onlyowner() {
        require(taxfee >= 0 && taxfee <=maxtaxfee,"tf err");
        require(liquidityfee >= 0 && liquidityfee <=maxliqfee,"lf err");
        require(burnfee >= 0 && burnfee <=maxburnfee,"bf err");
        require(walletfee >= 0 && walletfee <=maxwalletfee,"wf err");
        require(buybackfee >= 0 && buybackfee <=maxbuybackfee,"bbf err");
        require(profitsfee >= 0 && profitsfee <=maxprofitsfee,"bbf err");
        _taxfee = taxfee;
        _liquidityfee = liquidityfee;
        _burnfee = burnfee;
        _walletfee = walletfee;
        _buybackfee = buybackfee;        
        _profitsfee = profitsfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function setfeewallet(address payable _feewallet,address payable _profitwallet) external onlyowner {
        require(_feewallet != address(0), "zero address");
        require(_profitwallet != address(0), "zero address");
        feewallet = _feewallet;        
        profitwallet = _profitwallet;
    }

  Code Snippet:
    function setistakefee(bool _istakefee) public onlyowner{
        istakefee = _istakefee;
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee + _burnfee + _walletfee + _buybackfee + _profitsfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 && _burnfee == 0 && _walletfee == 0 && _buybackfee == 0 && _profitsfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousburnfee = _burnfee;
        _previouswalletfee = _walletfee;
        _previousbuybackfee = _buybackfee;
        _previousprofitsfee = _profitsfee;

        _taxfee = 0;
        _liquidityfee = 0;
        _burnfee = 0;
        _walletfee = 0;
        _buybackfee = 0;
        _profitsfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
        _burnfee = _previousburnfee;
        _walletfee = _previouswalletfee;
        _buybackfee = _previousbuybackfee;
        _profitsfee = _previousprofitsfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        //this needs to be distributed among burn, wallet and liquidity
        //burn
        uint8 totfee  = _burnfee + _walletfee + _liquidityfee + _buybackfee + _profitsfee; 
        uint256 spentamount = 0;
        uint256 totspentamount = 0;
        if(_burnfee != 0){
            spentamount  = contracttokenbalance.div(totfee).mul(_burnfee);
            _tokentransfernofee(address(this), dead, spentamount);
            totspentamount = spentamount;
        }

        if(_profitsfee != 0){
            spentamount = contracttokenbalance.div(totfee).mul(_profitsfee);
            uint256 initialbalance = address(this).balance;
            swaptokensforbnb(spentamount);
            uint256 newbalance = address(this).balance.sub(initialbalance);
            payable(profitwallet).transfer(newbalance);
            totspentamount = totspentamount + spentamount;
        }

        if(_walletfee != 0){
            spentamount = contracttokenbalance.div(totfee).mul(_walletfee);
            uint256 initialbalance = address(this).balance;
            swaptokensforbnb(spentamount);
            uint256 newbalance = address(this).balance.sub(initialbalance);
            payable(feewallet).transfer(newbalance);
            totspentamount = totspentamount + spentamount;
        }

        if(_buybackfee != 0){
            spentamount = contracttokenbalance.div(totfee).mul(_buybackfee);
            swaptokensforbnb(spentamount);
            totspentamount = totspentamount + spentamount;
        }

        if(_liquidityfee != 0){
            contracttokenbalance = contracttokenbalance.sub(totspentamount);

            // split the contract balance into halves
            uint256 half = contracttokenbalance.div(2);
            uint256 otherhalf = contracttokenbalance.sub(half);

            // capture the contract's current eth balance.
            // this is so that we can capture exactly the amount of eth that the
            // swap creates, and not make the liquidity event include any eth that
            // has been manually sent to the contract
            uint256 initialbalance = address(this).balance;

            // swap tokens for eth
            swaptokensforbnb(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

            // how much eth did we just swap into?
            uint256 newbalance = address(this).balance.sub(initialbalance);

            // add liquidity to uniswap
            addliquidity(otherhalf, newbalance);

            emit swapandliquify(half, newbalance, otherhalf);
        }

    }

  Code Snippet:
    function buybacktokens(uint256 amount) private locktheswap {
        if (amount > 0) {
            swapbnbfortokens(amount);
        }
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsv2router.weth();

        _approve(address(this), address(pcsv2router), tokenamount);

        // make the swap
        pcsv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapbnbfortokens(uint256 amount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = pcsv2router.weth();
        path[1] = address(this);

      // make the swap
        pcsv2router.swapexactethfortokenssupportingfeeontransfertokens{value: amount}(
            0, // accept any amount of tokens
            path,
            dead, // burn address
            block.timestamp.add(300)
        );        
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _tokentransfernofee(address sender, address recipient, uint256 amount) private {        
        uint256 currentrate =  _getrate();  
        uint256 ramount = amount.mul(currentrate);   

        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(ramount); 
        
        if (_isexcluded[sender]) {
            _towned[sender] = _towned[sender].sub(amount);
        } 
        if (_isexcluded[recipient]) {
            _towned[recipient] = _towned[recipient].add(amount);
        } 
        emit transfer(sender, recipient, amount);
    }


Holder Analysis
--------------
⚠️ Holder analysis exception in owner_circulating_supply_analysis: Exception during holder analysis in owner_circulating_supply_analysis: float division by zero

Liquidity Analysis
-----------------
Market Cap: $0.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 9803906063.7430
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0003
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 4104076.3591149906
LP holders count: 4

Liquidity holders for 0x2A5472268D5b176F5EF28D7a53C8258BBCE26313, (PEPECASH)

0xc765bddb93b0d1c1a88282ba0fa6b2d00e3e0c83 holds 4104046.940356555 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 28.533309592838208 LP tokens

0xb1b38cedf091714916bc01bc4b96674b1bacdc10 holds 0.8854488427365832 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 507.87 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2024-03-13T13:29:49
Last Active: 2025-08-02T00:10:01
Days Since Last Activity: 1.4218080865393519 days
Last Transaction Hash: 0xe2d6590dda451e0878a9da7240b356a4df87171ea5721258cf38b267a294772f
