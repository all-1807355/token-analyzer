Token Analysis Report
==================================================
Token: Baby Meta (0x4CC3c88daC183f7a1d082f895BdFaF2284253394)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function balanceof(address account) public view returns (uint256) {
        if (_isexcludedfromrewards[account]) return _towned[account];
        return tokenfromreflection(_rowned[account]);
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcludedfromrewards[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyteam {
        require(
            !_isexcludedfromrewards[account],
            "account is already excluded"
        );
        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcludedfromrewards[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) public onlyteam {
        require(_isexcludedfromrewards[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcludedfromrewards[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function setamounttosell(uint256 _divisormin, uint256 _divisormax) external onlyteam {
        mintokennumbertosell = _ttotal / _divisormin;
        tokennumbertosell = _ttotal / _divisormax;
    }

  Code Snippet:
    function setliqidityproviderwhitelisted(address _address, bool _whitelisted) external onlyteam {
        _liqprovwhitelist[_address] = _whitelisted;
        _taxwhitelist[_address] = _whitelisted;
        if (_whitelisted)
            excludefromreward(_address);
        else
            includeinreward(_address);
    }

  Code Snippet:
    function addliquiditypool(address lp, bool ispool) external onlyteam {
        liquiditypools[lp] = ispool;
        excludefromreward(lp);
    }

  Code Snippet:
    function addmarket(address _market) external onlyteam {
        ipancakerouter02 router = ipancakerouter02(_market);
        address pair = ipancakefactory(router.factory()).createpair(
            address(this),
            router.weth()
        );
        liquiditypools[pair] = true;
        markets[pair] = router;
        excludefromreward(pair);
    }

  Code Snippet:
    function _takeliquidity(uint256 tliquidity) private {
        uint256 currentrate = _getrate();
        uint256 rliquidity = tliquidity * currentrate;

        _rowned[address(this)] += rliquidity;
        if (_isexcludedfromrewards[address(this)])
            _towned[address(this)] += tliquidity;
        
    }

  Code Snippet:
    function shouldswap(address to) internal view returns(bool) {
        return 
            !inswap &&
            swapandliquifyenabled &&
            balanceof(address(this)) >= mintokennumbertosell &&
            !liquiditypools[msg.sender] &&
            liquiditypools[to] && 
            _liquidityfee > 0;
    }

  Code Snippet:
    function airdrop(address[] calldata _addresses, uint256[] calldata _amount) external onlyteam
    {
        require(_addresses.length == _amount.length);
        bool previousswap = swapandliquifyenabled;
        bool previousprotection = protectionenabled;
        swapandliquifyenabled = false;
        protectionenabled = false;
        for (uint256 i = 0; i < _addresses.length; i++) {
            require(!liquiditypools[_addresses[i]]);
            _transfer(msg.sender, _addresses[i], _amount[i] * (10 ** _decimals));
        }
        swapandliquifyenabled = previousswap;
        protectionenabled = previousprotection;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _transferownership(address(0));
    }

  Code Snippet:
    function verifycallresult(
        bool success,

WARNING: Is Honeypot Suspected
  Code Snippet:
    function verifycallresult(
        bool success,

  Code Snippet:
    function balanceof(address account) public view returns (uint256) {
        if (_isexcludedfromrewards[account]) return _towned[account];
        return tokenfromreflection(_rowned[account]);
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcludedfromrewards[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyteam {
        require(
            !_isexcludedfromrewards[account],
            "account is already excluded"
        );
        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcludedfromrewards[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) public onlyteam {
        require(_isexcludedfromrewards[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcludedfromrewards[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function setliqidityproviderwhitelisted(address _address, bool _whitelisted) external onlyteam {
        _liqprovwhitelist[_address] = _whitelisted;
        _taxwhitelist[_address] = _whitelisted;
        if (_whitelisted)
            excludefromreward(_address);
        else
            includeinreward(_address);
    }

  Code Snippet:
    function addliquiditypool(address lp, bool ispool) external onlyteam {
        liquiditypools[lp] = ispool;
        excludefromreward(lp);
    }

  Code Snippet:
    function addmarket(address _market) external onlyteam {
        ipancakerouter02 router = ipancakerouter02(_market);
        address pair = ipancakefactory(router.factory()).createpair(
            address(this),
            router.weth()
        );
        liquiditypools[pair] = true;
        markets[pair] = router;
        excludefromreward(pair);
    }

  Code Snippet:
    function _takeliquidity(uint256 tliquidity) private {
        uint256 currentrate = _getrate();
        uint256 rliquidity = tliquidity * currentrate;

        _rowned[address(this)] += rliquidity;
        if (_isexcludedfromrewards[address(this)])
            _towned[address(this)] += tliquidity;
        
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function settaxfeethousandth(uint256 taxfee, uint256 taxsellbias) external onlyteam {
        require(taxfee <= 100 && taxsellbias <= taxfee);
        _taxfee = taxfee;
        _taxsellbias = taxsellbias;
    }

  Code Snippet:
    function setbnbfeethousandth(uint256 _marketingfee, uint256 _lpfee, uint256 _sellbias) external onlyteam {
        require(_lpfee <= 100 && _marketingfee <= 150 && _sellbias <= _marketingfee + _lpfee);
        _liquidityfee = _marketingfee + _lpfee;
     
        totalfeestolp = _lpfee;
        totalfeestomarketing = _marketingfee;
        
        _liquiditysellbias = _sellbias;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyteam {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal - rfee;
        _tfeetotal = _tfeetotal + tfee;
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool selling, bool takefee)
        private

  Code Snippet:
    function _gettvalues(uint256 tamount, bool selling, bool takefee)
        private

  Code Snippet:
    function calculatetaxfee(uint256 _amount, bool selling) private view returns (uint256) {
        if (_taxfee == 0) return 0;
        return (_amount * (selling ? _taxfee + _taxsellbias : _taxfee - _taxsellbias )) / 1000;
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount, bool selling) private view returns (uint256) {
        if (_liquidityfee == 0) return 0;
        return (_amount * (selling ? _liquidityfee + _liquiditysellbias : _liquidityfee - _liquiditysellbias )) / 1000;
    }

  Code Snippet:
    function shouldswap(address to) internal view returns(bool) {
        return 
            !inswap &&
            swapandliquifyenabled &&
            balanceof(address(this)) >= mintokennumbertosell &&
            !liquiditypools[msg.sender] &&
            liquiditypools[to] && 
            _liquidityfee > 0;
    }

  Code Snippet:
    function swapandliquify(address to) internal swapping {
        uint256 amounttoswap = balanceof(address(this)) < tokennumbertosell ? balanceof(address(this)) : tokennumbertosell;

        uint256 tokensforlp = ((amounttoswap * totalfeestolp) / _liquidityfee) / 2;

        uint256 initialbalance = address(this).balance;

        swaptokensforeth(
            to,
            amounttoswap - tokensforlp
        );

        uint256 deltabalance = address(this).balance - initialbalance;
        uint256 totalbnbfee = _liquidityfee - totalfeestolp / 2;

        uint256 bnbtobeaddedtoliquidity = ((deltabalance * totalfeestolp) / totalbnbfee) / 2;

        if (bnbtobeaddedtoliquidity > 0)
            addliquidity(to, burnaddress, tokensforlp, bnbtobeaddedtoliquidity);

        uint256 bnbtobeaddedtomarketing = address(this).balance;
        
        if (bnbtobeaddedtomarketing > 0) {
            (bool sent, ) = marketingwallet.call{value: bnbtobeaddedtomarketing, gas: gnosisgas}("");
            require(sent, "failed to send to marketing");
        }
        
        emit swapandliquify(amounttoswap, deltabalance, tokensforlp);
    }

  Code Snippet:
    function swaptokensforeth(
        address pair,

  Code Snippet:
    function airdrop(address[] calldata _addresses, uint256[] calldata _amount) external onlyteam
    {
        require(_addresses.length == _amount.length);
        bool previousswap = swapandliquifyenabled;
        bool previousprotection = protectionenabled;
        swapandliquifyenabled = false;
        protectionenabled = false;
        for (uint256 i = 0; i < _addresses.length; i++) {
            require(!liquiditypools[_addresses[i]]);
            _transfer(msg.sender, _addresses[i], _amount[i] * (10 ** _decimals));
        }
        swapandliquifyenabled = previousswap;
        protectionenabled = previousprotection;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function setaccountwhitelisted(address account, bool whitelisted) public onlyteam
    {
        _taxwhitelist[account] = whitelisted;
    }

  Code Snippet:
    function setliqidityproviderwhitelisted(address _address, bool _whitelisted) external onlyteam {
        _liqprovwhitelist[_address] = _whitelisted;
        _taxwhitelist[_address] = _whitelisted;
        if (_whitelisted)
            excludefromreward(_address);
        else
            includeinreward(_address);
    }

  Code Snippet:
    function getlpwhitelisted(address _account) external view returns (bool) {
        return _liqprovwhitelist[_account];
    }

  Code Snippet:
    function iswhitelisted(address account) public view returns (bool) {
        return _taxwhitelist[account];
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x2d5a7b9b47c5be253ac4730eb1b688b94a21ef2e — 383,662,682,971,337,878,667,264 tokens (52.31% of circulating supply)
  2. 0x03bcc7e971c40609a72dacc63460b13c018f003f — 14,098,948,018,530,078,949,376 tokens (1.92% of circulating supply)
  3. 0x79fecf6b591df19eb8416060c95b0fa036d398de — 10,670,300,900,240,360,734,720 tokens (1.45% of circulating supply)
  4. 0xba9261abd9683bb514f32bd0029eeeec32572cba — 8,318,049,424,332,502,859,776 tokens (1.13% of circulating supply)
  5. 0xe836abf966ed709d436aae09ce7aac70261c0b44 — 3,887,109,360,364,339,855,360 tokens (0.53% of circulating supply)
  6. 0x2da926fd0918cd1e974a724b527c0ef8f0f776a9 — 3,039,435,583,174,326,353,920 tokens (0.41% of circulating supply)
  7. 0xdb224dac02acb44ae3fd31ae63c6717fad04a4a0 — 2,865,510,463,062,528,229,376 tokens (0.39% of circulating supply)
  8. 0x95e5f7284b5c07435a9698014d1e73e1b1b684b1 — 2,190,922,464,527,033,040,896 tokens (0.30% of circulating supply)
  9. 0x5922423692337e0421fbaa95e1e9b5677e334b0d — 1,943,135,546,100,252,147,712 tokens (0.26% of circulating supply)
  10. 0xaf4731bfb53d455098639dd691abb644af90b5c9 — 1,517,328,588,177,595,432,960 tokens (0.21% of circulating supply)

Top 10 Total Balance: 432,193,423,319,846,896,271,360 tokens
Top 10 Share of Circulating Supply: 58.93%
Top 10 Share of Total Supply: 43.22%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $64,220,642,946,554,392.00
Liquidity: $0.07
Liquidity/MCap Ratio: 0.0000
Token Volume: 32558106461.6125
USD Volume: 2851.0208
24h Volume/Liquidity Ratio: 42430.6401
Percentage of liquidity locked: 48.5600
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 2993.8750152239145
LP holders count: 4

Liquidity holders for 0x4CC3c88daC183f7a1d082f895BdFaF2284253394, (Baby Meta)

0x3c4f6eef598101828af63e44dff52aae0f207afa holds 1539.4804318340653 LP tokens

0x000000000000000000000000000000000000dead holds 1453.7487722824844 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.645811107364637 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1353.81 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-18T15:48:12
Last Active: 2025-07-29T10:05:22
Days Since Last Activity: 5.045640910763889 days
Last Transaction Hash: 0x252a86b77f4d7948bc7c236b2bd094964050095d0501859b7d2d6fffcd0bd1da
