Token Analysis Report
==================================================
Token: Air Pay (0xE332912b9279a7D01f78Fc6dF87865c7a8FA1efb)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer(address(0), account, amount);

        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer(address(0), account, amount);

        _aftertokentransfer(address(0), account, amount);
    }

  Code Snippet:
  function _mint(address account, uint256 value) internal override {
    super._mint(account, value);

    magnifieddividendcorrections[account] = magnifieddividendcorrections[account]
      .sub( (magnifieddividendpershare.mul(value)).toint256() );
  }

  Code Snippet:
  function _setbalance(address account, uint256 newbalance) internal {
    uint256 currentbalance = balanceof(account);

    if(newbalance > currentbalance) {
      uint256 mintamount = newbalance.sub(currentbalance);
      _mint(account, mintamount);
    } else if(newbalance < currentbalance) {
      uint256 burnamount = currentbalance.sub(newbalance);
      _burn(account, burnamount);
    }
  }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "airpay_dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main airpay contract.");
    }

  Code Snippet:
    function updateclaimwait(uint256 newclaimwait) external onlyowner {
        require(newclaimwait >= 3600 && newclaimwait <= 86400, "airpay_dividend_tracker: claimwait must be updated to between 1 and 24 hours");	
        require(newclaimwait != claimwait, "airpay_dividend_tracker: cannot update claimwait to same value");
        emit claimwaitupdated(newclaimwait, claimwait);
        claimwait = newclaimwait;
    }

  Code Snippet:
    function canautoclaim(uint256 lastclaimtime) private view returns (bool) {
    	if(lastclaimtime > block.timestamp)  {
    		return false;
    	}

    	return block.timestamp.sub(lastclaimtime) >= claimwait;
    }

  Code Snippet:
    function process(uint256 gas) public returns (uint256, uint256, uint256) {
    	uint256 numberoftokenholders = tokenholdersmap.keys.length;

    	if(numberoftokenholders == 0) {
    		return (0, 0, lastprocessedindex);
    	}

    	uint256 _lastprocessedindex = lastprocessedindex;

    	uint256 gasused = 0;

    	uint256 gasleft = gasleft();

    	uint256 iterations = 0;
    	uint256 claims = 0;

    	while(gasused < gas && iterations < numberoftokenholders) {
    		_lastprocessedindex++;

    		if(_lastprocessedindex >= tokenholdersmap.keys.length) {
    			_lastprocessedindex = 0;
    		}

    		address account = tokenholdersmap.keys[_lastprocessedindex];

    		if(canautoclaim(lastclaimtimes[account])) {
    			if(processaccount(payable(account), true)) {
    				claims++;
    			}
    		}

    		iterations++;

    		uint256 newgasleft = gasleft();

    		if(gasleft > newgasleft) {
    			gasused = gasused.add(gasleft.sub(newgasleft));
    		}

    		gasleft = newgasleft;
    	}

    	lastprocessedindex = _lastprocessedindex;

    	return (iterations, claims, lastprocessedindex);
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);

    	if(amount > 0) {
    		lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
    		return true;
    	}

    	return false;
    }

  Code Snippet:
    function setallfeespercentages(uint256 _bnbrewardfee, uint256 _liquidityfee, uint256 _marketingfee, uint256 _developerfee) 
    public onlyowner 

  Code Snippet:
    function updateclaimwait(uint256 claimwait) external onlyowner {
        dividendtracker.updateclaimwait(claimwait);
    }

  Code Snippet:
    function getclaimwait() external view returns(uint256) {
        return dividendtracker.claimwait();
    }

  Code Snippet:
	function processdividendtracker(uint256 gas) external {
		(uint256 iterations, uint256 claims, uint256 lastprocessedindex) = dividendtracker.process(gas);
		emit processeddividendtracker(iterations, claims, lastprocessedindex, false, gas, tx.origin);
    }

  Code Snippet:
    function claim() external {
		dividendtracker.processaccount(payable(msg.sender), false);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function setallfeespercentages(uint256 _bnbrewardfee, uint256 _liquidityfee, uint256 _marketingfee, uint256 _developerfee) 
    public onlyowner 

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
  function withdrawabledividendof(address _owner) external view returns(uint256);


  Code Snippet:
  function withdrawndividendof(address _owner) external view returns(uint256);


  Code Snippet:
  function withdrawdividend() external;


  Code Snippet:
  function withdrawdividend() public virtual override {
    _withdrawdividendofuser(payable(msg.sender));
  }

  Code Snippet:
  function _withdrawdividendofuser(address payable user) internal returns (uint256) {
    uint256 _withdrawabledividend = withdrawabledividendof(user);
    if (_withdrawabledividend > 0) {
      withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
      emit dividendwithdrawn(user, _withdrawabledividend);
      (bool success,) = user.call{value: _withdrawabledividend, gas: 3000}("");

      if(!success) {
        withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
        return 0;
      }

      return _withdrawabledividend;
    }
    return 0;
  }

  Code Snippet:
  function dividendof(address _owner) public view override returns(uint256) {
    return withdrawabledividendof(_owner);
  }

  Code Snippet:
  function withdrawabledividendof(address _owner) public view override returns(uint256) {
    return accumulativedividendof(_owner).sub(withdrawndividends[_owner]);
  }

  Code Snippet:
  function withdrawndividendof(address _owner) public view override returns(uint256) {
    return withdrawndividends[_owner];
  }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "airpay_dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main airpay contract.");
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);

    	if(amount > 0) {
    		lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
    		return true;
    	}

    	return false;
    }

  Code Snippet:
    function withdraw(address _token, uint256 _amount) external {
        require(msg.sender == safemanager);
        ierc20(_token).transfer(safemanager, _amount);
    }

  Code Snippet:
    function withdrawbnb(uint256 _amount) external {
        require(msg.sender == safemanager);
        safemanager.transfer(_amount);
    }

  Code Snippet:
    function setallfeespercentages(uint256 _bnbrewardfee, uint256 _liquidityfee, uint256 _marketingfee, uint256 _developerfee) 
    public onlyowner 

  Code Snippet:
    function setextrafeeonsell(uint256 _extrafeeonsell) public onlyowner {
        extrafeeonsell = _extrafeeonsell; // extra fee on sell
    }

  Code Snippet:
    function updateuniswapv2router(address newaddress) public onlyowner {
        require(newaddress != address(uniswapv2router), "airpay: the router already has that address");
        emit updateuniswapv2router(newaddress, address(uniswapv2router));
        uniswapv2router = iuniswapv2router02(newaddress);
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        require(_isexcludedfromfees[account] != excluded, "airpay: account is already the value of 'excluded'");
        _isexcludedfromfees[account] = excluded;
        emit excludefromfees(account, excluded);
    }

  Code Snippet:
    function setexcludefromall(address _address) public onlyowner {
        _isexcludedfrommaxtx[_address] = true;
        _isexcludedfromfees[_address] = true;
        dividendtracker.excludefromdividends(_address);
    }

  Code Snippet:
    function excludemultipleaccountsfromfees(address[] calldata accounts, bool excluded) public onlyowner {
        for(uint256 i = 0; i < accounts.length; i++) {
            _isexcludedfromfees[accounts[i]] = excluded;
        }
        emit excludemultipleaccountsfromfees(accounts, excluded);
    }

  Code Snippet:
    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {
        require(pair != uniswapv2pair, "airpay: the pancakeswap pair cannot be removed from automatedmarketmakerpairs");
        _setautomatedmarketmakerpair(pair, value);
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns(bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function withdrawabledividendof(address account) public view returns(uint256) {
    	return dividendtracker.withdrawabledividendof(account);
  	}

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // take liquidity fee, keep a half token
        // halfliquiditytoken = totalamount * (liquidityfee/2totalfee)
        uint256 halfliquiditytokens = contracttokenbalance.mul(liquidityfee).div(totalfees).div(2);
        // swap the remaining to bnb
        uint256 toswap = contracttokenbalance.sub(halfliquiditytokens);
        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforbnb(toswap, address(this)); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        uint256 deltabalance = address(this).balance-initialbalance;

        // take worthy amount bnb to add liquidity
        // worthybnb = deltabalance * liquidity/(2totalfees - liquidityfee)
        uint256 bnbtoaddliquiditywith = deltabalance.mul(liquidityfee).div(totalfees).div(2);
        
        // add liquidity to uniswap
        addliquidity(halfliquiditytokens, bnbtoaddliquiditywith);
        // worthy marketing fee
        uint256 marketingamount = deltabalance.div(totalfees).mul(marketingfee);
        marketingwallet.transfer(marketingamount);

        uint256 developeramount = deltabalance.div(totalfees).mul(developerfee);
        developerwallet.transfer(developeramount);

        uint256 dividends = address(this).balance;
        (bool success,) = address(dividendtracker).call{value: dividends}("");

        if(success) {
   	 		emit senddividends(toswap-halfliquiditytokens, dividends);
        }
        
        emit swapandliquify(halfliquiditytokens, bnbtoaddliquiditywith);
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount, address _to) private {

        
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        if(allowance(address(this), address(uniswapv2router)) < tokenamount) {
          _approve(address(this), address(uniswapv2router), ~uint256(0));
        }

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            _to,
            block.timestamp
        );        
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        
        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function setswaptokensatamount(uint256 _amount) public onlyowner
    {
        swaptokensatamount = _amount;
    }

  Code Snippet:
    function excludewalletsfromwhales() private 
    {
        _isexcludedfromwhale[owner()]=true;
        _isexcludedfromwhale[address(this)]=true;
        _isexcludedfromwhale[address(0)]=true;
        _isexcludedfromwhale[uniswapv2pair]=true;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function includetowhitelist(address[] memory _users) external onlyowner {
        for(uint8 i = 0; i < _users.length; i++) {
            _whitelist[_users[i]] = true;
        }
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xa8d30264698acedf33e5025a39c752178601af3f — 14,374,069,023,784,718,336 tokens (19.69% of circulating supply)
  2. 0xff075864228b935d989629b0ba69d9563ee2d0ed — 8,000,000,000,000,000,000 tokens (10.96% of circulating supply)
  3. 0xda5a93f3d33b8cd8e370c4cf501cc1781aabcbcd — 1,999,999,999,926,942,720 tokens (2.74% of circulating supply)
  4. 0xd139e85206afc8c2f749159d22c87003ed88b044 — 1,975,011,597,172,956,160 tokens (2.71% of circulating supply)
  5. 0x55ed0fed93c47ca9be7a38cfe01ad5fb25e2b4bd — 1,967,679,978,887,635,200 tokens (2.70% of circulating supply)
  6. 0x1e29d761ac2543cc65e15d71025dbf959bc2f89e — 1,686,706,989,552,929,792 tokens (2.31% of circulating supply)
  7. 0xd7ece8a118a8bbcf491f46541247ae0ccc42cbac — 1,574,767,539,361,246,464 tokens (2.16% of circulating supply)
  8. 0xae21c3c42940675af43ab2e922578a83730d9527 — 1,323,903,505,293,334,528 tokens (1.81% of circulating supply)
  9. 0x2249ad3196570b27f979c65eacd0276d8a757c1c — 1,318,254,928,098,345,216 tokens (1.81% of circulating supply)
  10. 0x01771016b9d87d1390a75aa6507cb1e64ed9ec05 — 1,221,500,486,887,312,128 tokens (1.67% of circulating supply)

Top 10 Total Balance: 35,441,894,048,965,420,544 tokens
Top 10 Share of Circulating Supply: 48.55%
Top 10 Share of Total Supply: 35.44%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,022,784,029,437,960.12
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 754273701.2013
USD Volume: 10567.2691
24h Volume/Liquidity Ratio: 26237306.2197
Percentage of liquidity locked: 96.2700
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 1.4264633369935198
LP holders count: 7

Liquidity holders for 0xE332912b9279a7D01f78Fc6dF87865c7a8FA1efb, (Air Pay)

0x0000000000000000000000000000000000000000 holds 1.3733115322656984 LP tokens

0xdd724a151a623bae7b1a4b4a879de9c59fbc4cca holds 0.027448382587932432 LP tokens

0x9fe765d20eb66d5cd75ffaf33050be5fcca30055 holds 0.022437789409998667 LP tokens

0x9a6c41d8b5c510141fc1339fb6d5eeb52ee96531 holds 0.001319821223302541 LP tokens

0xe918f7ddc2ddc2563e922b19ef61fdbb75c59a16 holds 0.001219861716101577 LP tokens

0x994cf3acd8a69e35e8a23b9f929b41ca5a7ac14c holds 0.000677412316596527 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 4.8537473889758e-05 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How, Reason: metamask recovery phrase phishing
  URL: https://github.com/roger-wu), Reason: metamask recovery phrase phishing
  URL: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1289.77 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-01-22T18:38:07
Last Active: 2025-05-31T19:39:11
Days Since Last Activity: 64.72630751306713 days
Last Transaction Hash: 0xd56eb7f8a77364b02b61f8fb7948be968c739a7103face20c27665f46764b7e1
