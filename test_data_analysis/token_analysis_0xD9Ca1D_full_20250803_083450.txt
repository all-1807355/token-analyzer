Token Analysis Report
==================================================
Token: Universal Pickle (0xD9Ca1D00De092A90463F27Fc3F5bD3B3D2b0C352)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock the token contract");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded from reward");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded from reward");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function safeapprove(ierc20 token, address spender, uint256 value) internal {
        // safeapprove should only be called when setting an initial allowance,
        // or when resetting it to zero. to increase and decrease it, use
        // 'safeincreaseallowance' and 'safedecreaseallowance'
        // solhint-disable-next-line max-line-length
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "safeerc20: approve from non-zero to non-zero allowance"
        );
        _calloptionalreturn(token, abi.encodewithselector(token.approve.selector, spender, value));
    }

  Code Snippet:
    function safedecreaseallowance(ierc20 token, address spender, uint256 value) internal {
        uint256 newallowance = token.allowance(address(this), spender).sub(value, "safeerc20: decreased allowance below zero");
        _calloptionalreturn(token, abi.encodewithselector(token.approve.selector, spender, newallowance));
    }

  Code Snippet:
    function _calloptionalreturn(ierc20 token, bytes memory data) private {
        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since
        // we're implementing it ourselves. we use {address.functioncall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functioncall(data, "safeerc20: low-level call failed");
        if (returndata.length > 0) { // return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "safeerc20: erc20 operation did not succeed");
        }
    }

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amt must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function setallfeepercent(uint8 taxfee, uint8 liquidityfee, uint8 burnfee, uint8 walletfee, uint8 buybackfee) external onlyowner() {
        require(taxfee >= 0 && taxfee <=maxtaxfee,"tf err");
        require(liquidityfee >= 0 && liquidityfee <=maxliqfee,"lf err");
        require(burnfee >= 0 && burnfee <=maxburnfee,"bf err");
        require(walletfee >= 0 && walletfee <=maxwalletfee,"wf err");
        require(buybackfee >= 0 && buybackfee <=maxbuybackfee,"bbf err");
        _taxfee = taxfee;
        _liquidityfee = liquidityfee;
        _burnfee = burnfee;
        _buybackfee = buybackfee;
        _walletfee = walletfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function setfeewallet(address payable newfeewallet) external onlyowner {
        require(newfeewallet != address(0), "zero address");
        feewallet = newfeewallet;
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee + _burnfee + _walletfee + _buybackfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 && _burnfee == 0 && _walletfee == 0 && _buybackfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousburnfee = _burnfee;
        _previouswalletfee = _walletfee;
        _previousbuybackfee = _buybackfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
        _burnfee = 0;
        _walletfee = 0;
        _buybackfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
        _burnfee = _previousburnfee;
        _walletfee = _previouswalletfee;
        _buybackfee = _previousbuybackfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        //this needs to be distributed among burn, wallet and liquidity
        //burn
        uint8 totfee  = _burnfee + _walletfee + _liquidityfee + _buybackfee; 
        uint256 spentamount = 0;
        uint256 totspentamount = 0;
        if(_burnfee != 0){
            spentamount  = contracttokenbalance.div(totfee).mul(_burnfee);
            _tokentransfernofee(address(this), dead, spentamount);
            totspentamount = spentamount;
        }

        if(_walletfee != 0){
            spentamount = contracttokenbalance.div(totfee).mul(_walletfee);
            _tokentransfernofee(address(this), feewallet, spentamount);
            totspentamount = totspentamount + spentamount;
        }

        if(_buybackfee != 0){
            spentamount = contracttokenbalance.div(totfee).mul(_buybackfee);
            swaptokensforbnb(spentamount);
            totspentamount = totspentamount + spentamount;
        }

        if(_liquidityfee != 0){
            contracttokenbalance = contracttokenbalance.sub(totspentamount);

            // split the contract balance into halves
            uint256 half = contracttokenbalance.div(2);
            uint256 otherhalf = contracttokenbalance.sub(half);

            // capture the contract's current eth balance.
            // this is so that we can capture exactly the amount of eth that the
            // swap creates, and not make the liquidity event include any eth that
            // has been manually sent to the contract
            uint256 initialbalance = address(this).balance;

            // swap tokens for eth
            swaptokensforbnb(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

            // how much eth did we just swap into?
            uint256 newbalance = address(this).balance.sub(initialbalance);

            // add liquidity to uniswap
            addliquidity(otherhalf, newbalance);

            emit swapandliquify(half, newbalance, otherhalf);
        }

    }

  Code Snippet:
    function buybacktokens(uint256 amount) private locktheswap {
    	if (amount > 0) {
    	    swapbnbfortokens(amount);
	    }
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsv2router.weth();

        _approve(address(this), address(pcsv2router), tokenamount);

        // make the swap
        pcsv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapbnbfortokens(uint256 amount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = pcsv2router.weth();
        path[1] = address(this);

      // make the swap
        pcsv2router.swapexactethfortokenssupportingfeeontransfertokens{value: amount}(
            0, // accept any amount of tokens
            path,
            dead, // burn address
            block.timestamp.add(300)
        );        
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _tokentransfernofee(address sender, address recipient, uint256 amount) private {        
        uint256 currentrate =  _getrate();  
        uint256 ramount = amount.mul(currentrate);   

        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(ramount); 
        
        if (_isexcluded[sender]) {
            _towned[sender] = _towned[sender].sub(amount);
        } 
        if (_isexcluded[recipient]) {
            _towned[recipient] = _towned[recipient].add(amount);
        } 
        emit transfer(sender, recipient, amount);
    }

  Code Snippet:
    function recoverbep20(address tokenaddress, uint256 tokenamount) public onlyowner {
        // do not allow recovering self token
        require(tokenaddress != address(this), "self withdraw");
        ierc20(tokenaddress).transfer(owner(), tokenamount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xb1b4c99e0933747225b1c590896500b0c074feb8 — 446,710,978,764,348,548,773,314,560 tokens (50.71% of circulating supply)
  2. 0xf84752c48c5c099aea8eeec7e348051fed979e23 — 28,625,999,170,190,237,998,514,176 tokens (3.25% of circulating supply)
  3. 0x587c5b8fd9e3b3e081032cf2f0e8c71d5bbd45d7 — 17,319,658,307,222,962,700,288,000 tokens (1.97% of circulating supply)
  4. 0xd63632535b028dee699f50642deb2a4d38fc0739 — 13,728,928,470,350,035,222,003,712 tokens (1.56% of circulating supply)
  5. 0x8341a4b3c071051fb69485df914db695ecb80e56 — 11,094,170,920,733,406,543,216,640 tokens (1.26% of circulating supply)
  6. 0xcdcbc2458e178f5b69bb385a778cf55a8569755e — 9,688,265,224,084,840,985,395,200 tokens (1.10% of circulating supply)
  7. 0xcc988026083c780c97f767f625dcc026d5feb27a — 8,895,355,965,569,708,733,759,488 tokens (1.01% of circulating supply)
  8. 0x2ca6ff322bcf5ab22c0a830d1eea8a42786c11fb — 7,792,684,335,761,443,931,553,792 tokens (0.88% of circulating supply)
  9. 0x4e9330a0073f326a07ff818a0f5f91899df269da — 6,778,087,650,996,507,117,617,152 tokens (0.77% of circulating supply)
  10. 0x5d687329d8cd5da9af07edf5d20b0ce7a1b614fd — 6,069,213,734,574,837,374,910,464 tokens (0.69% of circulating supply)

Top 10 Total Balance: 556,703,342,543,832,529,380,573,184 tokens
Top 10 Share of Circulating Supply: 63.20%
Top 10 Share of Total Supply: 55.67%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $61,527,220,385,986,856.00
Liquidity: $0.06
Liquidity/MCap Ratio: 0.0000
Token Volume: 110206.6160
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0001
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 95168.14564039375
LP holders count: 7

Liquidity holders for 0xD9Ca1D00De092A90463F27Fc3F5bD3B3D2b0C352, (Universal Pickle)

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 56984.92783183989 LP tokens

0x000000000000000000000000000000000000dead holds 38180.01359543221 LP tokens

0x9594ab17390c80ca959edf73a81da3dfeb4f7004 holds 1.8205033683481204 LP tokens

0x94a8ee3e89be35631293995a56f9c5dd23972809 holds 1.0460043407188289 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.33770541257917724 LP tokens

0xda95f3afe7bafe5d8070e2d3140d104effcb77fd holds 3.2456e-14 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1323.24 days
⚠️ Lifecycle analysis exception: Exception during lifecycle analysis in lifecycle_analysis: unsupported operand type(s) for /: 'NoneType' and 'int'
