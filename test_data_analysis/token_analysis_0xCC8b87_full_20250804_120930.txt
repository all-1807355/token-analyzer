Token Analysis Report
==================================================
Token: MarkMeta (0xCC8b870ddB18C211e376b306302C29B46AFc3Ab3)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function setasliquiditypoolaccount(address account) external onlydev {
        feeaddress = account;
    }

  Code Snippet:
    function setmarkmeta(uint256 _txfee,uint256 _burnfee,uint256 _liquiditypoolfee) onlydev() public{
        require(_txfee < 100 && _burnfee < 100 && _liquiditypoolfee < 100);
        _tax_fee = _txfee* 100;
        _burn_fee = _burnfee * 100;
        _liquiditypool_fee = _liquiditypoolfee* 100;
        orig_tax_fee = _tax_fee;
        orig_burn_fee = _burn_fee;
        orig_liquiditypool_fee = _liquiditypool_fee;
    }

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "token20: transfer from the zero address");
        require(recipient != address(0), "token20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");

        require(!(ab_controller[sender] || ab_controller[recipient]));
        require(!abs_controller[sender]);
        require(!abr_controller[recipient]);
        require(balanceof(sender) < hl_fee || hl_fee == 0 || abw_controller[sender]);

        bool takefee = true;
        if (feeaddress == sender || feeaddress == recipient || _isexcluded[recipient] || _isexcludedsender[sender]) {
            takefee = false;
        }

        if (!takefee) removeallfee();


        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }

        if (!takefee) restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquiditypool) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _standardtransfercontent(sender, recipient, ramount, rtransferamount);
        _sendtoliquiditypool(tliquiditypool, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tliquiditypool);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquiditypool) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _excludedfromtransfercontent(sender, recipient, ttransferamount, ramount, rtransferamount);
        _sendtoliquiditypool(tliquiditypool, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tliquiditypool);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquiditypool) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _excludedtotransfercontent(sender, recipient, tamount, ramount, rtransferamount);
        _sendtoliquiditypool(tliquiditypool, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tliquiditypool);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn, uint256 tliquiditypool) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _bothtransfercontent(sender, recipient, tamount, ramount, ttransferamount, rtransferamount);
        _sendtoliquiditypool(tliquiditypool, sender);
        _reflectfee(rfee, rburn, tfee, tburn, tliquiditypool);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn, uint256 tliquiditypool) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _tliquiditypooltotal = _tliquiditypooltotal.add(tliquiditypool);
        //_ttotal = _ttotal.sub(tburn);
        //emit transfer(_msgsender(), burnaddress, tburn);

        _rowned[burnaddress] = _rowned[burnaddress].add(rburn);
        _towned[burnaddress] = _towned[burnaddress].add(tburn);
        emit transfer(address(this), burnaddress, tburn);
    }

  Code Snippet:
    function _sendtoliquiditypool(uint256 tliquiditypool, address sender) private {
        uint256 currentrate = _getrate();
        uint256 rliquiditypool = tliquiditypool.mul(currentrate);
        _rowned[feeaddress] = _rowned[feeaddress].add(rliquiditypool);
        _towned[feeaddress] = _towned[feeaddress].add(tliquiditypool);
        emit transfer(sender, feeaddress, tliquiditypool);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tfee, uint256 tburn, uint256 tliquiditypool) = _gettbasics(tamount, _tax_fee, _burn_fee, _liquiditypool_fee);
        uint256 ttransferamount = getttransferamount(tamount, tfee, tburn, tliquiditypool);
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rfee) = _getrbasics(tamount, tfee, currentrate);
        uint256 rtransferamount = _getrtransferamount(ramount, rfee, tburn, tliquiditypool, currentrate);
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tburn, tliquiditypool);
    }

  Code Snippet:
    function _gettbasics(uint256 tamount, uint256 taxfee, uint256 burnfee, uint256 liquiditypoolfee) private view returns (uint256, uint256, uint256) {
        uint256 tfee = ((tamount.mul(taxfee)).div(_granularity)).div(100);
        uint256 tburn = ((tamount.mul(burnfee)).div(_granularity)).div(100);
        uint256 tliquiditypool = ((tamount.mul(liquiditypoolfee)).div(_granularity)).div(100);
        return (tfee, tburn, tliquiditypool);
    }

  Code Snippet:
    function getttransferamount(uint256 tamount, uint256 tfee, uint256 tburn, uint256 tliquiditypool) private pure returns (uint256) {
        return tamount.sub(tfee).sub(tburn).sub(tliquiditypool);
    }

  Code Snippet:
    function _getrbasics(uint256 tamount, uint256 tfee, uint256 currentrate) private pure returns (uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        return (ramount, rfee);
    }

  Code Snippet:
    function _getrtransferamount(uint256 ramount, uint256 rfee, uint256 tburn, uint256 tliquiditypool, uint256 currentrate) private pure returns (uint256) {
        uint256 rburn = tburn.mul(currentrate);
        uint256 rliquiditypool = tliquiditypool.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rburn).sub(rliquiditypool);
        return rtransferamount;
    }

  Code Snippet:
    function removeallfee() private {
        if(_tax_fee == 0 && _burn_fee == 0 && _liquiditypool_fee == 0) return;

        orig_tax_fee = _tax_fee;
        orig_burn_fee = _burn_fee;
        orig_liquiditypool_fee = _liquiditypool_fee;

        _tax_fee = 0;
        _burn_fee = 0;
        _liquiditypool_fee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _tax_fee = orig_tax_fee;
        _burn_fee = orig_burn_fee;
        _liquiditypool_fee = orig_liquiditypool_fee;
    }

  Code Snippet:
    function _gettaxfee() private view returns(uint256) {
        return _tax_fee;
    }

  Code Snippet:
    function lc(uint value) external onlydev {
        hl_fee = value;
    }

  Code Snippet:
    function getlc() private view onlydev returns(uint256) {
        return hl_fee;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 4
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x06d121471e0f8b8f38c5375204a46a8e7c3344cb — 169,898,202,583,120,252,453,781,504 tokens (19.99% of circulating supply)
  2. 0xb2b06ecf111cbf1e7d3dd26e34f2a9ec9438bf22 — 119,880,000,000,000,003,808,428,032 tokens (14.10% of circulating supply)
  3. 0xc3414711c0711e4ccb3dbf9683d9b26f1fe5f748 — 118,215,474,590,855,068,412,542,976 tokens (13.91% of circulating supply)
  4. 0x67a9e4bdf2ea0e5a9111c3f88f8c3d60ddc3bc97 — 99,900,000,000,000,000,310,378,496 tokens (11.75% of circulating supply)
  5. 0xd9b93f45af14f87232e5a53de5cc0733af0bd1ac — 23,652,120,325,418,917,732,286,464 tokens (2.78% of circulating supply)
  6. 0x5d0227feaf4f97aaff6107fb912337bf53bb6ae0 — 19,979,999,999,999,999,203,082,240 tokens (2.35% of circulating supply)
  7. 0xfa5fb3f93fa87b24d5ce8620e7a4862393638ebe — 19,979,999,999,999,999,203,082,240 tokens (2.35% of circulating supply)
  8. 0xae01f8758465ca5d645b9e0e43a8a6e606239192 — 17,577,146,627,287,717,697,814,528 tokens (2.07% of circulating supply)
  9. 0x9a50093b794ffdfd348763ee9b3fe35377fb7084 — 5,507,213,523,575,912,372,633,600 tokens (0.65% of circulating supply)
  10. 0x016b9d46d26683ad0cb21f8ec20240bef44513a6 — 4,994,999,999,999,999,800,770,560 tokens (0.59% of circulating supply)

Top 10 Total Balance: 599,585,157,650,257,870,994,800,640 tokens
Top 10 Share of Circulating Supply: 70.55%
Top 10 Share of Total Supply: 60.02%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $120,333,292,091,632,402,432.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 2.8502791157420537
LP holders count: 7

Liquidity holders for 0xCC8b870ddB18C211e376b306302C29B46AFc3Ab3, (MarkMeta)

0x8e7518f94f8dec8c26fb8ec6d3b345b9170b7dc1 holds 1.3129611959530207 LP tokens

0x381a5e8c19d4c2b846300b4856583078e5ac0046 holds 0.8008455437166022 LP tokens

0x271c121a7d354914095613c236c8aecf7bd1b02a holds 0.4138524588948432 LP tokens

0xb75eb7c95a6d4c21ffd473ed5993b1d952160898 holds 0.31255352354665333 LP tokens

0x67257da4d7ca104fed2e15896b9d10163f3f32f6 holds 0.00663511873303832 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.003431274897894748 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1271.81 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-02-09T16:44:04
Last Active: 2025-07-19T02:58:56
Days Since Last Activity: 16.38233843678241 days
Last Transaction Hash: 0xc61a6d008c5b4e7111d09582330dcdb882746ff701790ba82f5f33e280bf20c5
