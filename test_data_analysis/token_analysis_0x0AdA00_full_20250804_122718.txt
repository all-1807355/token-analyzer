Token Analysis Report
==================================================
Token: House of Dragmoon (0x0AdA00eD9F2caa91b4bEb812Fd64a16aE5569C9B)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function mint(address to) external returns (uint256 liquidity);


WARNING: Ownership Renounced
  Code Snippet:
  function renounceownership() public onlyowner {
    emit ownershiptransferred(_owner, address(0));
    _owner = address(0);
  }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _checkliquidityadd(address sender, address receiver) private {
        require(!_hasliqbeenadded, "liquidity already added and marked.");
        if (sender == liquidityholds && receiver == pcsv2pair) {
            _hasliqbeenadded = true;
            _liqaddblock = block.number;
            _liqaddtimestamp = block.timestamp;
        }
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
        address _whosends = sender;
        address _whoreceives = recipient;

        // check if a mempool bot is selling.
        if (has(_whosends)) {
            revert("mempooles closed.");
        }

        // check if this transfer falls under extra liquidity fee.
        bool applyextraliq = false;
        bool standardliq = false;
        if (takefee && _penaltiesenabled) {
            applyextraliq = _liqaddblock > 0 && _triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            standardliq = _liqaddblock > 0 && !_triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            if (applyextraliq) {
                _setantidumpmultiplier(2);
            } else if (standardliq) {
                _setantidumpmultiplier(1);
            }
        }

        // realise the transfer with or without taxes.
        if (!takefee || !_penaltiesenabled) {
            _liquidityfee = 0;
            _burnamount = 0;
        }
        _finalisetransfer(sender, recipient, amount);
        if (!takefee || !_penaltiesenabled) {
            _setbaselineliquidityfee();
        }

        // check if this is the liquidity adding tx to startup.
        if (!_hasliqbeenadded) {
            _checkliquidityadd(_whosends, _whoreceives);
        } else {
            if (_liqaddblock > 0 && _whosends == pcsv2pair && _haslimits(_whosends, _whoreceives)) {
                if (block.number == _liqaddblock) {
                    add(_whoreceives);
                    emit mempoolcaught(_whoreceives);
                } else if (block.number - _liqaddblock < 3) {
                    earlyblockbuy(_whoreceives);
                    emit snipercaught(_whoreceives);
                }
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;


  Code Snippet:
    function swap(
        uint256 amount0out,

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        if (_liquidityfee == 0) {
            return 0;
        }
        return _amount.div(100).mul(_liquidityfee);
    }

  Code Snippet:
    function _setantidumpmultiplier(uint256 doublepenalty) private {
        uint256 time_since_start = block.timestamp - _liqaddtimestamp;
        uint256 hour = 60 * 60;
        //uint256 minute = 60;
        uint256 second = 1;
        if (_penaltiesenabled) {
            if (time_since_start < 10 * second) {
                revert("please try again after a minute.");
            }
            if (time_since_start < 2 * hour) {
                _liquidityfee = 20 * doublepenalty;
            } else {
                _liquidityfee = _baselineliqfee;
            }
        } else {
            _liquidityfee = _baselineliqfee;
        }
    }

  Code Snippet:
    function _setbaselineliquidityfee() private {
        _liquidityfee = _baselineliqfee;
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {

        uint256 liquidtyportion = contracttokenbalance.div(10**2).mul(30);
        uint256 devportion = contracttokenbalance - liquidtyportion;
        
        // split the contract balance into halves
        uint256 half = liquidtyportion.div(2);
        uint256 otherhalf = liquidtyportion.sub(half);

        // capture the contract's current bnb balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalanceforliquify = address(this).balance;

        // swap tokens for bnb
        swaptokensforbnb(half, address(this));

        // how much bnb did we just swap into?
        uint256 newbalancefromliquify = address(this).balance.sub(initialbalanceforliquify);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalancefromliquify);

        swaptokensforbnb(devportion, payable(liquiditywallet));
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount, address to) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsv2router.weth();

        _approve(address(this), address(pcsv2router), tokenamount);

        // make the swap
        pcsv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            to,
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount, bool takefee) private {
        address _whosends = sender;
        address _whoreceives = recipient;

        // check if a mempool bot is selling.
        if (has(_whosends)) {
            revert("mempooles closed.");
        }

        // check if this transfer falls under extra liquidity fee.
        bool applyextraliq = false;
        bool standardliq = false;
        if (takefee && _penaltiesenabled) {
            applyextraliq = _liqaddblock > 0 && _triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            standardliq = _liqaddblock > 0 && !_triggerhappy[_whosends] && !_isdeadaddress(_whoreceives);
            if (applyextraliq) {
                _setantidumpmultiplier(2);
            } else if (standardliq) {
                _setantidumpmultiplier(1);
            }
        }

        // realise the transfer with or without taxes.
        if (!takefee || !_penaltiesenabled) {
            _liquidityfee = 0;
            _burnamount = 0;
        }
        _finalisetransfer(sender, recipient, amount);
        if (!takefee || !_penaltiesenabled) {
            _setbaselineliquidityfee();
        }

        // check if this is the liquidity adding tx to startup.
        if (!_hasliqbeenadded) {
            _checkliquidityadd(_whosends, _whoreceives);
        } else {
            if (_liqaddblock > 0 && _whosends == pcsv2pair && _haslimits(_whosends, _whoreceives)) {
                if (block.number == _liqaddblock) {
                    add(_whoreceives);
                    emit mempoolcaught(_whoreceives);
                } else if (block.number - _liqaddblock < 3) {
                    earlyblockbuy(_whoreceives);
                    emit snipercaught(_whoreceives);
                }
            }
        }
    }

  Code Snippet:
    function _finalisetransfer(address sender, address recipient, uint256 amount) private {
        uint256 liquidity = calculateliquidityfee(amount);
        uint256 burn = calculateburnamount(amount);
        uint256 transferamount = amount.sub(liquidity).sub(burn);

        _owned[sender] = _owned[sender].sub(amount);
        _owned[recipient] = _owned[recipient].add(transferamount);
        _takeliquidity(liquidity);
        _burntokens(burn);

        emit transfer(sender, recipient, transferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 105
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x5efde3bd3e70be7741f9c697e6a04d07325421cd — 338,393,434,805,200,832 tokens (45.15% of circulating supply)
  2. 0xc5a6d3680366c5ce334781092361cd1e4d865bd0 — 19,708,557,829,907,536 tokens (2.63% of circulating supply)
  3. 0xc93b9e9d6b69329339bc0663f81fa732ac59fe42 — 19,114,080,508,897,408 tokens (2.55% of circulating supply)
  4. 0x41c1e64ad9c69ea9eba150f20d867d594032c070 — 16,781,816,793,073,366 tokens (2.24% of circulating supply)
  5. 0xdf371bee7944199d96be1a1df9d168f9102e8f99 — 13,711,161,868,380,102 tokens (1.83% of circulating supply)
  6. 0x3d26edab14eef7eac2ae8f5dfeffbdf1527e7316 — 11,689,750,922,446,272 tokens (1.56% of circulating supply)
  7. 0xb01d9efff0c361251e0c8d144c3ce643040e3973 — 10,000,000,000,000,000 tokens (1.33% of circulating supply)
  8. 0xb7dbe29df45abe7c09e782ed4f7536e373e982e7 — 9,107,654,300,086,172 tokens (1.22% of circulating supply)
  9. 0x9dea4109cd801d089018e4f7542717b6f8ac01d1 — 9,093,047,049,845,402 tokens (1.21% of circulating supply)
  10. 0x0562e8105988809dd11101d4be1dae38c75b0cac — 6,632,291,956,740,215 tokens (0.88% of circulating supply)

Top 10 Total Balance: 454,231,796,034,577,305 tokens
Top 10 Share of Circulating Supply: 60.60%
Top 10 Share of Total Supply: 45.42%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $4,759,545,447,087,820.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 1907167.3900
USD Volume: 12109.9897
24h Volume/Liquidity Ratio: 2817973.3911
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.722425959236621
LP holders count: 3

Liquidity holders for 0x0AdA00eD9F2caa91b4bEb812Fd64a16aE5569C9B, (House of Dragmoon)

0x000000000000000000000000000000000000dead holds 0.7224213143131867 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 4.644923433424e-06 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/houseofdragmoon, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1526.08 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-31T10:33:14
Last Active: 2025-02-11T03:32:27
Days Since Last Activity: 174.37143190718749 days
Last Transaction Hash: 0xd02fcceace242cb322a99434b4e91bd53a368e132c7cf88684cc51ba6b6cbbf0
