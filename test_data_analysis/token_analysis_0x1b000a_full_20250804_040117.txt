Token Analysis Report
==================================================
Token: CarbonZero (0x1b000aBc16A40ABEe05EB5dC267beA3a5359c322)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event mint(address indexed sender, uint amount0, uint amount1);

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
    (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
    emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
    _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setmarketingfeepercent(uint256 marketingfee) external onlyowner() {
        _marketingfee = marketingfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, tmarketing, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity, tmarketing);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 tmarketing = calculatemarketingfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity).sub(tmarketing);
        return (ttransferamount, tfee, tliquidity, tmarketing);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rmarketing = tmarketing.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity).sub(rmarketing);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**3
        );
    }

  Code Snippet:
    function calculatemarketingfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_marketingfee).div(
            10**3
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**3
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0) return;
        _previoustaxfee = _taxfee;
        _previousmarketingfee = _marketingfee;
        _previousliquidityfee = _liquidityfee;
        _taxfee = 0;
        _marketingfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _marketingfee = _previousmarketingfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(half);
        uint256 newbalance = address(this).balance.sub(initialbalance);
        addliquidity(otherhalf, newbalance);
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tmarketing) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 137
Owner Address: 0x13ccbc9146f0cfdafdf283e853ad8e365c8d41be
Owner Balance: 543,593,123,571,811,778,659,713,781 tokens
Owner Share: 0.12% of circulating supply
✅ Owner holds LESS than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 5
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x0000000000000000000000000000000000000001 — 501,929,918,479,216,785,366,992,661,314 tokens (106.47% of circulating supply)
  2. 0x7a199a0d49fb3870e113c8bc3138b592dea3b4a8 — 299,389,537,727,013,426,076,855,739,196 tokens (63.51% of circulating supply)
  3. 0x2d045410f002a95efcee67759a92518fa3fce677 — 50,192,991,847,921,678,536,699,266,131 tokens (10.65% of circulating supply)
  4. 0x052dbc7ce8e6b548b21f73834bff5544d4571f82 — 30,403,424,871,954,634,526,718,432,281 tokens (6.45% of circulating supply)
  5. 0x9b635042fbd4ef621db83bb333079ee457dee3b2 — 25,147,259,366,526,771,412,599,850,676 tokens (5.33% of circulating supply)
  6. 0xbe5e15c6c15d9dea371ea08971a062df0a63dd97 — 9,845,988,539,449,706,954,267,005,153 tokens (2.09% of circulating supply)
  7. 0x220e9490b8dcb8a665a7100746f618a23529b416 — 9,199,447,283,162,504,122,548,322,975 tokens (1.95% of circulating supply)
  8. 0x0be6e71b8861840815f8327a371653be96c8a8e4 — 8,063,176,524,683,869,290,559,716,625 tokens (1.71% of circulating supply)
  9. 0xf9e014a6f106eefe9bd1c0313d658101e5f1153e — 5,451,116,887,256,502,154,198,422,730 tokens (1.16% of circulating supply)
  10. 0xd412e974822ed7ee21e5fd08e13dd4c50ef4258f — 3,511,935,536,745,817,415,715,129,168 tokens (0.74% of circulating supply)

Top 10 Total Balance: 943,134,797,063,931,695,857,154,546,249 tokens
Top 10 Share of Circulating Supply: 200.06%
Top 10 Share of Total Supply: 94.31%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $43,224,404,373,146,216.00
Liquidity: $0.05
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0544)
Total supply of LP tokens: 2454965.7706362405
LP holders count: 5

Liquidity holders for 0x1b000aBc16A40ABEe05EB5dC267beA3a5359c322, (CarbonZero)

0x8655e5c4d701186d16765d1cdcef6d5287e4679a holds 2401662.2800472695 LP tokens

0x5cd2bb4b81d7ac61fbaa6ee8f4ee5a3db964a172 holds 46081.287014330235 LP tokens

0xd771557cc87311d5dfa5095350d71a42681bce70 holds 7165.705844182639 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 56.497730457843765 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1471.07 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-07-25T02:16:31
Last Active: 2025-07-10T23:06:48
Days Since Last Activity: 24.20450977175926 days
Last Transaction Hash: 0xd182e85060ee8b899ed6cba57d88961fd5f4cfab581d812c72743333c378eb64
