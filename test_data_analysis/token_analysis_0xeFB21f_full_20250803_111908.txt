Token Analysis Report
==================================================
Token: SharkCoin (0xeFB21fCC222A324376A306c8C274EF0917133Feb)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: High Tax Detected
  Code Snippet:
    function tradingcheck() public view returns (bool) {
        return tradingenabled;
    }

  Code Snippet:
  function transfer(address to, uint256 value) public override returns (bool) {
    require(value <= _balances[msg.sender]);
    if(msg.sender != owner() && to != owner()){
        require(value <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        require(tradingenabled == true);}
    uint256 tokenstoburn = cut(value);
    uint256 tokenstotransfer = value.sub(tokenstoburn);
    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokenstotransfer);
    _balances[address(0xdead)] = _balances[address(0xdead)].add(tokenstoburn);

    emit transfer(msg.sender, to, tokenstotransfer);
    emit transfer(msg.sender, address(0xdead), tokenstoburn);
    return true;
  }

  Code Snippet:
  function trading(bool startstop) external onlyowner() {
        tradingenabled = startstop;
  }

  Code Snippet:
  function transferfrom(address from, address to, uint256 value) public override returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0xdead));
    if(from != owner() && to != owner()) { 
        require(value <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        require(tradingenabled == true); }
    _balances[from] = _balances[from].sub(value);
    uint256 tokenstoburn = cut(value);
    uint256 tokenstotransfer = value.sub(tokenstoburn);
    
    _balances[to] = _balances[to].add(tokenstotransfer);
    _balances[address(0xdead)] = _balances[address(0xdead)].add(tokenstoburn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit transfer(from, to, tokenstotransfer);
    emit transfer(from, address(0xdead), tokenstoburn);

    return true;
  }

WARNING: Trading Disabled Possible
  Code Snippet:
    function tradingcheck() public view returns (bool) {
        return tradingenabled;
    }

  Code Snippet:
  function transfer(address to, uint256 value) public override returns (bool) {
    require(value <= _balances[msg.sender]);
    if(msg.sender != owner() && to != owner()){
        require(value <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        require(tradingenabled == true);}
    uint256 tokenstoburn = cut(value);
    uint256 tokenstotransfer = value.sub(tokenstoburn);
    _balances[msg.sender] = _balances[msg.sender].sub(value);
    _balances[to] = _balances[to].add(tokenstotransfer);
    _balances[address(0xdead)] = _balances[address(0xdead)].add(tokenstoburn);

    emit transfer(msg.sender, to, tokenstotransfer);
    emit transfer(msg.sender, address(0xdead), tokenstoburn);
    return true;
  }

  Code Snippet:
  function trading(bool startstop) external onlyowner() {
        tradingenabled = startstop;
  }

  Code Snippet:
  function transferfrom(address from, address to, uint256 value) public override returns (bool) {
    require(value <= _balances[from]);
    require(value <= _allowed[from][msg.sender]);
    require(to != address(0xdead));
    if(from != owner() && to != owner()) { 
        require(value <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        require(tradingenabled == true); }
    _balances[from] = _balances[from].sub(value);
    uint256 tokenstoburn = cut(value);
    uint256 tokenstotransfer = value.sub(tokenstoburn);
    
    _balances[to] = _balances[to].add(tokenstotransfer);
    _balances[address(0xdead)] = _balances[address(0xdead)].add(tokenstoburn);

    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);

    emit transfer(from, to, tokenstotransfer);
    emit transfer(from, address(0xdead), tokenstoburn);

    return true;
  }


Holder Analysis
--------------
Total Unique Holders: 197
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x377478a1f69daa3d9b4efb49a7c5e57da1ab7ebe — 8,887,462,214,760,234 tokens (14.93% of circulating supply)
  2. 0x344fe5d62124b4256045e8c563319806e2a375bf — 1,656,733,998,447,046 tokens (2.78% of circulating supply)
  3. 0x78bd8f44ac22c9629c66481cd0c23569946a388a — 1,166,520,467,917,111 tokens (1.96% of circulating supply)
  4. 0x5491d8be26eea75d487c7522a7274cc3fb92c265 — 510,780,300,000,000 tokens (0.86% of circulating supply)
  5. 0xe683d345025c42062ba60bf2ac1896e40f69f6f4 — 418,928,439,983,953 tokens (0.70% of circulating supply)
  6. 0xd91b07769debc3bb45d37e41ac774cdf23ca6bcc — 380,122,256,763,089 tokens (0.64% of circulating supply)
  7. 0xd3b3256e9c066dc036f4cc3d32221e6b8eb43d00 — 348,369,001,670,277 tokens (0.59% of circulating supply)
  8. 0x71f55fd9648cae28fe77ad6c5d57b9547d005674 — 346,913,418,361,508 tokens (0.58% of circulating supply)
  9. 0xd6911b8ffed6b900601170ca0bc73206ddbe7074 — 345,247,946,140,898 tokens (0.58% of circulating supply)
  10. 0x129c56150b558595f1cbb03f4432ecc71df48758 — 338,466,745,447,258 tokens (0.57% of circulating supply)

Top 10 Total Balance: 14,399,544,789,491,374 tokens
Top 10 Share of Circulating Supply: 24.20%
Top 10 Share of Total Supply: 14.40%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $24,330,550,407,975,928.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 31392.2355
USD Volume: 12833.9581
24h Volume/Liquidity Ratio: 1765205.2120
Percentage of liquidity locked: 99.9900
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.1500465556087977
LP holders count: 3

Liquidity holders for 0xeFB21fCC222A324376A306c8C274EF0917133Feb, (SharkCoin)

0x000000000000000000000000000000000000dead holds 0.15003374620397802 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 1.2809404818672e-05 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1548.54 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-07T22:20:06
Last Active: 2024-12-07T14:42:53
Days Since Last Activity: 238.85851522251158 days
Last Transaction Hash: 0x38e15e749ca252ae741accf789fc56e3dc9bd5dfda469f33645fd937b7b5efca
