Token Analysis Report
==================================================
Token: Wraith Protocol (0x8690Cb98496EF0f8c6417D78b5e0E29907668808)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function minimumtokensbeforeswapamount() public view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function deliver(uint256 tamount) private {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) private view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {

        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        
        if(from != owner() && to != owner()) {
            require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }

        uint256 contracttokenbalance = balanceof(address(this));
        bool overminimumtokenbalance = contracttokenbalance >= minimumtokensbeforeswap;
        
        if (overminimumtokenbalance && !inswapandliquify && from != uniswapv2pair && swapandliquifyenabled) 
        {
            if(swapandliquifybylimitonly)
                contracttokenbalance = minimumtokensbeforeswap;
            swapandliquify(contracttokenbalance);    
        }
        
        bool takefee = true;
        
        //if any account belongs to _isexcludedfromfee account then remove the fee
        if(_isexcludedfromfee[from] || _isexcludedfromfee[to]){
            takefee = false;
        }
        
        _tokentransfer(from, to, amount, takefee);
    }

  Code Snippet:
    function swapandliquify(uint256 tamount) private locktheswap {
       
        uint256 forburn = tamount.div(_totaltaxpercent).mul(_burnfee);
        uint256 forliquidity = tamount.div(_totaltaxpercent).mul(_liquidityfee);
        uint256 forwallets = tamount.sub(forliquidity).sub(forburn);

        if(forliquidity > 0)
        {
            uint256 half = forliquidity.div(2);
            uint256 otherhalf = forliquidity.sub(half);
    
            uint256 initialbalance = address(this).balance;
            swaptokensforeth(half); 
            uint256 newbalance = address(this).balance.sub(initialbalance);
            addliquidity(otherhalf, newbalance);
            emit swapandliquify(half, newbalance, otherhalf);
        }

        if(forwallets > 0 && _vaultfee.add(_treasuryfee) > 0)
        {
            uint256 initialbalance = address(this).balance;
            swaptokensforeth(forwallets);
            uint256 newbalance = address(this).balance.sub(initialbalance);
    
            uint256 marketingshare = newbalance.div(_vaultfee.add(_treasuryfee)).mul(_vaultfee);
            uint256 wraithwalletshare = newbalance.sub(marketingshare);
            
            if(marketingshare > 0)
                transfertoaddresseth(vaultwalletaddress, marketingshare);
            
            if(wraithwalletshare > 0)
                transfertoaddresseth(treasurywalletaddress, wraithwalletshare);
        }
        
        if(forburn > 0)
        {
            _tokentransfer(address(this), deadaddress, forburn, false);
        }
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this), // the contract
            block.timestamp
        );
        
        emit swaptokensforeth(tokenamount, path);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256) {
        uint256 tliquidity = calculatefee(tamount);
        uint256 ttransferamount = tamount.sub(tliquidity);
        return (ttransferamount, tliquidity);
    }

  Code Snippet:
    function calculatefee(uint256 tamount) private view returns (uint256) {
        return tamount.mul(_totaltaxpercent).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        _prevtotaltaxpercent = _totaltaxpercent;
        _totaltaxpercent = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _totaltaxpercent = _prevtotaltaxpercent;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxes(uint256 newburnfee, uint256 newliquiditytax, uint256 newmarketingtax, uint256 newwraithcharitytax) external onlyowner() {
        _burnfee = newburnfee;
        _liquidityfee = newliquiditytax;
        _vaultfee = newmarketingtax;
        _treasuryfee = newwraithcharitytax;
        _totaltaxpercent = _burnfee.add(_liquidityfee).add(_vaultfee).add(_treasuryfee);
        _prevtotaltaxpercent = _totaltaxpercent;
    }

  Code Snippet:
    function setnumtokensbeforeswap(uint256 newlimit) external onlyowner() {
        minimumtokensbeforeswap = newlimit;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function setswapandliquifybylimitonly(bool newvalue) public onlyowner {
        swapandliquifybylimitonly = newvalue;
    }

  Code Snippet:
    function prepareforpresale() external onlyowner {
        setswapandliquifyenabled(false);
        _totaltaxpercent = 0;
        _prevtotaltaxpercent = 0;
        _maxtxamount = 1000000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function prepareforlaunch() external onlyowner {
        setswapandliquifyenabled(true);
        _totaltaxpercent = _burnfee.add(_liquidityfee).add(_vaultfee).add(_treasuryfee);
        _prevtotaltaxpercent = _totaltaxpercent;
        _maxtxamount = 3000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function changerouterversion(address newrouteraddress) public onlyowner returns(address newpairaddress) {

        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(newrouteraddress); 

        newpairaddress = iuniswapv2factory(_uniswapv2router.factory()).getpair(address(this), _uniswapv2router.weth());

        if(newpairaddress == address(0)) //create if doesnt exist
        {
            newpairaddress = iuniswapv2factory(_uniswapv2router.factory())
                .createpair(address(this), _uniswapv2router.weth());
        }

        uniswapv2pair = newpairaddress; //set new pair address
        uniswapv2router = _uniswapv2router; //set new router address
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x41a92a6d2c88b1bf0345929ba926df0797cdc2e9
Owner Balance: 6,090,277,188,598,077,849,600 tokens
Owner Share: 70.43% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x41a92a6d2c88b1bf0345929ba926df0797cdc2e9 — 6,090,277,188,598,077,849,600 tokens (70.43% of circulating supply)
  2. 0xeaed594b5926a7d5fbbc61985390baaf936a6b8d — 502,083,263,139,121,201,152 tokens (5.81% of circulating supply)
  3. 0xaa3d85ad9d128dfecb55424085754f6dfa643eb1 — 250,208,788,577,512,587,264 tokens (2.89% of circulating supply)
  4. 0x2630c7d2104b92721357b3735412ce647a28ed8a — 154,907,151,799,999,987,712 tokens (1.79% of circulating supply)
  5. 0x8b3b45e48be6c31366ffd9dd4f29c1edffcba97d — 65,825,009,923,999,997,952 tokens (0.76% of circulating supply)
  6. 0xba7d910797b75752d734b17165af5556fb3f44dd — 37,201,804,847,900,000,256 tokens (0.43% of circulating supply)
  7. 0x0903149213f3a0a1573e0f82b88be54c7e8432a5 — 30,616,213,676,777,525,248 tokens (0.35% of circulating supply)
  8. 0x3dfe94d5272aadbe5ae0283f1262ace8a593db39 — 28,929,826,070,599,999,488 tokens (0.33% of circulating supply)
  9. 0x5b84e5ef8a1f2eb781c9e2e23f64086865f423f9 — 27,883,382,108,391,874,560 tokens (0.32% of circulating supply)
  10. 0xcddf93dab137301271e0b92c339441da9abef9c3 — 19,877,760,000,000,000,000 tokens (0.23% of circulating supply)

Top 10 Total Balance: 7,207,810,388,742,381,023,232 tokens
Top 10 Share of Circulating Supply: 83.35%
Top 10 Share of Total Supply: 76.68%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $8,785,303,427,527,409,664.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (64.7902)
Total supply of LP tokens: 1.0795692790828e-05
LP holders count: 2

Liquidity holders for 0x8690Cb98496EF0f8c6417D78b5e0E29907668808, (Wraith Protocol)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 1.0795692789828e-05 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1380.53 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-10-22T20:14:50
Last Active: 2025-07-16T15:57:03
Days Since Last Activity: 17.71366762909722 days
Last Transaction Hash: 0x59c448586325702167d5534b8621a8405ca6287f55295b739a0caf2b711cf5d9
