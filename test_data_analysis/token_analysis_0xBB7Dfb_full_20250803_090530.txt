Token Analysis Report
==================================================
Token: KIKO INU (0xBB7Dfb3831F0A3778C1Cf621550Bb11065324d21)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer(address(0), account, amount);

        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer(address(0), account, amount);

        _aftertokentransfer(address(0), account, amount);
    }

  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer(address(0), account, amount);

        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer(address(0), account, amount);

        _aftertokentransfer(address(0), account, amount);
    }

  Code Snippet:
    function __dividendpayingtoken_init(
        address _rewardtoken,

  Code Snippet:
    function _mint(address account, uint256 value) internal override {
        super._mint(account, value);

        magnifieddividendcorrections[account] = magnifieddividendcorrections[
            account
        ].sub((magnifieddividendpershare.mul(value)).toint256safe());
    }

  Code Snippet:
    function _setbalance(address account, uint256 newbalance) internal {
        uint256 currentbalance = balanceof(account);

        if (newbalance > currentbalance) {
            uint256 mintamount = newbalance.sub(currentbalance);
            _mint(account, mintamount);
        } else if (newbalance < currentbalance) {
            uint256 burnamount = currentbalance.sub(newbalance);
            _burn(account, burnamount);
        }
    }

  Code Snippet:
    function initialize(
        address rewardtoken_,

  Code Snippet:
    function withdrawdividend() public pure override {
        require(
            false,
            "dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main babytoken contract."
        );
    }

  Code Snippet:
    function updateclaimwait(uint256 newclaimwait) external onlyowner {
        require(
            newclaimwait >= 3600 && newclaimwait <= 86400,
            "dividend_tracker: claimwait must be updated to between 1 and 24 hours"
        );
        require(
            newclaimwait != claimwait,
            "dividend_tracker: cannot update claimwait to same value"
        );
        emit claimwaitupdated(newclaimwait, claimwait);
        claimwait = newclaimwait;
    }

  Code Snippet:
    function canautoclaim(uint256 lastclaimtime) private view returns (bool) {
        if (lastclaimtime > block.timestamp) {
            return false;
        }

        return block.timestamp.sub(lastclaimtime) >= claimwait;
    }

  Code Snippet:
    function settokenrewardsfee(uint256 value) external onlyowner {
        tokenrewardsfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setliquiditfee(uint256 value) external onlyowner {
        liquidityfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setmarketingfee(uint256 value) external onlyowner {
        marketingfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function updateclaimwait(uint256 claimwait) external onlyowner {
        dividendtracker.updateclaimwait(claimwait);
    }

  Code Snippet:
    function getclaimwait() external view returns (uint256) {
        return dividendtracker.claimwait();
    }

  Code Snippet:
    function processdividendtracker(uint256 gas) external {
        (
            uint256 iterations,
            uint256 claims,
            uint256 lastprocessedindex
        ) = dividendtracker.process(gas);
        emit processeddividendtracker(
            iterations,
            claims,
            lastprocessedindex,
            false,
            gas,
            tx.origin
        );
    }

  Code Snippet:
    function claim() external {
        dividendtracker.processaccount(payable(msg.sender), false);
    }

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(
            address(this)
        );

        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(
            initialcakebalance
        );
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private {
        swaptokensforcake(tokens);
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(
            address(dividendtracker),
            dividends
        );

        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function __dividendpayingtoken_init(
        address _rewardtoken,

  Code Snippet:
    function initialize(
        address rewardtoken_,

  Code Snippet:
    function settokenrewardsfee(uint256 value) external onlyowner {
        tokenrewardsfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setliquiditfee(uint256 value) external onlyowner {
        liquidityfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setmarketingfee(uint256 value) external onlyowner {
        marketingfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(
            address(this)
        );

        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(
            initialcakebalance
        );
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private {
        swaptokensforcake(tokens);
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(
            address(dividendtracker),
            dividends
        );

        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint256 amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint256 amountout,

  Code Snippet:
    function swapexactethfortokens(
        uint256 amountoutmin,

  Code Snippet:
    function swaptokensforexacteth(
        uint256 amountout,

  Code Snippet:
    function swapexacttokensforeth(
        uint256 amountin,

  Code Snippet:
    function swapethforexacttokens(
        uint256 amountout,

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function withdrawdividend() external;


  Code Snippet:
    function withdrawabledividendof(address _owner)
        external

  Code Snippet:
    function withdrawndividendof(address _owner)
        external

  Code Snippet:
    function withdrawdividend() public virtual override {
        _withdrawdividendofuser(payable(msg.sender));
    }

  Code Snippet:
    function _withdrawdividendofuser(address payable user)
        internal

  Code Snippet:
    function dividendof(address _owner) public view override returns (uint256) {
        return withdrawabledividendof(_owner);
    }

  Code Snippet:
    function withdrawabledividendof(address _owner)
        public

  Code Snippet:
    function withdrawndividendof(address _owner)
        public

  Code Snippet:
    function withdrawdividend() public pure override {
        require(
            false,
            "dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main babytoken contract."
        );
    }

  Code Snippet:
    function setswaptokensatamount(uint256 amount) external onlyowner {
        swaptokensatamount = amount;
    }

  Code Snippet:
    function updatedividendtracker(address newaddress) public onlyowner {
        require(
            newaddress != address(dividendtracker),
            "babytoken: the dividend tracker already has that address"
        );

        babytokendividendtracker newdividendtracker = babytokendividendtracker(
            payable(newaddress)
        );

        require(
            newdividendtracker.owner() == address(this),
            "babytoken: the new dividend tracker must be owned by the babytoken token contract"
        );

        newdividendtracker.excludefromdividends(address(newdividendtracker));
        newdividendtracker.excludefromdividends(address(this));
        newdividendtracker.excludefromdividends(owner());
        newdividendtracker.excludefromdividends(address(uniswapv2router));

        emit updatedividendtracker(newaddress, address(dividendtracker));

        dividendtracker = newdividendtracker;
    }

  Code Snippet:
    function updateuniswapv2router(address newaddress) public onlyowner {
        require(
            newaddress != address(uniswapv2router),
            "babytoken: the router already has that address"
        );
        emit updateuniswapv2router(newaddress, address(uniswapv2router));
        uniswapv2router = iuniswapv2router02(newaddress);
        address _uniswapv2pair = iuniswapv2factory(uniswapv2router.factory())
            .createpair(address(this), uniswapv2router.weth());
        uniswapv2pair = _uniswapv2pair;
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        require(
            _isexcludedfromfees[account] != excluded,
            "babytoken: account is already the value of 'excluded'"
        );
        _isexcludedfromfees[account] = excluded;

        emit excludefromfees(account, excluded);
    }

  Code Snippet:
    function excludemultipleaccountsfromfees(
        address[] calldata accounts,

  Code Snippet:
    function settokenrewardsfee(uint256 value) external onlyowner {
        tokenrewardsfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setliquiditfee(uint256 value) external onlyowner {
        liquidityfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function setmarketingfee(uint256 value) external onlyowner {
        marketingfee = value;
        totalfees = tokenrewardsfee.add(liquidityfee).add(marketingfee);
        require(totalfees <= 25, "total fee is over 25%");
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns (bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function withdrawabledividendof(address account)
        public

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(
            address(this)
        );

        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(
            initialcakebalance
        );
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
    }

  Code Snippet:
    function swapandliquify(uint256 tokens) private {
        // split the contract balance into halves
        uint256 half = tokens.div(2);
        uint256 otherhalf = tokens.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);

        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(0),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private {
        swaptokensforcake(tokens);
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(
            address(dividendtracker),
            dividends
        );

        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x103574991d6ac2f94650faf609d6ee57f527f103 — 484,314,536,728,082,696,690,856,886,272 tokens (52.52% of circulating supply)
  2. 0x9df3f9380aa3530b1749cecc2afb6a1dea1235ca — 46,053,643,469,075,462,490,110,820,352 tokens (4.99% of circulating supply)
  3. 0x36f19dcc5b45489737c98be4c2e1a710a20b4874 — 25,079,487,907,944,114,127,940,616,192 tokens (2.72% of circulating supply)
  4. 0x4e18f1ed6f9e9328bc8fc0161f0e896645be9692 — 11,966,091,560,937,989,384,804,761,600 tokens (1.30% of circulating supply)
  5. 0xba8b11ad7f3d94e7b5dc86c12c1ab99c303554f4 — 10,273,895,258,611,535,595,123,507,200 tokens (1.11% of circulating supply)
  6. 0x75987b9edb5463ce1a3a857e11671424600927a4 — 8,830,041,792,772,047,559,622,393,856 tokens (0.96% of circulating supply)
  7. 0x3bcc60666d1172fe16d2de8d42ead0bfd12994ec — 8,189,555,462,549,428,671,189,352,448 tokens (0.89% of circulating supply)
  8. 0xab4038a3d57609e136b63264b4175a30d81ed10f — 7,829,118,420,046,572,976,311,631,872 tokens (0.85% of circulating supply)
  9. 0xbb3d93d0e5fa16c3b12ab931b77af0dd72249993 — 7,593,205,205,456,407,909,757,878,272 tokens (0.82% of circulating supply)
  10. 0x905c82291785b24d2cd51b9e44020a0ef9bea79a — 6,197,989,600,000,000,241,734,516,736 tokens (0.67% of circulating supply)

Top 10 Total Balance: 616,327,565,405,476,255,647,452,364,800 tokens
Top 10 Share of Circulating Supply: 66.83%
Top 10 Share of Total Supply: 61.63%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $19,878,586,471,681,676.00
Liquidity: $0.02
Liquidity/MCap Ratio: 0.0000
Token Volume: 7688628149.7329
USD Volume: 0.0002
24h Volume/Liquidity Ratio: 0.0078
Percentage of liquidity locked: 99.5100
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 1918385.3027907608
LP holders count: 4

Liquidity holders for 0xBB7Dfb3831F0A3778C1Cf621550Bb11065324d21, (KIKO INU)

0x0000000000000000000000000000000000000000 holds 1909034.5977391964 LP tokens

0xeeb6e2f1f5956d8c7e031ef38ff5ed4a4e7caf19 holds 9185.261165159496 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 126.72569776090015 LP tokens

0xf3c91d522bd533f558dddce71521aae698deb6fa holds 38.21155801975912 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1167[EIP, Reason: metamask recovery phrase phishing
  URL: https://github.com/roger-wu), Reason: metamask recovery phrase phishing
  URL: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1291.35 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-01-20T00:40:42
Last Active: 2025-07-31T05:15:16
Days Since Last Activity: 3.1598945104050924 days
Last Transaction Hash: 0x39866efb7489ca31d87e8c177787c313616ed0bfc32ae7c0754be3667d0f4d24
