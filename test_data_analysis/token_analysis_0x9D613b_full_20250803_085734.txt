Token Analysis Report
==================================================
Token: MetaGaming (0x9D613b820B788D0f696F0D7f92201347bA6cDBc4)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp < _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() 
    {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private whennotpaused
    {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 contracttokenbalance = balanceof(address(this));        
        bool overmintokenbalance = contracttokenbalance >= numtokensselltoaddtoliquidity;
        if (overmintokenbalance &&  !inswapandliquify && from != uniswapv2pair && swapandliquifyenabled)
        {
            contracttokenbalance = numtokensselltoaddtoliquidity;
            swapandliquify(contracttokenbalance);
        }
        _tokentransfer(from, to, amount);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() 
    {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function removeallfee() private {
        _taxfee = 0;
        _liquidityfee = 0;
        _burnfee = 0;
        _marketingfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
        _burnfee = _previousburnfee;
        _marketingfee = _previousmarketingfee;
    }

  Code Snippet:
    function setallfees(uint256 taxfee, uint256 liquidityfee, uint256 marketingfee, uint256 burnfee) external onlyowner() 
    {
        _taxfee = taxfee;
        _previoustaxfee = taxfee;
        _liquidityfee = liquidityfee;
        _previousliquidityfee = liquidityfee;
        _marketingfee = marketingfee;
        _previousmarketingfee = marketingfee;
        _burnfee = burnfee;
        _previousburnfee = burnfee;
    }

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(10**2);
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) 
    {  
        uint256 totalamount = _amount.div(100-_burnfee).mul(100);
        return totalamount.mul(_liquidityfee.add(_marketingfee)).div(100);
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private whennotpaused
    {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 contracttokenbalance = balanceof(address(this));        
        bool overmintokenbalance = contracttokenbalance >= numtokensselltoaddtoliquidity;
        if (overmintokenbalance &&  !inswapandliquify && from != uniswapv2pair && swapandliquifyenabled)
        {
            contracttokenbalance = numtokensselltoaddtoliquidity;
            swapandliquify(contracttokenbalance);
        }
        _tokentransfer(from, to, amount);
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap 
    {
        uint256 allfee = _liquidityfee.add(_marketingfee);
        uint256 halfliquiditytokens = contracttokenbalance.div(allfee).mul(_liquidityfee).div(2);
        uint256 swapabletokens = contracttokenbalance.sub(halfliquiditytokens);
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(swapabletokens);
        uint256 newbalance = address(this).balance.sub(initialbalance);
        
        if(halfliquiditytokens>0) 
        {
          uint256 ethforliquidity = newbalance.div(allfee).mul(_liquidityfee).div(2);
          addliquidity(halfliquiditytokens, ethforliquidity); 
          emit swapandliquify(halfliquiditytokens, ethforliquidity, halfliquiditytokens);
          newbalance = newbalance.sub(ethforliquidity);
        }
        marketingwallet.transfer(newbalance);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private 
    {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(tokenamount,0,path,address(this), block.timestamp);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private 
    {
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.addliquidityeth{value: ethamount}(address(this), tokenamount, 0, 0, owner(), block.timestamp);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount) private 
    {
        uint256 tframount = amount;
            
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient])
        {
            removeallfee();
        }
        else
        {
            require(amount <= balanceof(uniswapv2pair).div(100).mul(2), "transfer amount exceeds the maxtxamount.");
        }

        uint256 burntamount = tframount.div(100).mul(_burnfee);
        uint256 newbalance = balanceof(recipient).add(tframount);

       if(!_isexcludedfromwhale[sender] && !_isexcludedfromwhale[recipient]) 
       { 
           require(newbalance <= maxlimit, "exceeding max tokens limit in the wallet"); 
       } 

        if (_isexcluded[sender] && !_isexcluded[recipient]) 
        {
            _transferfromexcluded(sender, recipient, amount.sub(burntamount));
        } 
        else if (!_isexcluded[sender] && _isexcluded[recipient]) 
        {
            _transfertoexcluded(sender, recipient, amount.sub(burntamount));
        } 
        else if (!_isexcluded[sender] && !_isexcluded[recipient]) 
        {
            _transferstandard(sender, recipient, amount.sub(burntamount));
        } 
        else if (_isexcluded[sender] && _isexcluded[recipient]) 
        {
            _transferbothexcluded(sender, recipient, amount.sub(burntamount));
        } else 
        {
            _transferstandard(sender, recipient, amount.sub(burntamount));
        }
        
        if(burntamount>0)
        {
            removeallfee();
            _transferstandard(sender, address(0), burntamount);
        }
        
        restoreallfee();

    }

  Code Snippet:
    function manualburn(uint256 burnamount) public onlyowner
    {
        removeallfee();
        _transferstandard(owner(), address(0), burnamount);
        restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private 
    {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner 
    {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner 
    {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x65712af3795c0b430e0e6abc98584ea618f5df5a
Owner Balance: 25,042,102,757,408,196,974,232,993,792 tokens
Owner Share: 26.22% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 6
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x65712af3795c0b430e0e6abc98584ea618f5df5a — 25,042,102,757,408,196,974,232,993,792 tokens (26.21% of circulating supply)
  2. 0x81e0ef68e103ee65002d3cf766240ed1c070334d — 20,001,062,359,986,805,589,609,021,440 tokens (20.94% of circulating supply)
  3. 0xc0de1096717fe1f8176c834a0b64ca563abe38fc — 7,655,062,612,105,126,431,183,339,520 tokens (8.01% of circulating supply)
  4. 0xa4c7eb851c6abfa6454f9905e11f0173863fdb5b — 6,542,970,312,994,020,935,199,621,120 tokens (6.85% of circulating supply)
  5. 0x2c0e5d5de3c79ffee790cbd9020e8d6680051056 — 6,395,103,642,982,754,233,710,804,992 tokens (6.69% of circulating supply)
  6. 0x9d613b820b788d0f696f0d7f92201347ba6cdbc4 — 5,973,967,937,335,081,283,595,796,480 tokens (6.25% of circulating supply)
  7. 0x17d2083f3e9c929810c9212bf6efb09538087751 — 3,244,766,824,623,881,009,064,050,688 tokens (3.40% of circulating supply)
  8. 0x7bdc36f4ea88e98350419380bee04ff1222315e6 — 2,553,793,081,181,257,716,599,881,728 tokens (2.67% of circulating supply)
  9. 0x7e62de1a813f408af4ed8f869ffcaab82b5d1188 — 1,142,660,074,420,779,678,783,504,384 tokens (1.20% of circulating supply)
  10. 0xec277b7c98859cb2e3295f8640917fabb97f86fd — 913,046,272,945,205,706,171,088,896 tokens (0.96% of circulating supply)

Top 10 Total Balance: 79,464,535,875,983,109,558,150,103,040 tokens
Top 10 Share of Circulating Supply: 83.19%
Top 10 Share of Total Supply: 79.46%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $82,642,014,351,106,848.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 971615.5372
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0084
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (25.0426)
Total supply of LP tokens: 1426.4377522962309
LP holders count: 4

Liquidity holders for 0x9D613b820B788D0f696F0D7f92201347bA6cDBc4, (MetaGaming)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 1384.182490713511 LP tokens

Owner 0x65712af3795c0b430e0e6abc98584ea618f5df5a holds 34.87456273084739 LP tokens

0x20c74510bab640f3e07a563f449dd77a2059dab8 holds 7.380698851872501 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1343.95 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-28T10:08:59
Last Active: 2025-07-19T11:37:06
Days Since Last Activity: 14.889221229456018 days
Last Transaction Hash: 0x0ba36addd0c57422d8942c6121a98f022064e4d09b2e243808ff0e491fe1900b
