Token Analysis Report
==================================================
Token: Baby Clifford Inu (0xE40175E022a9F3ae5C37ea9993596A0465AbED5B)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer(address(0), account, amount);

        _totalsupply = _totalsupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit transfer(address(0), account, amount);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function enabletrading() external onlyowner {
        tradingactive = true;
        swapenabled = true;
        lastlpburntime = block.timestamp;
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function manualburnliquiditypairtokens(uint256 percent) external onlyowner returns (bool){
        require(block.timestamp > lastmanuallpburntime + manualburnfrequency , "must wait for cooldown to finish");
        require(percent <= 1000, "may not nuke more than 10% of tokens in lp");
        lastmanuallpburntime = block.timestamp;
        
        // get balance of liquidity pair
        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);
        
        // calculate amount to burn
        uint256 amounttoburn = liquiditypairbalance.mul(percent).div(10000);
        
        // pull tokens from pancakepair liquidity and move to dead address permanently
        if (amounttoburn > 0){
            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);
        }
        
        //sync price since this is not in a swap transaction!
        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);
        pair.sync();
        emit manualnukelp();
        return true;
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function enabletrading() external onlyowner {
        tradingactive = true;
        swapenabled = true;
        lastlpburntime = block.timestamp;
    }

  Code Snippet:
    function updateswaptokensatamount(uint256 newamount) external onlyowner returns (bool){
  	    require(newamount >= totalsupply() * 1 / 100000, "swap amount cannot be lower than 0.001% total supply.");
  	    require(newamount <= totalsupply() * 5 / 1000, "swap amount cannot be higher than 0.5% total supply.");
  	    swaptokensatamount = newamount;
  	    return true;
  	}

  Code Snippet:
    function updateswapenabled(bool enabled) external onlyowner(){
        swapenabled = enabled;
    }

  Code Snippet:
    function updatebuyfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _devfee) external onlyowner {
        buymarketingfee = _marketingfee;
        buyliquidityfee = _liquidityfee;
        buydevfee = _devfee;
        buytotalfees = buymarketingfee + buyliquidityfee + buydevfee;
        require(buytotalfees <= 20, "must keep fees at 20% or less");
    }

  Code Snippet:
    function updatesellfees(uint256 _marketingfee, uint256 _liquidityfee, uint256 _devfee) external onlyowner {
        sellmarketingfee = _marketingfee;
        sellliquidityfee = _liquidityfee;
        selldevfee = _devfee;
        selltotalfees = sellmarketingfee + sellliquidityfee + selldevfee;
        require(selltotalfees <= 25, "must keep fees at 25% or less");
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        _isexcludedfromfees[account] = excluded;
        emit excludefromfees(account, excluded);
    }

  Code Snippet:
    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {
        require(pair != uniswapv2pair, "the pair cannot be removed from automatedmarketmakerpairs");

        _setautomatedmarketmakerpair(pair, value);
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns(bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {

        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
        
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            deadaddress,
            block.timestamp
        );
    }

  Code Snippet:
    function swapback() private {
        uint256 contractbalance = balanceof(address(this));
        uint256 totaltokenstoswap = tokensforliquidity + tokensformarketing + tokensfordev;
        bool success;
        
        if(contractbalance == 0 || totaltokenstoswap == 0) {return;}

        if(contractbalance > swaptokensatamount * 20){
          contractbalance = swaptokensatamount * 20;
        }
        
        // halve the amount of liquidity tokens
        uint256 liquiditytokens = contractbalance * tokensforliquidity / totaltokenstoswap / 2;
        uint256 amounttoswapforeth = contractbalance.sub(liquiditytokens);
        
        uint256 initialethbalance = address(this).balance;

        swaptokensforeth(amounttoswapforeth); 
        
        uint256 ethbalance = address(this).balance.sub(initialethbalance);
        
        uint256 ethformarketing = ethbalance.mul(tokensformarketing).div(totaltokenstoswap);
        uint256 ethfordev = ethbalance.mul(tokensfordev).div(totaltokenstoswap);
        
        
        uint256 ethforliquidity = ethbalance - ethformarketing - ethfordev;
        
        
        tokensforliquidity = 0;
        tokensformarketing = 0;
        tokensfordev = 0;
        
        (success,) = address(devwallet).call{value: ethfordev}("");
        
        if(liquiditytokens > 0 && ethforliquidity > 0){
            addliquidity(liquiditytokens, ethforliquidity);
            emit swapandliquify(amounttoswapforeth, ethforliquidity, tokensforliquidity);
        }
        
        
        (success,) = address(marketingwallet).call{value: address(this).balance}("");
    }

  Code Snippet:
    function autoburnliquiditypairtokens() internal returns (bool){
        
        lastlpburntime = block.timestamp;
        
        // get balance of liquidity pair
        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);
        
        // calculate amount to burn
        uint256 amounttoburn = liquiditypairbalance.mul(percentforlpburn).div(10000);
        
        // pull tokens from pancakepair liquidity and move to dead address permanently
        if (amounttoburn > 0){
            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);
        }
        
        //sync price since this is not in a swap transaction!
        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);
        pair.sync();
        emit autonukelp();
        return true;
    }

  Code Snippet:
    function manualburnliquiditypairtokens(uint256 percent) external onlyowner returns (bool){
        require(block.timestamp > lastmanuallpburntime + manualburnfrequency , "must wait for cooldown to finish");
        require(percent <= 1000, "may not nuke more than 10% of tokens in lp");
        lastmanuallpburntime = block.timestamp;
        
        // get balance of liquidity pair
        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);
        
        // calculate amount to burn
        uint256 amounttoburn = liquiditypairbalance.mul(percent).div(10000);
        
        // pull tokens from pancakepair liquidity and move to dead address permanently
        if (amounttoburn > 0){
            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);
        }
        
        //sync price since this is not in a swap transaction!
        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);
        pair.sync();
        emit manualnukelp();
        return true;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xaa7bb2e3d953d8d2721655df67c553a72a621e53 — 623,501,860,074,177,692,164,604,035,072 tokens (72.38% of circulating supply)
  2. 0x638702924a4ce2454b3d324be8abcbbd6830bc26 — 50,735,839,106,020,807,130,180,747,264 tokens (5.89% of circulating supply)
  3. 0x5da67d4f02f4939018239c190d4c3087ab710690 — 2,102,239,890,786,463,389,784,735,744 tokens (0.24% of circulating supply)
  4. 0xe20b1bc989dd9fe55c217639a6a63601195b5032 — 2,009,935,439,586,733,383,680,524,288 tokens (0.23% of circulating supply)
  5. 0x4748b08ee45cdde33ea2ebddc6a82cd8d20921db — 2,006,573,269,598,614,031,377,104,896 tokens (0.23% of circulating supply)
  6. 0xc93f6419ca12fb5d2f98b9fb7eb3d6343b0f6b02 — 1,660,577,611,954,307,221,929,590,784 tokens (0.19% of circulating supply)
  7. 0xdf729d2312d928abc3ac8ea825f42f1e24581856 — 1,354,598,999,999,999,925,066,661,888 tokens (0.16% of circulating supply)
  8. 0x5c99b36f9a2cd7e37464136d624b0119620f0f29 — 1,228,374,038,699,999,961,590,792,192 tokens (0.14% of circulating supply)
  9. 0x07c41e6471f1e983bd0df8304bdeb6a1d7b7de46 — 1,129,516,199,999,999,954,741,362,688 tokens (0.13% of circulating supply)
  10. 0x0c230aa58ae6839e6df3e5be36dfd0d987fc59be — 1,046,137,484,779,053,206,680,371,200 tokens (0.12% of circulating supply)

Top 10 Total Balance: 686,775,652,115,603,670,369,635,926,016 tokens
Top 10 Share of Circulating Supply: 79.72%
Top 10 Share of Total Supply: 68.68%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,301,674,377,507,586.25
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 2734813933.0268
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0022
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 811861.104364929
LP holders count: 4

Liquidity holders for 0xE40175E022a9F3ae5C37ea9993596A0465AbED5B, (Baby Clifford Inu)

0x000000000000000000000000000000000000dead holds 806380.1112909729 LP tokens

0x3f4d6bf08cb7a003488ef082102c2e6418a4551e holds 5480.4253755 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.5676984561223484 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1313.73 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-28T16:55:58
Last Active: 2025-06-19T22:39:25
Days Since Last Activity: 44.49635527465278 days
Last Transaction Hash: 0x9e33c74e6f7de865ac306f3ca1d4d5cff056eef7198edaedff1409bd1eefd31d
