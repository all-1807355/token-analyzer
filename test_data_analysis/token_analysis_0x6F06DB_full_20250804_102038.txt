Token Analysis Report
==================================================
Token: Infant Shiba Inu  (0x6F06DB76c300d472944A43039Dd6D54929b6617d)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock.");
        require(block.timestamp > _locktime , "contract is locked.");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event mint(address indexed sender, uint amount0, uint amount1);

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                 assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                 assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
        function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tdev) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _takedev(tdev);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setdevfeepercent(uint256 devfee) external onlyowner() {
        _devfee = devfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tdev) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, tdev, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity, tdev);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 tdev = calculatedevfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity).sub(tdev);
        return (ttransferamount, tfee, tliquidity, tdev);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 tdev, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rdev = tdev.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity).sub(rdev);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculatedevfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_devfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private { 
        _previoustaxfee = _taxfee;
        _previousdevfee = _devfee;
        _previousliquidityfee = _liquidityfee;
        
        _taxfee = 0;
        _devfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _devfee = _previousdevfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(half); 
        uint256 newbalance = address(this).balance.sub(initialbalance);
        addliquidity(otherhalf, newbalance);
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tdev) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _takedev(tdev);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tdev) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _takedev(tdev);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tdev) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _takedev(tdev);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function setrouteraddress(address newrouter) external onlyowner {
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(newrouter);
        uniswapv2pair = iuniswapv2factory(_uniswapv2router.factory()).createpair(address(this), _uniswapv2router.weth());
        uniswapv2router = _uniswapv2router;
    }


Holder Analysis
--------------
Total Unique Holders: 84
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x8c9cb87c269af5a75e79373a688d53b1867131a5
Owner Balance: 376,679,920,310,759,456,768 tokens
Owner Share: 52.37% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x8c9cb87c269af5a75e79373a688d53b1867131a5 — 376,679,920,310,759,456,768 tokens (52.31% of circulating supply)
  2. 0x0a67623b1829d4a5189e15ff877a5e27491d1fa3 — 14,791,312,821,600,233,472 tokens (2.05% of circulating supply)
  3. 0xfac9f06b44000e3fb4d2853830791f15195917ca — 9,981,358,177,776,191,488 tokens (1.39% of circulating supply)
  4. 0xdbf5a6c867cf8e8531f3af5b2d3b1e8a40c5c2da — 5,000,000,000,000,000,000 tokens (0.69% of circulating supply)
  5. 0x5da3a975e2475b876bd9d4b5529badd377f1ae25 — 3,284,743,727,444,561,408 tokens (0.46% of circulating supply)
  6. 0x340532015afff4753653b62c1964bd58168554c1 — 2,935,145,054,542,332,416 tokens (0.41% of circulating supply)
  7. 0xedaf2cbe5ed61e7e4d4b2834aa1948320c37b5e1 — 2,792,083,755,299,750,400 tokens (0.39% of circulating supply)
  8. 0x5d24df8e13dd831e09910b6d371b2f097d5b621c — 2,789,410,894,024,888,832 tokens (0.39% of circulating supply)
  9. 0xe3b5859e4236c08e4bc0143b1c10f399c7498ad8 — 2,500,125,041,878,227,968 tokens (0.35% of circulating supply)
  10. 0x89038217bd8e3f0be1dc0f0e4e4ff57a1bcb8acc — 2,430,656,562,127,062,528 tokens (0.34% of circulating supply)

Top 10 Total Balance: 423,184,756,345,452,705,280 tokens
Top 10 Share of Circulating Supply: 58.77%
Top 10 Share of Total Supply: 42.32%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $22,783,808.43
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 1e-15
LP holders count: 1

Liquidity holders for 0x6F06DB76c300d472944A43039Dd6D54929b6617d, (Infant Shiba Inu )

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1484.50 days
⚠️ Lifecycle analysis exception: Exception during lifecycle analysis in lifecycle_analysis: unsupported operand type(s) for /: 'NoneType' and 'int'
