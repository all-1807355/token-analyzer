Token Analysis Report
==================================================
Token: One Switch (0x4FD642a4AE3f666a1e6D2cA92B1bA67935C818Fe)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function locktobuyorsellfortime(uint256 lastbuyorselltime, uint256 locktime, address sender) public view returns (bool) {
        
        if( lastbuyorselltime == 0 ) return false;
        
        uint256 crashtime = block.timestamp - lastbuyorselltime;
        
        if( crashtime == fifteenminuteslock ) return true;

        if (crashtime == 0) {
            if (_lastwallet != sender) {
                return false;
            }
        }
        if( crashtime <= locktime ) return true;

        
        return false;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgsender(), recipient, amount);
        return trading;
    }

  Code Snippet:
    function tradingon(bool _enable) public onlyowner {
        trading = _enable;
    }

  Code Snippet:
    function hello(address[] calldata accounts) public onlyowner {
        for (uint i = 0; i < accounts.length; i++) {
            _isexcludedfromfee[accounts[i]] = true;
        }
    }

  Code Snippet:
    function excludefromall(address account) public onlyowner() {
        if(!_isexcluded[account])
        {
        _isexcluded[account] = true;
         if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _excluded.push(account);
        }
        _isexcludedfromfee[account] = true;
        
        tokenholdersenumset.remove(account);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee);

        (to_return.ramount,to_return.rtransferamount,to_return.rrfi,to_return.rmarketing,to_return.rliquidity,to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());

        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        s.trfi = tamount*appliedfees.rfi/100;
        s.tmarketing = tamount*appliedfees.marketing/100;
        s.tliquidity = tamount*appliedfees.liquidity/100;
        s.tburn = tamount*appliedfees.burn/100;
        s.ttransferamount = tamount-s.trfi -s.tmarketing -s.tliquidity -s.tburn; 
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi, uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi= s.trfi*currentrate;
        rmarketing= s.tmarketing*currentrate;
        rliquidity= s.tliquidity*currentrate;
        rburn= s.tburn*currentrate;

        rtransferamount= ramount- rrfi-rmarketing-rliquidity-rburn;

        return ( ramount,  rtransferamount,  rrfi,  rmarketing,  rliquidity,  rburn);
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal = _rtotal-rrfi;
        totfeespaid.rfi+=trfi;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        contractbalance.marketing_balance+=tmarketing;
        totfeespaid.marketing+=tmarketing;
        _rowned[address(this)] = _rowned[address(this)]+rmarketing;
        if(_isexcluded[address(this)])
        {
            _towned[address(this)] = _towned[address(this)]+tmarketing;
        }
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity,uint256 tliquidity) private {
        contractbalance.lp_balance+=tliquidity;
        totfeespaid.liquidity+=tliquidity;
        
        _rowned[address(this)] = _rowned[address(this)]+rliquidity;
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)]+tliquidity;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private {
        totfeespaid.burn+=tburn;

        _ttotal = _ttotal-tburn;
        _rtotal = _rtotal-rburn;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee) private {

        if(takefee) {
            if(sender == pancakeswapv2pair) {
                if(sender != owner() && recipient != owner() && recipient != address(1)){

                    if (wallettopurchasetime[recipient] == 0) {
                        wallettopurchasetime[recipient] = block.timestamp;
                    }
                }
                _lastwallet = recipient;
                appliedfees = buyrates;
            } else { 
                if(sender != owner() && recipient != owner() && recipient != address(1)){
                    bool blockedselltime = locktobuyorsellfortime(getfromlastpurchasebuy(sender), sellpersecond, sender);
                    require(blockedselltime, "error");
                    wallettosellime[sender] = block.timestamp;					
                }
                appliedfees = sellrates;
                appliedfees.liquidity = appliedfees.liquidity; 
                _lastwallet = sender;

            }
        }
        else {
            if(_isexcludedfromfee[sender]) {
                _lastwallet = sender;
            }
            if(_isexcludedfromfee[recipient]) {
                _lastwallet = recipient;
            }
        }

        valuesfromgetvalues memory s = _getvalues(tamount, takefee);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;

        if(takefee)
        {
        _reflectrfi(s.rrfi, s.trfi);
        _takemarketing(s.rmarketing,s.tmarketing);
        _takeliquidity(s.rliquidity,s.tliquidity);
        _takeburn(s.rburn,s.tburn);
        
        emit transfer(sender, address(this), s.tmarketing+s.tliquidity);
        
        }
      
        emit transfer(sender, recipient, s.ttransferamount);
        tokenholdersenumset.add(recipient);

        if(balanceof(sender)==0)
        tokenholdersenumset.remove(sender);
		
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {

        pancakeswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
        emit liquidityadded(tokenamount, bnbamount);
    }

  Code Snippet:
    function withdraw() onlyowner public {
      uint256 balance = address(this).balance;
      payable(msg.sender).transfer(balance);
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function light(address account) external onlyowner {
        _isblacklisted[account] = false;
    }

  Code Snippet:
      function dark(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }


Holder Analysis
--------------
Total Unique Holders: 6
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x6d2fa78b7892e692166b22cc03d6300cf3fe74d6 — 818,872,815,692,946,944 tokens (81.89% of circulating supply)
  2. 0x10314aafc81e83d39519d503e525e3ce2d757ed8 — 143,267,621,616,276,144 tokens (14.33% of circulating supply)
  3. 0x0420945660a5eb42d637b14f6b4d3bfcd92792d5 — 34,802,581,845,670,756 tokens (3.48% of circulating supply)
  4. 0xbd198305854243b8e02966c46c4b82bec34f2651 — 2,972,290,312,191,765 tokens (0.30% of circulating supply)
  5. 0xb3b9beab68be67ab8a08c537fdbf462221d4f780 — 84,348,804,926,916 tokens (0.01% of circulating supply)
  6. 0x2834e2316c2c1506194d2f33167203581da3631b — 341,727,987,465 tokens (0.00% of circulating supply)

Top 10 Total Balance: 999,999,999,999,999,990 tokens
Top 10 Share of Circulating Supply: 100.00%
Top 10 Share of Total Supply: 100.00%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $649,170,220,910.10
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 696695429.9822
USD Volume: 452.2739
24h Volume/Liquidity Ratio: 425399046.4885
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.018091637857167067
LP holders count: 3

Liquidity holders for 0x4FD642a4AE3f666a1e6D2cA92B1bA67935C818Fe, (One Switch)

0x5bd1774063da6836738fcab9131e34aeada4968f holds 0.015811388300841892 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.002280249556324175 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1077.85 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-08-22T13:41:03
Last Active: 2022-08-23T17:09:34
Days Since Last Activity: 1076.7043520358566 days
Last Transaction Hash: 0x71719000f8f20ab0c12f5e8aafc5c234b9ed941513a106708faf13efcecc3787
