Token Analysis Report
==================================================
Token: Shitcoin (0x28D82C4D7315C02D19562dB1080a713eb5cc2639)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function setmintokentoswap(uint256 _amount) external onlyowner {
        mintokentoswap = _amount;
    }

  Code Snippet:
    function distributeandliquify(address from, address to) private {
        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is dex pair.
        uint256 contracttokenbalance = balanceof(address(this));

        bool shouldsell = contracttokenbalance >= mintokentoswap;

        if (
            shouldsell &&
            from != dexpair &&
            distributeandliquifystatus &&
            !(from == address(this) && to == address(dexpair)) // swap 1 time
        ) {
            // approve contract
            _approve(address(this), address(dexrouter), contracttokenbalance);

            uint256 halfliquidity = lpfeecounter.div(2);
            uint256 otherhalfliquidity = lpfeecounter.sub(halfliquidity);

            uint256 tokenamounttobeswapped = contracttokenbalance.sub(
                otherhalfliquidity
            );

            // now is to lock into liquidty pool
            utils.swaptokensforeth(address(dexrouter), tokenamounttobeswapped);

            uint256 deltabalance = address(this).balance;
            uint256 bnbtobeaddedtoliquidity = deltabalance
                .mul(halfliquidity)
                .div(tokenamounttobeswapped);
            uint256 bnbfordev = deltabalance.sub(bnbtobeaddedtoliquidity);

            // sending bnb to development wallet
            if (bnbfordev > 0) devwallet.transfer(bnbfordev);

            // add liquidity to dex
            if (bnbtobeaddedtoliquidity > 0) {
                utils.addliquidity(
                    address(dexrouter),
                    owner(),
                    otherhalfliquidity,
                    bnbtobeaddedtoliquidity
                );

                emit swapandliquify(
                    halfliquidity,
                    bnbtobeaddedtoliquidity,
                    otherhalfliquidity
                );
            }

            // reset all fee counters
            lpfeecounter = 0;
            devfeecounter = 0;
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = payable(address(0));
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function starttrading() external onlyowner {
        require(!_tradingopen, "stc: already enabled");
        _tradingopen = true;
        _launchtime = block.timestamp;
        distributeandliquifystatus = true;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function includeorexcludefromfee(address account, bool value)
        external

  Code Snippet:
    function setmintokentoswap(uint256 _amount) external onlyowner {
        mintokentoswap = _amount;
    }

  Code Snippet:
    function enableordisablefees(bool _value) external onlyowner {
        feesstatus = _value;
    }

  Code Snippet:
    function starttrading() external onlyowner {
        require(!_tradingopen, "stc: already enabled");
        _tradingopen = true;
        _launchtime = block.timestamp;
        distributeandliquifystatus = true;
    }

  Code Snippet:
    function totalbuyfeepertx(uint256 amount) public view returns (uint256) {
        uint256 fee = amount
            .mul(
                stakingfeeonbuying.add(devfeeonbuying).add(liquidityfeeonbuying)
            )
            .div(percentdivider);
        return fee;
    }

  Code Snippet:
    function totalsellfeepertx(uint256 amount) public view returns (uint256) {
        uint256 fee = amount
            .mul(
                stakingfeeonselling.add(devfeeonselling).add(
                    liquidityfeeonselling
                )
            )
            .div(percentdivider);
        return fee;
    }

  Code Snippet:
    function _takestakingpoolfeeonbuying(address sender, uint256 amount)
        internal

  Code Snippet:
    function _takedevfeeonbuying(address sender, uint256 amount) internal {
        uint256 _devfee = amount.mul(devfeeonbuying).div(percentdivider);
        devfeecounter = devfeecounter.add(_devfee);

        _balances[address(this)] = _balances[address(this)].add(_devfee);

        emit transfer(sender, address(this), _devfee);
    }

  Code Snippet:
    function _takeliquidityfeeonbuying(address sender, uint256 amount)
        internal

  Code Snippet:
    function _takestakingfeeonselling(address sender, uint256 amount) internal {
        uint256 fee = amount.mul(stakingfeeonselling).div(percentdivider);
        _balances[stakingpool] = _balances[stakingpool].add(fee);

        emit transfer(sender, stakingpool, fee);
    }

  Code Snippet:
    function _takedevfeeonselling(address sender, uint256 amount) internal {
        uint256 _devfee = amount.mul(devfeeonselling).div(percentdivider);
        devfeecounter = devfeecounter.add(_devfee);

        _balances[address(this)] = _balances[address(this)].add(_devfee);

        emit transfer(sender, address(this), _devfee);
    }

  Code Snippet:
    function _takeliquidityfeeonselling(address sender, uint256 amount)
        internal

  Code Snippet:
    function distributeandliquify(address from, address to) private {
        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is dex pair.
        uint256 contracttokenbalance = balanceof(address(this));

        bool shouldsell = contracttokenbalance >= mintokentoswap;

        if (
            shouldsell &&
            from != dexpair &&
            distributeandliquifystatus &&
            !(from == address(this) && to == address(dexpair)) // swap 1 time
        ) {
            // approve contract
            _approve(address(this), address(dexrouter), contracttokenbalance);

            uint256 halfliquidity = lpfeecounter.div(2);
            uint256 otherhalfliquidity = lpfeecounter.sub(halfliquidity);

            uint256 tokenamounttobeswapped = contracttokenbalance.sub(
                otherhalfliquidity
            );

            // now is to lock into liquidty pool
            utils.swaptokensforeth(address(dexrouter), tokenamounttobeswapped);

            uint256 deltabalance = address(this).balance;
            uint256 bnbtobeaddedtoliquidity = deltabalance
                .mul(halfliquidity)
                .div(tokenamounttobeswapped);
            uint256 bnbfordev = deltabalance.sub(bnbtobeaddedtoliquidity);

            // sending bnb to development wallet
            if (bnbfordev > 0) devwallet.transfer(bnbfordev);

            // add liquidity to dex
            if (bnbtobeaddedtoliquidity > 0) {
                utils.addliquidity(
                    address(dexrouter),
                    owner(),
                    otherhalfliquidity,
                    bnbtobeaddedtoliquidity
                );

                emit swapandliquify(
                    halfliquidity,
                    bnbtobeaddedtoliquidity,
                    otherhalfliquidity
                );
            }

            // reset all fee counters
            lpfeecounter = 0;
            devfeecounter = 0;
        }
    }

  Code Snippet:
    function swaptokensforeth(address routeraddress, uint256 tokenamount)
        internal

WARNING: Trading Disabled Possible
  Code Snippet:
    function starttrading() external onlyowner {
        require(!_tradingopen, "stc: already enabled");
        _tradingopen = true;
        _launchtime = block.timestamp;
        distributeandliquifystatus = true;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x923d0cff589104af7fb811baa7b4d98b0502ed5f — 1,003,022,996,366,949 tokens (52.47% of circulating supply)
  2. 0xc497f4bc8a10d29c24dfc47f5a7bc4bd0c7cfdf8 — 87,788,140,730,255 tokens (4.59% of circulating supply)
  3. 0x53f553ad579db6bd6df3a8be6ac30f4d70c278f5 — 40,630,186,750,886 tokens (2.13% of circulating supply)
  4. 0x9b17edc951c95d3fa2eb5fa790a822129e859a4c — 38,123,647,043,097 tokens (1.99% of circulating supply)
  5. 0x9fb1d1a3e8775fe0f4515e254b386bfa8f35ad43 — 29,780,921,195,078 tokens (1.56% of circulating supply)
  6. 0xe31908f82f40e94cb6d15978a67d5eb4d9cd457d — 24,091,488,207,282 tokens (1.26% of circulating supply)
  7. 0xcc5bd8114425600fb645a820cc2b6e9be94f2295 — 18,969,542,221,223 tokens (0.99% of circulating supply)
  8. 0x7b2676a841774c995acfcbd7b1f50fe9ae03cb6d — 18,058,458,605,723 tokens (0.94% of circulating supply)
  9. 0x3c8236bf53ccd2892a323eb76a184173737c0b2d — 16,207,247,200,402 tokens (0.85% of circulating supply)
  10. 0x354e546aeb015f26a860acf31808f0d1792cb9e7 — 15,341,220,189,954 tokens (0.80% of circulating supply)

Top 10 Total Balance: 1,292,013,848,510,849 tokens
Top 10 Share of Circulating Supply: 67.59%
Top 10 Share of Total Supply: 61.52%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $14,321,080,446,678.46
Liquidity: $150,296.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 20.1931
USD Volume: 0.1513
24h Volume/Liquidity Ratio: 0.0000
Percentage of liquidity locked: 98.0100
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.28460149170833626
LP holders count: 10

Liquidity holders for 0x28D82C4D7315C02D19562dB1080a713eb5cc2639, (Shitcoin)

0x0000000000000000000000000000000000000000 holds 0.17245256478714488 LP tokens

0x000000000000000000000000000000000000dead holds 0.0784176808648644 LP tokens

0x7ee058420e5937496f5a2096f04caa7721cf70cc holds 0.025820721910898393 LP tokens

0x62b8fc4ca6768626d54583539624e24d64594ed6 holds 0.003300153527850626 LP tokens

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 0.002256081806896673 LP tokens

0xbeb2257fd64ba8b8b31fc73c9a8550b5db77c70f holds 0.001301675809247884 LP tokens

0x9b17edc951c95d3fa2eb5fa790a822129e859a4c holds 0.000942121046560162 LP tokens

0x7344243feb3c55ad267b36a75f3ffa4e756e9acd holds 8.9391314536854e-05 LP tokens

0xb2633866b43e82f3be63137768110ff93da922f2 holds 1.6290903024034e-05 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 4.809737312373e-06 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://shitcoin69.com, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1320.67 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-22T19:56:50
Last Active: 2025-08-04T03:53:23
Days Since Last Activity: 0.339891714837963 days
Last Transaction Hash: 0x22171de28c4d4945f6ed6b66badfe7bfbcc3ee83e05a719a0bfed1e44031cb0b
