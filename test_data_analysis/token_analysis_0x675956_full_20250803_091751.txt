Token Analysis Report
==================================================
Token: VIP TOKEN (0x6759565574De509b7725ABb4680020704B3F404e)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(account != 0x10ed43c718714eb63d5aa57b78b54704e256024e, 'we can not exclude pancake router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 && _marketingfee==0 && _burnfee==0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousburnfee = _burnfee;
        _previousmarketingfee = _marketingfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
        _marketingfee = 0;
        _burnfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
       _taxfee = _previoustaxfee;
       _liquidityfee = _previousliquidityfee;
       _burnfee = _previousburnfee;
       _marketingfee = _previousmarketingfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        /* split the contract balance into halves */
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        /* 
        - capture the contract's current bnb balance.
        - this is so that we can capture exactly the amount of bnb that the
        - swap creates, and not make the liquidity event include any bnb that
        - has been manually sent to the contract 
        */
        uint256 initialbalance = address(this).balance;

        /* swap tokens for bnb */
        swaptokensforeth(half); // <- this breaks the bnb -> hate swap when swap+liquify is triggered

        /* how much bnb did we just swap into? */
        uint256 newbalance = address(this).balance.sub(initialbalance);

        /* add liquidity to pancakeswap */
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        /* generate the pancakeswap pair path of token -> wbnb */
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        /* make the swap */
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of bnb
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {
        /* approve token transfer to cover all possible scenarios */
        _approve(address(this), address(uniswapv2router), tokenamount);

        /* add the liquidity */
        uniswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount) private {
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            removeallfee();
        }
        
        /* calculate burn amount and marketing amount */
        uint256 burnamt = amount.mul(_burnfee).div(100);
        uint256 marketingamount = amount.mul(_marketingfee).div(100);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamount)));
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamount)));
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamount)));
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, (amount.sub(burnamt).sub(marketingamount)));
        } else {
            _transferstandard(sender, recipient, (amount.sub(burnamt).sub(marketingamount)));
        }
        
        /* temporarily remove fees to transfer to burn address and marketing wallet */
        _taxfee = 0;
        _liquidityfee = 0;


        _transferstandard(sender, address(0), burnamt);
        uint256 amounttosend = marketingamount/4;
        _transferstandard(sender, marketingwallet1, amounttosend);
        _transferstandard(sender, marketingwallet2, amounttosend);
        _transferstandard(sender, marketingwallet3, amounttosend);
        _transferstandard(sender, marketingwallet4, amounttosend);

        /* restore tax and liquidity fees */
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;


        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient])
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function disableallfees() external onlyowner() {
        _taxfee = 0;
        _previoustaxfee = _taxfee;
        _liquidityfee = 0;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketingfee = 0;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = false;
        emit swapandliquifyenabledupdated(false);
    }

  Code Snippet:
    function enableallfees() external onlyowner() {
        _taxfee = 2;
        _previoustaxfee = _taxfee;
        _liquidityfee = 2;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketingfee = 4;
        _previousmarketingfee = _marketingfee;
        inswapandliquify = true;
        emit swapandliquifyenabledupdated(true);
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setmarketingfeepercent(uint256 marketingfee) external onlyowner() {
        _marketingfee = marketingfee;
    }

  Code Snippet:
    function setburnfeepercent(uint256 burnfee) external onlyowner() {
        _burnfee = burnfee;
    }

  Code Snippet:
    function setrouteraddress(address newrouter) public onlyowner() {
        iuniswapv2router02 _newpancakerouter = iuniswapv2router02(newrouter);
        uniswapv2pair = iuniswapv2factory(_newpancakerouter.factory()).createpair(address(this), _newpancakerouter.weth());
        uniswapv2router = _newpancakerouter;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 200
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x3b225578a7e123e996d1abee4b3318b4ee19417b — 124,269,754,706,137,817,546,752 tokens (25586126798.12% of circulating supply)
  2. 0x471be7bff79182390f049a18b226c3b1c55d1078 — 21,591,306,392,713,698,476,032 tokens (4445473513.71% of circulating supply)
  3. 0xbac5f99cffd4c2a9b225a2eb3ce832392fe1a100 — 7,997,096,841,690,515,243,008 tokens (1646536876.91% of circulating supply)
  4. 0xb753d8b615c24579f67f16092700d9a47be03535 — 5,582,346,792,127,242,960,896 tokens (1149359578.22% of circulating supply)
  5. 0x1ffc3f7b9c215aedaf98d638feb1dad69b5bccf8 — 5,057,910,948,593,526,636,544 tokens (1041382524.41% of circulating supply)
  6. 0x44e24075f22de174ffb18fcdd05f312ed7a9aa36 — 4,469,729,903,782,382,796,800 tokens (920280854.68% of circulating supply)
  7. 0x65154fa4668c3a9d8c3e08c0567bd83d779128ef — 4,288,490,721,427,045,482,496 tokens (882965188.36% of circulating supply)
  8. 0xb5002091d51cd1bbd84fad4bad289add49c2fa5a — 4,059,536,429,270,336,274,432 tokens (835825370.92% of circulating supply)
  9. 0xbff1e5a24f8ecf10da7576336c4f1c3c6a0d571d — 3,373,714,509,255,203,094,528 tokens (694620243.02% of circulating supply)
  10. 0x328130164d0f2b9d7a52edc73b3632e713ff0ec6 — 3,082,082,664,016,014,999,552 tokens (634575629.69% of circulating supply)

Top 10 Total Balance: 183,771,969,909,013,783,511,040 tokens
Top 10 Share of Circulating Supply: 37837146578.03%
Top 10 Share of Total Supply: 18.38%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $357,857.82
Liquidity: $183,131.97
Liquidity/MCap Ratio: 0.5117
Token Volume: 557780426204.1019
USD Volume: 410.9726
24h Volume/Liquidity Ratio: 0.0022
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 3833.059573012811
LP holders count: 7

Liquidity holders for 0x6759565574De509b7725ABb4680020704B3F404e, (VIP TOKEN)

0x1df1bbb1a8803ba94295b70033a3720c482c2335 holds 3831.295130568816 LP tokens

Owner 0x373dc6284d80f4e958a49947fc3ad4c2a7bd08b8 holds 1.5195933751650477 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.144840105911286 LP tokens

0x0b221198e61150f533aeb22cb35c307464821763 holds 0.1 LP tokens

0x0000000000000000000000000000000000000000 holds 4.778384793593e-06 LP tokens

0x996730db3c8ef2aa6bfbd3fa9c99a8201f97a5db holds 4.087085080123e-06 LP tokens

0xb04336c1d0ac42909ec68f98186ec2915c769592 holds 9.7448367403e-08 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1375.39 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-10-27T23:57:20
Last Active: 2025-08-02T21:35:22
Days Since Last Activity: 0.48784100001157404 days
Last Transaction Hash: 0xe38380a47babb3e7e9373763c220cdf27f8d1b364530e349cfcb6f9c0958468e
