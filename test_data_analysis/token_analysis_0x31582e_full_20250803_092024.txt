Token Analysis Report
==================================================
Token: Zeronauts (0x31582e4Dd4906f2eb71C0D7b141AA097FB715491)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
    event mint(address indexed sender, uint amount0, uint amount1);

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
        emit setexcludefromreward(msg.sender ,account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                uint256 currentrate = _getrate();
                _rowned[account] = _towned[account].mul(currentrate);
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
        emit setincludeinreward(msg.sender ,account);
    }

  Code Snippet:
    function setbnbrewardpercentage(uint256 charitypcent,uint256 stabilitypcent,uint256 businesspcent,uint256 marketingpcent)public onlyowner{
        require((charitypcent+ stabilitypcent+ businesspcent+ marketingpcent) == 100,"setbnbrewardvalues: invalid fee percentage");
        _charitypcent = charitypcent;
        _stabilityreservepcent = stabilitypcent;
        _businessdevelopmentpcent = businesspcent;
        _marketingpcent = marketingpcent;
        emit setbnbrewardvalues(msg.sender, charitypcent, stabilitypcent, businesspcent, marketingpcent);
    }

  Code Snippet:
    function settokenrewardpercentage(uint256 assessmentpcent, uint256 reservepcent, uint256 burnpcent )public onlyowner{
        require((assessmentpcent +reservepcent +burnpcent)==100,"settokenrewardvalues: invalid fee percentage");
        _assessmentpcent = assessmentpcent;
        _reservepcent = reservepcent;
        _burnpcent = burnpcent;
        emit settokenrewardvalues(msg.sender,assessmentpcent, reservepcent, burnpcent);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
        emit setexcludefromreward(msg.sender ,account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                uint256 currentrate = _getrate();
                _rowned[account] = _towned[account].mul(currentrate);
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
        emit setincludeinreward(msg.sender ,account);
    }

  Code Snippet:
    function setbnbrewardpercentage(uint256 charitypcent,uint256 stabilitypcent,uint256 businesspcent,uint256 marketingpcent)public onlyowner{
        require((charitypcent+ stabilitypcent+ businesspcent+ marketingpcent) == 100,"setbnbrewardvalues: invalid fee percentage");
        _charitypcent = charitypcent;
        _stabilityreservepcent = stabilitypcent;
        _businessdevelopmentpcent = businesspcent;
        _marketingpcent = marketingpcent;
        emit setbnbrewardvalues(msg.sender, charitypcent, stabilitypcent, businesspcent, marketingpcent);
    }

  Code Snippet:
    function settokenrewardpercentage(uint256 assessmentpcent, uint256 reservepcent, uint256 burnpcent )public onlyowner{
        require((assessmentpcent +reservepcent +burnpcent)==100,"settokenrewardvalues: invalid fee percentage");
        _assessmentpcent = assessmentpcent;
        _reservepcent = reservepcent;
        _burnpcent = burnpcent;
        emit settokenrewardvalues(msg.sender,assessmentpcent, reservepcent, burnpcent);
    }

WARNING: High Tax Detected
  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
        emit setexcludefromreward(msg.sender ,account);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
        emit setexcludefromfee(msg.sender, account);
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
        emit setincludeinfee(msg.sender, account);
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
        emit settaxfeepercent(msg.sender, taxfee);
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
        emit setliquidityfeepercent(msg.sender, liquidityfee);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function setbnbrewardpercentage(uint256 charitypcent,uint256 stabilitypcent,uint256 businesspcent,uint256 marketingpcent)public onlyowner{
        require((charitypcent+ stabilitypcent+ businesspcent+ marketingpcent) == 100,"setbnbrewardvalues: invalid fee percentage");
        _charitypcent = charitypcent;
        _stabilityreservepcent = stabilitypcent;
        _businessdevelopmentpcent = businesspcent;
        _marketingpcent = marketingpcent;
        emit setbnbrewardvalues(msg.sender, charitypcent, stabilitypcent, businesspcent, marketingpcent);
    }

  Code Snippet:
    function settokenrewardpercentage(uint256 assessmentpcent, uint256 reservepcent, uint256 burnpcent )public onlyowner{
        require((assessmentpcent +reservepcent +burnpcent)==100,"settokenrewardvalues: invalid fee percentage");
        _assessmentpcent = assessmentpcent;
        _reservepcent = reservepcent;
        _burnpcent = burnpcent;
        emit settokenrewardvalues(msg.sender,assessmentpcent, reservepcent, burnpcent);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function tokenextraction(uint256 contracttokenbalance) private locktheswap{
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;
        // swap tokens for eth
        swaptokensforbnb(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered
        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);
        
        (_charity).transfer(newbalance.mul(_charitypcent).div(100));
        (_stability).transfer(newbalance.mul(_stabilityreservepcent).div(100));
        (_business).transfer(newbalance.mul(_businessdevelopmentpcent).div(100));
        (_marketing).transfer(newbalance.mul(_marketingpcent).div(100));
        
        _tokentransfer(address(this), _assesment,otherhalf.mul(_assessmentpcent).div(100), false);
        _tokentransfer(address(this), _reserve,otherhalf.mul(_reservepcent).div(100), false);
        _tokentransfer(address(this), _burn,otherhalf.mul(_burnpcent).div(100), false);
        emit tokenextraction(newbalance,otherhalf);
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;
        // swap tokens for eth
        swaptokensforbnb(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered
        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);
        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);
        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function safewithdrawbnb(address payable _receiver) external onlyowner {
        uint256 amount = address(this).balance;
        _receiver.transfer(amount);
        emit safewithdrwabnb(msg.sender, _receiver, amount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x35cf833e43862cca9140e38c32860ad8c88688ef
Owner Balance: 61,542,347,583,021,000 tokens
Owner Share: 62.14% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x35cf833e43862cca9140e38c32860ad8c88688ef — 61,542,347,583,021,000 tokens (62.10% of circulating supply)
  2. 0x0e71fc19f24beab401308989f75614eb7361c9bf — 4,203,445,891,806,203 tokens (4.24% of circulating supply)
  3. 0xcd35d8c5ce8315c9ab077a4593f394ac7f55a5a9 — 3,000,000,000,000,000 tokens (3.03% of circulating supply)
  4. 0xf091dbdcd5b1c02c854734bf79128968ff2d1876 — 3,000,000,000,000,000 tokens (3.03% of circulating supply)
  5. 0xc590b2ea46738356c85e5336b58546b6a4e43e13 — 3,000,000,000,000,000 tokens (3.03% of circulating supply)
  6. 0xcf9c3f6aec80503314bb96955303b82be9293246 — 1,847,434,521,174,817 tokens (1.86% of circulating supply)
  7. 0x9d5157996de92c97db70e5897bb214e5577fd22f — 1,677,816,034,572,280 tokens (1.69% of circulating supply)
  8. 0xb38ab7bdcd1c628eb89ea6f647703f2cb297d1e8 — 1,624,372,134,045,882 tokens (1.64% of circulating supply)
  9. 0xbe2caa21f0a977dae34894597051858eed16a33e — 1,558,540,940,725,471 tokens (1.57% of circulating supply)
  10. 0x5d1e4d94650868bea9d6b6fc092cc49157a215de — 1,335,437,608,927,569 tokens (1.35% of circulating supply)

Top 10 Total Balance: 82,789,394,714,273,222 tokens
Top 10 Share of Circulating Supply: 83.54%
Top 10 Share of Total Supply: 82.79%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $79,703,775,386,266,576.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 2360.2309
USD Volume: 1898.1865
24h Volume/Liquidity Ratio: 280101.2659
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (61.5874)
Total supply of LP tokens: 0.101982000000001
LP holders count: 2

Liquidity holders for 0x31582e4Dd4906f2eb71C0D7b141AA097FB715491, (Zeronauts)

0x3f4d6bf08cb7a003488ef082102c2e6418a4551e holds 0.101982 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1507.40 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-06-17T23:43:41
Last Active: 2025-07-19T11:33:03
Days Since Last Activity: 14.907891899525463 days
Last Transaction Hash: 0x84b36756bdf99928fe2de91dac6ab9b0f8cfc56bff1a5084e7fdc38bb4d84e39
