Token Analysis Report
==================================================
Token: PowerInu (0xec743655ddb648c4362DFa71CdB1877783Ed1CcA)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until time lock");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(sniperprotection) {
          // if sender is a sniper address, reject the sell.
          if(issniper(sender)) {
            revert('sniper rejected.');
          }
    
          // check if this is the liquidity adding tx to startup.
          if(!_hasliqbeenadded) {
            _checkliquidityadd(sender, recipient);
          } else {
            if(
              launchedat > 0
                && sender == pancakepair
                && !_liquidityholders[sender]
                && !_liquidityholders[recipient]
            ) {
              if(block.number - launchedat < 1) {
                _issniper[recipient] = true;
                sniperscaught++;
              }
            }
          }
        }
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        if(launchedat.add(3) >= block.number){
            return _amount.mul(_liquidityfee.mul(7)).div(
                10**2
            );
        } else {
            return _amount.mul(_liquidityfee).div(
                10**2
            );
        }
    
    }

  Code Snippet:
    function _checkliquidityadd(address from, address to) private {
        // if liquidity is added by the _liquidityholders set trading enables to true and start the anti sniper timer
        require(!_hasliqbeenadded, 'liquidity already added and marked.');
    
        if(_liquidityholders[from] && to == pancakepair) {
          _hasliqbeenadded = true;
          _tradingenabled = true;
          launchedat = block.number;
        }
    }

  Code Snippet:
    function presaleafter() external onlyowner {
        setswapandliquifyenabled(true);
        launchedat = block.number;
        _hasliqbeenadded = true;
        _tradingenabled = true;
        _reflectionfee = 0;
        _liquidityfee = 11;
        _maxtxamount = 2500 * 10**6 * 10**9;
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
   function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function minimumtokensbeforeswapamount() public view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) internal locktheswap {
        // split the contract balance into halves
        uint256 whole = contracttokenbalance.div(div1);
        uint256 half = whole.div(2);
        uint256 otherhalf = whole.sub(half);
        uint256 remains = contracttokenbalance.sub(whole);
        
        // capture the contract's current bnb balance.
        // this is so that we can capture exactly the amount of bnb that the
        // swap creates, and not make the liquidity event include any bnb that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for bnb
        swaptokensforeth(half);

        // how much bnb did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity
        addliquidity(otherhalf, newbalance);

        initialbalance = address(this).balance;
        
        // swap tokens for bnb
        swaptokensforeth(remains);
        
        uint256 transferredbalance = address(this).balance.sub(initialbalance);
        uint256 marketingbalance = transferredbalance.mul(div2).div(100);
        uint256 overallbalance = transferredbalance.sub(marketingbalance);
        uint256 buybackbalance = overallbalance.mul(affiliatepercent).div(100);
        uint256 affiliatebalance = overallbalance.sub(buybackbalance);
        
        // send token to wallet address
        transfertoaddresseth(buybackaddress, buybackbalance);
        transfertoaddresseth(affilateaddress, affiliatebalance);
        transfertoaddresseth(marketingaddress, marketingbalance);

        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the pancake pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pancakerouter.weth();

        _approve(address(this), address(pancakerouter), tokenamount);

        // make the swap
        pancakerouter.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of bnb
            path,
            address(this), // the contract
            block.timestamp
        );
        
        emit swaptokensforeth(tokenamount, path);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(sniperprotection) {
          // if sender is a sniper address, reject the sell.
          if(issniper(sender)) {
            revert('sniper rejected.');
          }
    
          // check if this is the liquidity adding tx to startup.
          if(!_hasliqbeenadded) {
            _checkliquidityadd(sender, recipient);
          } else {
            if(
              launchedat > 0
                && sender == pancakepair
                && !_liquidityholders[sender]
                && !_liquidityholders[recipient]
            ) {
              if(block.number - launchedat < 1) {
                _issniper[recipient] = true;
                sniperscaught++;
              }
            }
          }
        }
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
	    _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatereflectionfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatereflectionfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_reflectionfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        if(launchedat.add(3) >= block.number){
            return _amount.mul(_liquidityfee.mul(7)).div(
                10**2
            );
        } else {
            return _amount.mul(_liquidityfee).div(
                10**2
            );
        }
    
    }

  Code Snippet:
    function manualswapandliquify(uint256 _balance) external onlyowner {
        swapandliquify(_balance);
    }

  Code Snippet:
    function removeallfee() private {
        if(_reflectionfee == 0 && _liquidityfee == 0) return;
        
        _previousreflectionfee = _reflectionfee;
        _previousliquidityfee = _liquidityfee;
        
        _reflectionfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _reflectionfee = _previousreflectionfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function getswapminutes() public view returns(uint256) {
        return _intervalsecondsforswap.div(60);
    }

  Code Snippet:
    function setswapminutes(uint256 newminutes) external onlyowner {
        _intervalsecondsforswap = newminutes * 1 minutes;
    }

  Code Snippet:
    function setreflectionfeepercent(uint256 reflectionfee) external onlyowner() {
        require(reflectionfee < 30, "tax too high");
        _reflectionfee = reflectionfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner {
        require(liquidityfee < 30, "tax too high");
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function _checkliquidityadd(address from, address to) private {
        // if liquidity is added by the _liquidityholders set trading enables to true and start the anti sniper timer
        require(!_hasliqbeenadded, 'liquidity already added and marked.');
    
        if(_liquidityholders[from] && to == pancakepair) {
          _hasliqbeenadded = true;
          _tradingenabled = true;
          launchedat = block.number;
        }
    }

  Code Snippet:
    function setminimumtokensbeforeswap(uint256 _minimumtokensbeforeswap) external onlyowner {
        minimumtokensbeforeswap = _minimumtokensbeforeswap;
    }  

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function buyback() public payable {
        address[] memory path = new address[](2);
        path[0] = pancakerouter.weth();
        path[1] = address(this);
        pancakerouter.swapexactethfortokenssupportingfeeontransfertokens{value : msg.value}(0,path,stakingaddress,block.timestamp.add(10));
    }

  Code Snippet:
    function presalebefore() external onlyowner {
        setswapandliquifyenabled(false);
        _reflectionfee = 0;
        _liquidityfee = 0;
        _maxtxamount = 1000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function presaleafter() external onlyowner {
        setswapandliquifyenabled(true);
        launchedat = block.number;
        _hasliqbeenadded = true;
        _tradingenabled = true;
        _reflectionfee = 0;
        _liquidityfee = 11;
        _maxtxamount = 2500 * 10**6 * 10**9;
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _checkliquidityadd(address from, address to) private {
        // if liquidity is added by the _liquidityholders set trading enables to true and start the anti sniper timer
        require(!_hasliqbeenadded, 'liquidity already added and marked.');
    
        if(_liquidityholders[from] && to == pancakepair) {
          _hasliqbeenadded = true;
          _tradingenabled = true;
          launchedat = block.number;
        }
    }

  Code Snippet:
    function presaleafter() external onlyowner {
        setswapandliquifyenabled(true);
        launchedat = block.number;
        _hasliqbeenadded = true;
        _tradingenabled = true;
        _reflectionfee = 0;
        _liquidityfee = 11;
        _maxtxamount = 2500 * 10**6 * 10**9;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x1275254b1b59b08d936fb8ea33f131ae02dd0763 — 817,414,425,741,300,596,736 tokens (82.19% of circulating supply)
  2. 0xec743655ddb648c4362dfa71cdb1877783ed1cca — 99,272,427,138,577,186,816 tokens (9.98% of circulating supply)
  3. 0xf28352976ffa24c82d6a89c03c71ec6b964119e2 — 5,862,199,080,000,000,000 tokens (0.59% of circulating supply)
  4. 0xfc854e3a2993618386a50f23f0acd6b72bccabcf — 5,757,434,391,630,972,928 tokens (0.58% of circulating supply)
  5. 0x68a1e80fc59e5547bf1719ed20e9dafeff0938c0 — 5,092,343,571,499,999,232 tokens (0.51% of circulating supply)
  6. 0x57c54be25d81ed161389569dff4bcb3f28329cf7 — 4,747,914,399,905,154,048 tokens (0.48% of circulating supply)
  7. 0xe096fbcff5beb319b89d846c69acd47b83523fd4 — 4,466,401,596,400,000,000 tokens (0.45% of circulating supply)
  8. 0x381042284059fd8ada8d8e0f84f71890d5550dbb — 2,729,008,585,923,670,528 tokens (0.27% of circulating supply)
  9. 0xbf68e1420e623a5403898c734fc33c4837cf1bc0 — 2,622,406,763,108,739,584 tokens (0.26% of circulating supply)
  10. 0x5bc3b68a388ba55f2af542da4da136e4c2df8a4f — 1,701,653,300,008,900,096 tokens (0.17% of circulating supply)

Top 10 Total Balance: 949,666,214,568,355,219,968 tokens
Top 10 Share of Circulating Supply: 95.49%
Top 10 Share of Total Supply: 94.97%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,889,062,071,717,646.50
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 2251980250.0000
USD Volume: 4277.4111
24h Volume/Liquidity Ratio: 195571507.7946
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.21445969365012377
LP holders count: 3

Liquidity holders for 0xec743655ddb648c4362DFa71CdB1877783Ed1CcA, (PowerInu)

0x33b9ff9abf03000fa79a0340659a9992ce0d871f holds 0.21394117533086296 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000518518319259804 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://tg.powerinu.net, Reason: metamask recovery phrase phishing
  URL: https://discord.powerinu.net, Reason: metamask recovery phrase phishing
  URL: https://twitter.powerinu.net, Reason: metamask recovery phrase phishing
  URL: https://youtube.powerinu.net, Reason: metamask recovery phrase phishing
  URL: https://powerinu.net, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1351.79 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-20T13:57:05
Last Active: 2025-07-19T10:21:54
Days Since Last Activity: 14.943764094282407 days
Last Transaction Hash: 0x48f427d61353f7b2cca3bd86341c2402e13ba1ff7143fcd52be6a6964658a9dc
