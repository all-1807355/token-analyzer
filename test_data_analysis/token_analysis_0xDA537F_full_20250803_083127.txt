Token Analysis Report
==================================================
Token: DiamondBalls (0xDA537F087b9D554f931c51ad6e6357211eEE498F)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {

        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function minimumtokensbeforeswapamount() public view returns (uint256) {
        return minimumtokensbeforeswap;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function swaptokens(uint256 contracttokenbalance) private locktheswap {
       
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(contracttokenbalance);
        uint256 transferredbalance = address(this).balance.sub(initialbalance);

        // send to marketing address
        transfertoaddresseth(marketingaddress, transferredbalance.mul(marketingdivisor).div(100));
        
    }

  Code Snippet:
    function buybacktokens(uint256 amount) private locktheswap {
    	if (amount > 0) {
    	    swapethfortokens(amount);
	    }
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this), // the contract
            block.timestamp
        );
        
        emit swaptokensforeth(tokenamount, path);
    }

  Code Snippet:
    function swapethfortokens(uint256 amount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = uniswapv2router.weth();
        path[1] = address(this);

      // make the swap
        uniswapv2router.swapexactethfortokenssupportingfeeontransfertokens{value: amount}(
            0, // accept any amount of tokens
            path,
            deadaddress, // burn address
            block.timestamp.add(300)
        );
        
        emit swapethfortokens(amount, path);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
	    _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
    	_towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function _getsellbnbamount(uint256 tokenamount) private view returns(uint256) {
        address[] memory path = new address[](2);

        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        uint[] memory amounts = uniswapv2router.getamountsout(tokenamount, path);

        return amounts[1];
    }

  Code Snippet:
    function getswapminutes() public view returns(uint256) {
        return _intervalminutesforswap.div(60);
    }

  Code Snippet:
    function setswapminutes(uint256 newminutes) external onlyowner {
        _intervalminutesforswap = newminutes * 1 minutes;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setbuyfee(uint256 buytaxfee, uint256 buyliquidityfee) external onlyowner {
        _buytaxfee = buytaxfee;
        _buyliquidityfee = buyliquidityfee;
    }

  Code Snippet:
    function setsellfee(uint256 selltaxfee, uint256 sellliquidityfee) external onlyowner {
        _selltaxfee = selltaxfee;
        _sellliquidityfee = sellliquidityfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setnumtokensselltoaddtobuyback(uint256 _minimumtokensbeforeswap) external onlyowner {
        minimumtokensbeforeswap = _minimumtokensbeforeswap;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function prepareforpresale() external onlyowner {
        setswapandliquifyenabled(false);
        _taxfee = 0;
        _liquidityfee = 0;
        _maxtxamount = 1000000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function afterpresale() external onlyowner {
        setswapandliquifyenabled(true);
        _taxfee = 2;
        _liquidityfee = 10;
        _maxtxamount = 3000000 * 10**6 * 10**9;
    }

  Code Snippet:
    function changerouterversion(address _router) public onlyowner returns(address _pair) {
        iuniswapv2router02 _uniswapv2router = iuniswapv2router02(_router);
        
        _pair = iuniswapv2factory(_uniswapv2router.factory()).getpair(address(this), _uniswapv2router.weth());
        if(_pair == address(0)){
            // pair doesn't exist
            _pair = iuniswapv2factory(_uniswapv2router.factory())
            .createpair(address(this), _uniswapv2router.weth());
        }
        uniswapv2pair = _pair;

        // set the router of the contract variables
        uniswapv2router = _uniswapv2router;
    }

  Code Snippet:
    function setaddressfee(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._taxfee = _addresstaxfee;
        _addressfees[_address]._liquidityfee = _addressliquidityfee;
    }

  Code Snippet:
    function setbuyaddressfee(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._buytaxfee = _addresstaxfee;
        _addressfees[_address]._buyliquidityfee = _addressliquidityfee;
    }

  Code Snippet:
    function setselladdressfee(address _address, bool _enable, uint256 _addresstaxfee, uint256 _addressliquidityfee) external onlyowner {
        _addressfees[_address].enable = _enable;
        _addressfees[_address]._selltaxfee = _addresstaxfee;
        _addressfees[_address]._sellliquidityfee = _addressliquidityfee;
    }


Holder Analysis
--------------
Total Unique Holders: 35
Owner Address: 0x50f8b1c126e33f2d56d4673d7f1556b16993761a
Owner Balance: 911,905,703,000,000,036,864 tokens
Owner Share: 91.20% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x50f8b1c126e33f2d56d4673d7f1556b16993761a — 911,905,703,000,000,036,864 tokens (91.20% of circulating supply)
  2. 0x5db02b983277a9e1117bc4555938997a7fec6017 — 25,136,443,946,506,444,800 tokens (2.51% of circulating supply)
  3. 0x1e56fb4ae026113f1b55f3a0879e65dcf999dec3 — 25,116,871,998,239,477,760 tokens (2.51% of circulating supply)
  4. 0x161827e1f83e587962c989cfa7888b7dc0988d96 — 25,095,349,536,089,587,712 tokens (2.51% of circulating supply)
  5. 0xde2267f9a8fdf91e81eae8e5c1a62e9f602efe06 — 8,372,465,163,761,705,984 tokens (0.84% of circulating supply)
  6. 0x67372df5277c802442ae306364b98cbfd9568922 — 1,028,270,043,200,538,752 tokens (0.10% of circulating supply)
  7. 0x3671e929b17ea6075be0b8f58df81e82dc66206d — 920,508,985,107,086,208 tokens (0.09% of circulating supply)
  8. 0xe1906fe13751f002a9171293047cb46ffe8fd45b — 430,720,688,724,260,480 tokens (0.04% of circulating supply)
  9. 0xfcce9ccc4427eeff33b15d16e52f1c06edc6f6fa — 381,554,694,377,670,656 tokens (0.04% of circulating supply)
  10. 0xa2b8f1b9406e490face29a2485ae636e46592158 — 372,391,242,810,018,752 tokens (0.04% of circulating supply)

Top 10 Total Balance: 998,760,279,298,816,827,968 tokens
Top 10 Share of Circulating Supply: 99.88%
Top 10 Share of Total Supply: 99.88%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $161,847,725,673,344.88
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 18147082421.8393
USD Volume: 2937.2374
24h Volume/Liquidity Ratio: 1083735916.8949
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (91.1906)
Total supply of LP tokens: 0.09146204405435313
LP holders count: 6

Liquidity holders for 0xDA537F087b9D554f931c51ad6e6357211eEE498F, (DiamondBalls)

0x161827e1f83e587962c989cfa7888b7dc0988d96 holds 0.0225 LP tokens

Owner 0x50f8b1c126e33f2d56d4673d7f1556b16993761a holds 0.02 LP tokens
WARNING: Owner/Creator holds over 5% of the liquidityWARNING: Owner holds over 5% of the liquidity
0x1e56fb4ae026113f1b55f3a0879e65dcf999dec3 holds 0.02 LP tokens

0x5db02b983277a9e1117bc4555938997a7fec6017 holds 0.0175 LP tokens

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 0.011462044054352125 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1236.85 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-03-15T12:06:11
Last Active: 2022-03-21T01:29:42
Days Since Last Activity: 1231.2928895364698 days
Last Transaction Hash: 0xaede84347fba9e9065c7df63719f0abce95d57eb931c005df70deead09331a6a
