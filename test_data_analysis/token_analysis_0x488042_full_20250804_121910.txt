Token Analysis Report
==================================================
Token: DynamiteBOOM (0x488042a0a2941D7Ae5d748Ef1718A5463b83d017)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(now > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = now + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        // require(account != 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, 'we can not exclude uniswap router.');
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
        function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _takefeebuysell(tfeebuysell);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
        function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner() {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner() {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setbuysellfeepercent(uint256 buysellfee) external onlyowner() {
        _buysellfee = buysellfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function setbuysellfeeenabled(bool _enabled) public onlyowner {
        buysellfeeenabled = _enabled;
        emit buysellfeeenabledupdated(_enabled);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, tfeebuysell, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity, tfeebuysell);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 tfeebuysell = calculatebuysellfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity).sub(tfeebuysell);
        return (ttransferamount, tfee, tliquidity, tfeebuysell);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rfeebuysell = tfeebuysell.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity).sub(rfeebuysell);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function _takefeebuysell(uint256 tfeebuysell) private {
        uint256 currentrate =  _getrate();
        _treasury = _treasury.add(tfeebuysell);
        uint256 rbuysellfee = tfeebuysell.mul(currentrate);
        _rowned[address(this)] = _rowned[address(this)].add(rbuysellfee);
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)].add(tfeebuysell);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculatebuysellfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_buysellfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 && _buysellfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousbuysellfee = _buysellfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
        _buysellfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
        _taxfee = _previoustaxfee;
        _liquidityfee = _previousliquidityfee;
        _buysellfee = _previousbuysellfee;
    }

  Code Snippet:
    function removebuysellfee() private {
        if(_buysellfee == 0) return;

        _previousbuysellfee = _buysellfee;

        _buysellfee = 0;
    }

  Code Snippet:
    function restorebuysellfee() private {
        _buysellfee = _previousbuysellfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance, uint256 buysellfeebalance) private locktheswap {
        // split the contract balance into halves
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        uint256 totaltokenamountforeth = half.add(buysellfeebalance);
        // swap tokens for eth
        swaptokensforeth(totaltokenamountforeth); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        uint256 ethforbuysellfee = newbalance.mul(buysellfeebalance).div(totaltokenamountforeth);
        uint256 ethforliquidity = newbalance.sub(ethforbuysellfee);

        if (ethforliquidity > 0) {
            // add liquidity to uniswap
            addliquidity(otherhalf, ethforliquidity);
            
            emit swapandliquify(half, ethforliquidity, otherhalf);
        }

        if (ethforbuysellfee > 0) {
            payable(_treasuryaddress).transfer(ethforbuysellfee);
            _treasury = _treasury.sub(buysellfeebalance);
        }
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function isbuyorsell(address sender, address recipient) private view returns (bool) {
        if (sender == uniswapv2pair || recipient == uniswapv2pair) {
            return true;
        }

        return false;
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        if(!takefee)
            removeallfee();

        if (takefee && !isbuyorsell(sender, recipient)) {
            removebuysellfee();
        }
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }

        if (takefee && !isbuyorsell(sender, recipient)) {
            restorebuysellfee();
        }
        
        if(!takefee)
            restoreallfee();
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _takefeebuysell(tfeebuysell);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _takefeebuysell(tfeebuysell);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity, uint256 tfeebuysell) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _takefeebuysell(tfeebuysell);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x94528c8e27dbd36df499f3f2809f4896c67cbc42
Owner Balance: 74,483,951,318,793,355,001,856 tokens
Owner Share: 12.47% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x488042a0a2941d7ae5d748ef1718a5463b83d017 — 85,504,223,196,110,607,351,808 tokens (14.31% of circulating supply)
  2. 0x94528c8e27dbd36df499f3f2809f4896c67cbc42 — 74,483,951,318,793,355,001,856 tokens (12.47% of circulating supply)
  3. 0x8b3f61f46272470f8f81b300ec32fc5ee04f22ec — 4,447,736,098,046,345,740,288 tokens (0.74% of circulating supply)
  4. 0x487b9be735985b31842182ddd9918c77fe4887eb — 3,557,720,127,795,513,262,080 tokens (0.60% of circulating supply)
  5. 0xc397310362e80b344d8a0351fcf4fd387ba34319 — 2,340,019,682,717,184,819,200 tokens (0.39% of circulating supply)
  6. 0x0ad3b97a9c821b6b39697871acdc37d0de9ad058 — 1,580,432,031,401,146,580,992 tokens (0.26% of circulating supply)
  7. 0x5969b8575c7dfe54eb8d6c70bdf8a154adf0ad93 — 1,533,860,611,789,223,624,704 tokens (0.26% of circulating supply)
  8. 0x6a2829e0e388a438a0994c02ebca077bf1ab6303 — 1,371,791,511,626,567,647,232 tokens (0.23% of circulating supply)
  9. 0x19d34490d39ddf6293abff0209ffb63cedf18956 — 1,263,414,713,842,898,305,024 tokens (0.21% of circulating supply)
  10. 0x73fb77d97aa1ac4c66688cd2b2470431fe2c8df6 — 1,068,535,709,534,661,246,976 tokens (0.18% of circulating supply)

Top 10 Total Balance: 177,151,685,001,657,503,580,160 tokens
Top 10 Share of Circulating Supply: 29.65%
Top 10 Share of Total Supply: 17.72%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $6,648,542,466,414,558.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (7.4501)
Total supply of LP tokens: 10.006524333640101
LP holders count: 3

Liquidity holders for 0x488042a0a2941D7Ae5d748Ef1718A5463b83d017, (DynamiteBOOM)

0xaa3d85ad9d128dfecb55424085754f6dfa643eb1 holds 10.0 LP tokens

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 0.006524333640100267 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1545.46 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-12T01:10:46
Last Active: 2025-07-19T00:45:36
Days Since Last Activity: 16.48165002505787 days
Last Transaction Hash: 0x11746af2e504af5a228f4a8cfc615459841bb6e9f7c04b8c29e097c97a06e385
