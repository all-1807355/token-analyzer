Token Analysis Report
==================================================
Token: Transhuman Coin (0x56083560594E314b5cDd1680eC6a493bb851BBd8)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is still locked");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcluded[account], "account is already excluded");

        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcluded[account], "account is already excluded");

        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcluded[account], "account is already excluded");

        if (_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcluded[account], "account is already excluded");

        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");

        (, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();
        (uint256 ramount,,) = _getrvalues(tamount, tfee, tliquidity, currentrate);

        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal         = _rtotal.sub(ramount);
        _tfeetotal      = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        (, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();

        if (!deducttransferfee) {
            (uint256 ramount,,) = _getrvalues(tamount, tfee, tliquidity, currentrate);
            return ramount;

        } else {
            (, uint256 rtransferamount,) = _getrvalues(tamount, tfee, tliquidity, currentrate);
            return rtransferamount;
        }
    }

  Code Snippet:
    function setexcludedfromfee(address account, bool e) external onlyowner {
        _isexcludedfromfee[account] = e;
    }

  Code Snippet:
    function settaxfeepercent(uint256 taxfee) external onlyowner {
        _taxfee = taxfee;
    }

  Code Snippet:
    function setliquidityfeepercent(uint256 liquidityfee) external onlyowner {
        _liquidityfee = liquidityfee;
    }

  Code Snippet:
    function setpercentageofliquidityformarketing(uint256 marketingfee) external onlyowner {
        _percentageofliquidityformarketing = marketingfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool e) public onlyowner {
        _swapandliquifyenabled = e;
        emit swapandliquifyenabledupdated(e);
    }

  Code Snippet:
    function setuniswaprouter(address r) external onlyowner {
        iuniswapv2router02 uniswapv2router = iuniswapv2router02(r);
        _uniswapv2router = uniswapv2router;
    }

  Code Snippet:
    function setuniswappair(address p) external onlyowner {
        _uniswapv2pair = p;
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal    = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee       = calculatefee(tamount, _taxfee);
        uint256 tliquidity = calculatefee(tamount, _liquidityfee);
        uint256 ttransferamount = tamount.sub(tfee);
        ttransferamount = ttransferamount.sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount    = tamount.mul(currentrate);
        uint256 rfee       = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee);
        rtransferamount = rtransferamount.sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function taketransactionfee(address to, uint256 tamount, uint256 currentrate) private {
        if (tamount <= 0) { return; }

        uint256 ramount = tamount.mul(currentrate);
        _rowned[to] = _rowned[to].add(ramount);
        if (_isexcluded[to]) {
            _towned[to] = _towned[to].add(tamount);
        }
    }

  Code Snippet:
    function calculatefee(uint256 amount, uint256 fee) private pure returns (uint256) {
        return amount.mul(fee).div(100);
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        // split contract balance into halves
        uint256 half      = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);

        /*
            capture the contract's current bnb balance.
            this is so that we can capture exactly the amount of bnb that
            the swap creates, and not make the liquidity event include any bnb
            that has been manually sent to the contract.
        */
        uint256 initialbalance = address(this).balance;

        // swap tokens for bnb
        swaptokensforbnb(half);

        // this is the amount of bnb that we just swapped into
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // take marketing fee
        uint256 marketingfee          = newbalance.mul(_percentageofliquidityformarketing).div(100);
        uint256 bnbforliquidity = newbalance.sub(marketingfee);
        if (marketingfee > 0) {
            payable(_marketingwallet).transfer(marketingfee);
            emit marketingfeesent(_marketingwallet, marketingfee);
        }

        // add liquidity to uniswap
        addliquidity(otherhalf, bnbforliquidity);
        
        emit swapandliquify(half, bnbforliquidity, otherhalf);
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _uniswapv2router.weth();

        _approve(address(this), address(_uniswapv2router), tokenamount);

        // make the swap
        _uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of bnb
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(_uniswapv2router), tokenamount);

        // add the liquidity
        _uniswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee) private {
        uint256 previoustaxfee       = _taxfee;
        uint256 previousliquidityfee = _liquidityfee;
        
        if (!takefee) {
            _taxfee       = 0;
            _liquidityfee = 0;
        }
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);

        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);

        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);

        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);

        } else {
            _transferstandard(sender, recipient, amount);
        }
        
        if (!takefee) {
            _taxfee       = previoustaxfee;
            _liquidityfee = previousliquidityfee;
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, currentrate);

        _rowned[sender]    = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);

        taketransactionfee(address(this), tliquidity, currentrate);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, currentrate);

        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);

        taketransactionfee(address(this), tliquidity, currentrate);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, currentrate);

        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);

        taketransactionfee(address(this), tliquidity, currentrate);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        uint256 currentrate = _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, currentrate);

        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        
        taketransactionfee(address(this), tliquidity, currentrate);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x018fbdf1d7085781d321e8fbb25004c3dbfa1f9a
Owner Balance: 337,877,412,485,980,800 tokens
Owner Share: 4949145685.28% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 200
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x62be1533f3a78de99ca297ebbe489a3fb7253bef — 1,239,085,049,736,522,752 tokens (18142810172.45% of circulating supply)
  2. 0x7c83bc37831e815097f5d2c639d726f62cf73c24 — 376,508,215,823,152,512 tokens (5512871848.06% of circulating supply)
  3. 0x97ed77197994366daa3673f3e5d9ef57b568fb8b — 364,728,737,797,357,824 tokens (5340395524.67% of circulating supply)
  4. 0x44e57da2da8ecb435256745f8d217e234b9e0c73 — 345,761,051,556,704,000 tokens (5062668720.57% of circulating supply)
  5. 0x018fbdf1d7085781d321e8fbb25004c3dbfa1f9a — 337,877,412,485,980,800 tokens (4947235670.06% of circulating supply)
  6. 0x8c37466cd0a234f8daaa5d46ece46722b5f96f37 — 244,198,819,063,908,224 tokens (3575584113.10% of circulating supply)
  7. 0xb9f32f8d9e228ea66ec3cdf5a80ec0120378cb5c — 142,138,819,745,152,752 tokens (2081211152.79% of circulating supply)
  8. 0x2d6a87b8fa5b1124fd576783418bd5c644a68c43 — 136,051,157,805,731,312 tokens (1992074983.34% of circulating supply)
  9. 0xe55f392e9a444ff26f2aab0433bbe22144df64b2 — 130,164,230,754,697,184 tokens (1905877994.68% of circulating supply)
  10. 0x95f5f30ea6df8b1fadb00ae9855b599479c1777c — 95,577,408,289,034,576 tokens (1399454198.67% of circulating supply)

Top 10 Total Balance: 3,412,090,903,058,241,936 tokens
Top 10 Share of Circulating Supply: 49960184378.39%
Top 10 Share of Total Supply: 48.74%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $573,414.92
Liquidity: $208,084.16
Liquidity/MCap Ratio: 0.3629
Token Volume: 677904.5047
USD Volume: 56.9169
24h Volume/Liquidity Ratio: 0.0003
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (4.8287)
Total supply of LP tokens: 11.786909306682347
LP holders count: 10

Liquidity holders for 0x56083560594E314b5cDd1680eC6a493bb851BBd8, (Transhuman Coin)

0x56083560594e314b5cdd1680ec6a493bb851bbd8 holds 9.068459580637017 LP tokens

0x8655e5c4d701186d16765d1cdcef6d5287e4679a holds 2.5787593916455243 LP tokens

0x17d7251a8a8d60ab74d7d2b2d20d2a0389871729 holds 0.09842888338348814 LP tokens

0x7e214f5f19ef8f3fec429d6f4cdd205a6681f413 holds 0.021046835330404884 LP tokens

0xb552cf92e761c8c71f8de52ed10b0df6dcfa24ff holds 0.010470357050110662 LP tokens

0xab3a41ac49260351e9db29b0715bd4b03818da4e holds 0.004243139226985409 LP tokens

0x634034b7ab8df86bd672769d5e9d67b83bd6e72a holds 0.002872354256252495 LP tokens

0xdb2786e08d9ab601446d3b92a5ba54cb25c78441 holds 0.001810860203548675 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000374937057892303 LP tokens

0xf23a37b339d9768c1e00b38235a0ea30ae2009de holds 0.000163220347424821 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1463.37 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-08-01T00:29:54
Last Active: 2025-08-03T08:54:33
Days Since Last Activity: 0.01574974173611111 days
Last Transaction Hash: 0xc6413a146779b2f3153c5e0a7533444268b5648d1ada87acdeed34e987fe1922
