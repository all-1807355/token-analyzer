Token Analysis Report
==================================================
Token: CHEEBS (0xE6c78F31e481b144df5e6e35dF8Be83F58769670)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // the easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        
        _owner = address(0);
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // the easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already included");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        uint trade_type = 0;
        bool takefee = true;
        bool overminimumtokenbalance = balanceof(address(this)) >= minimumtokensbeforeswap;
        require(from != address(0), "erc20: transfer from the zero address");
    // market status flag
        if(!marketactive) {
            require(premarketuser[from],"cannot trade before the market opening");
        }
    // normal transaction
        if(!isinternaltransaction) {
        // tx limits
            //buy
            if(automatedmarketmakerpairs[from]) {
                trade_type = 1;
                // limits
                if(!excludedfromfees[to]) {
                    // tx limit
                    if(limitbuys) {
                        require(amount <= maxbuytxamount, "maxbuytxamount limit exceeded");
                    }
                    if (maxwalletactive) {
                        require(balanceof(to) + amount <= maxwallet, "maxwallet limit exceeded");
                    }
                    
                    // multi-buy limit
                    if(blockmultibuys) {
                        require(marketactiveat + 3 < block.timestamp,"you cannot buy at launch.");
                        require(userlasttradedata[to].lastbuytime + buysecondslimit <= block.timestamp,"you cannot do multi-buy orders.");
                        userlasttradedata[to].lastbuytime = block.timestamp;
                    }
                }
            }
            //sell
            else if(automatedmarketmakerpairs[to]) {
                trade_type = 2;
                // marketing auto-bnb
                bool tm =  block.timestamp > starttime + timetowait;
                if (swapandliquifyenabled && balanceof(uniswapv2pair) > 0 && overminimumtokenbalance &&  tm) {
                    swapandliquify(minimumtokensbeforeswap);
                    starttime = block.timestamp;

                }
                // limits
                if(!excludedfromfees[from]) {
                    // tx limit
                    if(limitsells) {
                    require(amount <= maxselltxamount, "maxselltxamount limit exceeded");
                    
                    }
                }
            }
        }
        //if any account belongs to excludedfromfees account then remove the fee
        if(excludedfromfees[from] || excludedfromfees[to]){
            takefee = false;
        }
        // transfer tokens
        _tokentransfer(from,to,amount,takefee,trade_type);
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        excludedfromfees[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        excludedfromfees[account] = false;
    }

  Code Snippet:
    function setswap(bool swap) external onlyowner {
        swapbnbactive = swap;
    }

  Code Snippet:
    function setfees() private {
        buyfee = buyreflectionfee + buymarketingfee + buyteamfee + buybuybackfee;
        sellfee = sellreflectionfee + sellteamfee + sellmarketingfee + sellbuybackfee;
    }

  Code Snippet:
    function setreflectionfee(uint buy, uint sell) external onlyowner() {
        buyreflectionfee = buy;
        sellreflectionfee = sell;
        setfees();
    }

  Code Snippet:
    function setteamfee(uint buy, uint sell) external onlyowner() {
        buyteamfee = buy;
        sellteamfee = sell;
        setfees();
    }

  Code Snippet:
    function setmarketingfee(uint buy, uint sell) external onlyowner() {
        buymarketingfee = buy;
        sellmarketingfee = sell;
        setfees();
    }

  Code Snippet:
    function setbuybackfee(uint buy, uint sell) external onlyowner() {
        buybuybackfee = buy;
        sellbuybackfee = sell;
        setfees();
    }

  Code Snippet:
    function set_multipliersorterfee(uint mult) external onlyowner() {
        multipliersorterfee = mult;
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) {
        (ttransferamount, tfee, tteam, tmarketing, tbuyback) = _gettvalues(tamount);
        (ramount, rtransferamount, rfee) = _getrvalues(tamount, tfee, tteam, tmarketing, tbuyback, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tteam, tmarketing, tbuyback);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) {
        tfee = calculatereflectionfee(tamount);
        tteam = calculateteamfee(tamount);
        tmarketing = calculatemarketingfee(tamount);
        tbuyback = calculatebuybackfee(tamount);
        ttransferamount = tamount.sub(tfee).sub(tteam).sub(tmarketing).sub(tbuyback);
        return (ttransferamount, tfee, tteam, tmarketing, tbuyback);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rbuyback = tbuyback.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rteam = tteam.mul(currentrate);
        uint256 rmarketing = tmarketing.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rteam).sub(rmarketing).sub(rbuyback);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatereflectionfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_reflectionfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateteamfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_teamfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculatemarketingfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_marketingfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculatebuybackfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_buybackfee).div(
            10**2
        );
    }

  Code Snippet:
    function setoldfees() private {
        _oldreflectionfee = _reflectionfee;
        _oldteamfee = _teamfee;
        _oldmarketingfee = _marketingfee;
        _oldbuybackfee = _buybackfee;
    }

  Code Snippet:
    function shutdownfees() private {
        _reflectionfee = 0;
        _teamfee = 0;
        _marketingfee = 0;
        _buybackfee = 0;
    }

  Code Snippet:
    function setfeesbytype(uint tradetype) private {
        //buy
        if(tradetype == 1) {
            _reflectionfee = buyreflectionfee;
            _teamfee = buyteamfee;
            _marketingfee = buymarketingfee;
            _buybackfee = buybuybackfee;
        }
        //sell
        else if(tradetype == 2) {
            _reflectionfee = sellreflectionfee;
            _teamfee = sellteamfee;
            _marketingfee = sellmarketingfee;
            _buybackfee = sellbuybackfee;
        }
    }

  Code Snippet:
    function restorefees() private {
        _reflectionfee = _oldreflectionfee;
        _teamfee = _oldteamfee;
        _marketingfee = _oldmarketingfee;
        _buybackfee = _oldbuybackfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return excludedfromfees[account];
    }

  Code Snippet:
    function sendtowallet(uint amount) private { 
        uint256 marketing_part = (amount * (sellmarketingfee*multipliersorterfee)) / 100;
        uint256 team_part = (amount * (sellteamfee*multipliersorterfee)) / 100;
        uint256 buyback_part = (amount * (sellbuybackfee*multipliersorterfee)) /100;
        (bool success1, ) = payable(_marketingwalletaddress).call{value: marketing_part, gas: 30000}("");
        if(success1) {
            emit marketingcollected(marketing_part);
        }
        (bool success2, ) = payable(_teamwalletaddress).call{value: team_part, gas: 30000}("");
        if(success2) {
            emit teamcollected(team_part);
        }
        (bool success3, ) = payable(_buybackwalletaddress).call{value: buyback_part, gas: 30000}("");
        if(success3) {
            emit buybackcollected(buyback_part);
        }
    }

  Code Snippet:
    function swapandliquify(uint256 tokenntoswap) private fasttx {
        if(swapbnbactive) {
            swaptokensforeth(tokenntoswap);
        }
        uint256 newbalance = address(this).balance;
        if(movebnbtowallets) {
            sendtowallet(newbalance);
        }
    }

  Code Snippet:
    function setfeeaddresses(address _marketing, address _buyback, address _team) external onlyowner {
        _marketingwalletaddress =_marketing;
        _buybackwalletaddress = _buyback;
        _teamwalletaddress = _team;
    }

  Code Snippet:
    function setswapandliquify(bool _state, uint _minimumtokensbeforeswap) external onlyowner {
        swapandliquifyenabled = _state;
        minimumtokensbeforeswap = _minimumtokensbeforeswap;
    }

  Code Snippet:
    function editexcludedfromfees(address _target, bool _status) external onlyowner {
        excludedfromfees[_target] = _status;
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        uint trade_type = 0;
        bool takefee = true;
        bool overminimumtokenbalance = balanceof(address(this)) >= minimumtokensbeforeswap;
        require(from != address(0), "erc20: transfer from the zero address");
    // market status flag
        if(!marketactive) {
            require(premarketuser[from],"cannot trade before the market opening");
        }
    // normal transaction
        if(!isinternaltransaction) {
        // tx limits
            //buy
            if(automatedmarketmakerpairs[from]) {
                trade_type = 1;
                // limits
                if(!excludedfromfees[to]) {
                    // tx limit
                    if(limitbuys) {
                        require(amount <= maxbuytxamount, "maxbuytxamount limit exceeded");
                    }
                    if (maxwalletactive) {
                        require(balanceof(to) + amount <= maxwallet, "maxwallet limit exceeded");
                    }
                    
                    // multi-buy limit
                    if(blockmultibuys) {
                        require(marketactiveat + 3 < block.timestamp,"you cannot buy at launch.");
                        require(userlasttradedata[to].lastbuytime + buysecondslimit <= block.timestamp,"you cannot do multi-buy orders.");
                        userlasttradedata[to].lastbuytime = block.timestamp;
                    }
                }
            }
            //sell
            else if(automatedmarketmakerpairs[to]) {
                trade_type = 2;
                // marketing auto-bnb
                bool tm =  block.timestamp > starttime + timetowait;
                if (swapandliquifyenabled && balanceof(uniswapv2pair) > 0 && overminimumtokenbalance &&  tm) {
                    swapandliquify(minimumtokensbeforeswap);
                    starttime = block.timestamp;

                }
                // limits
                if(!excludedfromfees[from]) {
                    // tx limit
                    if(limitsells) {
                    require(amount <= maxselltxamount, "maxselltxamount limit exceeded");
                    
                    }
                }
            }
        }
        //if any account belongs to excludedfromfees account then remove the fee
        if(excludedfromfees[from] || excludedfromfees[to]){
            takefee = false;
        }
        // transfer tokens
        _tokentransfer(from,to,amount,takefee,trade_type);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount,bool takefee, uint tradetype) private checkdisablefees(takefee,tradetype) {
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, amount);
        } else if (!_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferstandard(sender, recipient, amount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, amount);
        } else {
            _transferstandard(sender, recipient, amount);
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takebuyback(tbuyback);
        _taketeam(tteam);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);  
        _takebuyback(tbuyback);
        _taketeam(tteam);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount); 
        _takebuyback(tbuyback);
        _taketeam(tteam);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tteam, uint256 tmarketing, uint256 tbuyback) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takebuyback(tbuyback);
        _taketeam(tteam);
        _takemarketing(tmarketing);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x3ebe9c411fbfb825f3e0bd0dbdf1e268443ff515
Owner Balance: 71,627,110,522,194,919,424 tokens
Owner Share: 81.26% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x3ebe9c411fbfb825f3e0bd0dbdf1e268443ff515 — 71,627,110,522,194,919,424 tokens (81.25% of circulating supply)
  2. 0xc06cc281ce04bc6203f8becf93cc82e798fce7d5 — 538,585,944,581,678,400 tokens (0.61% of circulating supply)
  3. 0x3bd4ba2e0e2697dc3c1a1e48364b85b93452f802 — 459,671,520,076,960,640 tokens (0.52% of circulating supply)
  4. 0xfff76b65f0c22b45f670a200432e918ab9cab1c4 — 326,168,252,350,021,568 tokens (0.37% of circulating supply)
  5. 0x0580326fc73c46d76faf98569db52197ea9b5aa3 — 211,562,071,276,795,040 tokens (0.24% of circulating supply)
  6. 0xb3cda99926a1d4ba8f35a4bbce85008e12b50f7e — 146,398,461,018,606,784 tokens (0.17% of circulating supply)
  7. 0x0a5db6305e1a1b5c270df91eaf0bc4d67fbabe24 — 128,740,196,373,907,472 tokens (0.15% of circulating supply)
  8. 0x0ed943ce24baebf257488771759f9bf482c39706 — 106,843,909,548,379,136 tokens (0.12% of circulating supply)
  9. 0x25bc9777dd467c11ac0360fe91f0b60d2afb6405 — 106,304,404,178,038,272 tokens (0.12% of circulating supply)
  10. 0x5a8e9f6e565c3f25770a1b3dc3f059422b01cf6a — 100,000,000,000,000,000 tokens (0.11% of circulating supply)

Top 10 Total Balance: 73,751,385,281,599,306,736 tokens
Top 10 Share of Circulating Supply: 83.66%
Top 10 Share of Total Supply: 73.75%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $69,556,408,610,975,912.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.2374598529771618
LP holders count: 3

Liquidity holders for 0xE6c78F31e481b144df5e6e35dF8Be83F58769670, (CHEEBS)

Owner 0x3ebe9c411fbfb825f3e0bd0dbdf1e268443ff515 holds 0.2368900142564055 LP tokens
WARNING: Owner holds over 5% of the liquidity
0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000569838720755291 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------

Lifecycle Analysis
-------------
Token Age: 1265.34 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-02-15T01:03:31
Last Active: 2025-07-19T11:49:13
Days Since Last Activity: 14.889713765347222 days
Last Transaction Hash: 0xdc2cb58e98175847840234fea73672f82626379c6c7ebe2f2641a36948adcec3
