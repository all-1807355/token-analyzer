Token Analysis Report
==================================================
Token: CATCOIN (0x3E362283B86C1b45097CC3FB02213b79CF6211Df)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function settradingstatus(bool state) external onlyowner{
        tradingenabled = state;
        swapenabled = state;
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function settaxes(uint256 _rfi, uint256 _marketing, uint256 _liquidity, uint256 _burn) public onlyowner {
        require(_rfi + _marketing + _liquidity + _burn <= 35, "fees must be lower than 35%");
        taxes.rfi = _rfi;
        taxes.marketing = _marketing;
        taxes.liquidity = _liquidity;
        taxes.burn = _burn;
        emit feeschanged();
    }

  Code Snippet:
    function setbuytaxes(uint256 _rfi, uint256 _marketing, uint256 _liquidity, uint256 _burn) public onlyowner {
        require(_rfi + _marketing + _liquidity + _burn <= 35, "fees must be lower than 35%");
        buytaxes.rfi = _rfi;
        buytaxes.marketing = _marketing;
        buytaxes.liquidity = _liquidity;
        buytaxes.burn = _burn;
        emit feeschanged();
    }

  Code Snippet:
    function setselltaxes(uint256 _rfi, uint256 _marketing, uint256 _liquidity, uint256 _burn) public onlyowner {
        require(_rfi + _marketing + _liquidity + _burn <= 35, "fees must be lower than 35%");
        selltaxes.rfi = _rfi;
        selltaxes.marketing = _marketing;
        selltaxes.liquidity = _liquidity;
        selltaxes.burn = _burn;
        emit feeschanged();
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal -=rrfi;
        totfeespaid.rfi +=trfi;
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity, uint256 tliquidity) private {
        totfeespaid.liquidity +=tliquidity;

        if(_isexcluded[address(this)])
        {
            _towned[address(this)]+=tliquidity;
        }
        _rowned[address(this)] +=rliquidity;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        totfeespaid.marketing +=tmarketing;

        if(_isexcluded[marketingaddress])
        {
            _towned[marketingaddress]+=tmarketing;
        }
        _rowned[marketingaddress] +=rmarketing;
    }

  Code Snippet:
    function _takeburn(uint256 rburn, uint256 tburn) private{
        totfeespaid.burn +=tburn;

        if(_isexcluded[deadaddress])
        {
            _towned[deadaddress]+=tburn;
        }
        _rowned[deadaddress] +=rburn;
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee, uint8 category) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee, category);
        (to_return.ramount, to_return.rtransferamount, to_return.rrfi, to_return.rmarketing, to_return.rliquidity, to_return.rburn) = _getrvalues(to_return, tamount, takefee, _getrate());
        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee, uint8 category) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        taxes memory temp;
        if(category == 0) temp = selltaxes;
        else if(category == 1) temp = buytaxes;
        else temp = taxes;
        
        s.trfi = tamount*temp.rfi/100;
        s.tmarketing = tamount*temp.marketing/100;
        s.tliquidity = tamount*temp.liquidity/100;
        s.tburn = tamount*temp.burn/100;
        s.ttransferamount = tamount-s.trfi-s.tmarketing-s.tliquidity-s.tburn;
        return s;
    }

  Code Snippet:
    function _getrvalues(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi,uint256 rmarketing, uint256 rliquidity, uint256 rburn) {
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0,0);
        }

        rrfi = s.trfi*currentrate;
        rmarketing = s.tmarketing*currentrate;
        rliquidity = s.tliquidity*currentrate;
        rburn = s.rburn*currentrate;
        rtransferamount =  ramount-rrfi-rmarketing-rliquidity-rburn;
        return (ramount, rtransferamount, rrfi,rmarketing,rliquidity, rburn);
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isbot[from] && !_isbot[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading is not enabled yet");
            require(amount <= antiwhaleamt, "you are exceeding anti whale amount");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && from != pair){
            bool newcycle = block.timestamp - userlastsell[from].lastselltime >= antidumpcycle;
            if(!newcycle){
                require(userlastsell[from].amountsoldincycle + amount <= maxsellamountpercycle, "you are exceeding maxsellamountpercycle");
                userlastsell[from].amountsoldincycle += amount;
            }
            else{
                require(amount <= maxsellamountpercycle, "you are exceeding maxsellamountpercycle");
                userlastsell[from].amountsoldincycle = amount;
            }
            userlastsell[from].lastselltime = block.timestamp;
            
        }
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            swapandliquify(swaptokensatamount);
        }
        
        uint8 category;
        if(to == pair) category = 0; // 0 --> sell
        else if(from == pair) category = 1; // 1 --> buy
        else if(from != pair && to != pair) category = 2; // 2 --> transfer

        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]), category);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee, uint8 category) private {

        valuesfromgetvalues memory s = _getvalues(tamount, takefee, category);

        if (_isexcluded[sender] ) {  //from excluded
                _towned[sender] = _towned[sender]-tamount;
        }
        if (_isexcluded[recipient]) { //to excluded
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;
        
        if(s.rrfi > 0 || s.trfi > 0) _reflectrfi(s.rrfi, s.trfi);
        if(s.rliquidity > 0 || s.tliquidity > 0) {
            _takeliquidity(s.rliquidity,s.tliquidity);
            emit transfer(sender, address(this), s.tliquidity);
        }
        if(s.rmarketing > 0 || s.tmarketing > 0){
            _takemarketing(s.rmarketing, s.tmarketing);
            emit transfer(sender, marketingaddress, s.tmarketing);
        }
        if(s.rburn > 0 || s.tburn > 0){
            _takeburn(s.rburn, s.tburn);
            emit transfer(sender, deadaddress, s.tburn);
        }
        emit transfer(sender, recipient, s.ttransferamount);
        
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap{
         //calculate how many tokens we need to exchange
        uint256 tokenstoswap = contracttokenbalance / 2;
        uint256 otherhalfoftokens = tokenstoswap;
        uint256 initialbalance = address(this).balance;
        swaptokensforbnb(tokenstoswap, address(this));
        uint256 newbalance = address(this).balance - (initialbalance);
        addliquidity(otherhalfoftokens, newbalance);
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount, address recipient) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        _approve(address(this), address(router), tokenamount);

        // make the swap
        router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            payable(recipient),
            block.timestamp
        );
    }

  Code Snippet:
    function updatemarketingwallet(address newwallet) external onlyowner{
        require(marketingaddress != newwallet ,'wallet already set');
        marketingaddress = newwallet;
        _isexcludedfromfee[marketingaddress];
    }

  Code Snippet:
    function updateswaptokensatamount(uint256 amount) external onlyowner{
        swaptokensatamount = amount * 10**_decimals;
    }

  Code Snippet:
    function updateswapenabled(bool _enabled) external onlyowner{
        swapenabled = _enabled;
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function settradingstatus(bool state) external onlyowner{
        tradingenabled = state;
        swapenabled = state;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isbot[from] && !_isbot[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading is not enabled yet");
            require(amount <= antiwhaleamt, "you are exceeding anti whale amount");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && from != pair){
            bool newcycle = block.timestamp - userlastsell[from].lastselltime >= antidumpcycle;
            if(!newcycle){
                require(userlastsell[from].amountsoldincycle + amount <= maxsellamountpercycle, "you are exceeding maxsellamountpercycle");
                userlastsell[from].amountsoldincycle += amount;
            }
            else{
                require(amount <= maxsellamountpercycle, "you are exceeding maxsellamountpercycle");
                userlastsell[from].amountsoldincycle = amount;
            }
            userlastsell[from].lastselltime = block.timestamp;
            
        }
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            swapandliquify(swaptokensatamount);
        }
        
        uint8 category;
        if(to == pair) category = 0; // 0 --> sell
        else if(from == pair) category = 1; // 1 --> buy
        else if(from != pair && to != pair) category = 2; // 2 --> transfer

        _tokentransfer(from, to, amount, !(_isexcludedfromfee[from] || _isexcludedfromfee[to]), category);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x2c3b0b62c83b3885e7439d81dc0793db9d805fed
Owner Balance: 13,998,426,237,313,540,515,954,688 tokens
Owner Share: 14.73% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x2c3b0b62c83b3885e7439d81dc0793db9d805fed — 13,998,426,237,313,540,515,954,688 tokens (14.73% of circulating supply)
  2. 0x0e3391eadd7bf8d70e70749c1cf956927896834d — 2,872,736,429,461,397,814,902,784 tokens (3.02% of circulating supply)
  3. 0x965e8a9d57945b19c8a672e0de496528a21cedb4 — 2,800,072,465,402,038,623,141,888 tokens (2.95% of circulating supply)
  4. 0x09be49530d2b5d64992997909b994523ec16c60a — 2,689,715,757,088,484,079,173,632 tokens (2.83% of circulating supply)
  5. 0x285f9c5092628703773c8d17faee6ad2a435815f — 2,671,866,113,656,601,123,487,744 tokens (2.81% of circulating supply)
  6. 0x215b4eadf224335cebe28c75c95d3f4cca85ba3f — 2,655,784,281,599,795,982,761,984 tokens (2.80% of circulating supply)
  7. 0x0ab1dae1ecd0a74dcf1930f70191586bba5752a5 — 2,500,000,000,000,000,226,492,416 tokens (2.63% of circulating supply)
  8. 0x78eb284bc93121c96c0978f828af7d26462ba3e6 — 2,400,000,000,000,000,067,108,864 tokens (2.53% of circulating supply)
  9. 0xb15d124bc38a19d1024e7c0070fee989ace51279 — 2,299,999,999,999,999,907,725,312 tokens (2.42% of circulating supply)
  10. 0xecdbc703a6f3646ee9e5cd274d2e7c5f5bf6de79 — 2,216,924,579,103,486,383,226,880 tokens (2.33% of circulating supply)

Top 10 Total Balance: 37,105,525,863,625,344,723,976,192 tokens
Top 10 Share of Circulating Supply: 39.06%
Top 10 Share of Total Supply: 37.11%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $3,100,579,433,255,310,848.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (13.9984)
Total supply of LP tokens: 48.88544863515141
LP holders count: 6

Liquidity holders for 0x3E362283B86C1b45097CC3FB02213b79CF6211Df, (CATCOIN)

0x38bd868ba1f183ea517b912de3ed534b35f8382f holds 22.336182114300133 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 18.229991373055572 LP tokens

0x56cc84072ab0501d607bcfce210c71b69394f76d holds 4.124946322185662 LP tokens

0x7634aa0d926abbcab6f37a666bc60953c9ec00dc holds 3.260190341593302 LP tokens

0x666218971e068c363d93b4f2ddf4d9254e8e0207 holds 0.9341384840167436 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1223.92 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-03-28T01:43:19
Last Active: 2025-07-26T20:46:11
Days Since Last Activity: 7.122755950694444 days
Last Transaction Hash: 0x6b0331e46531617e78456452ae5993889109c447e46bd6eced1d513273db2245
