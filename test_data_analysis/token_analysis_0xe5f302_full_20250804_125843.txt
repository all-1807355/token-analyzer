Token Analysis Report
==================================================
Token: May The 4th Be With You (0xe5f302a5AA259a7C4AF29F0F0951178277f6c07b)
Chain: ETH
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 taxamount=0;

        if (from != owner() && to != owner()) {
            taxamount = amount.mul((_buycount> _reducebuytaxat)? _finalbuytax: ((_buycount> _midbuytaxat)? _midbuytax: _initialbuytax)).div(1000);

            if (marketpair[from] && to != address(uniswapv2router) && ! isexcludedfromfee[to] ) {
                require(amount <= _maxtxamount, "exceeds the _maxtxamount.");
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");

                if (firstblock + 3  > block.number) {
                    require(!iscontract(to));
                }
                _buycount++;
            }

            if (!marketpair[to] && ! isexcludedfromfee[to]) {
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");
            }

            if(marketpair[to] && from!= address(this) ){
                taxamount = amount.mul((_buycount> _reduceselltaxat)? _finalselltax: ((_buycount> _midselltaxat)? _midselltax: _initialselltax)).div(1000);
            }

	    if (!marketpair[from] && !marketpair[to] && from!= address(this) ) {
                taxamount = 0;
            }

            uint256 contracttokenbalance = balanceof(address(this));
            if (caswitch && !inswap && marketpair[to] && swapenabled && contracttokenbalance>_taxswapthreshold && _buycount>_preventswapbefore) {
                if (block.number > lastsellblock) {
                    sellcount = 0;
                }
                require(sellcount < zx, "ca balance sell");
                swaptokensforeth(min(amount,min(contracttokenbalance,_maxtaxswap)));
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
                sellcount++;
                lastsellblock = block.number;
            }

            else if(!inswap && marketpair[to] && swapenabled && contracttokenbalance>_taxswapthreshold && _buycount>_preventswapbefore) {
                swaptokensforeth(min(amount,min(contracttokenbalance,_maxtaxswap)));
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
            }
        }

        if(taxamount>0){
          _balances[address(this)]=_balances[address(this)].add(taxamount);
          emit transfer(from, address(this),taxamount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxamount));
        emit transfer(from, to, amount.sub(taxamount));
    }

  Code Snippet:
    function enabletrading() external onlyowner() {
        require(!tradingopen,"trading is already open");
        uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
        marketpair[address(uniswapv2pair)] = true;
        isexcludedfromfee[address(uniswapv2pair)] = true;
        uniswapv2router.addliquidityeth{value: address(this).balance}(address(this),balanceof(address(this)),0,0,owner(),block.timestamp);
        ierc20(uniswapv2pair).approve(address(uniswapv2router), type(uint).max);
        swapenabled = true;
        tradingopen = true;
        firstblock = block.number;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        uint256 taxamount=0;

        if (from != owner() && to != owner()) {
            taxamount = amount.mul((_buycount> _reducebuytaxat)? _finalbuytax: ((_buycount> _midbuytaxat)? _midbuytax: _initialbuytax)).div(1000);

            if (marketpair[from] && to != address(uniswapv2router) && ! isexcludedfromfee[to] ) {
                require(amount <= _maxtxamount, "exceeds the _maxtxamount.");
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");

                if (firstblock + 3  > block.number) {
                    require(!iscontract(to));
                }
                _buycount++;
            }

            if (!marketpair[to] && ! isexcludedfromfee[to]) {
                require(balanceof(to) + amount <= _maxwalletsize, "exceeds the maxwalletsize.");
            }

            if(marketpair[to] && from!= address(this) ){
                taxamount = amount.mul((_buycount> _reduceselltaxat)? _finalselltax: ((_buycount> _midselltaxat)? _midselltax: _initialselltax)).div(1000);
            }

	    if (!marketpair[from] && !marketpair[to] && from!= address(this) ) {
                taxamount = 0;
            }

            uint256 contracttokenbalance = balanceof(address(this));
            if (caswitch && !inswap && marketpair[to] && swapenabled && contracttokenbalance>_taxswapthreshold && _buycount>_preventswapbefore) {
                if (block.number > lastsellblock) {
                    sellcount = 0;
                }
                require(sellcount < zx, "ca balance sell");
                swaptokensforeth(min(amount,min(contracttokenbalance,_maxtaxswap)));
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
                sellcount++;
                lastsellblock = block.number;
            }

            else if(!inswap && marketpair[to] && swapenabled && contracttokenbalance>_taxswapthreshold && _buycount>_preventswapbefore) {
                swaptokensforeth(min(amount,min(contracttokenbalance,_maxtaxswap)));
                uint256 contractethbalance = address(this).balance;
                if(contractethbalance > 0) {
                    sendethtofee(address(this).balance);
                }
            }
        }

        if(taxamount>0){
          _balances[address(this)]=_balances[address(this)].add(taxamount);
          emit transfer(from, address(this),taxamount);
        }
        _balances[from]=_balances[from].sub(amount);
        _balances[to]=_balances[to].add(amount.sub(taxamount));
        emit transfer(from, to, amount.sub(taxamount));
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private locktheswap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function sendethtofee(uint256 amount) private {
        _taxwallet.transfer(amount);
    }

  Code Snippet:
    function enabletrading() external onlyowner() {
        require(!tradingopen,"trading is already open");
        uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
        marketpair[address(uniswapv2pair)] = true;
        isexcludedfromfee[address(uniswapv2pair)] = true;
        uniswapv2router.addliquidityeth{value: address(this).balance}(address(this),balanceof(address(this)),0,0,owner(),block.timestamp);
        ierc20(uniswapv2pair).approve(address(uniswapv2router), type(uint).max);
        swapenabled = true;
        tradingopen = true;
        firstblock = block.number;
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function enabletrading() external onlyowner() {
        require(!tradingopen,"trading is already open");
        uniswapv2router = iuniswapv2router02(0x7a250d5630b4cf539739df2c5dacb4c659f2488d);
        _approve(address(this), address(uniswapv2router), _ttotal);
        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(address(this), uniswapv2router.weth());
        marketpair[address(uniswapv2pair)] = true;
        isexcludedfromfee[address(uniswapv2pair)] = true;
        uniswapv2router.addliquidityeth{value: address(this).balance}(address(this),balanceof(address(this)),0,0,owner(),block.timestamp);
        ierc20(uniswapv2pair).approve(address(uniswapv2router), type(uint).max);
        swapenabled = true;
        tradingopen = true;
        firstblock = block.number;
    }


Holder Analysis
--------------
Total Unique Holders: 78
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x709e52fc6a779b6ff6c3532656cb3268a24fb948 — 313,387,283,441,999,157,395,456 tokens (74.49% of circulating supply)
  2. 0xe5cde7d4732b7645e82d4c767e1840c58a56c39a — 52,481,743,918,417,737,416,704 tokens (12.48% of circulating supply)
  3. 0x000000000000000000000000000000000000dead — 15,103,033,091,585,688,469,504 tokens (3.59% of circulating supply)
  4. 0x6ab7aa0ac99def0eade7e45893fa658f056a72ea — 11,507,207,287,223,145,725,952 tokens (2.74% of circulating supply)
  5. 0x24c29bb20b600e86f076724f82aed2e293f3e877 — 3,453,436,513,005,741,801,472 tokens (0.82% of circulating supply)
  6. 0x6950283f178810fc43bba6845a78e7510116e13e — 3,155,175,000,000,000,163,840 tokens (0.75% of circulating supply)
  7. 0xbf533f971a7079eb7a2ef5b0bd0ad9984aa1609e — 2,664,563,628,072,884,502,528 tokens (0.63% of circulating supply)
  8. 0xfc43611b73fbdbb262c9d522ce8f7647d2d2263a — 2,145,148,658,675,889,995,776 tokens (0.51% of circulating supply)
  9. 0x00000000a991c429ee2ec6df19d40fe0c80088b8 — 2,103,450,281,474,976,645,120 tokens (0.50% of circulating supply)
  10. 0x6757bfb286bce37b461cb07ce29bca19078a9fd4 — 2,093,587,195,518,214,209,536 tokens (0.50% of circulating supply)

Top 10 Total Balance: 408,094,629,015,973,436,325,888 tokens
Top 10 Share of Circulating Supply: 97.01%
Top 10 Share of Total Supply: 97.01%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $5,145,636,921,517,249,921,024.00
Liquidity: $7,666.34
Liquidity/MCap Ratio: 0.0000
Token Volume: 201492091478922.1562
USD Volume: 2464534800702.8291
24h Volume/Liquidity Ratio: 321474581.3325
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 561.7094444639506
LP holders count: 2

Liquidity holders for 0xe5f302a5AA259a7C4AF29F0F0951178277f6c07b, (May The 4th Be With You)

0x000000000000000000000000000000000000dead holds 561.7094444639506 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://www.maythe4th.vip/, Reason: metamask recovery phrase phishing
  URL: https://t.me/maythe4thcoin, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/Maythe4th__, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 456.77 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2024-05-04T18:27:11
Last Active: 2025-05-31T00:30:59
Days Since Last Activity: 65.51926199513889 days
Last Transaction Hash: 0xd5511d2ab00102b77f26f8314132de95d6e87290fa1d42a9fe3fcbf4ee41f4bd
