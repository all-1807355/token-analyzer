Token Analysis Report
==================================================
Token: BitFame (0xb1Baa71e4A8054342508Cb7241D51B1DcedCdAD1)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until some time passes");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function balanceof(address account) public view virtual override returns (uint256) {
        if (_isexcludedfromreward[account]) return _balances[account];
        return tokenfromreflection(_reflectbalances[account]);
    }

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "transfer from the zero address");
        require(recipient != address(0), "transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");


        (uint256 burnfee, uint256 reflectfee) = gettransferfee(sender, recipient);
        uint256 currentrate = _getrate();
        uint256 burntoken = ((amount*burnfee)/_granularity)/100;
        uint256 reflecttoken = ((amount*reflectfee)/_granularity)/100;

        _reflectbalances[sender] -= amount*currentrate;
        _reflectbalances[recipient] += ((amount-burntoken-reflecttoken)*currentrate);
        _reflectbalances[_burnaddress]+=burntoken*currentrate;
        if(_isexcludedfromreward[sender]) _balances[sender] -= amount ;
        if(_isexcludedfromreward[recipient]) _balances[recipient] += (amount-burntoken-reflecttoken);
        if(_isexcludedfromreward[_burnaddress]) _balances[_burnaddress] += burntoken;
        _reflectedtotal -= reflecttoken*currentrate;
        emit transfer(sender, recipient, amount-burntoken-reflecttoken);
        if (burntoken!=uint256(0)) emit transfer(sender, _burnaddress, burntoken);
    }

  Code Snippet:
    function _getcurrentsupply() private view returns(uint256, uint256) {
        uint256 reflectedsupply = _reflectedtotal;
        uint256 tokensupply = _tokentotal;      
        for (uint256 i = 0; i < _excludedfromreward.length; i++) {
            if (_reflectbalances[_excludedfromreward[i]] > reflectedsupply || _balances[_excludedfromreward[i]] > tokensupply) return (_reflectedtotal, _tokentotal);
            reflectedsupply -= _reflectbalances[_excludedfromreward[i]];
            tokensupply -= _balances[_excludedfromreward[i]];
        }
        if (reflectedsupply < (_reflectedtotal /_tokentotal) ) return (_reflectedtotal, _tokentotal);
        return (reflectedsupply, tokensupply);
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcludedfromreward[account], "account is already excluded");
        if(_reflectbalances[account] > 0) {
            _balances[account] = tokenfromreflection(_reflectbalances[account]);
        }
        _isexcludedfromreward[account] = true;
        _excludedfromreward.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcludedfromreward[account], "account is not excluded");
        for (uint256 i = 0; i < _excludedfromreward.length; i++) {
            if (_excludedfromreward[i] == account) {
                _excludedfromreward[i] = _excludedfromreward[_excludedfromreward.length - 1];
                _balances[account] = 0;
                _isexcludedfromreward[account] = false;
                _excludedfromreward.pop();
                break;
            }
        }
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns(bool){
        return _isexcludedfromreward[account];
    }

WARNING: Ownership Renounced
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // the easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function functioncallwithvalue(address target, bytes memory data, uint256 value, string memory errormessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "address: insufficient balance for call");
        require(iscontract(target), "address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functionstaticcall(address target, bytes memory data, string memory errormessage) internal view returns (bytes memory) {
        require(iscontract(target), "address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function functiondelegatecall(address target, bytes memory data, string memory errormessage) internal returns (bytes memory) {
        require(iscontract(target), "address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifycallresult(success, returndata, errormessage);
    }

  Code Snippet:
    function _verifycallresult(bool success, bytes memory returndata, string memory errormessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // the easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errormessage);
            }
        }
    }

  Code Snippet:
    function balanceof(address account) public view virtual override returns (uint256) {
        if (_isexcludedfromreward[account]) return _balances[account];
        return tokenfromreflection(_reflectbalances[account]);
    }

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "transfer from the zero address");
        require(recipient != address(0), "transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");


        (uint256 burnfee, uint256 reflectfee) = gettransferfee(sender, recipient);
        uint256 currentrate = _getrate();
        uint256 burntoken = ((amount*burnfee)/_granularity)/100;
        uint256 reflecttoken = ((amount*reflectfee)/_granularity)/100;

        _reflectbalances[sender] -= amount*currentrate;
        _reflectbalances[recipient] += ((amount-burntoken-reflecttoken)*currentrate);
        _reflectbalances[_burnaddress]+=burntoken*currentrate;
        if(_isexcludedfromreward[sender]) _balances[sender] -= amount ;
        if(_isexcludedfromreward[recipient]) _balances[recipient] += (amount-burntoken-reflecttoken);
        if(_isexcludedfromreward[_burnaddress]) _balances[_burnaddress] += burntoken;
        _reflectedtotal -= reflecttoken*currentrate;
        emit transfer(sender, recipient, amount-burntoken-reflecttoken);
        if (burntoken!=uint256(0)) emit transfer(sender, _burnaddress, burntoken);
    }

  Code Snippet:
    function _getcurrentsupply() private view returns(uint256, uint256) {
        uint256 reflectedsupply = _reflectedtotal;
        uint256 tokensupply = _tokentotal;      
        for (uint256 i = 0; i < _excludedfromreward.length; i++) {
            if (_reflectbalances[_excludedfromreward[i]] > reflectedsupply || _balances[_excludedfromreward[i]] > tokensupply) return (_reflectedtotal, _tokentotal);
            reflectedsupply -= _reflectbalances[_excludedfromreward[i]];
            tokensupply -= _balances[_excludedfromreward[i]];
        }
        if (reflectedsupply < (_reflectedtotal /_tokentotal) ) return (_reflectedtotal, _tokentotal);
        return (reflectedsupply, tokensupply);
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner {
        require(!_isexcludedfromreward[account], "account is already excluded");
        if(_reflectbalances[account] > 0) {
            _balances[account] = tokenfromreflection(_reflectbalances[account]);
        }
        _isexcludedfromreward[account] = true;
        _excludedfromreward.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcludedfromreward[account], "account is not excluded");
        for (uint256 i = 0; i < _excludedfromreward.length; i++) {
            if (_excludedfromreward[i] == account) {
                _excludedfromreward[i] = _excludedfromreward[_excludedfromreward.length - 1];
                _balances[account] = 0;
                _isexcludedfromreward[account] = false;
                _excludedfromreward.pop();
                break;
            }
        }
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns(bool){
        return _isexcludedfromreward[account];
    }

WARNING: High Tax Detected
  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "transfer from the zero address");
        require(recipient != address(0), "transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");


        (uint256 burnfee, uint256 reflectfee) = gettransferfee(sender, recipient);
        uint256 currentrate = _getrate();
        uint256 burntoken = ((amount*burnfee)/_granularity)/100;
        uint256 reflecttoken = ((amount*reflectfee)/_granularity)/100;

        _reflectbalances[sender] -= amount*currentrate;
        _reflectbalances[recipient] += ((amount-burntoken-reflecttoken)*currentrate);
        _reflectbalances[_burnaddress]+=burntoken*currentrate;
        if(_isexcludedfromreward[sender]) _balances[sender] -= amount ;
        if(_isexcludedfromreward[recipient]) _balances[recipient] += (amount-burntoken-reflecttoken);
        if(_isexcludedfromreward[_burnaddress]) _balances[_burnaddress] += burntoken;
        _reflectedtotal -= reflecttoken*currentrate;
        emit transfer(sender, recipient, amount-burntoken-reflecttoken);
        if (burntoken!=uint256(0)) emit transfer(sender, _burnaddress, burntoken);
    }

  Code Snippet:
    function gettransferfee(address sender, address recipient) private view returns (uint256, uint256){
        if (_disablefees || _isexcludedfromfee[sender] || _isexcludedfromfee[recipient] ){
            return (uint256(0),uint256(0));
        }
        uint256 burnfee = 600;
        uint256 reflectfee = 600;
        uint256 burnt = balanceof(_burnaddress);

        if ( burnt < _tokentotal/200 ){
            burnfee = 1000;
            reflectfee = 200;
        }else if ( burnt < _tokentotal/100 ){
            burnfee = 800;
            reflectfee = 400;
        }else if( burnt < _tokentotal/50 ){
            burnfee =  600;
            reflectfee = 600;
        }else if( burnt < _tokentotal/20 ){
            burnfee =  400;
            reflectfee = 800;
        }else{
            burnfee = 100;
            reflectfee = 1100;
        }
        
        return (burnfee,reflectfee);
    }

  Code Snippet:
    function excludefromfees(address account) public onlyowner{
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfees(address account) public onlyowner{
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function setfeesstate(bool _enabled) public onlyowner {
        _disablefees = _enabled;
    }

  Code Snippet:
    function getfeeinfo() public view returns(uint256,uint256){
        return (gettransferfee(_burnaddress, _burnaddress));
    }

  Code Snippet:
    function getfase() public view returns(string memory){
        (uint256 bf,) = gettransferfee(_burnaddress, _burnaddress);
        if (bf==uint256(1000)){
            return "p1";
        }else if(bf==uint256(800)){
            return "p2";
        }else if(bf==uint256(600)){
            return "p3";
        }else if(bf==uint256(400)){
            return "p4";
        }else if(bf==uint256(100)){
            return "p5";
        }else{
            return "p0";
        }
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool){
        return _isexcludedfromfee[account];
    }


Holder Analysis
--------------
Total Unique Holders: 124
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x37145570220e590e1bdbe41de0ed36f1d8baeefc
Owner Balance: 1,425,282,311 tokens
Owner Share: 29.74% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x000000000000000000000000000000000000dead — 2,267,335,889 tokens (47.31% of circulating supply)
  2. 0x37145570220e590e1bdbe41de0ed36f1d8baeefc — 1,425,282,311 tokens (29.74% of circulating supply)
  3. 0x9539cb7fc1d1e8e163c06dfa418fa7f998ee3c11 — 543,464,965 tokens (11.34% of circulating supply)
  4. 0xb545108f3ee074de830a21e09c6b9cce87b43edb — 147,809,388 tokens (3.08% of circulating supply)
  5. 0xe2968359b54ef9b991c301125e8e1061a86b70a6 — 132,243,764 tokens (2.76% of circulating supply)
  6. 0x7730f83ae618cd402f9f6c2d9f0851c74814e3fb — 21,254,586 tokens (0.44% of circulating supply)
  7. 0x93896e2466f4c59062ca860ef32679fd4db57564 — 9,410,770 tokens (0.20% of circulating supply)
  8. 0x8e10335fd9bc6d64986312610d44e2e63fa6ff91 — 8,584,570 tokens (0.18% of circulating supply)
  9. 0xe5d9409fe7210f53dd8ab3b116eb4142629db6a7 — 7,506,620 tokens (0.16% of circulating supply)
  10. 0xb143badf46de71fb34f900316107ea7dc621c985 — 2,584,848 tokens (0.05% of circulating supply)

Top 10 Total Balance: 4,565,477,711 tokens
Top 10 Share of Circulating Supply: 95.27%
Top 10 Share of Total Supply: 91.31%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,044,517,283.66
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (28.5056)
Total supply of LP tokens: 6.550976927e-09
LP holders count: 2

Liquidity holders for 0xb1Baa71e4A8054342508Cb7241D51B1DcedCdAD1, (BitFame)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 6.550975927e-09 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1549.91 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-07T00:17:20
Last Active: 2023-03-04T17:21:48
Days Since Last Activity: 883.1968071802314 days
Last Transaction Hash: 0x25c928293f9b90654e7997e77cf7dd1044bf9124a9d4a0a966d83cc5d25dbe17
