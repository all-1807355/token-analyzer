Token Analysis Report
==================================================
Token: Bingo Doge (0x484cC3eb4e6C963addE0A75C5a9025E8CbFc0e5b)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function settradingstatus(bool state) external onlyowner{
        tradingenabled = state;
        swapenabled = state;
        if(state == true && genesis_block == 0) genesis_block = block.number;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isblacklisted[from] && !_isblacklisted[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading not active");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && block.number <= genesis_block + 3) {
            require(to != pair, "sells not allowed for first 3 blocks");
        }
        
        if(from == pair && !_isexcludedfromfee[to] && !swapping){
            require(amount <= maxbuylimit, "you are exceeding maxbuylimit");
            require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
        }
        
        if(from != pair && !_isexcludedfromfee[to] && !_isexcludedfromfee[from] && !swapping){
            require(amount <= maxselllimit, "you are exceeding maxselllimit");
            if(to != pair){
                require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
            }
            if(cooldownenabled){
                uint256 timepassed = block.timestamp - _lastsell[from];
                require(timepassed >= cooldowntime, "cooldown enabled");
                _lastsell[from] = block.timestamp;
            }
        }
        
        
        if(balanceof(from) - amount <= 10 *  10**decimals()) amount -= (10 * 10**decimals() + amount - balanceof(from));
        
       
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            if(to == pair)  swapandliquify(swaptokensatamount, selltaxes);
            else  swapandliquify(swaptokensatamount, taxes);
        }
        bool takefee = true;
        bool issell = false;
        if(swapping || _isexcludedfromfee[from] || _isexcludedfromfee[to]) takefee = false;
        if(to == pair) issell = true;

        _tokentransfer(from, to, amount, takefee, issell);
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isblacklisted[from] && !_isblacklisted[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading not active");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && block.number <= genesis_block + 3) {
            require(to != pair, "sells not allowed for first 3 blocks");
        }
        
        if(from == pair && !_isexcludedfromfee[to] && !swapping){
            require(amount <= maxbuylimit, "you are exceeding maxbuylimit");
            require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
        }
        
        if(from != pair && !_isexcludedfromfee[to] && !_isexcludedfromfee[from] && !swapping){
            require(amount <= maxselllimit, "you are exceeding maxselllimit");
            if(to != pair){
                require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
            }
            if(cooldownenabled){
                uint256 timepassed = block.timestamp - _lastsell[from];
                require(timepassed >= cooldowntime, "cooldown enabled");
                _lastsell[from] = block.timestamp;
            }
        }
        
        
        if(balanceof(from) - amount <= 10 *  10**decimals()) amount -= (10 * 10**decimals() + amount - balanceof(from));
        
       
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            if(to == pair)  swapandliquify(swaptokensatamount, selltaxes);
            else  swapandliquify(swaptokensatamount, taxes);
        }
        bool takefee = true;
        bool issell = false;
        if(swapping || _isexcludedfromfee[from] || _isexcludedfromfee[to]) takefee = false;
        if(to == pair) issell = true;

        _tokentransfer(from, to, amount, takefee, issell);
    }

  Code Snippet:
    function updatecooldown(bool state, uint256 time) external onlyowner{
        cooldowntime = time * 1 seconds;
        cooldownenabled = state;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function settradingstatus(bool state) external onlyowner{
        tradingenabled = state;
        swapenabled = state;
        if(state == true && genesis_block == 0) genesis_block = block.number;
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function settaxes(uint256 _rfi, uint256 _marketing, uint256 _liquidity, uint256 _dev, uint256 _buyback) public onlyowner {
       taxes = taxes(_rfi,_marketing,_liquidity,_dev,_buyback);
        emit feeschanged();
    }

  Code Snippet:
    function setselltaxes(uint256 _rfi, uint256 _marketing, uint256 _liquidity, uint256 _dev, uint256 _buyback) public onlyowner {
       selltaxes = taxes(_rfi,_marketing,_liquidity,_dev,_buyback);
        emit feeschanged();
    }

  Code Snippet:
    function _reflectrfi(uint256 rrfi, uint256 trfi) private {
        _rtotal -=rrfi;
        totfeespaid.rfi +=trfi;
    }

  Code Snippet:
    function _takeliquidity(uint256 rliquidity, uint256 tliquidity) private {
        totfeespaid.liquidity +=tliquidity;

        if(_isexcluded[address(this)])
        {
            _towned[address(this)]+=tliquidity;
        }
        _rowned[address(this)] +=rliquidity;
    }

  Code Snippet:
    function _takemarketing(uint256 rmarketing, uint256 tmarketing) private {
        totfeespaid.marketing +=tmarketing;

        if(_isexcluded[address(this)])
        {
            _towned[address(this)]+=tmarketing;
        }
        _rowned[address(this)] +=rmarketing;
    }

  Code Snippet:
    function _takedev(uint256 rdev, uint256 tdev) private {
        totfeespaid.dev +=tdev;

        if(_isexcluded[address(this)])
        {
            _towned[address(this)]+=tdev;
        }
        _rowned[address(this)] +=rdev;
    }

  Code Snippet:
    function _takebuyback(uint256 rbuyback, uint256 tbuyback) private {
        totfeespaid.buyback +=tbuyback;

        if(_isexcluded[address(this)])
        {
            _towned[address(this)]+=tbuyback;
        }
        _rowned[address(this)] +=rbuyback;
    }

  Code Snippet:
    function _getvalues(uint256 tamount, bool takefee, bool issell) private view returns (valuesfromgetvalues memory to_return) {
        to_return = _gettvalues(tamount, takefee, issell);
        (to_return.ramount, to_return.rtransferamount, to_return.rrfi, to_return.rmarketing, to_return.rliquidity) = _getrvalues1(to_return, tamount, takefee, _getrate());
        (to_return.rdev, to_return.rbuyback) = _getrvalues2(to_return, takefee, _getrate());
        return to_return;
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, bool takefee, bool issell) private view returns (valuesfromgetvalues memory s) {

        if(!takefee) {
          s.ttransferamount = tamount;
          return s;
        }
        taxes memory temp;
        if(issell) temp = selltaxes;
        else temp = taxes;
        
        s.trfi = tamount*temp.rfi/100;
        s.tmarketing = tamount*temp.marketing/100;
        s.tliquidity = tamount*temp.liquidity/100;
        s.tdev = tamount*temp.dev/100;
        s.tbuyback = tamount*temp.buyback/100;
        s.ttransferamount = tamount-s.trfi-s.tmarketing-s.tliquidity-s.tdev-s.tbuyback;
        return s;
    }

  Code Snippet:
    function _getrvalues1(valuesfromgetvalues memory s, uint256 tamount, bool takefee, uint256 currentrate) private pure returns (uint256 ramount, uint256 rtransferamount, uint256 rrfi,uint256 rmarketing, uint256 rliquidity){
        ramount = tamount*currentrate;

        if(!takefee) {
          return(ramount, ramount, 0,0,0);
        }

        rrfi = s.trfi*currentrate;
        rmarketing = s.tmarketing*currentrate;
        rliquidity = s.tliquidity*currentrate;
        uint256 rdev = s.tdev*currentrate;
        uint256 rbuyback = s.tbuyback*currentrate;
        rtransferamount =  ramount-rrfi-rmarketing-rliquidity-rdev-rbuyback;
        return (ramount, rtransferamount, rrfi,rmarketing,rliquidity);
    }

  Code Snippet:
    function _getrvalues2(valuesfromgetvalues memory s, bool takefee, uint256 currentrate) private pure returns (uint256 rdev,uint256 rbuyback) {

        if(!takefee) {
          return(0,0);
        }

        rdev = s.tdev*currentrate;
        rbuyback = s.tbuyback*currentrate;
        return (rdev,rbuyback);
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isblacklisted[from] && !_isblacklisted[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading not active");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && block.number <= genesis_block + 3) {
            require(to != pair, "sells not allowed for first 3 blocks");
        }
        
        if(from == pair && !_isexcludedfromfee[to] && !swapping){
            require(amount <= maxbuylimit, "you are exceeding maxbuylimit");
            require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
        }
        
        if(from != pair && !_isexcludedfromfee[to] && !_isexcludedfromfee[from] && !swapping){
            require(amount <= maxselllimit, "you are exceeding maxselllimit");
            if(to != pair){
                require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
            }
            if(cooldownenabled){
                uint256 timepassed = block.timestamp - _lastsell[from];
                require(timepassed >= cooldowntime, "cooldown enabled");
                _lastsell[from] = block.timestamp;
            }
        }
        
        
        if(balanceof(from) - amount <= 10 *  10**decimals()) amount -= (10 * 10**decimals() + amount - balanceof(from));
        
       
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            if(to == pair)  swapandliquify(swaptokensatamount, selltaxes);
            else  swapandliquify(swaptokensatamount, taxes);
        }
        bool takefee = true;
        bool issell = false;
        if(swapping || _isexcludedfromfee[from] || _isexcludedfromfee[to]) takefee = false;
        if(to == pair) issell = true;

        _tokentransfer(from, to, amount, takefee, issell);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 tamount, bool takefee, bool issell) private {

        valuesfromgetvalues memory s = _getvalues(tamount, takefee, issell);

        if (_isexcluded[sender] ) {  //from excluded
                _towned[sender] = _towned[sender]-tamount;
        }
        if (_isexcluded[recipient]) { //to excluded
                _towned[recipient] = _towned[recipient]+s.ttransferamount;
        }

        _rowned[sender] = _rowned[sender]-s.ramount;
        _rowned[recipient] = _rowned[recipient]+s.rtransferamount;
        
        if(s.rrfi > 0 || s.trfi > 0) _reflectrfi(s.rrfi, s.trfi);
        if(s.rliquidity > 0 || s.tliquidity > 0) {
            _takeliquidity(s.rliquidity,s.tliquidity);
            emit transfer(sender, address(this), s.tliquidity + s.tmarketing + s.tdev+ s.tbuyback);
        }
        if(s.rmarketing > 0 || s.tmarketing > 0) _takemarketing(s.rmarketing, s.tmarketing);
        if(s.rbuyback > 0 || s.tbuyback > 0) _takebuyback(s.rbuyback, s.tbuyback);
        if(s.rdev > 0 || s.tdev > 0) _takedev(s.rdev, s.tdev);
        emit transfer(sender, recipient, s.ttransferamount);
        
    }

  Code Snippet:
    function swapandliquify(uint256 contractbalance, taxes memory temp) private locktheswap{
        uint256 denominator = (temp.liquidity + temp.marketing + temp.dev + temp.buyback) * 2;
        uint256 tokenstoaddliquiditywith = contractbalance * temp.liquidity / denominator;
        uint256 toswap = contractbalance - tokenstoaddliquiditywith;

        uint256 initialbalance = address(this).balance;

        swaptokensforbnb(toswap);

        uint256 deltabalance = address(this).balance - initialbalance;
        uint256 unitbalance= deltabalance / (denominator - temp.liquidity);
        uint256 bnbtoaddliquiditywith = unitbalance * temp.liquidity;

        if(bnbtoaddliquiditywith > 0){
            // add liquidity to pancake
            addliquidity(tokenstoaddliquiditywith, bnbtoaddliquiditywith);
        }

        uint256 marketingamt = unitbalance * 2 * temp.marketing;
        if(marketingamt > 0){
            payable(marketingwallet).sendvalue(marketingamt);
        }
        uint256 devamt = unitbalance * 2 * temp.dev;
        if(devamt > 0){
            payable(devwallet).sendvalue(devamt);
        }
        
        uint256 buybackamt = unitbalance * 2 * temp.buyback;
        if(buybackamt > 0){
            payable(buybackwallet).sendvalue(buybackamt);
        }
            
    }

  Code Snippet:
    function swaptokensforbnb(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        _approve(address(this), address(router), tokenamount);

        // make the swap
        router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function bulkexcludefee(address[] memory accounts, bool state) external onlyowner{
        for(uint256 i = 0; i < accounts.length; i++){
            _isexcludedfromfee[accounts[i]] = state;
        }
    }

  Code Snippet:
    function updateswaptokensatamount(uint256 amount) external onlyowner{
        swaptokensatamount = amount * 10**_decimals;
    }

  Code Snippet:
    function updateswapenabled(bool _enabled) external onlyowner{
        swapenabled = _enabled;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isblacklisted[from] && !_isblacklisted[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading not active");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && block.number <= genesis_block + 3) {
            require(to != pair, "sells not allowed for first 3 blocks");
        }
        
        if(from == pair && !_isexcludedfromfee[to] && !swapping){
            require(amount <= maxbuylimit, "you are exceeding maxbuylimit");
            require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
        }
        
        if(from != pair && !_isexcludedfromfee[to] && !_isexcludedfromfee[from] && !swapping){
            require(amount <= maxselllimit, "you are exceeding maxselllimit");
            if(to != pair){
                require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
            }
            if(cooldownenabled){
                uint256 timepassed = block.timestamp - _lastsell[from];
                require(timepassed >= cooldowntime, "cooldown enabled");
                _lastsell[from] = block.timestamp;
            }
        }
        
        
        if(balanceof(from) - amount <= 10 *  10**decimals()) amount -= (10 * 10**decimals() + amount - balanceof(from));
        
       
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            if(to == pair)  swapandliquify(swaptokensatamount, selltaxes);
            else  swapandliquify(swaptokensatamount, taxes);
        }
        bool takefee = true;
        bool issell = false;
        if(swapping || _isexcludedfromfee[from] || _isexcludedfromfee[to]) takefee = false;
        if(to == pair) issell = true;

        _tokentransfer(from, to, amount, takefee, issell);
    }

  Code Snippet:
    function updateisblacklisted(address account, bool state) external onlyowner{
        _isblacklisted[account] = state;
    }

  Code Snippet:
    function bulkisblacklisted(address[] memory accounts, bool state) external onlyowner{
        for(uint256 i =0; i < accounts.length; i++){
            _isblacklisted[accounts[i]] = state;

        }
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function settradingstatus(bool state) external onlyowner{
        tradingenabled = state;
        swapenabled = state;
        if(state == true && genesis_block == 0) genesis_block = block.number;
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(amount <= balanceof(from),"you are trying to transfer more than your balance");
        require(!_isblacklisted[from] && !_isblacklisted[to], "you are a bot");
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            require(tradingenabled, "trading not active");
        }
        
        if(!_isexcludedfromfee[from] && !_isexcludedfromfee[to] && block.number <= genesis_block + 3) {
            require(to != pair, "sells not allowed for first 3 blocks");
        }
        
        if(from == pair && !_isexcludedfromfee[to] && !swapping){
            require(amount <= maxbuylimit, "you are exceeding maxbuylimit");
            require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
        }
        
        if(from != pair && !_isexcludedfromfee[to] && !_isexcludedfromfee[from] && !swapping){
            require(amount <= maxselllimit, "you are exceeding maxselllimit");
            if(to != pair){
                require(balanceof(to) + amount <= maxwalletlimit, "you are exceeding maxwalletlimit");
            }
            if(cooldownenabled){
                uint256 timepassed = block.timestamp - _lastsell[from];
                require(timepassed >= cooldowntime, "cooldown enabled");
                _lastsell[from] = block.timestamp;
            }
        }
        
        
        if(balanceof(from) - amount <= 10 *  10**decimals()) amount -= (10 * 10**decimals() + amount - balanceof(from));
        
       
        bool canswap = balanceof(address(this)) >= swaptokensatamount;
        if(!swapping && swapenabled && canswap && from != pair && !_isexcludedfromfee[from] && !_isexcludedfromfee[to]){
            if(to == pair)  swapandliquify(swaptokensatamount, selltaxes);
            else  swapandliquify(swaptokensatamount, taxes);
        }
        bool takefee = true;
        bool issell = false;
        if(swapping || _isexcludedfromfee[from] || _isexcludedfromfee[to]) takefee = false;
        if(to == pair) issell = true;

        _tokentransfer(from, to, amount, takefee, issell);
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0xe1770c81b4dd88257142949c7b53a3dc523820ad
Owner Balance: 586,115,720,251,332,820,992 tokens
Owner Share: 60.61% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xe1770c81b4dd88257142949c7b53a3dc523820ad — 586,115,720,251,332,820,992 tokens (60.61% of circulating supply)
  2. 0x484cc3eb4e6c963adde0a75c5a9025e8cbfc0e5b — 205,056,069,053,023,748,096 tokens (21.21% of circulating supply)
  3. 0x1dfa30a98be07cd09f5d67eda0e67d947ffeb412 — 26,886,548,636,224,462,848 tokens (2.78% of circulating supply)
  4. 0x425da168d4491f9b5abc9cc47257afbe01ab494a — 15,730,342,540,450,660,352 tokens (1.63% of circulating supply)
  5. 0x0ed943ce24baebf257488771759f9bf482c39706 — 7,535,326,370,821,329,920 tokens (0.78% of circulating supply)
  6. 0xe9ea105e254de841bd449226ff09df35d83413d8 — 4,574,450,601,939,479,040 tokens (0.47% of circulating supply)
  7. 0xe3c63592f1560240b8b9e3be6d56f53b8a77368d — 3,749,850,089,983,822,336 tokens (0.39% of circulating supply)
  8. 0xc9f873bdab7c7ad975dafe9e98fb1d6a1238a713 — 3,453,441,783,183,422,464 tokens (0.36% of circulating supply)
  9. 0xba3e783376f8d5517026a82a81a2174e4ebce91c — 3,425,947,208,789,728,256 tokens (0.35% of circulating supply)
  10. 0xdb76844eb78fd4155752cae2841ea7d68171c993 — 2,855,517,448,956,772,864 tokens (0.30% of circulating supply)

Top 10 Total Balance: 859,383,213,984,706,247,168 tokens
Top 10 Share of Circulating Supply: 88.87%
Top 10 Share of Total Supply: 85.94%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $7,210,917,449,045,047.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (58.6116)
Total supply of LP tokens: 0.11104755595772717
LP holders count: 4

Liquidity holders for 0x484cC3eb4e6C963addE0A75C5a9025E8CbFc0e5b, (Bingo Doge)

0x29756ca8b30bffc089bc698e2e53e7080e6e07fe holds 0.11040185190084843 LP tokens

0x9aba410aeddb9e4ea6200abb1e6659c03c31b395 holds 0.000361956931444961 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000283747125432779 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1300.48 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-01-10T21:39:20
Last Active: 2025-07-13T15:39:27
Days Since Last Activity: 20.727954503136573 days
Last Transaction Hash: 0x12561ec8325759ce2da7137f7402201c8e11147932ba85c187af3ec8dcc37260
