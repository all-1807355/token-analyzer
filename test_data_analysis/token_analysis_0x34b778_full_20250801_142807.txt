Token Analysis Report
==================================================
Token: Save Luna (0x34b778985CEC08b607aa8b1996d212e8f7380BA1)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
 function _withdrawdividendofuser(address payable user) internal returns (uint256) {
    uint256 _withdrawabledividend = withdrawabledividendof(user);
    if (_withdrawabledividend > 0) {
      withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
      emit dividendwithdrawn(user, _withdrawabledividend);
      bool success = ierc20(reward_token).transfer(user, _withdrawabledividend);

      if(!success) {
        withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
        return 0;
      }

      return _withdrawabledividend;
    }

    return 0;
  }

  Code Snippet:
  function _setbalance(address account, uint256 newbalance) internal {
    uint256 currentbalance = balanceof(account);

    if(newbalance > currentbalance) {
      uint256 mintamount = newbalance.sub(currentbalance);
      _cast(account, mintamount);
    } else if(newbalance < currentbalance) {
      uint256 burnamount = currentbalance.sub(newbalance);
      _burn(account, burnamount);
    }
  }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main contract.");
    }

  Code Snippet:
    function updateclaimwait(uint256 newclaimwait) external onlyowner {
        require(newclaimwait >= 3600 && newclaimwait <= 86400, "udaotoken_dividend_tracker: claimwait must be updated to between 1 and 24 hours");
        require(newclaimwait != claimwait, "udaotoken_dividend_tracker: cannot update claimwait to same value");
        emit claimwaitupdated(newclaimwait, claimwait);
        claimwait = newclaimwait;
    }

  Code Snippet:
    function canautoclaim(uint256 lastclaimtime) private view returns (bool) {
        if(lastclaimtime > block.timestamp)  {
            return false;
        }

        return block.timestamp.sub(lastclaimtime) >= claimwait;
    }

  Code Snippet:
    function process(uint256 gas) public returns (uint256, uint256, uint256) {
        uint256 numberoftokenholders = tokenholdersmap.keys.length;

        if(numberoftokenholders == 0) {
            return (0, 0, lastprocessedindex);
        }

        uint256 _lastprocessedindex = lastprocessedindex;

        uint256 gasused = 0;

        uint256 gasleft = gasleft();

        uint256 iterations = 0;
        uint256 claims = 0;

        while(gasused < gas && iterations < numberoftokenholders) {
            _lastprocessedindex++;

            if(_lastprocessedindex >= tokenholdersmap.keys.length) {
                _lastprocessedindex = 0;
            }

            address account = tokenholdersmap.keys[_lastprocessedindex];

            if(canautoclaim(lastclaimtimes[account])) {
                if(processaccount(payable(account), true)) {
                    claims++;
                }
            }

            iterations++;

            uint256 newgasleft = gasleft();

            if(gasleft > newgasleft) {
                gasused = gasused.add(gasleft.sub(newgasleft));
            }

            gasleft = newgasleft;
        }

        lastprocessedindex = _lastprocessedindex;

        return (iterations, claims, lastprocessedindex);
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);

        if(amount > 0) {
            lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
            return true;
        }

        return false;
    }

  Code Snippet:
    function updateclaimwait(uint256 claimwait) external onlyowner {
        dividendtracker.updateclaimwait(claimwait);
    }

  Code Snippet:
    function getclaimwait() external view returns(uint256) {
        return dividendtracker.claimwait();
    }

  Code Snippet:
    function processdividendtracker(uint256 gas) external {
        (uint256 iterations, uint256 claims, uint256 lastprocessedindex) = dividendtracker.process(gas);
        emit processeddividendtracker(iterations, claims, lastprocessedindex, false, gas, tx.origin);
    }

  Code Snippet:
    function claim() external {
        dividendtracker.processaccount(payable(msg.sender), false);
    }

  Code Snippet:
    function swapmanual() public onlyowner {
        uint256 contracttokenbalance = balanceof(address(this));
        require(contracttokenbalance > 0 , "token balance zero");
        swapping = true;
        if(amountliquidityfee > 0) swapandliquify(amountliquidityfee);
        if(amounttokenrewardsfee > 0) swapandsenddividends(amounttokenrewardsfee);
        if(amountmarketingfee > 0) swapandsendtofee(amountmarketingfee);
        swapping = false;
    }

  Code Snippet:
    function setbuytaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total buy fee is over 25%");
        buytokenrewardsfee = rewardsfee;
        buyliquidityfee = liquidity;
        buymarketingfee = marketingfee;
        buydeadfee = deadfee;

    }

  Code Snippet:
    function setseltaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total sel fee is over 25%");
        selltokenrewardsfee = rewardsfee;
        sellliquidityfee = liquidity;
        sellmarketingfee = marketingfee;
        selldeadfee = deadfee;
    }

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private  {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(address(this));
        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(initialcakebalance);
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
        amountmarketingfee = amountmarketingfee - tokens;
    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;
        _approve(address(this), address(uniswapv2router), tokenamount);
        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private{
        swaptokensforcake(tokens);
        amounttokenrewardsfee = amounttokenrewardsfee - tokens;
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(address(dividendtracker), dividends);
        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _transferownership(address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
 function _withdrawdividendofuser(address payable user) internal returns (uint256) {
    uint256 _withdrawabledividend = withdrawabledividendof(user);
    if (_withdrawabledividend > 0) {
      withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
      emit dividendwithdrawn(user, _withdrawabledividend);
      bool success = ierc20(reward_token).transfer(user, _withdrawabledividend);

      if(!success) {
        withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
        return 0;
      }

      return _withdrawabledividend;
    }

    return 0;
  }

  Code Snippet:
    function swapmanual() public onlyowner {
        uint256 contracttokenbalance = balanceof(address(this));
        require(contracttokenbalance > 0 , "token balance zero");
        swapping = true;
        if(amountliquidityfee > 0) swapandliquify(amountliquidityfee);
        if(amounttokenrewardsfee > 0) swapandsenddividends(amounttokenrewardsfee);
        if(amountmarketingfee > 0) swapandsendtofee(amountmarketingfee);
        swapping = false;
    }

  Code Snippet:
    function setbuytaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total buy fee is over 25%");
        buytokenrewardsfee = rewardsfee;
        buyliquidityfee = liquidity;
        buymarketingfee = marketingfee;
        buydeadfee = deadfee;

    }

  Code Snippet:
    function setseltaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total sel fee is over 25%");
        selltokenrewardsfee = rewardsfee;
        sellliquidityfee = liquidity;
        sellmarketingfee = marketingfee;
        selldeadfee = deadfee;
    }

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private  {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(address(this));
        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(initialcakebalance);
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
        amountmarketingfee = amountmarketingfee - tokens;
    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;
        _approve(address(this), address(uniswapv2router), tokenamount);
        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private{
        swaptokensforcake(tokens);
        amounttokenrewardsfee = amounttokenrewardsfee - tokens;
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(address(dividendtracker), dividends);
        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
  function withdrawdividend() external;


  Code Snippet:
  function withdrawabledividendof(address _owner) external view returns(uint256);


  Code Snippet:
  function withdrawndividendof(address _owner) external view returns(uint256);


  Code Snippet:
  function withdrawdividend() public virtual override {
    _withdrawdividendofuser(payable(msg.sender));
  }

  Code Snippet:
 function _withdrawdividendofuser(address payable user) internal returns (uint256) {
    uint256 _withdrawabledividend = withdrawabledividendof(user);
    if (_withdrawabledividend > 0) {
      withdrawndividends[user] = withdrawndividends[user].add(_withdrawabledividend);
      emit dividendwithdrawn(user, _withdrawabledividend);
      bool success = ierc20(reward_token).transfer(user, _withdrawabledividend);

      if(!success) {
        withdrawndividends[user] = withdrawndividends[user].sub(_withdrawabledividend);
        return 0;
      }

      return _withdrawabledividend;
    }

    return 0;
  }

  Code Snippet:
  function dividendof(address _owner) public view override returns(uint256) {
    return withdrawabledividendof(_owner);
  }

  Code Snippet:
  function withdrawabledividendof(address _owner) public view override returns(uint256) {
    return accumulativedividendof(_owner).sub(withdrawndividends[_owner]);
  }

  Code Snippet:
  function withdrawndividendof(address _owner) public view override returns(uint256) {
    return withdrawndividends[_owner];
  }

  Code Snippet:
    function withdrawdividend() public pure override {
        require(false, "dividend_tracker: withdrawdividend disabled. use the 'claim' function on the main contract.");
    }

  Code Snippet:
    function processaccount(address payable account, bool automatic) public onlyowner returns (bool) {
        uint256 amount = _withdrawdividendofuser(account);

        if(amount > 0) {
            lastclaimtimes[account] = block.timestamp;
            emit claim(account, amount, automatic);
            return true;
        }

        return false;
    }

  Code Snippet:
    function updateuniswapv2router(address newaddress) public onlyowner {
        require(newaddress != address(uniswapv2router), "the router already has that address");
        emit updateuniswapv2router(newaddress, address(uniswapv2router));
        uniswapv2router = iuniswapv2router02(newaddress);
        address _uniswapv2pair = iuniswapv2factory(uniswapv2router.factory())
            .createpair(address(this), uniswapv2router.weth());
        uniswapv2pair = _uniswapv2pair;
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        if(_isexcludedfromfees[account] != excluded){
            _isexcludedfromfees[account] = excluded;
            emit excludefromfees(account, excluded);
        }
    }

  Code Snippet:
    function excludemultipleaccountsfromfees(address[] calldata accounts, bool excluded) public onlyowner {
        for(uint256 i = 0; i < accounts.length; i++) {
            _isexcludedfromfees[accounts[i]] = excluded;
        }

        emit excludemultipleaccountsfromfees(accounts, excluded);
    }

  Code Snippet:
    function setautomatedmarketmakerpair(address pair, bool value) public onlyowner {
        require(pair != uniswapv2pair, "the pancakeswap pair cannot be removed from automatedmarketmakerpairs");
        _setautomatedmarketmakerpair(pair, value);
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns(bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function withdrawabledividendof(address account) public view returns(uint256) {
        return dividendtracker.withdrawabledividendof(account);
    }

  Code Snippet:
    function swapmanual() public onlyowner {
        uint256 contracttokenbalance = balanceof(address(this));
        require(contracttokenbalance > 0 , "token balance zero");
        swapping = true;
        if(amountliquidityfee > 0) swapandliquify(amountliquidityfee);
        if(amounttokenrewardsfee > 0) swapandsenddividends(amounttokenrewardsfee);
        if(amountmarketingfee > 0) swapandsendtofee(amountmarketingfee);
        swapping = false;
    }

  Code Snippet:
    function setswaptokensatamount(uint256 amount) public onlyowner {
        swaptokensatamount = amount;
    }

  Code Snippet:
    function setbuytaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total buy fee is over 25%");
        buytokenrewardsfee = rewardsfee;
        buyliquidityfee = liquidity;
        buymarketingfee = marketingfee;
        buydeadfee = deadfee;

    }

  Code Snippet:
    function setseltaxes(uint256 liquidity, uint256 rewardsfee, uint256 marketingfee, uint256 deadfee) external onlyowner {
        require(rewardsfee.add(liquidity).add(marketingfee).add(deadfee) <= 25, "total sel fee is over 25%");
        selltokenrewardsfee = rewardsfee;
        sellliquidityfee = liquidity;
        sellmarketingfee = marketingfee;
        selldeadfee = deadfee;
    }

  Code Snippet:
    function swapandsendtofee(uint256 tokens) private  {
        uint256 initialcakebalance = ierc20(rewardtoken).balanceof(address(this));
        swaptokensforcake(tokens);
        uint256 newbalance = (ierc20(rewardtoken).balanceof(address(this))).sub(initialcakebalance);
        ierc20(rewardtoken).transfer(_marketingwalletaddress, newbalance);
        amountmarketingfee = amountmarketingfee - tokens;
    }

  Code Snippet:
    function swapandliquify(uint256 tokens) private {
       // split the contract balance into halves
        uint256 half = tokens.div(2);
        uint256 otherhalf = tokens.sub(half);

        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        addliquidity(otherhalf, newbalance);
        amountliquidityfee = amountliquidityfee - tokens;
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );

    }

  Code Snippet:
    function swaptokensforcake(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = rewardtoken;
        _approve(address(this), address(uniswapv2router), tokenamount);
        // make the swap
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);
        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            _node,
            block.timestamp
        );

    }

  Code Snippet:
    function swapandsenddividends(uint256 tokens) private{
        swaptokensforcake(tokens);
        amounttokenrewardsfee = amounttokenrewardsfee - tokens;
        uint256 dividends = ierc20(rewardtoken).balanceof(address(this));
        bool success = ierc20(rewardtoken).transfer(address(dividendtracker), dividends);
        if (success) {
            dividendtracker.distributecakedividends(dividends);
            emit senddividends(tokens, dividends);
        }
    }


Holder Analysis
--------------
Total Unique Holders: 70
Owner Address: 0xa10cb5a262c964d98d755b173e823f1c47532a15
Owner Balance: 577,379,547,861,633,974,449,209,344 tokens
Owner Share: 58.14% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 4
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xa10cb5a262c964d98d755b173e823f1c47532a15 — 577,379,547,861,633,974,449,209,344 tokens (58.14% of circulating supply)
  2. 0x48a48d61f4a94a00c9c110b62402c84a383f3a15 — 178,851,981,696,340,344,252,137,472 tokens (18.01% of circulating supply)
  3. 0x8dda30e525711f6b74b39872edcf10e746f61259 — 100,000,000,000,000,004,764,729,344 tokens (10.07% of circulating supply)
  4. 0x8175732f812af3aff7cf5f73dfcf947c9eef279c — 55,797,185,482,191,212,411,617,280 tokens (5.62% of circulating supply)
  5. 0x8f5de61f216a1628a94dd6225af894ef48a86d77 — 23,520,160,348,788,571,961,819,136 tokens (2.37% of circulating supply)
  6. 0x34b778985cec08b607aa8b1996d212e8f7380ba1 — 15,085,214,558,361,297,205,854,208 tokens (1.52% of circulating supply)
  7. 0x0cda48c2e46cf3be681af1241ae189bda59ba5f4 — 15,030,408,850,168,266,480,418,816 tokens (1.51% of circulating supply)
  8. 0xe41c3e7b384bd581aa58d303ebc93866a003db67 — 7,902,435,200,000,000,121,634,816 tokens (0.80% of circulating supply)
  9. 0x821cdf92a45378ea9b32f35da0aa439cb998cdc0 — 4,002,248,800,879,999,767,805,952 tokens (0.40% of circulating supply)
  10. 0x6ef654892690896e82e41d625c2bde5a63f7f28c — 3,423,715,594,073,717,371,568,128 tokens (0.34% of circulating supply)

Top 10 Total Balance: 980,992,898,392,437,388,786,794,496 tokens
Top 10 Share of Circulating Supply: 98.77%
Top 10 Share of Total Supply: 98.10%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $13,357,785,589,472.87
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 164799016.1764
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.4607
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (57.738)
Total supply of LP tokens: 574.0358459878927
LP holders count: 3

Liquidity holders for 0x34b778985CEC08b607aa8b1996d212e8f7380BA1, (Save Luna)

0x51e46fddf884518d96ebea18023f7b2d0a82582a holds 555.7640993766598 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 18.271746611232896 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1174.76 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-05-14T20:14:05
Last Active: 2023-11-30T01:05:16
Days Since Last Activity: 610.5575371149885 days
Last Transaction Hash: 0x4bcfbca38a4665ffd6c3d198909d0b358d31978abc9323cd18e3a8422b43de31
