Token Analysis Report
==================================================
Token: SUPERPIXEL (0x736bCE9185dd74c544b8e3E873D26beB5E996Afe)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal isallow(sender, recipient) returns (bool) {
        require(!blacklist[sender], "address is blacklisted");

        if(inswap){ return _basictransfer(sender, recipient, amount); }
        
        checktxlimit(sender, amount);

        if(shouldswapback(recipient)){ 
            swapandliquify(swapthreshold); 
        }

        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = takefee(sender, recipient, amount);
        _balances[recipient] = _balances[recipient].add(amountreceived);

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function canswap() internal view returns (bool) {
        return msg.sender != pair && !inswap;
    }

  Code Snippet:
    function takefee(address sender, address recipient, uint256 amount) internal returns (uint256) {
        if (excludefee[sender] || excludefee[recipient]) return amount;

        uint256 feeamount = amount.mul(totalfee).div(feedenominator);
        if(recipient == pair) {
            uint256 extrafee = amount.mul(extrafeeonsell).div(feedenominator);
            feeamount = feeamount.add(extrafee);
        }
        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function shouldswapback(address recipient) internal view returns (bool) {
        return recipient == pair
        && !inswap
        && swapenabled
        && _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function swapandliquify(uint256 amount) private swapping {
        uint256 tfee = totalfee.sub(liquidityfee.div(2));

        uint256 swapamount = amount.mul(tfee).div(totalfee);
        uint256 liqamount = amount.sub(swapamount);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

            // swap tokens for eth
        swaptokensforeth(swapamount); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);
        // calculate liquidity
        uint256 amountbnbdev = (newbalance.mul(devfee)).div(tfee);
        uint256 amountliqbnb = newbalance.sub(amountbnbdev);

        payable(dev).call{value: amountbnbdev, gas: 30000}("");
        // add liquidity to uniswap
        addliquidity(liqamount, amountliqbnb);
        
        emit swapandliquify(swapamount, newbalance, liqamount);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.weth();

        approve(address(router), tokenamount);

        // make the swap
        try router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        ) {} catch error(string memory e) {
            emit swaptokenforethfailed(string(abi.encodepacked("swaptokenforethfailed failed with error ", e)));
        } catch {
            emit swaptokenforethfailed("swaptokenforethfailed failed without an error message from pancakeswap");
        }
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios

        approve(address(router), tokenamount);

        // add the liquidity
        try router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            address(this),
            block.timestamp.add(300)
        ){} catch error(string memory e) {
            emit addliquidityfailed(string(abi.encodepacked("addliquidityfailed failed with error ", e)));
        } catch {
            emit addliquidityfailed("addliquidityfailed failed without an error message from pancakeswap");
        }
    }

  Code Snippet:
    function setexcludefee(address holder, bool exempt) external onlyowner {
        excludefee[holder] = exempt;
    }

  Code Snippet:
    function setextrafeeonsell(uint256 _extrafee) external onlyowner {
        require(_extrafee <= feedenominator / 2);
        extrafeeonsell = _extrafee;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _devfee) external onlyowner {
        liquidityfee = _liquidityfee;
        devfee = _devfee;
        totalfee = _liquidityfee.add(_devfee);
        require(totalfee <= feedenominator / 4, "invalid fee");
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external onlyowner {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal isallow(sender, recipient) returns (bool) {
        require(!blacklist[sender], "address is blacklisted");

        if(inswap){ return _basictransfer(sender, recipient, amount); }
        
        checktxlimit(sender, amount);

        if(shouldswapback(recipient)){ 
            swapandliquify(swapthreshold); 
        }

        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = takefee(sender, recipient, amount);
        _balances[recipient] = _balances[recipient].add(amountreceived);

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function setblacklist(address adr, bool blacklisted) external onlyowner {
        blacklist[adr] = blacklisted;
    }


Holder Analysis
--------------
Total Unique Holders: 37
Owner Address: 0x95bddfc8e10e5a5b7d2c97c2384fd2bac9cfc17c
Owner Balance: 1,496,987,490,808,207 tokens
Owner Share: 7.22% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x81e0ef68e103ee65002d3cf766240ed1c070334d — 11,949,385,706,034,679 tokens (57.60% of circulating supply)
  2. 0x1aac2776291cc66f28c6ae00f04d14e840a15de5 — 6,145,599,176,429,617 tokens (29.62% of circulating supply)
  3. 0x95bddfc8e10e5a5b7d2c97c2384fd2bac9cfc17c — 1,496,987,490,808,207 tokens (7.22% of circulating supply)
  4. 0x736bce9185dd74c544b8e3e873d26beb5e996afe — 403,818,428,182,814 tokens (1.95% of circulating supply)
  5. 0xb42dad2aa2fb8e4c78d3162782adcefb8a25a70c — 86,193,424,742,806 tokens (0.42% of circulating supply)
  6. 0x69e8d28a0bc4f7578daf584f3b48bf621c0f7961 — 78,258,040,099,611 tokens (0.38% of circulating supply)
  7. 0x4c609cf1dc6fea09143933c489ceb5b5ac01b816 — 72,599,413,322,769 tokens (0.35% of circulating supply)
  8. 0x8b26184783f98634b7b1cb9be497440d7cf70f18 — 46,302,464,429,207 tokens (0.22% of circulating supply)
  9. 0x6da33963a12a4d426dc909fdea65ab48f179c234 — 42,505,119,861,097 tokens (0.20% of circulating supply)
  10. 0xb17fcb82208a2265752819bd886f9c17e7719051 — 35,293,021,846,762 tokens (0.17% of circulating supply)

Top 10 Total Balance: 20,356,942,285,757,569 tokens
Top 10 Share of Circulating Supply: 98.12%
Top 10 Share of Total Supply: 96.94%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $112,416,948,970,454,224.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 1.993454395023e-05
LP holders count: 3

Liquidity holders for 0x736bCE9185dd74c544b8e3E873D26beB5E996Afe, (SUPERPIXEL)

0x2afcdcb64dcc9774a634752ef2169d560dad7bc2 holds 1.9719965877882e-05 LP tokens

0xae335776201b2eec6c62483bbecbe55f3e973c2d holds 2.14578071348e-07 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1341.25 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-12-01T15:23:08
Last Active: 2025-07-27T21:44:01
Days Since Last Activity: 6.982357059918981 days
Last Transaction Hash: 0x143406016463a6cb9f96e87525b6a3a3f1545218315adde60ad842db5bdc67a1
