Token Analysis Report
==================================================
Token: 1MDB (0x14522E91d3B3FA38A3e5c08Dbabb36fCa6b705cc)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);       
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _ttotal = _ttotal.sub(tburn);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tburn) = _gettvalues(tamount, _taxfee, _burnfee);
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tburn, currentrate);
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tburn);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, uint256 taxfee, uint256 burnfee) private pure returns (uint256, uint256, uint256) {
        uint256 tfee = ((tamount.mul(taxfee)).div(100)).div(100);
        uint256 tburn = ((tamount.mul(burnfee)).div(100)).div(100);
        uint256 ttransferamount = tamount.sub(tfee).sub(tburn);
        return (ttransferamount, tfee, tburn);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tburn, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rburn = tburn.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rburn);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function _gettaxfee() public view returns(uint256) {
        return _taxfee;
    }

  Code Snippet:
    function _getburnfee() public view returns(uint256) {
        return _burnfee;
    }

  Code Snippet:
function _settaxfee(uint256 taxfee) external onlyowner() {
        require(taxfee <=260 ); //limit taxfee to 2.6%
        _taxfee = taxfee;
    }

  Code Snippet:
    function _setburnfee(uint256 burnfee) external onlyowner() {
        require(burnfee <=260 ); //limit burnfee to 2.6% 
        _burnfee = burnfee;
    }


Holder Analysis
--------------
Total Unique Holders: 111
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x6a501cab05330b9d781c95d449e358d0a8b592f7 — 1,397,758,865,941,589,504 tokens (71.82% of circulating supply)
  2. 0xaf5409fa1fa2262eb88e2f7d48b37a2aaa7647cc — 94,901,041,497,708,848 tokens (4.88% of circulating supply)
  3. 0x41f0ffa6f66c908354753b33c33debca77c12265 — 94,900,469,605,148,432 tokens (4.88% of circulating supply)
  4. 0x701c4d5435f7994f861cb9bb9b54c4275175bf5d — 94,900,363,239,588,800 tokens (4.88% of circulating supply)
  5. 0xc471249c33b3e7a3bebca551a20a1bd34eb60e39 — 39,084,495,730,065,264 tokens (2.01% of circulating supply)
  6. 0x6666c898d548da0c4f4e76bac36be9fad414fae2 — 17,054,723,252,114,164 tokens (0.88% of circulating supply)
  7. 0x43d4b4551bc9cd2f1770e5fc59b043043a80d167 — 15,110,220,311,612,284 tokens (0.78% of circulating supply)
  8. 0xbd4f4b54ac627ecda5c2b7542288760a470c54c9 — 14,232,773,072,074,282 tokens (0.73% of circulating supply)
  9. 0x62a546493b6ab44c8dd25f32c9af9fa3f9ec31fd — 11,370,420,812,386,980 tokens (0.58% of circulating supply)
  10. 0x3c1acf05c4dcc8ef94cf7ff48f64f5757aafb9db — 9,482,867,919,527,208 tokens (0.49% of circulating supply)

Top 10 Total Balance: 1,788,796,241,381,815,766 tokens
Top 10 Share of Circulating Supply: 91.91%
Top 10 Share of Total Supply: 89.77%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,214,790,250,704,679.50
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 80.1000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.8884826641159402
LP holders count: 4

Liquidity holders for 0x14522E91d3B3FA38A3e5c08Dbabb36fCa6b705cc, (1MDB)

0x000000000000000000000000000000000000dead holds 0.7116740827092122 LP tokens

0xf5a81a1ae35ac6d1771853932b56a61eb117d746 holds 0.17622940008564852 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.000579181321078479 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1537.79 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-05-18T16:14:47
Last Active: 2024-10-13T01:38:42
Days Since Last Activity: 294.40329319520833 days
Last Transaction Hash: 0xbb00934f04ddf9e21e7f966ff740c8a38ef722207f0263103e4fdd4120811f2c
