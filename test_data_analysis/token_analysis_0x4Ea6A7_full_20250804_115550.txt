Token Analysis Report
==================================================
Token: ROCK (0x4Ea6A743c1e2cFA1E15e1CD2db786B71CaaC1D7D)
Chain: ETH
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): No
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "erc20: mint to the zero address");

        _beforetokentransfer(address(0), account, amount);

        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer(address(0), account, amount);

        _aftertokentransfer(address(0), account, amount);
    }

  Code Snippet:
    function mint(address to) external returns (uint256 liquidity);


WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _transferownership(address(0));
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function enabletrading() external onlyowner {
        tradingactive = true;
        swapenabled = true;
        lastlpburntime = block.timestamp;
    }

WARNING: High Tax Detected
  Code Snippet:
    function feeto() external view returns (address);


  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeeto(address) external;


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swap(
        uint256 amount0out,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint256 amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function enabletrading() external onlyowner {
        tradingactive = true;
        swapenabled = true;
        lastlpburntime = block.timestamp;
    }

  Code Snippet:
    function updateswaptokensatamount(uint256 newamount)
        external

  Code Snippet:
    function updateswapenabled(bool enabled) external onlyowner {
        swapenabled = enabled;
    }

  Code Snippet:
    function updatebuyfees(
        uint256 _marketingfee,

  Code Snippet:
    function updatesellfees(
        uint256 _marketingfee,

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        _isexcludedfromfees[account] = excluded;
        emit excludefromfees(account, excluded);
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns (bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(uniswapv2router), tokenamount);

        // add the liquidity
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            deadaddress,
            block.timestamp
        );
    }

  Code Snippet:
    function swapback() private {
        uint256 contractbalance = balanceof(address(this));
        uint256 totaltokenstoswap = tokensforliquidity +
            tokensformarketing +
            tokensfordev;
        bool success;

        if (contractbalance == 0 || totaltokenstoswap == 0) {
            return;
        }

        if (contractbalance > swaptokensatamount * 20) {
            contractbalance = swaptokensatamount * 20;
        }

        // halve the amount of liquidity tokens
        uint256 liquiditytokens = (contractbalance * tokensforliquidity) /
            totaltokenstoswap /
            2;
        uint256 amounttoswapforeth = contractbalance.sub(liquiditytokens);

        uint256 initialethbalance = address(this).balance;

        swaptokensforeth(amounttoswapforeth);

        uint256 ethbalance = address(this).balance.sub(initialethbalance);

        uint256 ethformarketing = ethbalance.mul(tokensformarketing).div(
            totaltokenstoswap
        );
        uint256 ethfordev = ethbalance.mul(tokensfordev).div(totaltokenstoswap);

        uint256 ethforliquidity = ethbalance - ethformarketing - ethfordev;

        tokensforliquidity = 0;
        tokensformarketing = 0;
        tokensfordev = 0;

        (success, ) = address(developmentwallet).call{value: ethfordev}("");

        if (liquiditytokens > 0 && ethforliquidity > 0) {
            addliquidity(liquiditytokens, ethforliquidity);
            emit swapandliquify(
                amounttoswapforeth,
                ethforliquidity,
                tokensforliquidity
            );
        }

        (success, ) = address(marketingwallet).call{
            value: address(this).balance
        }("");
    }

  Code Snippet:
    function autoburnliquiditypairtokens() internal returns (bool) {
        lastlpburntime = block.timestamp;

        // get balance of liquidity pair
        uint256 liquiditypairbalance = this.balanceof(uniswapv2pair);

        // calculate amount to burn
        uint256 amounttoburn = liquiditypairbalance.mul(percentforlpburn).div(
            10000
        );

        // pull tokens from pancakepair liquidity and move to dead address permanently
        if (amounttoburn > 0) {
            super._transfer(uniswapv2pair, address(0xdead), amounttoburn);
        }

        //sync price since this is not in a swap transaction!
        iuniswapv2pair pair = iuniswapv2pair(uniswapv2pair);
        pair.sync();
        emit autonukelp();
        return true;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0xb6d39a1782697be088188d58ae8b48b540182a80
Owner Balance: 81,641,909,736,449,144,185,159,680 tokens
Owner Share: 81.64% of circulating supply
⚠️ Creator holds MORE than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xb6d39a1782697be088188d58ae8b48b540182a80 — 81,641,909,736,449,144,185,159,680 tokens (81.64% of circulating supply)
  2. 0xe6b5118a51ec131700d88f39b9acba24c953a53a — 2,119,799,628,836,283,711,750,144 tokens (2.12% of circulating supply)
  3. 0xc28efdb6ceec3444fedbf0ee161b3e8424fd6bcc — 1,196,641,257,412,992,375,455,744 tokens (1.20% of circulating supply)
  4. 0xd37719a79cc8b03ed5147271814460e7163a2a38 — 1,014,590,153,916,775,921,614,848 tokens (1.01% of circulating supply)
  5. 0xf54cbf4b5a58c822d2f78de5808ccc138ca7b906 — 975,352,084,064,456,218,247,168 tokens (0.98% of circulating supply)
  6. 0xb7d07a17d22e4f8d3d4d3e05d196827b0cda6267 — 400,345,995,180,944,098,590,720 tokens (0.40% of circulating supply)
  7. 0x000000d40b595b94918a28b27d1e2c66f43a51d3 — 371,122,011,321,268,652,998,656 tokens (0.37% of circulating supply)
  8. 0x445ded51691354289a10e06a32dbb8512b2ef974 — 332,057,751,217,247,581,372,416 tokens (0.33% of circulating supply)
  9. 0xb1908af2e4c2b43f9811f3c325810e16397ac445 — 296,938,272,333,342,372,265,984 tokens (0.30% of circulating supply)
  10. 0xa3f79d095774179b33d1896940b54037c0163859 — 270,021,216,887,453,800,988,672 tokens (0.27% of circulating supply)

Top 10 Total Balance: 88,618,778,107,619,908,918,444,032 tokens
Top 10 Share of Circulating Supply: 88.62%
Top 10 Share of Total Supply: 88.62%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $64,079,230,749,964,595,363,840.00
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 100.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (81.6419)
Total supply of LP tokens: 1e-15
LP holders count: 1

Liquidity holders for 0x4Ea6A743c1e2cFA1E15e1CD2db786B71CaaC1D7D, (ROCK)

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://twitter.com/EtherRock_ETH, Reason: metamask recovery phrase phishing
  URL: https://t.me/EtherROCKETH, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 790.15 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2023-06-06T08:18:47
Last Active: 2025-02-11T14:38:11
Days Since Last Activity: 173.88726514443286 days
Last Transaction Hash: 0x31fb1999744ed8595f53cae45d2481e509218cb4719fd5040186864f06f8da44
