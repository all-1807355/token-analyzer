Token Analysis Report
==================================================
Token: ROCKET (0x61D99Ac4e23a5F44c850245fCB24D06D42982a5C)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function minter() public view returns (address) {
        return _minter;
    }

  Code Snippet:
    function transfermintership(address newminter) public virtual onlyminter {
        require(newminter != address(0), "mintable: new minter is the zero address");
        emit mintershiptransferred(_minter, newminter);
        _minter = newminter;
    }

  Code Snippet:
    function mint(address _to, uint256 _amount) public onlyminter {
        _mint(_to, _amount);
    }

  Code Snippet:
    function _mint(address account, uint256 amount) private {
        require(account != address(0), "rocket: mint to the zero address");
        _totalsupply += amount;
        _balances[account] += amount;
        emit transfer(address(0), account, amount);
    }

  Code Snippet:
    function addpool(uint256 _allocpoint, ierc20 _staketoken, bool _update) public onlyowner {
        if(_update) {
            massupdatepools();
        }

        uint256 lastrewardblock = block.number > startblock ? block.number : startblock;
        totalallocpoint = totalallocpoint + _allocpoint;
        poolinfo.push(
            poolinfo({
                staketoken: _staketoken,
                allocpoint: _allocpoint,
                lastrewardblock: lastrewardblock,
                accrewardpershare: 0,
                depositedamount: 0
            })
        );
    }

  Code Snippet:
    function pendingrewards(uint256 _pid, address _user) external view returns (uint256) {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][_user];
        uint256 accrewardpershare = pool.accrewardpershare;
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(block.number > pool.lastrewardblock && stakesupply != 0) {
            uint256 multiplier = block.number - pool.lastrewardblock;
            uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
            accrewardpershare = accrewardpershare + ((reward * 1e12) / stakesupply);
        }
        return ((user.amount * accrewardpershare) / 1e12) - user.rewarddebt + user.pendingrewards;
    }

  Code Snippet:
    function updatepool(uint256 _pid) public {
        poolinfo storage pool = poolinfo[_pid];
        if(block.number <= pool.lastrewardblock) {
            return;
        }
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(stakesupply == 0) {
            pool.lastrewardblock = block.number;
            return;
        }
        uint256 multiplier = block.number - pool.lastrewardblock;
        uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
        rocket.mint(address(this), reward);
        pool.accrewardpershare = pool.accrewardpershare + ((reward * 1e12) / stakesupply);
        pool.lastrewardblock = block.number;
    }

  Code Snippet:
    function deposit(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(_amount > 0, "amount must be a positive number");
        updatepool(_pid);
        if(user.amount > 0) {
            uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
            if(pending > 0) {
                user.pendingrewards = user.pendingrewards + pending;
                if(_withdrawrewards) {
                    saferewardtransfer(msg.sender, user.pendingrewards);
                    emit claim(msg.sender, _pid, user.pendingrewards);
                    user.pendingrewards = 0;
                }
            }
        }
        if(_amount > 0) {
            pool.staketoken.safetransferfrom(address(msg.sender), address(this), _amount);
            user.amount = user.amount + _amount;
            pool.depositedamount = pool.depositedamount + _amount;
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit deposit(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function withdraw(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(user.amount >= _amount, "withdrawing more than your stake");
        updatepool(_pid);
        uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
        if(pending > 0) {
            user.pendingrewards = user.pendingrewards + pending;
            if(_withdrawrewards) {
                saferewardtransfer(msg.sender, user.pendingrewards);
                emit claim(msg.sender, _pid, user.pendingrewards);
                user.pendingrewards = 0;
            }
        }
        if(_amount > 0) {
            user.amount = user.amount - _amount;
            pool.depositedamount = pool.depositedamount - _amount;
            pool.staketoken.safetransfer(address(msg.sender), _amount);
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit withdraw(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function emergencywithdraw(uint256 _pid) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        pool.staketoken.safetransfer(address(msg.sender), user.amount);
        emit emergencywithdraw(msg.sender, _pid, user.amount);
        pool.depositedamount = pool.depositedamount - user.amount;
        user.amount = 0;
        user.rewarddebt = 0;
        user.pendingrewards = 0;
    }

  Code Snippet:
    function claim(uint256 _pid) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        updatepool(_pid);
        uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
        if(pending > 0 || user.pendingrewards > 0) {
            user.pendingrewards = user.pendingrewards + pending;
            saferewardtransfer(msg.sender, user.pendingrewards);
            emit claim(msg.sender, _pid, user.pendingrewards);
            user.pendingrewards = 0;
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
    }

  Code Snippet:
    function saferewardtransfer(address _to, uint256 _amount) internal {
        uint256 rewardbal = rocket.balanceof(address(this));
        if(_amount > rewardbal) {
            rocket.transfer(_to, rewardbal);
        } else {
            rocket.transfer(_to, _amount);
        }
    }

  Code Snippet:
    function setrewardperblock(uint256 _rewardperblock) public onlyowner {
        rewardperblock = _rewardperblock;      
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        _setowner(address(0));
    }

  Code Snippet:
    function _verifycallresult(
        bool success,

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function addpool(uint256 _allocpoint, ierc20 _staketoken, bool _update) public onlyowner {
        if(_update) {
            massupdatepools();
        }

        uint256 lastrewardblock = block.number > startblock ? block.number : startblock;
        totalallocpoint = totalallocpoint + _allocpoint;
        poolinfo.push(
            poolinfo({
                staketoken: _staketoken,
                allocpoint: _allocpoint,
                lastrewardblock: lastrewardblock,
                accrewardpershare: 0,
                depositedamount: 0
            })
        );
    }

  Code Snippet:
    function pendingrewards(uint256 _pid, address _user) external view returns (uint256) {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][_user];
        uint256 accrewardpershare = pool.accrewardpershare;
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(block.number > pool.lastrewardblock && stakesupply != 0) {
            uint256 multiplier = block.number - pool.lastrewardblock;
            uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
            accrewardpershare = accrewardpershare + ((reward * 1e12) / stakesupply);
        }
        return ((user.amount * accrewardpershare) / 1e12) - user.rewarddebt + user.pendingrewards;
    }

  Code Snippet:
    function updatepool(uint256 _pid) public {
        poolinfo storage pool = poolinfo[_pid];
        if(block.number <= pool.lastrewardblock) {
            return;
        }
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(stakesupply == 0) {
            pool.lastrewardblock = block.number;
            return;
        }
        uint256 multiplier = block.number - pool.lastrewardblock;
        uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
        rocket.mint(address(this), reward);
        pool.accrewardpershare = pool.accrewardpershare + ((reward * 1e12) / stakesupply);
        pool.lastrewardblock = block.number;
    }

  Code Snippet:
    function deposit(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(_amount > 0, "amount must be a positive number");
        updatepool(_pid);
        if(user.amount > 0) {
            uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
            if(pending > 0) {
                user.pendingrewards = user.pendingrewards + pending;
                if(_withdrawrewards) {
                    saferewardtransfer(msg.sender, user.pendingrewards);
                    emit claim(msg.sender, _pid, user.pendingrewards);
                    user.pendingrewards = 0;
                }
            }
        }
        if(_amount > 0) {
            pool.staketoken.safetransferfrom(address(msg.sender), address(this), _amount);
            user.amount = user.amount + _amount;
            pool.depositedamount = pool.depositedamount + _amount;
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit deposit(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function withdraw(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(user.amount >= _amount, "withdrawing more than your stake");
        updatepool(_pid);
        uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
        if(pending > 0) {
            user.pendingrewards = user.pendingrewards + pending;
            if(_withdrawrewards) {
                saferewardtransfer(msg.sender, user.pendingrewards);
                emit claim(msg.sender, _pid, user.pendingrewards);
                user.pendingrewards = 0;
            }
        }
        if(_amount > 0) {
            user.amount = user.amount - _amount;
            pool.depositedamount = pool.depositedamount - _amount;
            pool.staketoken.safetransfer(address(msg.sender), _amount);
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit withdraw(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function emergencywithdraw(uint256 _pid) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        pool.staketoken.safetransfer(address(msg.sender), user.amount);
        emit emergencywithdraw(msg.sender, _pid, user.amount);
        pool.depositedamount = pool.depositedamount - user.amount;
        user.amount = 0;
        user.rewarddebt = 0;
        user.pendingrewards = 0;
    }

  Code Snippet:
    function claim(uint256 _pid) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        updatepool(_pid);
        uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
        if(pending > 0 || user.pendingrewards > 0) {
            user.pendingrewards = user.pendingrewards + pending;
            saferewardtransfer(msg.sender, user.pendingrewards);
            emit claim(msg.sender, _pid, user.pendingrewards);
            user.pendingrewards = 0;
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
    }

  Code Snippet:
    function saferewardtransfer(address _to, uint256 _amount) internal {
        uint256 rewardbal = rocket.balanceof(address(this));
        if(_amount > rewardbal) {
            rocket.transfer(_to, rewardbal);
        } else {
            rocket.transfer(_to, _amount);
        }
    }

  Code Snippet:
    function setrewardperblock(uint256 _rewardperblock) public onlyowner {
        rewardperblock = _rewardperblock;      
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function addpool(uint256 _allocpoint, ierc20 _staketoken, bool _update) public onlyowner {
        if(_update) {
            massupdatepools();
        }

        uint256 lastrewardblock = block.number > startblock ? block.number : startblock;
        totalallocpoint = totalallocpoint + _allocpoint;
        poolinfo.push(
            poolinfo({
                staketoken: _staketoken,
                allocpoint: _allocpoint,
                lastrewardblock: lastrewardblock,
                accrewardpershare: 0,
                depositedamount: 0
            })
        );
    }

  Code Snippet:
    function pendingrewards(uint256 _pid, address _user) external view returns (uint256) {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][_user];
        uint256 accrewardpershare = pool.accrewardpershare;
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(block.number > pool.lastrewardblock && stakesupply != 0) {
            uint256 multiplier = block.number - pool.lastrewardblock;
            uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
            accrewardpershare = accrewardpershare + ((reward * 1e12) / stakesupply);
        }
        return ((user.amount * accrewardpershare) / 1e12) - user.rewarddebt + user.pendingrewards;
    }

  Code Snippet:
    function updatepool(uint256 _pid) public {
        poolinfo storage pool = poolinfo[_pid];
        if(block.number <= pool.lastrewardblock) {
            return;
        }
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(stakesupply == 0) {
            pool.lastrewardblock = block.number;
            return;
        }
        uint256 multiplier = block.number - pool.lastrewardblock;
        uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
        rocket.mint(address(this), reward);
        pool.accrewardpershare = pool.accrewardpershare + ((reward * 1e12) / stakesupply);
        pool.lastrewardblock = block.number;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function feetosetter() external view returns (address);


  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function _calloptionalreturn(ierc20 token, bytes memory data) private {
        // we need to perform a low level call here, to bypass solidity's return data size checking mechanism, since
        // we're implementing it ourselves. we use {address.functioncall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functioncall(data, "safeerc20: low-level call failed");
        if (returndata.length > 0) {
            // return data is optional
            require(abi.decode(returndata, (bool)), "safeerc20: erc20 operation did not succeed");
        }
    }

  Code Snippet:
    function setswapenabled(bool _enabled) external onlyowner {
        swapenabled = _enabled;
    }

  Code Snippet:
    function excludefromfees(address account, bool excluded) public onlyowner {
        _isexcludedfromfees[account] = excluded;
    }

  Code Snippet:
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "rocket: transfer from the zero address");
        require(recipient != address(0), "rocket: transfer to the zero address");

        if(antibotenabled) {
            pinkantibot.onpretransfercheck(sender, recipient, amount);
        }

        require(_balances[sender] >= amount, "rocket: transfer amount exceeds balance");

        // handle our swapping logic
        uint256 contracttokenbalance = balanceof(address(this));
        bool canswap = contracttokenbalance >= swaptokensatamount;
        if(swapenabled &&
          canswap &&
          !swapping &&
          sender != address(uniswapv2pair) &&   // no swap on remove liquidity step 1 or dex buy
          sender != address(uniswapv2router) && // no swap on remove liquidity step 2
          sender != owner() &&
          recipient != owner()
        ) {
            swapping = true;
            _executeswap(contracttokenbalance);
            lastswaptime = block.timestamp;
            swapping = false;
        }

        bool takefee;

        if(sender == address(uniswapv2pair) || recipient == address(uniswapv2pair)) {
            takefee = true;
        }

        if(_isexcludedfromfees[sender] || _isexcludedfromfees[recipient]) {
            takefee = false;
        }

        if(swapping || !taxenabled) {
            takefee = false;
        }

        if(takefee) {
            uint256 fees;
            // dex buy
            if(sender == address(uniswapv2pair) && recipient != address(uniswapv2router)) {
                fees = amount * buytotalfeebps / 10000;
            }
            // dex sell or add liquidity
            if(recipient == address(uniswapv2pair)) {
                fees = amount * selltotalfeebps / 10000;
            }
            if(fees > 0) {
                amount -= fees;
                _executetransfer(sender, address(this), fees);
            }
        }

        _executetransfer(sender, recipient, amount);
    }

  Code Snippet:
    function _executeswap(uint256 tokens) private {
        if(tokens <= 0) {
            return;
        }

        // calculate our overall fee split
        uint256 devfeebps;
        uint256 marketingfeebps;
        uint256 buybackfeebps;
        uint256 totalfeebps;

        if(address(devwallet) != address(0)) {
            devfeebps = buydevfeebps;
            totalfeebps = totalfeebps + devfeebps;
        }

        if(address(marketingwallet) != address(0)) {
            marketingfeebps = buymarketingfeebps + sellmarketingfeebps;
            totalfeebps = totalfeebps + marketingfeebps;
        }

        if(address(buybackwallet) != address(0)) {
            buybackfeebps = buybuybackfeebps + sellbuybackfeebps;
            totalfeebps = totalfeebps + buybackfeebps;
        }

        // if this fails, contract keeps moving
        swaptokensfornative(tokens);

        // skip transfering if we don't have enough bnb
        uint256 nativebalance = address(this).balance;
        if(nativebalance == 0 || nativebalance < swapnativeminimum) {
            return;
        }

        // calculate native bnb amounts
        uint256 nativedev = nativebalance * devfeebps / totalfeebps;
        uint256 nativemarketing = nativebalance * marketingfeebps / totalfeebps;
        uint256 nativebuyback = nativebalance - nativedev - nativemarketing;

        if(nativedev > 0) {
            payable(devwallet).transfer(nativedev);
        }
        if(nativemarketing > 0) {
            payable(marketingwallet).transfer(nativemarketing);
        }
        if(nativebuyback > 0) {
            payable(buybackwallet).transfer(nativebuyback);
        }
    } 

  Code Snippet:
    function swaptokensfornative(uint256 tokens) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        _approve(address(this), address(uniswapv2router), tokens);
        try uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokens,
            0, // accept any amount of native
            path,
            address(this),
            block.timestamp
        ) {
            // success
        } catch error(string memory /*err*/) {
            // failure
        }
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns (bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function addpool(uint256 _allocpoint, ierc20 _staketoken, bool _update) public onlyowner {
        if(_update) {
            massupdatepools();
        }

        uint256 lastrewardblock = block.number > startblock ? block.number : startblock;
        totalallocpoint = totalallocpoint + _allocpoint;
        poolinfo.push(
            poolinfo({
                staketoken: _staketoken,
                allocpoint: _allocpoint,
                lastrewardblock: lastrewardblock,
                accrewardpershare: 0,
                depositedamount: 0
            })
        );
    }

  Code Snippet:
    function pendingrewards(uint256 _pid, address _user) external view returns (uint256) {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][_user];
        uint256 accrewardpershare = pool.accrewardpershare;
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(block.number > pool.lastrewardblock && stakesupply != 0) {
            uint256 multiplier = block.number - pool.lastrewardblock;
            uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
            accrewardpershare = accrewardpershare + ((reward * 1e12) / stakesupply);
        }
        return ((user.amount * accrewardpershare) / 1e12) - user.rewarddebt + user.pendingrewards;
    }

  Code Snippet:
    function updatepool(uint256 _pid) public {
        poolinfo storage pool = poolinfo[_pid];
        if(block.number <= pool.lastrewardblock) {
            return;
        }
        uint256 stakesupply = pool.staketoken.balanceof(address(this));
        if(stakesupply == 0) {
            pool.lastrewardblock = block.number;
            return;
        }
        uint256 multiplier = block.number - pool.lastrewardblock;
        uint256 reward = ((multiplier * rewardperblock) * pool.allocpoint) / totalallocpoint;
        rocket.mint(address(this), reward);
        pool.accrewardpershare = pool.accrewardpershare + ((reward * 1e12) / stakesupply);
        pool.lastrewardblock = block.number;
    }

  Code Snippet:
    function deposit(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(_amount > 0, "amount must be a positive number");
        updatepool(_pid);
        if(user.amount > 0) {
            uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
            if(pending > 0) {
                user.pendingrewards = user.pendingrewards + pending;
                if(_withdrawrewards) {
                    saferewardtransfer(msg.sender, user.pendingrewards);
                    emit claim(msg.sender, _pid, user.pendingrewards);
                    user.pendingrewards = 0;
                }
            }
        }
        if(_amount > 0) {
            pool.staketoken.safetransferfrom(address(msg.sender), address(this), _amount);
            user.amount = user.amount + _amount;
            pool.depositedamount = pool.depositedamount + _amount;
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit deposit(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function withdraw(uint256 _pid, uint256 _amount, bool _withdrawrewards) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        require(user.amount >= _amount, "withdrawing more than your stake");
        updatepool(_pid);
        uint256 pending = ((user.amount * pool.accrewardpershare) / 1e12) - user.rewarddebt;
        if(pending > 0) {
            user.pendingrewards = user.pendingrewards + pending;
            if(_withdrawrewards) {
                saferewardtransfer(msg.sender, user.pendingrewards);
                emit claim(msg.sender, _pid, user.pendingrewards);
                user.pendingrewards = 0;
            }
        }
        if(_amount > 0) {
            user.amount = user.amount - _amount;
            pool.depositedamount = pool.depositedamount - _amount;
            pool.staketoken.safetransfer(address(msg.sender), _amount);
        }
        user.rewarddebt = (user.amount * pool.accrewardpershare) / 1e12;
        emit withdraw(msg.sender, _pid, _amount);
    }

  Code Snippet:
    function emergencywithdraw(uint256 _pid) public nonreentrant {
        poolinfo storage pool = poolinfo[_pid];
        userinfo storage user = userinfo[_pid][msg.sender];
        pool.staketoken.safetransfer(address(msg.sender), user.amount);
        emit emergencywithdraw(msg.sender, _pid, user.amount);
        pool.depositedamount = pool.depositedamount - user.amount;
        user.amount = 0;
        user.rewarddebt = 0;
        user.pendingrewards = 0;
    }


Holder Analysis
--------------
Total Unique Holders: 200
Owner Address: 0x182d79cc247aaac0ecdafb330719e6c3b58bd139
Owner Balance: 1,118,733,763,107,062,320,075,680,776,192 tokens
Owner Share: 39.33% of circulating supply
⚠️ Owner holds MORE than 5% of circulating supply
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 3
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x285fa9f2bfbf6428942504521e9478da75a75881 — 1,324,648,061,303,885,068,065,740,685,312 tokens (46.57% of circulating supply)
  2. 0x182d79cc247aaac0ecdafb330719e6c3b58bd139 — 1,118,733,763,107,062,320,075,680,776,192 tokens (39.33% of circulating supply)
  3. 0xf5f4628720bfd493c1f023ba3857efbaab84776a — 319,324,308,457,282,564,135,218,839,552 tokens (11.23% of circulating supply)
  4. 0x765ef7d3e1629d6034c8dbebc34a6e958b4237e4 — 4,440,009,830,000,000,215,254,302,720 tokens (0.16% of circulating supply)
  5. 0xeec8c2f15c76a44185e77e564b34ddd94dcc08f4 — 4,320,000,000,000,000,013,421,772,800 tokens (0.15% of circulating supply)
  6. 0xf2240c885a28128f18e41d4d33ecc3735e0f374e — 2,934,224,700,465,180,470,163,800,064 tokens (0.10% of circulating supply)
  7. 0x4931ccd9c29cd7a7af2a946b9926887c20d0b437 — 2,399,999,999,999,999,976,914,550,784 tokens (0.08% of circulating supply)
  8. 0x0f6622a4b001241d4c96916cfef6c322598d3c5d — 2,156,373,535,825,116,096,710,574,080 tokens (0.08% of circulating supply)
  9. 0x9db19705fc69681fa224306e5f54e14eea002df7 — 2,067,218,854,681,300,582,164,070,400 tokens (0.07% of circulating supply)
  10. 0x052f9af2d224260559ef76f0aed2147c9f56d5bf — 1,809,894,790,861,796,300,325,650,432 tokens (0.06% of circulating supply)

Top 10 Total Balance: 2,782,833,854,580,063,345,931,595,022,336 tokens
Top 10 Share of Circulating Supply: 97.83%
Top 10 Share of Total Supply: 97.75%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $420,866,470,292,300.75
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: False (39.2962)
Total supply of LP tokens: 103349.85807303853
LP holders count: 5

Liquidity holders for 0x61D99Ac4e23a5F44c850245fCB24D06D42982a5C, (ROCKET)

0x285fa9f2bfbf6428942504521e9478da75a75881 holds 102429.26823713083 LP tokens

0x9fff038339961c5655050a9a76d2c1498fcccc4b holds 636.6223605732363 LP tokens

0x143b8ee8dec95565be1ba6a2163f14aa63965cac holds 188.83106061542725 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 95.13641471904133 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing
  URL: https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-2200), Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1286.80 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2022-01-24T13:47:25
Last Active: 2025-07-15T20:43:49
Days Since Last Activity: 18.515453330925926 days
Last Transaction Hash: 0xafd23ae158cbfda0ae68c3868c35dfcf91bc339fba5723bc5aaa91283d51a198
