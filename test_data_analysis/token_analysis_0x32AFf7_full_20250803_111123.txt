Token Analysis Report
==================================================
Token: FlokiBro (0x32AFf736F1E855f0ddE6872A3F072B85315Ff431)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function transferowner(address newowner) external onlyowner() {
        require(newowner != address(0), "call renounceownership to transfer owner to the zero address.");
        require(newowner != dead, "call renounceownership to transfer owner to the zero address.");
        setexcludedfromfees(_owner, false);
        setexcludedfromfees(newowner, true);
        
        if (_marketingwallet == payable(_owner))
            _marketingwallet = payable(newowner);
        
        if(balanceof(_owner) > 0) {
            _transfer(_owner, newowner, balanceof(_owner));
        }
        
        _owner = newowner;
        emit ownershiptransferred(_owner, newowner);
        
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner() {
        setexcludedfromfees(_owner, false);
        _owner = address(0);
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Delayed Trading Detected
  Code Snippet:
    function enabletrading() public onlyowner {
        require(!tradingenabled, "trading already enabled!");
        require(_hasliqbeenadded, "liquidity must be added.");
        try antisnipe.setlaunch(lppair, uint32(block.number), uint64(block.timestamp)) {} catch {}
        tradingenabled = true;
    }

WARNING: High Tax Detected
  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
    external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function transferowner(address newowner) external onlyowner() {
        require(newowner != address(0), "call renounceownership to transfer owner to the zero address.");
        require(newowner != dead, "call renounceownership to transfer owner to the zero address.");
        setexcludedfromfees(_owner, false);
        setexcludedfromfees(newowner, true);
        
        if (_marketingwallet == payable(_owner))
            _marketingwallet = payable(newowner);
        
        if(balanceof(_owner) > 0) {
            _transfer(_owner, newowner, balanceof(_owner));
        }
        
        _owner = newowner;
        emit ownershiptransferred(_owner, newowner);
        
    }

  Code Snippet:
    function renounceownership() public virtual onlyowner() {
        setexcludedfromfees(_owner, false);
        _owner = address(0);
        emit ownershiptransferred(_owner, address(0));
    }

  Code Snippet:
    function setnewrouter(address newrouter) public onlyowner() {
        iuniswapv2router02 _newrouter = iuniswapv2router02(newrouter);
        address get_pair = iuniswapv2factory(_newrouter.factory()).getpair(address(this), _newrouter.weth());
        if (get_pair == address(0)) {
            lppair = iuniswapv2factory(_newrouter.factory()).createpair(address(this), _newrouter.weth());
        }
        else {
            lppair = get_pair;
        }
        dexrouter = _newrouter;
        _approve(address(this), address(dexrouter), type(uint256).max);
    }

  Code Snippet:
    function isexcludedfromfees(address account) public view returns(bool) {
        return _isexcludedfromfees[account];
    }

  Code Snippet:
    function setexcludedfromfees(address account, bool enabled) public onlyowner {
        _isexcludedfromfees[account] = enabled;
    }

  Code Snippet:
    function settaxes(uint16 buyfee, uint16 sellfee, uint16 transferfee) external onlyowner {
        require(buyfee <= staticvals.maxbuytaxes
                && sellfee <=staticvals. maxselltaxes
                && transferfee <= staticvals.maxtransfertaxes,
                "cannot exceed maximums.");
        _taxrates.buyfee = buyfee;
        _taxrates.sellfee = sellfee;
        _taxrates.transferfee = transferfee;
    }

  Code Snippet:
    function setswapsettings(uint256 thresholdpercent, uint256 thresholddivisor, uint256 amountpercent, uint256 amountdivisor) external onlyowner {
        swapthreshold = (_ttotal * thresholdpercent) / thresholddivisor;
        swapamount = (_ttotal * amountpercent) / amountdivisor;
    }

  Code Snippet:
    function setcontractswapenabled(bool _enabled) public onlyowner {
        contractswapenabled = _enabled;
        emit contractswapenabledupdated(_enabled);
    }

  Code Snippet:
    function excludepresaleaddresses(address router, address presale) external onlyowner {
        require(allowedpresaleexclusion, "function already used.");
        if (router == presale) {
            _liquidityholders[presale] = true;
            presaleaddresses[presale] = true;
            setexcludedfromfees(presale, true);
        } else {
            _liquidityholders[router] = true;
            _liquidityholders[presale] = true;
            presaleaddresses[router] = true;
            presaleaddresses[presale] = true;
            setexcludedfromfees(router, true);
            setexcludedfromfees(presale, true);
        }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) internal returns (bool) {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if(_haslimits(from, to)) {
            if(!tradingenabled) {
                revert("trading not yet enabled!");
            }
            if(to != _routeraddress && !lppairs[to]) {
                require(balanceof(to) + amount <= _maxwalletsize, "transfer amount exceeds the maxwalletsize.");
            }
        }

        bool takefee = true;
        if(_isexcludedfromfees[from] || _isexcludedfromfees[to]){
            takefee = false;
        }

        if (lppairs[to]) {
            if (!inswap
                && contractswapenabled
                && !presaleaddresses[to]
                && !presaleaddresses[from]
            ) {
                uint256 contracttokenbalance = balanceof(address(this));
                if (contracttokenbalance >= swapthreshold) {
                    if(contracttokenbalance >= swapamount) { contracttokenbalance = swapamount; }
                    contractswap(contracttokenbalance);
                }
            }      
        } 
        return _finalizetransfer(from, to, amount, takefee);
    }

  Code Snippet:
    function contractswap(uint256 contracttokenbalance) private locktheswap {
        if (_ratios.total == 0)
            return;

        if(_allowances[address(this)][address(dexrouter)] != type(uint256).max) {
            _allowances[address(this)][address(dexrouter)] = type(uint256).max;
        }

        uint256 toliquify = ((contracttokenbalance * _ratios.liquidity) / _ratios.total) / 2;

        uint256 toswapforeth = contracttokenbalance - toliquify;
        
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = dexrouter.weth();

        dexrouter.swapexacttokensforethsupportingfeeontransfertokens(
            toswapforeth,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );

        uint256 liquiditybalance = ((address(this).balance * _ratios.liquidity) / _ratios.total) / 2;
        __balances.liquidity = liquiditybalance;

        if (toliquify > 0) {
            dexrouter.addliquidityeth{value: liquiditybalance}(
                address(this),
                toliquify,
                0, // slippage is unavoidable
                0, // slippage is unavoidable
                dead,
                block.timestamp
            );
            emit swapandliquify(toliquify, liquiditybalance, toliquify);
        }
        if (contracttokenbalance - toliquify > 0) {
            __balances.market = (address(this).balance * _ratios.marketing) / (_ratios.total - _ratios.liquidity);
            _marketingwallet.transfer((address(this).balance * _ratios.marketing) / (_ratios.total - _ratios.liquidity));
            __balances.team = address(this).balance;
            _teamwallet.transfer(address(this).balance);
        }
    }

  Code Snippet:
    function _checkliquidityadd(address from, address to) private {
        require(!_hasliqbeenadded, "liquidity already added and marked.");
        if (!_haslimits(from, to) && to == lppair) {
            _liquidityholders[from] = true;
            _hasliqbeenadded = true;
            if(address(antisnipe) == address(0)){
                antisnipe = antisnipe(address(this));
            }
            contractswapenabled = true;
            emit contractswapenabledupdated(true);
        }
    }

  Code Snippet:
    function enabletrading() public onlyowner {
        require(!tradingenabled, "trading already enabled!");
        require(_hasliqbeenadded, "liquidity must be added.");
        try antisnipe.setlaunch(lppair, uint32(block.number), uint64(block.timestamp)) {} catch {}
        tradingenabled = true;
    }

  Code Snippet:
    function _finalizetransfer(address from, address to, uint256 amount, bool takefee) private returns (bool) {
        if (!_hasliqbeenadded) {
            _checkliquidityadd(from, to);
            if (!_hasliqbeenadded && _haslimits(from, to)) {
                revert("only owner can transfer at this time.");
            }
        }

        if (_haslimits(from, to)) {
            bool checked;
            try antisnipe.checkuser(from, to, amount) returns (bool check) {
                checked = check;
            } catch {
                revert();
            }

            if(!checked) {
                revert();
            }
        }

        _towned[from] -= amount;
        uint256 amountreceived = (takefee) ? taketaxes(from, to, amount) : amount;
        _towned[to] += amountreceived;

        emit transfer(from, to, amountreceived);
        return true;
    }

  Code Snippet:
    function taketaxes(address from, address to, uint256 amount) internal returns (uint256) {
        uint256 currentfee;
        if (from == lppair) {
            currentfee = _taxrates.buyfee;
        } else if (to == lppair) {
            currentfee = _taxrates.sellfee;
        } else {
            currentfee = _taxrates.transferfee;
        }

        uint256 feeamount = amount * currentfee / staticvals.mastertaxdivisor;

        _towned[address(this)] += feeamount;
        emit transfer(from, address(this), feeamount);

        return amount - feeamount;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function setblacklistenabled(address account, bool enabled) external;
}

  Code Snippet:
    function isblacklisted(address account) public view returns (bool) {
        return antisnipe.isblacklisted(account);
    }

  Code Snippet:
    function removeblacklisted(address account) external onlyowner {
        antisnipe.removeblacklisted(account);
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transfer(address from, address to, uint256 amount) internal returns (bool) {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        if(_haslimits(from, to)) {
            if(!tradingenabled) {
                revert("trading not yet enabled!");
            }
            if(to != _routeraddress && !lppairs[to]) {
                require(balanceof(to) + amount <= _maxwalletsize, "transfer amount exceeds the maxwalletsize.");
            }
        }

        bool takefee = true;
        if(_isexcludedfromfees[from] || _isexcludedfromfees[to]){
            takefee = false;
        }

        if (lppairs[to]) {
            if (!inswap
                && contractswapenabled
                && !presaleaddresses[to]
                && !presaleaddresses[from]
            ) {
                uint256 contracttokenbalance = balanceof(address(this));
                if (contracttokenbalance >= swapthreshold) {
                    if(contracttokenbalance >= swapamount) { contracttokenbalance = swapamount; }
                    contractswap(contracttokenbalance);
                }
            }      
        } 
        return _finalizetransfer(from, to, amount, takefee);
    }

  Code Snippet:
    function enabletrading() public onlyowner {
        require(!tradingenabled, "trading already enabled!");
        require(_hasliqbeenadded, "liquidity must be added.");
        try antisnipe.setlaunch(lppair, uint32(block.number), uint64(block.timestamp)) {} catch {}
        tradingenabled = true;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x686a99cf0d102fb074c1adbd2fc2da1f35758df7 — 830,012,020,956,531,962,459,193,344 tokens (83.70% of circulating supply)
  2. 0x32aff736f1e855f0dde6872a3f072b85315ff431 — 64,711,616,448,392,617,147,760,640 tokens (6.53% of circulating supply)
  3. 0x58fa5d040dd0ea0dbaf3652f8d6c0254e7ad315f — 10,534,816,311,454,182,462,717,952 tokens (1.06% of circulating supply)
  4. 0x0f5f5672d4565c68377587d5dbcff101840e4e02 — 7,661,512,097,051,918,884,405,248 tokens (0.77% of circulating supply)
  5. 0x20ef35989fbf05617ec71f8df533188592bf7a46 — 4,623,411,862,522,422,687,170,560 tokens (0.47% of circulating supply)
  6. 0x23337fec5bee1ddb3cb5006a8127f6f8dc4856c6 — 3,509,038,509,889,037,315,080,192 tokens (0.35% of circulating supply)
  7. 0xdb8d9745f4bad12d13fa30e17762762693115d76 — 1,828,680,901,206,463,930,695,680 tokens (0.18% of circulating supply)
  8. 0x42b3b690c719b47b731b71c06a4e5315a560dc17 — 1,675,846,000,000,000,044,564,480 tokens (0.17% of circulating supply)
  9. 0x3f0b17562048fab9f7ef183142e436c017e208d8 — 1,428,092,849,487,295,669,075,968 tokens (0.14% of circulating supply)
  10. 0x48a628ab84ec5654289816866f52e9668ce701ff — 1,363,832,175,457,316,733,190,144 tokens (0.14% of circulating supply)

Top 10 Total Balance: 927,348,868,111,993,217,333,854,208 tokens
Top 10 Share of Circulating Supply: 93.51%
Top 10 Share of Total Supply: 92.73%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $1,572,230,175,467,017.50
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Token Volume: 1124335.7220
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0007
Percentage of liquidity locked: 99.9800
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 28464.9202226467
LP holders count: 3

Liquidity holders for 0x32AFf736F1E855f0ddE6872A3F072B85315Ff431, (FlokiBro)

0x000000000000000000000000000000000000dead holds 28460.536202267023 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 19.915608478400706 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1361.55 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-11-10T21:57:02
Last Active: 2025-07-19T10:33:49
Days Since Last Activity: 15.026089008055555 days
Last Transaction Hash: 0x630c9b2535c1f5ee863dc281eb88eff7f8c4d742c8ed4b0e1546c332a9463b09
