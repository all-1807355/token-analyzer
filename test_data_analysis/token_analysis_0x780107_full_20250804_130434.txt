Token Analysis Report
==================================================
Token: HORNY DOGE (0x7801079014641434c96BEc7Ec0F9cc6DC83363e8)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function geunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(_previousowner == msg.sender, "you don't have permission to unlock");
        require(block.timestamp > _locktime , "contract is locked until 7 days");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(!_isblacklisted[from] && !_isblacklisted[to], 'blacklisted address');
        if(from != owner() && to != owner() && ! _isexcludedfromfee[to] && ! _isexcludedfromfee[from]) {
          require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }
      
        uint256 contracttokenbalance = balanceof(address(this));
        
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        
        bool overmintokenbalance = contracttokenbalance >= numtokensselltoaddtoliquidity;
        if (
            overmintokenbalance &&
            !inswapandliquify &&
            from != uniswapv2pair &&
            swapandliquifyenabled
        ) {
            contracttokenbalance = numtokensselltoaddtoliquidity;
            //add liquidity
            swapandliquify(contracttokenbalance);
        }
        _tokentransfer(from,to,amount);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function isexcludedfromreward(address account) public view returns (bool) {
        return _isexcluded[account];
    }

  Code Snippet:
    function excludefromreward(address account) public onlyowner() {
        require(!_isexcluded[account], "account is already excluded");
        if(_rowned[account] > 0) {
            _towned[account] = tokenfromreflection(_rowned[account]);
        }
        _isexcluded[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner() {
        require(_isexcluded[account], "account is already excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _towned[account] = 0;
                _isexcluded[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

WARNING: High Tax Detected
  Code Snippet:
    function setfeetosetter(address) external;
}

  Code Snippet:
    function swapexacttokensfortokens(
        uint amountin,

  Code Snippet:
    function swaptokensforexacttokens(
        uint amountout,

  Code Snippet:
    function swapexactethfortokens(uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swaptokensforexacteth(uint amountout, uint amountinmax, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapexacttokensforeth(uint amountin, uint amountoutmin, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function swapethforexacttokens(uint amountout, address[] calldata path, address to, uint deadline)
        external

  Code Snippet:
    function removeliquidityethsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function removeliquidityethwithpermitsupportingfeeontransfertokens(
        address token,

  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function excludefromfee(address account) public onlyowner {
        _isexcludedfromfee[account] = true;
    }

  Code Snippet:
    function includeinfee(address account) public onlyowner {
        _isexcludedfromfee[account] = false;
    }

  Code Snippet:
    function excludefrommarketfee(address account) public onlyowner {
        _isexcludedfrommarketfee[account] = true;
    }

  Code Snippet:
    function excludefrommarketfeelist(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isexcludedfrommarketfee[addresses[i]] = true;
      }
    }

  Code Snippet:
    function includeinmarketfee(address account) public onlyowner {
        _isexcludedfrommarketfee[account] = false;
    }

  Code Snippet:
    function includefrommarketfeelist(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isexcludedfrommarketfee[addresses[i]] = false;
      }
    }

  Code Snippet:
    function setbuytaxfeepercent(uint256 buytaxfee) external onlyowner() {
        _buytaxfee = buytaxfee;
    }

  Code Snippet:
    function setselltaxfeepercent(uint256 selltaxfee) external onlyowner() {
        _selltaxfee = selltaxfee;
    }

  Code Snippet:
    function setbuyliquidityfeepercent(uint256 buyliquidityfee) external onlyowner() {
        _buyliquidityfee = buyliquidityfee;
    }

  Code Snippet:
    function setsellliquidityfeepercent(uint256 sellliquidityfee) external onlyowner() {
        _sellliquidityfee = sellliquidityfee;
    }

  Code Snippet:
    function setbuymarketfeepercent(uint256 buymarketfee) external onlyowner() {
        _buymarketfee = buymarketfee;
    }

  Code Snippet:
    function setsellmarketfeepercent(uint256 sellmarketfee) external onlyowner() {
        _sellmarketfee = sellmarketfee;
    }

  Code Snippet:
    function setbuyburnfeepercent(uint256 buyburnfee) external onlyowner() {
        _buyburnfee = buyburnfee;
    }

  Code Snippet:
    function setswapandliquifyenabled(bool _enabled) public onlyowner {
        swapandliquifyenabled = _enabled;
        emit swapandliquifyenabledupdated(_enabled);
    }

  Code Snippet:
    function disableallbuyfees() external onlyowner() {
        _buymarketfee = 0;
        _buyburnfee = 0;
        _buytaxfee = 0;
        _buyliquidityfee = 0;
    }

  Code Snippet:
    function disableallsellfees() external onlyowner() {
        _sellmarketfee = 0;
        _sellburnfee = 0;
        _selltaxfee = 0;
        _sellliquidityfee = 0;
    }

  Code Snippet:
    function disableallfees() external onlyowner() {
        _taxfee = 0;
        _previoustaxfee = _taxfee;
        _liquidityfee = 0;
        _previousliquidityfee = _liquidityfee;
        _burnfee = 0;
        _previousburnfee = _taxfee;
        _marketfee = 0;
        _previousmarketfee = _marketfee;
        inswapandliquify = false;
        emit swapandliquifyenabledupdated(false);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 tfee) private {
        _rtotal = _rtotal.sub(rfee);
        _tfeetotal = _tfeetotal.add(tfee);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _gettvalues(tamount);
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tliquidity, _getrate());
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount) private view returns (uint256, uint256, uint256) {
        uint256 tfee = calculatetaxfee(tamount);
        uint256 tliquidity = calculateliquidityfee(tamount);
        uint256 ttransferamount = tamount.sub(tfee).sub(tliquidity);
        return (ttransferamount, tfee, tliquidity);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tliquidity, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rliquidity = tliquidity.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rliquidity);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function calculatetaxfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_taxfee).div(
            10**2
        );
    }

  Code Snippet:
    function calculateliquidityfee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_liquidityfee).div(
            10**2
        );
    }

  Code Snippet:
    function removeallbuysellfee() private {
        _previousbuytaxfee = _buytaxfee;
        _previousbuyburnfee = _buyburnfee;
        _previousbuymarketfee = _buymarketfee;
        _previousbuyliquidityfee = _buyliquidityfee;
        
        _previousselltaxfee = _selltaxfee;
        _previoussellburnfee = _sellburnfee;
        _previoussellmarketfee = _sellmarketfee;
        _previoussellliquidityfee = _sellliquidityfee;
        
        _buymarketfee = 0;
        _buyburnfee = 0;
        _buytaxfee = 0;
        _buyliquidityfee = 0;
    
        _sellmarketfee = 0;
        _sellburnfee = 0;
        _selltaxfee = 0;
        _sellliquidityfee = 0;
    }

  Code Snippet:
    function restoreallbuysellfee() private {
        _buytaxfee = _previousbuytaxfee;
        _buyburnfee = _previousbuyburnfee;
        _buymarketfee = _previousbuymarketfee;
        _buyliquidityfee = _previousbuyliquidityfee;
        
        _selltaxfee = _previousselltaxfee;
        _sellburnfee = _previoussellburnfee;
        _sellmarketfee = _previoussellmarketfee;
        _sellliquidityfee = _previoussellliquidityfee;
        
    }

  Code Snippet:
    function removeallfee() private {
        if(_taxfee == 0 && _liquidityfee == 0 && _marketfee == 0 && _burnfee == 0) return;
        
        _previoustaxfee = _taxfee;
        _previousliquidityfee = _liquidityfee;
        _previousburnfee = _burnfee;
        _previousmarketfee = _marketfee;
        
        _taxfee = 0;
        _liquidityfee = 0;
        _marketfee = 0;
        _burnfee = 0;
    }

  Code Snippet:
    function restoreallfee() private {
       _taxfee = _previoustaxfee;
       _liquidityfee = _previousliquidityfee;
       _burnfee = _previousburnfee;
       _marketfee = _previousmarketfee;
    }

  Code Snippet:
    function isexcludedfromfee(address account) public view returns(bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function swapandsendtofeedoge(uint256 tokens) private  {
        uint256 initialdogebalance = ierc20(doge).balanceof(address(this));
        swaptokensfordoge(tokens);
        uint256 newbalance = (ierc20(doge).balanceof(address(this))).sub(initialdogebalance);
        ierc20(doge).transfer(_marketingwalletaddress, newbalance);
    }  

  Code Snippet:
    function swaptokensfordoge(uint256 tokenamount) private {
        address[] memory path = new address[](3);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();
        path[2] = doge;

        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.swapexacttokensfortokenssupportingfeeontransfertokens(
            tokenamount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandsendtofeebnb(uint256 tokens) private  {
        uint256 initialbnbbalance = address(this).balance;
        swaptokensforeth(tokens);
        uint256 newbalance = (address(this).balance).sub(initialbnbbalance);
        payable(_marketingwalletaddress).transfer(newbalance);
    }

  Code Snippet:
    function swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapv2router.weth();

        _approve(address(this), address(uniswapv2router), tokenamount);

        // make the swap
        uniswapv2router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            0, // accept any amount of eth
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function swapandliquify(uint256 contracttokenbalance) private locktheswap {
        uint256 half = contracttokenbalance.div(2);
        uint256 otherhalf = contracttokenbalance.sub(half);
        uint256 initialbalance = address(this).balance;
        swaptokensforeth(half); 
        uint256 newbalance = address(this).balance.sub(initialbalance);
        addliquidity(otherhalf, newbalance);
        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function addliquidity(uint256 tokenamount, uint256 ethamount) private {
        _approve(address(this), address(uniswapv2router), tokenamount);
        uniswapv2router.addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(!_isblacklisted[from] && !_isblacklisted[to], 'blacklisted address');
        if(from != owner() && to != owner() && ! _isexcludedfromfee[to] && ! _isexcludedfromfee[from]) {
          require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }
      
        uint256 contracttokenbalance = balanceof(address(this));
        
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        
        bool overmintokenbalance = contracttokenbalance >= numtokensselltoaddtoliquidity;
        if (
            overmintokenbalance &&
            !inswapandliquify &&
            from != uniswapv2pair &&
            swapandliquifyenabled
        ) {
            contracttokenbalance = numtokensselltoaddtoliquidity;
            //add liquidity
            swapandliquify(contracttokenbalance);
        }
        _tokentransfer(from,to,amount);
    }

  Code Snippet:
    function _tokentransfer(address sender, address recipient, uint256 amount) private {
         
        bool takefee = true; 
         
        if(_isexcludedfromfee[sender] || _isexcludedfromfee[recipient]){
            takefee = false;
        }
        if(!takefee){
            removeallbuysellfee();
        }
        else{
            // buy
            if(sender == uniswapv2pair){
                _taxfee = _buytaxfee;
                _liquidityfee = _buyliquidityfee;
                _burnfee = _buyburnfee;
                if(!_isexcludedfrommarketfee[recipient]){
                    _marketfee = _buymarketfee;
                }
            }
            // sell
            if(recipient == uniswapv2pair){
                _taxfee = _selltaxfee;
                _liquidityfee = _sellliquidityfee;
                _burnfee = _sellburnfee;
                if(!_isexcludedfrommarketfee[sender]){
                    _marketfee = _sellmarketfee;
                }
            }
        }
        uint256 burnamt = amount.mul(_burnfee).div(100);
        uint256 marketamt = amount.mul(_marketfee).div(100);
        uint256 finalamount = amount.sub(burnamt).sub(marketamt);
        
        if (_isexcluded[sender] && !_isexcluded[recipient]) {
            _transferfromexcluded(sender, recipient, finalamount);
        } else if (!_isexcluded[sender] && _isexcluded[recipient]) {
            _transfertoexcluded(sender, recipient, finalamount);
        } else if (_isexcluded[sender] && _isexcluded[recipient]) {
            _transferbothexcluded(sender, recipient, finalamount);
        } else {
            _transferstandard(sender, recipient, finalamount);
        }
        removeallfee();
        _transferstandard(sender, address(0) ,burnamt);
       _transferstandard(sender, _marketingwalletaddress,marketamt);
        if(!takefee){
           restoreallbuysellfee();
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tliquidity) = _getvalues(tamount);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _takeliquidity(tliquidity);
        _reflectfee(rfee, tfee);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
     function setrouteraddress(address newrouter) public onlyowner() {
         iuniswapv2router02 _newpancakerouter = iuniswapv2router02(newrouter);
         uniswapv2pair = iuniswapv2factory(_newpancakerouter.factory()).createpair(address(this), _newpancakerouter.weth());
         uniswapv2router = _newpancakerouter;
     }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function setblacklistaddress(address account, bool value) external onlyowner{
        _isblacklisted[account] = value;
    }

  Code Snippet:
    function addtoblacklist(address[] calldata addresses) external onlyowner {
      for (uint256 i; i < addresses.length; ++i) {
        _isblacklisted[addresses[i]] = true;
      }
    }

  Code Snippet:
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "erc20: transfer from the zero address");
        require(to != address(0), "erc20: transfer to the zero address");
        require(amount > 0, "transfer amount must be greater than zero");
        require(!_isblacklisted[from] && !_isblacklisted[to], 'blacklisted address');
        if(from != owner() && to != owner() && ! _isexcludedfromfee[to] && ! _isexcludedfromfee[from]) {
          require(amount <= _maxtxamount, "transfer amount exceeds the maxtxamount.");
        }
      
        uint256 contracttokenbalance = balanceof(address(this));
        
        if(contracttokenbalance >= _maxtxamount)
        {
            contracttokenbalance = _maxtxamount;
        }
        
        bool overmintokenbalance = contracttokenbalance >= numtokensselltoaddtoliquidity;
        if (
            overmintokenbalance &&
            !inswapandliquify &&
            from != uniswapv2pair &&
            swapandliquifyenabled
        ) {
            contracttokenbalance = numtokensselltoaddtoliquidity;
            //add liquidity
            swapandliquify(contracttokenbalance);
        }
        _tokentransfer(from,to,amount);
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x390bd00926038bbfb5505171ba79fe0582808895 — 124,039,112,145,088,380,928 tokens (18.94% of circulating supply)
  2. 0x7801079014641434c96bec7ec0f9cc6dc83363e8 — 59,423,557,413,756,452,864 tokens (9.07% of circulating supply)
  3. 0xef258eb2d53e30a161ae66fa0b2c6f5fff915e6b — 20,000,000,000,000,000,000 tokens (3.05% of circulating supply)
  4. 0x04bfcb7b6bc81361f14c1e2c7592d712e3b9f456 — 19,415,283,266,142,584,832 tokens (2.96% of circulating supply)
  5. 0x52550784b04b7405157f6dd472f42d09d62bbdfe — 10,000,000,000,000,000,000 tokens (1.53% of circulating supply)
  6. 0x642dbfcbde4851b15630d270aa91b94ecb9f5654 — 5,541,775,664,194,340,864 tokens (0.85% of circulating supply)
  7. 0x875261901446f697fed6c92d2d7078f10d9032db — 5,529,621,263,460,570,112 tokens (0.84% of circulating supply)
  8. 0x30e17685ec0d4a09a6e2be9a4731f867518f4d93 — 5,165,912,365,830,619,136 tokens (0.79% of circulating supply)
  9. 0xadfb9a5e2d0db1e440f7cdc589e7461d519ddae0 — 4,355,000,000,000,000,000 tokens (0.67% of circulating supply)
  10. 0x221232340d930b19a85012f508d79b18efb7e75b — 4,015,627,710,807,473,664 tokens (0.61% of circulating supply)

Top 10 Total Balance: 257,485,889,829,280,422,400 tokens
Top 10 Share of Circulating Supply: 39.32%
Top 10 Share of Total Supply: 25.75%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $15,239,626,177,280,588.00
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 928044026.4494
USD Volume: 21598.2339
24h Volume/Liquidity Ratio: 3740933.0428
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 15.599147322664711
LP holders count: 5

Liquidity holders for 0x7801079014641434c96BEc7Ec0F9cc6DC83363e8, (HORNY DOGE)

0x7040d772ff6c0287b6e32d93315b39f29fcb330d holds 15.596046950367262 LP tokens

0xde9e2fe2e975a00a9ef4913cc68eabae833c1638 holds 0.001664176353444514 LP tokens

0xdda14047ee3ec97fb4bb62e1586c08c54d2461d7 holds 0.001196082100995184 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.00024011384300852 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1424.75 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-09-09T18:58:57
Last Active: 2025-07-29T20:49:19
Days Since Last Activity: 5.677268396238426 days
Last Transaction Hash: 0x0ecc03a5dd1e049ee384b5e70b18078d7c1d66b794f530eef20a8789b6ee1367
