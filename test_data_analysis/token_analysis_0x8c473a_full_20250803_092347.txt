Token Analysis Report
==================================================
Token: Fruit Fighters (0x8c473a401e7EBde6DAB178eA0bB5b35Cde542c0e)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function claimdividend() external;
}

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            busd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function claimdividend() external override {
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function claimdividend() external {
        distributor.claimdividend();
    }

WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = busd.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = wbnb;
        path[1] = address(busd);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = busd.balanceof(address(this)).sub(balancebefore);

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }

        uint256 amount = getunpaidearnings(shareholder);
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            busd.transfer(shareholder, amount);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function withdraw(address _token, uint256 _amount) external {
        require(msg.sender == safemanager);
        ibep20(_token).transfer(safemanager, _amount);
    }

  Code Snippet:
    function withdrawbnb(uint256 _amount) external {
        require(msg.sender == safemanager);
        safemanager.transfer(_amount);
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal open(sender, recipient) returns (bool) {
        require(!blacklist[sender], "address is blacklisted");

        if(inswap){ return _basictransfer(sender, recipient, amount); }
        
        checktxlimit(sender, amount);

        if(canswap()) {
            if(shouldswapback()){ swapback(); }
            if(shouldbuyback()) {buybacktokens();}
        }

        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = takefee(sender, recipient, amount);
        _balances[recipient] = _balances[recipient].add(amountreceived);

        if(!excludedividend[sender]){ try distributor.setshare(sender, _balances[sender]) {} catch {} }
        if(!excludedividend[recipient]){ try distributor.setshare(recipient, _balances[recipient]) {} catch {} }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function canswap() internal view returns (bool) {
        return msg.sender != pair && !inswap;
    }

  Code Snippet:
    function takefee(address sender, address recipient, uint256 amount) internal returns (uint256) {
        if (excludefee[sender] || excludefee[recipient]) return amount;

        uint256 feeamount = amount.mul(totalfee).div(feedenominator);
        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function shouldswapback() internal view returns (bool) {
        return msg.sender != pair
        && !inswap
        && swapenabled
        && _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function swapback() internal swapping {

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = wbnb;

        uint256 balancebefore = address(this).balance;

        try router.swapexacttokensforethsupportingfeeontransfertokens(
            swapthreshold,
            0,
            path,
            address(this),
            block.timestamp
        ) {
            uint256 amountbnb = address(this).balance.sub(balancebefore);
            uint256 amountbnbreflection = amountbnb.mul(reflectionfee).div(totalfee);
            uint256 amountbnbmarketing = amountbnb.mul(marketingfee).div(totalfee);

            try distributor.deposit{value: amountbnbreflection}() {} catch {}
            payable(marketing).call{value: amountbnbmarketing, gas: 30000}("");
            emit swapbacksuccess(swapthreshold);
        } catch error(string memory e) {
            emit swapbackfailed(string(abi.encodepacked("swapback failed with error ", e)));
        } catch {
            emit swapbackfailed("swapback failed without an error message from pancakeswap");
        }
    }

  Code Snippet:
    function buybacktokens() private swapping {
        uint256 amount = address(this).balance;
        if (amount > buybackupperlimit) {amount = buybackupperlimit;}

        if (amount > 0) {
            swapbnbfortokens(amount);
        }
    }

  Code Snippet:
    function swapbnbfortokens(uint256 amount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = router.weth();
        path[1] = address(this);

        // make the swap
        router.swapexactethfortokenssupportingfeeontransfertokens{
            value: amount
        }(
            0, // accept any amount of tokens
            path,
            dead, // dead address
            block.timestamp.add(300)
        );

        emit swapbnbfortokens(amount, path);
    }

  Code Snippet:
    function setexcludefee(address holder, bool exempt) external onlyowner {
        excludefee[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _burnfee, uint256 _reflectionfee, uint256 _marketingfee, uint256 _feedenominator) external onlyowner {
        burnfee = _burnfee;
        reflectionfee = _reflectionfee;
        marketingfee = _marketingfee;
        totalfee = _burnfee.add(_reflectionfee).add(_marketingfee);
        feedenominator = _feedenominator;
        require(totalfee <= feedenominator / 5, "invalid fee");
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external onlyowner {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function includetowhitelist(address[] memory _users) external onlyowner {
        for(uint8 i = 0; i < _users.length; i++) {
            _whitelist[_users[i]] = true;
        }
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal open(sender, recipient) returns (bool) {
        require(!blacklist[sender], "address is blacklisted");

        if(inswap){ return _basictransfer(sender, recipient, amount); }
        
        checktxlimit(sender, amount);

        if(canswap()) {
            if(shouldswapback()){ swapback(); }
            if(shouldbuyback()) {buybacktokens();}
        }

        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = takefee(sender, recipient, amount);
        _balances[recipient] = _balances[recipient].add(amountreceived);

        if(!excludedividend[sender]){ try distributor.setshare(sender, _balances[sender]) {} catch {} }
        if(!excludedividend[recipient]){ try distributor.setshare(recipient, _balances[recipient]) {} catch {} }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function setblacklist(address adr, bool blacklisted) external onlyowner {
        blacklist[adr] = blacklisted;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 6
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x8c473a401e7ebde6dab178ea0bb5b35cde542c0e — 193,792,039,032,945,311,744 tokens (22.32% of circulating supply)
  2. 0xb1695936924db873d17349075d732ae1f703ed61 — 130,740,018,909,676,470,272 tokens (15.05% of circulating supply)
  3. 0x493b0677f0313855c4157882b50b2e31600a1922 — 110,000,000,000,000,000,000 tokens (12.67% of circulating supply)
  4. 0x0ed943ce24baebf257488771759f9bf482c39706 — 109,358,961,670,739,116,032 tokens (12.59% of circulating supply)
  5. 0x9b69b82b91d9d610d53b41fc69146d6f96101be8 — 52,469,253,274,986,864,640 tokens (6.04% of circulating supply)
  6. 0xd1eed456d6e4697440b3cdeb9347fd5d3c6dd864 — 50,692,000,000,000,000,000 tokens (5.84% of circulating supply)
  7. 0x9651517faa8b3841f595e126217b158705f9453b — 28,553,783,069,991,096,320 tokens (3.29% of circulating supply)
  8. 0x6a0811428061f834d1d0247f573ded9d22919682 — 6,386,197,494,720,000,000 tokens (0.74% of circulating supply)
  9. 0x350776b2b17a89f358708eeda999ef589a4ad19d — 3,381,638,944,487,393,280 tokens (0.39% of circulating supply)
  10. 0xbbc1b6a71a656e2b6b1c12ae98a21f5e948dded9 — 2,109,425,961,743,136,256 tokens (0.24% of circulating supply)

Top 10 Total Balance: 687,483,318,359,289,388,544 tokens
Top 10 Share of Circulating Supply: 79.16%
Top 10 Share of Total Supply: 68.75%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $51,445,265,127,624.59
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 0.001740306040563107
LP holders count: 2

Liquidity holders for 0x8c473a401e7EBde6DAB178eA0bB5b35Cde542c0e, (Fruit Fighters)

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.001740306040562107 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1404.99 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-09-28T09:36:02
Last Active: 2024-07-09T06:28:03
Days Since Last Activity: 390.12204301927085 days
Last Transaction Hash: 0x7d7eb3064361aee56447df17032c5db8eec05d908e3e9ec30cf3616f62a16e17
