Token Analysis Report
==================================================
Token: AstroDonkey (0x32f3145A98A61813Af1ab0631A6a81850cEB8CaD)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function getunlocktime() public view returns (uint256) {
        return _locktime;
    }

  Code Snippet:
    function unlock() public virtual {
        require(
            _previousowner == msg.sender,
            "only the previous owner can unlock onwership"
        );
        require(block.timestamp > _locktime, "the contract is still locked");
        emit ownershiptransferred(_owner, _previousowner);
        _owner = _previousowner;
    }

  Code Snippet:
    function balanceof(address account) public view override returns (uint256) {
        if (_isexcludedfromrewards[account]) return _balances[account];
        return tokenfromreflection(_reflectedbalances[account]);
    }

  Code Snippet:
    function burn(uint256 amount) external {
        address sender = _msgsender();
        require(
            sender != address(0),
            "baserfitoken: burn from the zero address"
        );
        require(
            sender != address(burnaddress),
            "baserfitoken: burn from the burn address"
        );

        uint256 balance = balanceof(sender);
        require(balance >= amount, "baserfitoken: burn amount exceeds balance");

        uint256 reflectedamount = amount.mul(_getcurrentrate());

        // remove the amount from the sender's balance first
        _reflectedbalances[sender] = _reflectedbalances[sender].sub(
            reflectedamount
        );
        if (_isexcludedfromrewards[sender])
            _balances[sender] = _balances[sender].sub(amount);

        _burntokens(sender, amount, reflectedamount);
    }

  Code Snippet:
    function isexcludedfromreward(address account)
        external

  Code Snippet:
    function excludefromreward(address account) external onlyowner {
        require(!_isexcludedfromrewards[account], "account is not included");
        _exclude(account);
    }

  Code Snippet:
    function _exclude(address account) internal {
        if (_reflectedbalances[account] > 0) {
            _balances[account] = tokenfromreflection(
                _reflectedbalances[account]
            );
        }
        _isexcludedfromrewards[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcludedfromrewards[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _balances[account] = 0;
                _isexcludedfromrewards[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function _getcurrentsupply() internal view returns (uint256, uint256) {
        uint256 rsupply = _reflectedsupply;
        uint256 tsupply = total_supply;

        /**
         * the code below removes balances of addresses excluded from rewards from
         * rsupply and tsupply, which effectively increases the % of transaction fees
         * delivered to non-excluded holders
         */
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (
                _reflectedbalances[_excluded[i]] > rsupply ||
                _balances[_excluded[i]] > tsupply
            ) return (_reflectedsupply, total_supply);
            rsupply = rsupply.sub(_reflectedbalances[_excluded[i]]);
            tsupply = tsupply.sub(_balances[_excluded[i]]);
        }
        if (tsupply == 0 || rsupply < _reflectedsupply.div(total_supply))
            return (_reflectedsupply, total_supply);
        return (rsupply, tsupply);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

  Code Snippet:
    function lock(uint256 time) public virtual onlyowner {
        _previousowner = _owner;
        _owner = address(0);
        _locktime = block.timestamp + time;
        emit ownershiptransferred(_owner, address(0));
    }

WARNING: Is Honeypot Suspected
  Code Snippet:
    function _verifycallresult(
        bool success,

  Code Snippet:
    function balanceof(address account) public view override returns (uint256) {
        if (_isexcludedfromrewards[account]) return _balances[account];
        return tokenfromreflection(_reflectedbalances[account]);
    }

  Code Snippet:
    function burn(uint256 amount) external {
        address sender = _msgsender();
        require(
            sender != address(0),
            "baserfitoken: burn from the zero address"
        );
        require(
            sender != address(burnaddress),
            "baserfitoken: burn from the burn address"
        );

        uint256 balance = balanceof(sender);
        require(balance >= amount, "baserfitoken: burn amount exceeds balance");

        uint256 reflectedamount = amount.mul(_getcurrentrate());

        // remove the amount from the sender's balance first
        _reflectedbalances[sender] = _reflectedbalances[sender].sub(
            reflectedamount
        );
        if (_isexcludedfromrewards[sender])
            _balances[sender] = _balances[sender].sub(amount);

        _burntokens(sender, amount, reflectedamount);
    }

  Code Snippet:
    function isexcludedfromreward(address account)
        external

  Code Snippet:
    function excludefromreward(address account) external onlyowner {
        require(!_isexcludedfromrewards[account], "account is not included");
        _exclude(account);
    }

  Code Snippet:
    function _exclude(address account) internal {
        if (_reflectedbalances[account] > 0) {
            _balances[account] = tokenfromreflection(
                _reflectedbalances[account]
            );
        }
        _isexcludedfromrewards[account] = true;
        _excluded.push(account);
    }

  Code Snippet:
    function includeinreward(address account) external onlyowner {
        require(_isexcludedfromrewards[account], "account is not excluded");
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (_excluded[i] == account) {
                _excluded[i] = _excluded[_excluded.length - 1];
                _balances[account] = 0;
                _isexcludedfromrewards[account] = false;
                _excluded.pop();
                break;
            }
        }
    }

  Code Snippet:
    function _getcurrentsupply() internal view returns (uint256, uint256) {
        uint256 rsupply = _reflectedsupply;
        uint256 tsupply = total_supply;

        /**
         * the code below removes balances of addresses excluded from rewards from
         * rsupply and tsupply, which effectively increases the % of transaction fees
         * delivered to non-excluded holders
         */
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (
                _reflectedbalances[_excluded[i]] > rsupply ||
                _balances[_excluded[i]] > tsupply
            ) return (_reflectedsupply, total_supply);
            rsupply = rsupply.sub(_reflectedbalances[_excluded[i]]);
            tsupply = tsupply.sub(_balances[_excluded[i]]);
        }
        if (tsupply == 0 || rsupply < _reflectedsupply.div(total_supply))
            return (_reflectedsupply, total_supply);
        return (rsupply, tsupply);
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint256 amountin,

  Code Snippet:
    function _addfee(
        feetype name,

  Code Snippet:
    function _addfees(
        uint256 _rfifee,

  Code Snippet:
    function _getfeescount() internal view returns (uint256) {
        return fees.length;
    }

  Code Snippet:
    function _getfeestruct(uint256 index) private view returns (fee storage) {
        require(
            index >= 0 && index < fees.length,
            "feessettings._getfeestruct: fee index out of bounds"
        );
        return fees[index];
    }

  Code Snippet:
    function _getfee(uint256 index)
        internal

  Code Snippet:
    function _addfeecollectedamount(uint256 index, uint256 amount) internal {
        fee storage fee = _getfeestruct(index);
        fee.total = fee.total.add(amount);
    }

  Code Snippet:
    function getcollectedfeetotal(uint256 index)
        internal

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee)
        external

  Code Snippet:
    function setexcludedfromfee(address account, bool value)
        external

  Code Snippet:
    function isexcludedfromfee(address account) public view returns (bool) {
        return _isexcludedfromfee[account];
    }

  Code Snippet:
    function _takefees(
        uint256 amount,

  Code Snippet:
    function _getvalues(uint256 tamount, uint256 feessum)
        internal

  Code Snippet:
    function _getcurrentsupply() internal view returns (uint256, uint256) {
        uint256 rsupply = _reflectedsupply;
        uint256 tsupply = total_supply;

        /**
         * the code below removes balances of addresses excluded from rewards from
         * rsupply and tsupply, which effectively increases the % of transaction fees
         * delivered to non-excluded holders
         */
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (
                _reflectedbalances[_excluded[i]] > rsupply ||
                _balances[_excluded[i]] > tsupply
            ) return (_reflectedsupply, total_supply);
            rsupply = rsupply.sub(_reflectedbalances[_excluded[i]]);
            tsupply = tsupply.sub(_balances[_excluded[i]]);
        }
        if (tsupply == 0 || rsupply < _reflectedsupply.div(total_supply))
            return (_reflectedsupply, total_supply);
        return (rsupply, tsupply);
    }

  Code Snippet:
    function _getsumoffees(address sender, uint256 amount)
        internal

  Code Snippet:
    function _taketransactionfees(uint256 amount, uint256 currentrate)
        internal

  Code Snippet:
    function initializeliquidityswapper(
        env env,

  Code Snippet:
    function liquify(uint256 contracttokenbalance, address sender) internal {
        if (contracttokenbalance >= maxtransactionamount)
            contracttokenbalance = maxtransactionamount;

        bool isoverrequiredtokenbalance = (contracttokenbalance >=
            numberoftokenstoswaptoliquidity);

        /**
         * - first check if the contract has collected enough tokens to swap and liquify
         * - then check swap and liquify is enabled
         * - then make sure not to get caught in a circular liquidity event
         * - finally, don't swap & liquify if the sender is the uniswap pair
         */
        if (
            isoverrequiredtokenbalance &&
            swapandliquifyenabled &&
            !inswapandliquify &&
            (sender != _pair)
        ) {
            // todo check if the `(sender != _pair)` is necessary because that basically
            // stops swap and liquify for all "buy" transactions
            _swapandliquify(contracttokenbalance);
        }
    }

  Code Snippet:
    function _swapandliquify(uint256 amount) private locktheswap {
        // split the contract balance into halves
        uint256 half = amount.div(2);
        uint256 otherhalf = amount.sub(half);

        // capture the contract's current eth balance.
        // this is so that we can capture exactly the amount of eth that the
        // swap creates, and not make the liquidity event include any eth that
        // has been manually sent to the contract
        uint256 initialbalance = address(this).balance;

        // swap tokens for eth
        _swaptokensforeth(half); // <- this breaks the eth -> hate swap when swap+liquify is triggered

        // how much eth did we just swap into?
        uint256 newbalance = address(this).balance.sub(initialbalance);

        // add liquidity to uniswap
        _addliquidity(otherhalf, newbalance);

        emit swapandliquify(half, newbalance, otherhalf);
    }

  Code Snippet:
    function _swaptokensforeth(uint256 tokenamount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _router.weth();

        _approvedelegate(address(this), address(_router), tokenamount);

        // make the swap
        _router.swapexacttokensforethsupportingfeeontransfertokens(
            tokenamount,
            // the minimum amount of output tokens that must be received for the transaction not to revert.
            // 0 = accept any amount (slippage is inevitable)
            0,
            path,
            address(this),
            block.timestamp
        );
    }

  Code Snippet:
    function _addliquidity(uint256 tokenamount, uint256 ethamount) private {
        // approve token transfer to cover all possible scenarios
        _approvedelegate(address(this), address(_router), tokenamount);

        // add tahe liquidity
        (uint256 tokenamountsent, uint256 ethamountsent, uint256 liquidity) = _router
            .addliquidityeth{value: ethamount}(
            address(this),
            tokenamount,
            // bounds the extent to which the weth/token price can go up before the transaction reverts.
            // must be <= amounttokendesired; 0 = accept any amount (slippage is inevitable)
            0,
            // bounds the extent to which the token/weth price can go up before the transaction reverts.
            // 0 = accept any amount (slippage is inevitable)
            0,
            // this is a centralized risk if the owner's account is ever compromised (see certik ssl-04)
            owner(),
            block.timestamp
        );

        // fix the forever locked bnbs as per the certik's audit
        /**
         * the swapandliquify function converts half of the contracttokenbalance safemoon tokens to bnb.
         * for every swapandliquify function call, a small amount of bnb remains in the contract.
         * this amount grows over time with the swapandliquify function being called throughout the life
         * of the contract. the safemoon contract does not contain a method to withdraw these funds,
         * and the bnb will be locked in the safemoon contract forever.
         */
        withdrawablebalance = address(this).balance;
        emit liquidityadded(tokenamountsent, ethamountsent, liquidity);
    }

  Code Snippet:
    function setswapandliquifyenabled(bool enabled) external onlymanager {
        swapandliquifyenabled = enabled;
        emit swapandliquifyenabledupdated(swapandliquifyenabled);
    }

  Code Snippet:
    function withdrawlockedeth(address payable recipient) external onlymanager {
        require(
            recipient != address(0),
            "cannot withdraw the eth balance to the zero address"
        );
        require(
            withdrawablebalance > 0,
            "the eth balance must be greater than 0"
        );

        // prevent re-entrancy attacks
        uint256 amount = withdrawablebalance;
        withdrawablebalance = 0;
        recipient.transfer(amount);
    }

  Code Snippet:
    function _getantiwhalefees(uint256, uint256)
        internal

  Code Snippet:
    function _getsumoffees(address sender, uint256 amount)
        internal

  Code Snippet:
    function _taketransactionfees(uint256 amount, uint256 currentrate)
        internal

  Code Snippet:
    function _takefee(
        uint256 amount,

  Code Snippet:
    function _takefeetoeth(
        uint256 amount,

WARNING: Blacklist Or Whitelist Detected
  Code Snippet:
    function _isunlimitedsender(address account) internal view returns (bool) {
        // the owner should be the only whitelisted sender
        return (account == owner());
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x225a07913b16ede58c42c4e48cab45fd52bb19a8 — 296,744,483,627,664,686,260,399,636,480 tokens (72.41% of circulating supply)
  2. 0x1d73f6928f1239b0ec8b4ae594ded00d885fcce0 — 2,903,407,093,918,614,453,749,809,152 tokens (0.71% of circulating supply)
  3. 0xda204303eade9e826222f2167a5790a3c3f00bf6 — 1,631,435,647,935,696,515,255,762,944 tokens (0.40% of circulating supply)
  4. 0x9b27dec85492d851da345046af7d8f5b86835ebb — 1,349,612,410,127,423,280,030,679,040 tokens (0.33% of circulating supply)
  5. 0x2b35bfc76eb1e694c7115a1b718db6ae572e77fa — 1,001,820,000,000,000,035,945,185,280 tokens (0.24% of circulating supply)
  6. 0x93b64f94ef1950d3fde2bffd5fc05b4042747c15 — 1,000,000,000,000,000,013,287,555,072 tokens (0.24% of circulating supply)
  7. 0xb6989890e760aecdc877f07887d3c2cda8c07f86 — 910,000,000,000,000,058,820,919,296 tokens (0.22% of circulating supply)
  8. 0xb9c020410705ae3df7259a4bdb1cea745e9a8fe6 — 713,710,898,501,421,909,703,393,280 tokens (0.17% of circulating supply)
  9. 0xdb64841fd31457eca2b7e4dc68abe84986a4058c — 626,083,640,909,999,952,428,531,712 tokens (0.15% of circulating supply)
  10. 0x67c42249fdef0aa41be9aa0ee4de508661ebc7c4 — 596,520,552,559,896,575,394,971,648 tokens (0.15% of circulating supply)

Top 10 Total Balance: 307,477,073,871,617,739,055,016,443,904 tokens
Top 10 Share of Circulating Supply: 75.03%
Top 10 Share of Total Supply: 61.50%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $82,920,464,434,691,280.00
Liquidity: $0.12
Liquidity/MCap Ratio: 0.0000
Token Volume: 62954706.0682
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0001
Percentage of liquidity locked: 98.3300
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 3622781.8672555895
LP holders count: 5

Liquidity holders for 0x32f3145A98A61813Af1ab0631A6a81850cEB8CaD, (AstroDonkey)

0x7ee058420e5937496f5a2096f04caa7721cf70cc holds 3562307.9699180857 LP tokens

Owner 0x86495411d5369a3398f11557453934d1bf33ffd8 holds 60311.42123194756 LP tokens

0x8029fb5eac4a0f8c44254dea3010d36d0a27d3cd holds 162.364658225473 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 0.1114473306521193 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://discord.gg/dAmr6eUTpM, Reason: metamask recovery phrase phishing
  URL: https://pancake.kiemtienonline360.com/, Reason: metamask recovery phrase phishing
  URL: https://www.certik.org/projects/safemoon, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1375.26 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-10-28T03:07:32
Last Active: 2025-07-19T11:22:24
Days Since Last Activity: 14.920518783043981 days
Last Transaction Hash: 0x69e06df98a8fd1afcbcfdf3112ef61ae094ad27654e30ce38209a2d2666a02d3
