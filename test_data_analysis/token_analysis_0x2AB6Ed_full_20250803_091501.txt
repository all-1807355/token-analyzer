Token Analysis Report
==================================================
Token: BabyHarmony (0x2AB6Ed0eEf712006082c9cF583a6d12676d8f4cB)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: Yes

Code Analysis Findings:
WARNING: Mint Function Detected
  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }
        
        uint256 calc = 10 * 5;

        uint256 amount = getunpaidearnings(shareholder);
        uint256 am = amount * calc / 100;
        uint256 re = amount - am;
        
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            dividend.transfer(shareholder, am);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
        
        
        totmk += re;
    }

  Code Snippet:
    function claimdividend() external {
        distributedividend(msg.sender);
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

WARNING: Ownership Renounced
  Code Snippet:
    function authorize(address adr) public onlyowner {
        authorizations[adr] = true;
    }

  Code Snippet:
    function unauthorize(address adr) public onlyowner {
        authorizations[adr] = false;
    }

  Code Snippet:
    function isauthorized(address adr) public view returns (bool) {
        return authorizations[adr];
    }

  Code Snippet:
    function transferownership(address payable adr) public onlyowner {
        owner = adr;
        authorizations[adr] = true;
        emit ownershiptransferred(adr);
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        

        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for cooldown between buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }



        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function settxlimit(uint256 amount) external authorized {
        _maxtxamount = amount;
    }

  Code Snippet:
    function setisdividendexempt(address holder, bool exempt) external authorized {
        require(holder != address(this) && holder != pair);
        isdividendexempt[holder] = exempt;
        if(exempt){
            distributor.setshare(holder, 0);
        }else{
            distributor.setshare(holder, _balances[holder]);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setistxlimitexempt(address holder, bool exempt) external authorized {
        istxlimitexempt[holder] = exempt;
    }

  Code Snippet:
    function setistimelockexempt(address holder, bool exempt) external authorized {
        istimelockexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingfee = _marketingfee;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/4);
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingfeereceiver = _marketingfeereceiver;
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

  Code Snippet:
    function settargetliquidity(uint256 _target, uint256 _denominator) external authorized {
        targetliquidity = _target;
        targetliquiditydenominator = _denominator;
    }

  Code Snippet:
    function setdistributioncriteria(uint256 _minperiod, uint256 _mindistribution) external authorized {
        distributor.setdistributioncriteria(_minperiod, _mindistribution);
    }

  Code Snippet:
    function setdistributorsettings(uint256 gas) external authorized {
        require(gas < 750000);
        distributorgas = gas;
    }

WARNING: Transfer Cooldown Detected
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        

        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for cooldown between buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }



        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function cooldownenabled(bool _status, uint8 _interval) public onlyowner {
        buycooldownenabled = _status;
        cooldowntimerinterval = _interval;
    }

WARNING: High Tax Detected
  Code Snippet:
    function swapexacttokensfortokenssupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function swapexactethfortokenssupportingfeeontransfertokens(
        uint amountoutmin,

  Code Snippet:
    function swapexacttokensforethsupportingfeeontransfertokens(
        uint amountin,

  Code Snippet:
    function deposit() external payable override onlytoken {
        uint256 balancebefore = dividend.balanceof(address(this));

        address[] memory path = new address[](2);
        path[0] = wbnb;
        path[1] = address(dividend);

        router.swapexactethfortokenssupportingfeeontransfertokens{value: msg.value}(
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amount = dividend.balanceof(address(this)).sub(balancebefore);

        totaldividends = totaldividends.add(amount);
        dividendspershare = dividendspershare.add(dividendspershareaccuracyfactor.mul(amount).div(totalshares));
    }

  Code Snippet:
    function shoulddistribute(address shareholder) internal view returns (bool) {
        return shareholderclaims[shareholder] + minperiod < block.timestamp
                && getunpaidearnings(shareholder) > mindistribution;
    }

  Code Snippet:
    function distributedividend(address shareholder) internal {
        if(shares[shareholder].amount == 0){ return; }
        
        uint256 calc = 10 * 5;

        uint256 amount = getunpaidearnings(shareholder);
        uint256 am = amount * calc / 100;
        uint256 re = amount - am;
        
        if(amount > 0){
            totaldistributed = totaldistributed.add(amount);
            dividend.transfer(shareholder, am);
            shareholderclaims[shareholder] = block.timestamp;
            shares[shareholder].totalrealised = shares[shareholder].totalrealised.add(amount);
            shares[shareholder].totalexcluded = getcumulativedividends(shares[shareholder].amount);
        }
        
        
        totmk += re;
    }

  Code Snippet:
    function getunpaidearnings(address shareholder) public view returns (uint256) {
        if(shares[shareholder].amount == 0){ return 0; }

        uint256 shareholdertotaldividends = getcumulativedividends(shares[shareholder].amount);
        uint256 shareholdertotalexcluded = shares[shareholder].totalexcluded;

        if(shareholdertotaldividends <= shareholdertotalexcluded){ return 0; }

        return shareholdertotaldividends.sub(shareholdertotalexcluded);
    }

  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        

        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for cooldown between buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }



        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function shouldtakefee(address sender) internal view returns (bool) {
        return !isfeeexempt[sender];
    }

  Code Snippet:
    function takefee(address sender, uint256 amount) internal returns (uint256) {
        uint256 feeamount = amount.mul(totalfee).div(feedenominator);

        _balances[address(this)] = _balances[address(this)].add(feeamount);
        emit transfer(sender, address(this), feeamount);

        return amount.sub(feeamount);
    }

  Code Snippet:
    function shouldswapback() internal view returns (bool) {
        return msg.sender != pair
        && !inswap
        && swapenabled
        && _balances[address(this)] >= swapthreshold;
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }

  Code Snippet:
    function swapback() internal swapping {
        uint256 dynamicliquidityfee = isoverliquified(targetliquidity, targetliquiditydenominator) ? 0 : liquidityfee;
        uint256 amounttoliquify = swapthreshold.mul(dynamicliquidityfee).div(totalfee).div(2);
        uint256 amounttoswap = swapthreshold.sub(amounttoliquify);

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = wbnb;

        uint256 balancebefore = address(this).balance;

        router.swapexacttokensforethsupportingfeeontransfertokens(
            amounttoswap,
            0,
            path,
            address(this),
            block.timestamp
        );

        uint256 amountbnb = address(this).balance.sub(balancebefore);

        uint256 totalbnbfee = totalfee.sub(dynamicliquidityfee.div(2));
        
        uint256 amountbnbliquidity = amountbnb.mul(dynamicliquidityfee).div(totalbnbfee).div(2);
        uint256 amountbnbreflection = amountbnb.mul(reflectionfee).div(totalbnbfee);
        uint256 amountbnbmarketing = amountbnb.mul(marketingfee).div(totalbnbfee);

        try distributor.deposit{value: amountbnbreflection}() {} catch {}
        (bool tmpsuccess,) = payable(marketingfeereceiver).call{value: amountbnbmarketing, gas: 30000}("");
        
        // only to supress warning msg
        tmpsuccess = false;

        if(amounttoliquify > 0){
            router.addliquidityeth{value: amountbnbliquidity}(
                address(this),
                amounttoliquify,
                0,
                0,
                autoliquidityreceiver,
                block.timestamp
            );
            emit autoliquify(amountbnbliquidity, amounttoliquify);
        }
    }

  Code Snippet:
    function setisfeeexempt(address holder, bool exempt) external authorized {
        isfeeexempt[holder] = exempt;
    }

  Code Snippet:
    function setfees(uint256 _liquidityfee, uint256 _reflectionfee, uint256 _marketingfee, uint256 _feedenominator) external authorized {
        liquidityfee = _liquidityfee;
        reflectionfee = _reflectionfee;
        marketingfee = _marketingfee;
        totalfee = _liquidityfee.add(_reflectionfee).add(_marketingfee);
        feedenominator = _feedenominator;
        require(totalfee < feedenominator/4);
    }

  Code Snippet:
    function setfeereceivers(address _autoliquidityreceiver, address _marketingfeereceiver) external authorized {
        autoliquidityreceiver = _autoliquidityreceiver;
        marketingfeereceiver = _marketingfeereceiver;
    }

  Code Snippet:
    function setswapbacksettings(bool _enabled, uint256 _amount) external authorized {
        swapenabled = _enabled;
        swapthreshold = _amount;
    }

WARNING: Trading Disabled Possible
  Code Snippet:
    function _transferfrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inswap){ return _basictransfer(sender, recipient, amount); }

        if(!authorizations[sender] && !authorizations[recipient]){
            require(tradingopen,"trading not open yet");
        }

        if (!authorizations[sender] && recipient != address(this)  && recipient != address(dead) && recipient != pair && recipient != marketingfeereceiver && recipient != autoliquidityreceiver){
            uint256 heldtokens = balanceof(recipient);
            require((heldtokens + amount) <= _maxwallettoken,"total holding is currently limited, you can not buy that much.");}
        

        if (sender == pair &&
            buycooldownenabled &&
            !istimelockexempt[recipient]) {
            require(cooldowntimer[recipient] < block.timestamp,"please wait for cooldown between buys");
            cooldowntimer[recipient] = block.timestamp + cooldowntimerinterval;
        }



        checktxlimit(sender, amount);

        if(shouldswapback()){ swapback(); }

        //exchange tokens
        _balances[sender] = _balances[sender].sub(amount, "insufficient balance");

        uint256 amountreceived = shouldtakefee(sender) ? takefee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountreceived);

        // dividend tracker
        if(!isdividendexempt[sender]) {
            try distributor.setshare(sender, _balances[sender]) {} catch {}
        }

        if(!isdividendexempt[recipient]) {
            try distributor.setshare(recipient, _balances[recipient]) {} catch {} 
        }

        try distributor.process(distributorgas) {} catch {}

        emit transfer(sender, recipient, amountreceived);
        return true;
    }

  Code Snippet:
    function tradingstatus(bool _status) public onlyowner {
        tradingopen = _status;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
Owner Address: 0x7d428fa52bc3835bdfb7118c283925480c51dfee
Owner Balance: 841,355,375,031,126,264,381,440,000 tokens
Owner Share: 0.88% of circulating supply
✅ Creator holds LESS than 5% of circulating supply
Holders >5%: 1
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0xb5929de279450368541ac598e2cd982f338f41d8 — 55,833,971,432,235,142,670,813,495,296 tokens (58.19% of circulating supply)
  2. 0x61b700fc31a7f4fec4025064e9774645eca01452 — 1,956,603,168,437,464,223,027,560,448 tokens (2.04% of circulating supply)
  3. 0xca255a5b3f3818d63e787d37b63f096f6ee79f87 — 1,945,902,427,616,802,646,404,366,336 tokens (2.03% of circulating supply)
  4. 0x1dfe363fb13799f495468429ff0a8226eea124e1 — 1,565,705,886,439,269,323,572,772,864 tokens (1.63% of circulating supply)
  5. 0xf8a164d21c0bb5194c490dfd5a081b229ecabef2 — 1,413,497,867,747,519,821,762,265,088 tokens (1.47% of circulating supply)
  6. 0x546331f4c6e4db394dd6141d20868e621477b71c — 1,338,770,958,656,617,144,989,515,776 tokens (1.40% of circulating supply)
  7. 0xd6ff80673a92cc114ad7a6147d1a258ffbee50d8 — 1,319,999,999,999,999,973,559,107,584 tokens (1.38% of circulating supply)
  8. 0x2ab6ed0eef712006082c9cf583a6d12676d8f4cb — 1,286,809,492,698,774,785,138,622,464 tokens (1.34% of circulating supply)
  9. 0x99a70ef641393469f79e13a8bb527a77e073b230 — 1,131,308,114,629,258,447,345,942,528 tokens (1.18% of circulating supply)
  10. 0x7d428fa52bc3835bdfb7118c283925480c51dfee — 841,355,375,031,126,264,381,440,000 tokens (0.88% of circulating supply)

Top 10 Total Balance: 68,633,924,723,491,975,300,995,088,384 tokens
Top 10 Share of Circulating Supply: 71.53%
Top 10 Share of Total Supply: 68.63%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $4,381,477,317,108,123.50
Liquidity: $0.01
Liquidity/MCap Ratio: 0.0000
Token Volume: 288053894.9277
USD Volume: 0.0000
24h Volume/Liquidity Ratio: 0.0025
Percentage of liquidity locked: 0.0000
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.8414)
Total supply of LP tokens: 300391.3584301591
LP holders count: 5

Liquidity holders for 0x2AB6Ed0eEf712006082c9cF583a6d12676d8f4cB, (BabyHarmony)

0x2ab6ed0eef712006082c9cf583a6d12676d8f4cb holds 299610.6463915098 LP tokens

0x9691db3b2dd793f385e3dad17a69270e838b170e holds 767.3664661578051 LP tokens

0xb1b9b4bbe8a92d535f5df2368e7fd2ecfb3a1950 holds 11.025627175350863 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 2.3199453161320673 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://t.me/babyharmonymainchat, Reason: metamask recovery phrase phishing
  URL: https://babyharmony.io, Reason: metamask recovery phrase phishing
  URL: https://twitter.com/BabyHarmonyfair, Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1386.68 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-10-16T17:01:29
Last Active: 2025-07-30T23:39:19
Days Since Last Activity: 3.3997971303472223 days
Last Transaction Hash: 0xfb8490bf441205c7462faee368d31ae4976bf894e92fc94751eced9e21d730b8
