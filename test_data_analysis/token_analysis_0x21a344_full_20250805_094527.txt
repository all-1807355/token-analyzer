Token Analysis Report
==================================================
Token: WolfyToken (0x21a3440ce7D17C7c9AF110431af45A51a0Fc55bC)
Chain: BSC
Contract Analysis
-----------------
Verified: OK!
Owner Address: None
Creator Address: None
Is Proxy: No
Is sellable (no honeypot): Yes
Is owner hardcoded: No

Code Analysis Findings:
WARNING: Ownership Renounced
  Code Snippet:
    function renounceownership() public virtual onlyowner {
        emit ownershiptransferred(_owner, address(0));
        _owner = address(0);
    }

WARNING: High Tax Detected
  Code Snippet:
    function totalfees() public view returns (uint256) {
        return _tfeetotal;
    }

  Code Snippet:
    function deliver(uint256 tamount) public {
        address sender = _msgsender();
        require(!_isexcluded[sender], "excluded addresses cannot call this function");
        (uint256 ramount,,,,,) = _getvalues(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rtotal = _rtotal.sub(ramount);
        _tfeetotal = _tfeetotal.add(tamount);
    }

  Code Snippet:
    function reflectionfromtoken(uint256 tamount, bool deducttransferfee) public view returns(uint256) {
        require(tamount <= _ttotal, "amount must be less than supply");
        if (!deducttransferfee) {
            (uint256 ramount,,,,,) = _getvalues(tamount);
            return ramount;
        } else {
            (,uint256 rtransferamount,,,,) = _getvalues(tamount);
            return rtransferamount;
        }
    }

  Code Snippet:
    function _transferstandard(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);       
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transfertoexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);           
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferfromexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);   
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _transferbothexcluded(address sender, address recipient, uint256 tamount) private {
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee, uint256 ttransferamount, uint256 tfee, uint256 tburn) = _getvalues(tamount);
        uint256 rburn =  tburn.mul(currentrate);
        _towned[sender] = _towned[sender].sub(tamount);
        _rowned[sender] = _rowned[sender].sub(ramount);
        _towned[recipient] = _towned[recipient].add(ttransferamount);
        _rowned[recipient] = _rowned[recipient].add(rtransferamount);        
        _reflectfee(rfee, rburn, tfee, tburn);
        emit transfer(sender, recipient, ttransferamount);
    }

  Code Snippet:
    function _reflectfee(uint256 rfee, uint256 rburn, uint256 tfee, uint256 tburn) private {
        _rtotal = _rtotal.sub(rfee).sub(rburn);
        _tfeetotal = _tfeetotal.add(tfee);
        _tburntotal = _tburntotal.add(tburn);
        _ttotal = _ttotal.sub(tburn);
    }

  Code Snippet:
    function _getvalues(uint256 tamount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 ttransferamount, uint256 tfee, uint256 tburn) = _gettvalues(tamount, _taxfee, _burnfee);
        uint256 currentrate =  _getrate();
        (uint256 ramount, uint256 rtransferamount, uint256 rfee) = _getrvalues(tamount, tfee, tburn, currentrate);
        return (ramount, rtransferamount, rfee, ttransferamount, tfee, tburn);
    }

  Code Snippet:
    function _gettvalues(uint256 tamount, uint256 taxfee, uint256 burnfee) private pure returns (uint256, uint256, uint256) {
        uint256 tfee = ((tamount.mul(taxfee)).div(100)).div(100);
        uint256 tburn = ((tamount.mul(burnfee)).div(100)).div(100);
        uint256 ttransferamount = tamount.sub(tfee).sub(tburn);
        return (ttransferamount, tfee, tburn);
    }

  Code Snippet:
    function _getrvalues(uint256 tamount, uint256 tfee, uint256 tburn, uint256 currentrate) private pure returns (uint256, uint256, uint256) {
        uint256 ramount = tamount.mul(currentrate);
        uint256 rfee = tfee.mul(currentrate);
        uint256 rburn = tburn.mul(currentrate);
        uint256 rtransferamount = ramount.sub(rfee).sub(rburn);
        return (ramount, rtransferamount, rfee);
    }

  Code Snippet:
    function _gettaxfee() public view returns(uint256) {
        return _taxfee;
    }

  Code Snippet:
    function _getburnfee() public view returns(uint256) {
        return _burnfee;
    }

  Code Snippet:
function tax_fee(uint256 taxfee) external onlyowner() {
        require(taxfee <=500 ); //limit taxfee to 1%
        _taxfee = taxfee;
    }

  Code Snippet:
    function burn_fee(uint256 burnfee) external onlyowner() {
        require(burnfee <=500 ); //limit burnfee to 1% 
        _burnfee = burnfee;
    }


Holder Analysis
--------------
Total Unique Holders: 200
⚠️ Owner information is not available (possibly hidden or unverified)
⚠️ Creator information is not available (possibly hidden or unverified)
Holders >5%: 2
⚠️ Some holders exceed 5% of supply

Top 10 Token Holders:
  1. 0x0ed943ce24baebf257488771759f9bf482c39706 — 464,648,869,901,567,895,707,582,464 tokens (60.14% of circulating supply)
  2. 0x2c3c8864b3466c633b6a13059078f83877a5673a — 164,688,803,197,397,042,657,755,136 tokens (21.31% of circulating supply)
  3. 0x5cc68a81adce7352188c55033f7c96b874ffb402 — 20,454,219,777,010,618,421,215,232 tokens (2.65% of circulating supply)
  4. 0x16437e4f67b394d03ffeba3d71de7fb8dac60c4a — 12,973,460,664,336,994,464,169,984 tokens (1.68% of circulating supply)
  5. 0x548e03c19a175a66912685f71e157706fee6a04d — 11,999,999,999,999,999,798,673,408 tokens (1.55% of circulating supply)
  6. 0x33347db7dc04cbcef309a0b5b9a9f9eb6b7ce4c2 — 10,201,332,581,242,050,904,588,288 tokens (1.32% of circulating supply)
  7. 0xfc27c999c16a89c72cb3702f864967d6255601b7 — 9,502,486,076,692,373,801,271,296 tokens (1.23% of circulating supply)
  8. 0x7536592bb74b5d62eb82e8b93b17eed4eed9a85c — 6,479,375,083,172,900,565,417,984 tokens (0.84% of circulating supply)
  9. 0xe0438637afd43ba318f6dfa7b0218c91ca164d90 — 5,000,000,000,000,000,452,984,832 tokens (0.65% of circulating supply)
  10. 0x48aa63c01c7e35f3f8ffc322c8ca69a0adffbd36 — 4,610,356,747,600,226,720,677,888 tokens (0.60% of circulating supply)

Top 10 Total Balance: 710,558,904,029,020,103,494,336,512 tokens
Top 10 Share of Circulating Supply: 91.96%
Top 10 Share of Total Supply: 90.38%
✅ Top 10 holders control LESS than 70% of circulating supply

Liquidity Analysis
-----------------
Market Cap: $24,953,421,830,899.19
Liquidity: $0.00
Liquidity/MCap Ratio: 0.0000
Percentage of liquidity locked: 94.7300
Was 95% of liquidity locked for more than 15 days?: False
Secure
Creator owns under 5% of LP tokens: True (0.0)
Total supply of LP tokens: 60.673362182430395
LP holders count: 3

Liquidity holders for 0x21a3440ce7D17C7c9AF110431af45A51a0Fc55bC, (WolfyToken)

0x000000000000000000000000000000000000dead holds 57.47589129365459 LP tokens

0x0ed943ce24baebf257488771759f9bf482c39706 holds 3.197470888775798 LP tokens

0x0000000000000000000000000000000000000000 holds 1e-15 LP tokens
⚠️ Liquidity analysis error: Liquidity pool info could not be retrieved.

Security Analysis
-----------------
⚠️ Suspicious URL(s) found in the contract.
  URL: https://github.com/ethereum/solidity/issues/2691, Reason: metamask recovery phrase phishing
  URL: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729, Reason: metamask recovery phrase phishing
  URL: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522, Reason: metamask recovery phrase phishing
  URL: https://eips.ethereum.org/EIPS/eip-1884[EIP1884], Reason: metamask recovery phrase phishing
  URL: https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions, Reason: metamask recovery phrase phishing
  URL: https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`]., Reason: metamask recovery phrase phishing

Lifecycle Analysis
-------------
Token Age: 1510.54 days
Time to First Trade: 0.00 hours
Blocks to First Trade: 0
Token Creation Date: 2021-06-16T20:42:19
Last Active: 2024-04-07T03:47:33
Days Since Last Activity: 485.2485474910301 days
Last Transaction Hash: 0x66a3513d785fae2e44a97873afc3a9e93bd6bce22d621cb711202f96435ac849
