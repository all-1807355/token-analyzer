{
  "total_matches": 6,
  "patterns_found": {
    "minting_mechanics": {
      "count": 6,
      "snippets": [
        {
          "matched_code": "_mint(msg.sender, 2 * 1e18)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {ERC20} from \\\"erc20/ERC20.sol\\\";\\nimport {IOPNToken} from \\\"./interfaces/IOPNToken.sol\\\";\\n\\n/// @title OPNToken\\n/// @author The OPN Ecosystem Team\\ncontract OPNToken is IOPNToken, ERC20 {\\n    string public constant NAME = \\\"Open Ecosystem Token\\\";\\n    string public constant SYMBOL = \\\"OPN\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override mintManagerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override daoControllerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    bool public override migrationIssuanceDisabledPermanently = false;\\n\\n    constructor(address _initialController) ERC20(NAME, SYMBOL, DECIMALS) {\\n        daoControllerAddress = _initialController;\\n        // mint 2 tokens for bridge registrations and testing post migration\\n        _mint(msg.sender, 2 * 1e18);\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyMintManager() {\\n        require(\\n            msg.sender == mintManagerAddress,\\n            \\\"OPNToken: UNAUTHORIZED MINT MANAGER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDAOController() {\\n        require(\\n            msg.sender == daoControllerAddress,\\n            \\\"OPNToken: UNAUTHORIZED DAO CONTROLLER\\\"\\n        );\\n        _;\\n    }\\n\\n    // Operational functions for migration\\n\\n    /// @inheritdoc IOPNToken\\n    function issueTokensMigration(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyMintManager {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationMint(_to, _amount);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokenPolygonInventory(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationInventoryMint(_to, _amount);\\n    }\\n\\n    // Operational functions for DAO post operations\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokensByDAO(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        _mint(_to, _amount);\\n        emit DaoMint(_to, _amount);\\n    }\\n\\n    // Operational functions for token holders\\n\\n    /// @inheritdoc IOPNToken\\n    function burn(uint256 _amount) external override {\\n        _burn(msg.sender, _amount);\\n        emit TokensBurned(msg.sender, _amount);\\n    }\\n\\n    // Configuration functions\\n\\n    /// @inheritdoc IOPNToken\\n    function setDAOControllerAddress(\\n        address _newDaoController\\n    ) external override onlyDAOController {\\n        daoControllerAddress = _newDaoController;\\n        emit DaoControllerSet(_newDaoController);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function finalizeMigration() external override onlyDAOController {\\n        migrationIssuanceDisabledPermanently = true;\\n        delete mintManagerAddress;\\n        emit MigrationConfigFinalized();\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function setMintManager(\\n        address _newMigrationManager\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        mintManagerAddress = _newMigrationManager;\\n        emit MigrationManagerSet(_newMigrationManager);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {ERC20} from \\\"erc20/ERC20.sol\\\";\\nimport {IOPNToken} from \\\"./interfaces/IOPNToken.sol\\\";\\n\\n/// @title OPNToken\\n/// @author The OPN Ecosystem Team\\ncontract OPNToken is IOPNToken, ERC20 {\\n    string public constant NAME = \\\"Open Ecosystem Token\\\";\\n    string public constant SYMBOL = \\\"OPN\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override mintManagerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override daoControllerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    bool public override migrationIssuanceDisabledPermanently = false;\\n\\n    constructor(address _initialController) ERC20(NAME, SYMBOL, DECIMALS) {\\n        daoControllerAddress = _initialController;\\n        // mint 2 tokens for bridge registrations and testing post migration\\n        _mint(msg.sender, 2 * 1e18);\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyMintManager() {\\n        require(\\n            msg.sender == mintManagerAddress,\\n            \\\"OPNToken: UNAUTHORIZED MINT MANAGER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDAOController() {\\n        require(\\n            msg.sender == daoControllerAddress,\\n            \\\"OPNToken: UNAUTHORIZED DAO CONTROLLER\\\"\\n        );\\n        _;\\n    }\\n\\n    // Operational functions for migration\\n\\n    /// @inheritdoc IOPNToken\\n    function issueTokensMigration(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyMintManager {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationMint(_to, _amount);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokenPolygonInventory(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationInventoryMint(_to, _amount);\\n    }\\n\\n    // Operational functions for DAO post operations\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokensByDAO(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        _mint(_to, _amount);\\n        emit DaoMint(_to, _amount);\\n    }\\n\\n    // Operational functions for token holders\\n\\n    /// @inheritdoc IOPNToken\\n    function burn(uint256 _amount) external override {\\n        _burn(msg.sender, _amount);\\n        emit TokensBurned(msg.sender, _amount);\\n    }\\n\\n    // Configuration functions\\n\\n    /// @inheritdoc IOPNToken\\n    function setDAOControllerAddress(\\n        address _newDaoController\\n    ) external override onlyDAOController {\\n        daoControllerAddress = _newDaoController;\\n        emit DaoControllerSet(_newDaoController);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function finalizeMigration() external override onlyDAOController {\\n        migrationIssuanceDisabledPermanently = true;\\n        delete mintManagerAddress;\\n        emit MigrationConfigFinalized();\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function setMintManager(\\n        address _newMigrationManager\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        mintManagerAddress = _newMigrationManager;\\n        emit MigrationManagerSet(_newMigrationManager);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {ERC20} from \\\"erc20/ERC20.sol\\\";\\nimport {IOPNToken} from \\\"./interfaces/IOPNToken.sol\\\";\\n\\n/// @title OPNToken\\n/// @author The OPN Ecosystem Team\\ncontract OPNToken is IOPNToken, ERC20 {\\n    string public constant NAME = \\\"Open Ecosystem Token\\\";\\n    string public constant SYMBOL = \\\"OPN\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override mintManagerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override daoControllerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    bool public override migrationIssuanceDisabledPermanently = false;\\n\\n    constructor(address _initialController) ERC20(NAME, SYMBOL, DECIMALS) {\\n        daoControllerAddress = _initialController;\\n        // mint 2 tokens for bridge registrations and testing post migration\\n        _mint(msg.sender, 2 * 1e18);\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyMintManager() {\\n        require(\\n            msg.sender == mintManagerAddress,\\n            \\\"OPNToken: UNAUTHORIZED MINT MANAGER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDAOController() {\\n        require(\\n            msg.sender == daoControllerAddress,\\n            \\\"OPNToken: UNAUTHORIZED DAO CONTROLLER\\\"\\n        );\\n        _;\\n    }\\n\\n    // Operational functions for migration\\n\\n    /// @inheritdoc IOPNToken\\n    function issueTokensMigration(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyMintManager {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationMint(_to, _amount);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokenPolygonInventory(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationInventoryMint(_to, _amount);\\n    }\\n\\n    // Operational functions for DAO post operations\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokensByDAO(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        _mint(_to, _amount);\\n        emit DaoMint(_to, _amount);\\n    }\\n\\n    // Operational functions for token holders\\n\\n    /// @inheritdoc IOPNToken\\n    function burn(uint256 _amount) external override {\\n        _burn(msg.sender, _amount);\\n        emit TokensBurned(msg.sender, _amount);\\n    }\\n\\n    // Configuration functions\\n\\n    /// @inheritdoc IOPNToken\\n    function setDAOControllerAddress(\\n        address _newDaoController\\n    ) external override onlyDAOController {\\n        daoControllerAddress = _newDaoController;\\n        emit DaoControllerSet(_newDaoController);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function finalizeMigration() external override onlyDAOController {\\n        migrationIssuanceDisabledPermanently = true;\\n        delete mintManagerAddress;\\n        emit MigrationConfigFinalized();\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function setMintManager(\\n        address _newMigrationManager\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        mintManagerAddress = _newMigrationManager;\\n        emit MigrationManagerSet(_newMigrationManager);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport {ERC20} from \\\"erc20/ERC20.sol\\\";\\nimport {IOPNToken} from \\\"./interfaces/IOPNToken.sol\\\";\\n\\n/// @title OPNToken\\n/// @author The OPN Ecosystem Team\\ncontract OPNToken is IOPNToken, ERC20 {\\n    string public constant NAME = \\\"Open Ecosystem Token\\\";\\n    string public constant SYMBOL = \\\"OPN\\\";\\n    uint8 public constant DECIMALS = 18;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override mintManagerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    address public override daoControllerAddress;\\n\\n    /// @inheritdoc IOPNToken\\n    bool public override migrationIssuanceDisabledPermanently = false;\\n\\n    constructor(address _initialController) ERC20(NAME, SYMBOL, DECIMALS) {\\n        daoControllerAddress = _initialController;\\n        // mint 2 tokens for bridge registrations and testing post migration\\n        _mint(msg.sender, 2 * 1e18);\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyMintManager() {\\n        require(\\n            msg.sender == mintManagerAddress,\\n            \\\"OPNToken: UNAUTHORIZED MINT MANAGER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDAOController() {\\n        require(\\n            msg.sender == daoControllerAddress,\\n            \\\"OPNToken: UNAUTHORIZED DAO CONTROLLER\\\"\\n        );\\n        _;\\n    }\\n\\n    // Operational functions for migration\\n\\n    /// @inheritdoc IOPNToken\\n    function issueTokensMigration(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyMintManager {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationMint(_to, _amount);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokenPolygonInventory(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        _mint(_to, _amount);\\n        emit MigrationInventoryMint(_to, _amount);\\n    }\\n\\n    // Operational functions for DAO post operations\\n\\n    /// @inheritdoc IOPNToken\\n    function mintTokensByDAO(\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyDAOController {\\n        _mint(_to, _amount);\\n        emit DaoMint(_to, _amount);\\n    }\\n\\n    // Operational functions for token holders\\n\\n    /// @inheritdoc IOPNToken\\n    function burn(uint256 _amount) external override {\\n        _burn(msg.sender, _amount);\\n        emit TokensBurned(msg.sender, _amount);\\n    }\\n\\n    // Configuration functions\\n\\n    /// @inheritdoc IOPNToken\\n    function setDAOControllerAddress(\\n        address _newDaoController\\n    ) external override onlyDAOController {\\n        daoControllerAddress = _newDaoController;\\n        emit DaoControllerSet(_newDaoController);\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function finalizeMigration() external override onlyDAOController {\\n        migrationIssuanceDisabledPermanently = true;\\n        delete mintManagerAddress;\\n        emit MigrationConfigFinalized();\\n    }\\n\\n    /// @inheritdoc IOPNToken\\n    function setMintManager(\\n        address _newMigrationManager\\n    ) external override onlyDAOController {\\n        require(\\n            !migrationIssuanceDisabledPermanently,\\n            \\\"OPNToken: MIGRATION MINTING DISABLED PERMANENTLY\\\"\\n        );\\n        mintManagerAddress = _newMigrationManager;\\n        emit MigrationManagerSet(_newMigrationManager);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address recipient_, uint256 amount_)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551          \u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551         \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\\n*/\\n\\n/**\\n *  @title Modern ERC-20 implementation.\\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\\n */\\ncontract ERC20 is IERC20 {\\n\\n    /**************/\\n    /*** ERC-20 ***/\\n    /**************/\\n\\n    string public override name;\\n    string public override symbol;\\n\\n    uint8 public immutable override decimals;\\n\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /****************/\\n    /*** ERC-2612 ***/\\n    /****************/\\n\\n    // PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    uint256 internal immutable initialChainId;\\n\\n    bytes32 internal immutable initialDomainSeparator;\\n\\n    mapping(address => uint256) public override nonces;\\n\\n    /**\\n     *  @param name_     The name of the token.\\n     *  @param symbol_   The symbol of the token.\\n     *  @param decimals_ The decimal precision used by the token.\\n     */\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        name     = name_;\\n        symbol   = symbol_;\\n        decimals = decimals_;\\n        initialChainId = block.chainid;\\n        initialDomainSeparator = _computeDomainSeparator();\\n    }\\n\\n    /**************************/\\n    /*** External Functions ***/\\n    /**************************/\\n\\n    function approve(address spender_, uint256 amount_) external override returns (bool success_) {\\n        _approve(msg.sender, spender_, amount_);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external override returns (bool success_) {\\n        _decreaseAllowance(msg.sender, spender_, subtractedAmount_);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender_, uint256 addedAmount_) external override returns (bool success_) {\\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\\n        return true;\\n    }\\n\\n    function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {\\n        require(deadline_ >= block.timestamp, \\\"ERC20:P:EXPIRED\\\");\\n\\n        // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.\\n        require(\\n            uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&\\n            (v_ == 27 || v_ == 28),\\n            \\\"ERC20:P:MALLEABLE\\\"\\n        );\\n\\n        // Nonce realistically cannot overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v_, r_, s_);\\n\\n            require(recoveredAddress == owner_ && owner_ != address(0), \\\"ERC20:P:INVALID_SIGNATURE\\\");\\n        }\\n\\n        _approve(owner_, spender_, amount_);\\n    }\\n\\n    function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\\n        _transfer(msg.sender, recipient_, amount_);\\n        return true;\\n    }\\n\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {\\n        _decreaseAllowance(owner_, msg.sender, amount_);\\n        _transfer(owner_, recipient_, amount_);\\n        return true;\\n    }\\n\\n    /**********************/\\n    /*** View Functions ***/\\n    /**********************/\\n\\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32 domainSeparator_) {\\n        return block.chainid == initialChainId ? initialDomainSeparator : _computeDomainSeparator();\\n    }\\n\\n    /**************************/\\n    /*** Internal Functions ***/\\n    /**************************/\\n\\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\\n        emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\\n    }\\n\\n    function _burn(address owner_, uint256 amount_) internal virtual {\\n        balanceOf[owner_] -= amount_;\\n\\n        // Cannot underflow because a user's balance will never be larger than the total supply.\\n        unchecked { totalSupply -= amount_; }\\n\\n        emit Transfer(owner_, address(0), amount_);\\n    }\\n\\n    function _computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator_) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _decreaseAllowance(address owner_, address spender_, uint256 subtractedAmount_) internal {\\n        uint256 spenderAllowance = allowance[owner_][spender_];  // Cache to memory.\\n\\n        if (spenderAllowance != type(uint256).max) {\\n            _approve(owner_, spender_, spenderAllowance - subtractedAmount_);\\n        }\\n    }\\n\\n    function _mint(address recipient_, uint256 amount_) internal virtual {\\n        totalSupply += amount_;\\n\\n        // Cannot overflow because totalSupply would first overflow in the statement above.\\n        unchecked { balanceOf[recipient_] += amount_; }\\n\\n        emit Transfer(address(0), recipient_, amount_);\\n    }\\n\\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal virtual {\\n        balanceOf[owner_] -= amount_;\\n\\n        // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances == totalSupply.\\n        unchecked { balanceOf[recipient_] += amount_; }\\n\\n        emit Transfer(owner_, recipient_, amount_);\\n    }\\n\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.7;\\n\\nimport { IERC20 } from \\\"./interfaces/IERC20.sol\\\";\\n\\n/*\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2588\u2588\u2557\\n    \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551          \u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2551\\n    \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551         \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\n    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\\n*/\\n\\n/**\\n *  @title Modern ERC-20 implementation.\\n *  @dev   Acknowledgements to Solmate, OpenZeppelin, and DSS for inspiring this code.\\n */\\ncontract ERC20 is IERC20 {\\n\\n    /**************/\\n    /*** ERC-20 ***/\\n    /**************/\\n\\n    string public override name;\\n    string public override symbol;\\n\\n    uint8 public immutable override decimals;\\n\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /****************/\\n    /*** ERC-2612 ***/\\n    /****************/\\n\\n    // PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 private constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    uint256 internal immutable initialChainId;\\n\\n    bytes32 internal immutable initialDomainSeparator;\\n\\n    mapping(address => uint256) public override nonces;\\n\\n    /**\\n     *  @param name_     The name of the token.\\n     *  @param symbol_   The symbol of the token.\\n     *  @param decimals_ The decimal precision used by the token.\\n     */\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n        name     = name_;\\n        symbol   = symbol_;\\n        decimals = decimals_;\\n        initialChainId = block.chainid;\\n        initialDomainSeparator = _computeDomainSeparator();\\n    }\\n\\n    /**************************/\\n    /*** External Functions ***/\\n    /**************************/\\n\\n    function approve(address spender_, uint256 amount_) external override returns (bool success_) {\\n        _approve(msg.sender, spender_, amount_);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender_, uint256 subtractedAmount_) external override returns (bool success_) {\\n        _decreaseAllowance(msg.sender, spender_, subtractedAmount_);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender_, uint256 addedAmount_) external override returns (bool success_) {\\n        _approve(msg.sender, spender_, allowance[msg.sender][spender_] + addedAmount_);\\n        return true;\\n    }\\n\\n    function permit(address owner_, address spender_, uint256 amount_, uint256 deadline_, uint8 v_, bytes32 r_, bytes32 s_) external override {\\n        require(deadline_ >= block.timestamp, \\\"ERC20:P:EXPIRED\\\");\\n\\n        // Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}.\\n        require(\\n            uint256(s_) <= uint256(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) &&\\n            (v_ == 27 || v_ == 28),\\n            \\\"ERC20:P:MALLEABLE\\\"\\n        );\\n\\n        // Nonce realistically cannot overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner_, spender_, amount_, nonces[owner_]++, deadline_))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v_, r_, s_);\\n\\n            require(recoveredAddress == owner_ && owner_ != address(0), \\\"ERC20:P:INVALID_SIGNATURE\\\");\\n        }\\n\\n        _approve(owner_, spender_, amount_);\\n    }\\n\\n    function transfer(address recipient_, uint256 amount_) external override returns (bool success_) {\\n        _transfer(msg.sender, recipient_, amount_);\\n        return true;\\n    }\\n\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external override returns (bool success_) {\\n        _decreaseAllowance(owner_, msg.sender, amount_);\\n        _transfer(owner_, recipient_, amount_);\\n        return true;\\n    }\\n\\n    /**********************/\\n    /*** View Functions ***/\\n    /**********************/\\n\\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32 domainSeparator_) {\\n        return block.chainid == initialChainId ? initialDomainSeparator : _computeDomainSeparator();\\n    }\\n\\n    /**************************/\\n    /*** Internal Functions ***/\\n    /**************************/\\n\\n    function _approve(address owner_, address spender_, uint256 amount_) internal {\\n        emit Approval(owner_, spender_, allowance[owner_][spender_] = amount_);\\n    }\\n\\n    function _burn(address owner_, uint256 amount_) internal virtual {\\n        balanceOf[owner_] -= amount_;\\n\\n        // Cannot underflow because a user's balance will never be larger than the total supply.\\n        unchecked { totalSupply -= amount_; }\\n\\n        emit Transfer(owner_, address(0), amount_);\\n    }\\n\\n    function _computeDomainSeparator() internal view virtual returns (bytes32 domainSeparator_) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _decreaseAllowance(address owner_, address spender_, uint256 subtractedAmount_) internal {\\n        uint256 spenderAllowance = allowance[owner_][spender_];  // Cache to memory.\\n\\n        if (spenderAllowance != type(uint256).max) {\\n            _approve(owner_, spender_, spenderAllowance - subtractedAmount_);\\n        }\\n    }\\n\\n    function _mint(address recipient_, uint256 amount_) internal virtual {\\n        totalSupply += amount_;\\n\\n        // Cannot overflow because totalSupply would first overflow in the statement above.\\n        unchecked { balanceOf[recipient_] += amount_; }\\n\\n        emit Transfer(address(0), recipient_, amount_);\\n    }\\n\\n    function _transfer(address owner_, address recipient_, uint256 amount_) internal virtual {\\n        balanceOf[owner_] -= amount_;\\n\\n        // Cannot overflow because minting prevents overflow of totalSupply, and sum of user balances == totalSupply.\\n        unchecked { balanceOf[recipient_] += amount_; }\\n\\n        emit Transfer(owner_, recipient_, amount_);\\n    }\\n\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}