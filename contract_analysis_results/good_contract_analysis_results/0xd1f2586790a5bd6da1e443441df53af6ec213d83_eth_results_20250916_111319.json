{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "_mint(msg.sender, opssupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n * Ledger Ai  |  Improve Governance, Reduce Risk, and Strengthen Outcomes\\n * Ticker: $LEDGER\\n * TG: @LedgerAI_Aura\\n * X: x.com/LedgerAI_Aura\\n * Web: http://ledgerai.co/\\n */\\n\\npragma solidity 0.8.23;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./IUniswapV2Router02.sol\\\";\\nimport {IUniswapV3Router} from \\\"./IUniswapV3Router.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./IUniswapV2Factory.sol\\\";\\nimport {IUniswapV3Factory} from \\\"./IUniswapV3Factory.sol\\\";\\n\\ncontract Ledger is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    struct Tax {\\n        uint256 operationsBuyFee;\\n        uint256 operationsSellFee;\\n        uint256 marketingBuyFee;\\n        uint256 marketingSellFee;\\n        uint256 totalBuyFee;\\n        uint256 totalSellFee;\\n    }\\n\\n    Tax private TAX_STRUCTURE_1 = Tax(90, 90, 10, 10, 100, 100); // 10% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_2 = Tax(45, 45, 5, 5, 50, 50); // 5% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_3 = Tax(36, 36, 4, 4, 40, 40); // 4% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_4 = Tax(0, 45, 0, 5, 0, 50); // 0% BUY TAX, 5% SELL TAX\\n    Tax private TAX_STRUCTURE_5 = Tax(9, 9, 1, 1, 10, 10); // 1% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_FINAL = Tax(0, 0, 0, 0, 0, 0); // NO TAX\\n    Tax public CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n\\n    uint256 public maxBuyAmount;\\n    uint256 public maxSellAmount;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    IUniswapV3Router public immutable uniswapV3Router;\\n    address public uniswapV2Pair;\\n    address public uniswapV3Pair;\\n    bool private v3LPProtectionEnabled;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    address public operationsAddress;\\n    address public marketingAddress;\\n\\n    uint256 public tradingActiveBlock = 0;\\n    mapping(address => bool) public markedAsSniper;\\n\\n    bool public limitsInEffect = true;\\n    bool public tradingActive = false;\\n    bool public swapEnabled = false;\\n\\n    uint256 public tokensForOperations;\\n    uint256 public tokensForMarketing;\\n\\n    bool public oncePerBlockEnabled = true;\\n    uint256 private lastSwapBlock;\\n    uint256 public maxSwapsPerBlock = 1;\\n    uint256 private swapsThisBlock = 0;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event EnabledTrading();\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdatedOperationsAddress(address indexed newWallet);\\n    event UpdatedMarketingAddress(address indexed newWallet);\\n    event MaxTransactionExclusion(address _address, bool excluded);\\n    event OwnerForcedSwapBack(uint256 timestamp);\\n    event TransferForeignToken(address token, uint256 amount);\\n    event UpdatedTaxStructure(uint8 structure);\\n\\n    constructor(\\n        address _operationsWallet,\\n        address _marketingWallet\\n    ) payable ERC20(\\\"Ledger Ai\\\", \\\"LEDGER\\\") Ownable(msg.sender) {\\n        uint256 totalSupply = 3_141_592_654 * 1e18;\\n\\n        maxBuyAmount = (totalSupply * 2) / 100; // 2%\\n        maxSellAmount = (totalSupply * 1) / 100; // 1%\\n        swapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05 %\\n\\n        operationsAddress = address(_operationsWallet);\\n        marketingAddress = address(_marketingWallet);\\n\\n        // initialize V2 router\\n        uniswapV2Router = IUniswapV2Router02(\\n            address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\n        );\\n\\n        // initialize V3 router\\n        uniswapV3Router = IUniswapV3Router(\\n            address(0xE592427A0AEce92De3Edee1F18E0157C05861564)\\n        );\\n\\n        v3LPProtectionEnabled = true;\\n\\n        excludeFromFees(msg.sender, true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(address(0xdead), true);\\n        excludeFromFees(address(operationsAddress), true);\\n        excludeFromFees(address(marketingAddress), true);\\n\\n        uint256 opsSupply = (totalSupply * 75) / 100;\\n        uint256 lpSupply = totalSupply - opsSupply;\\n\\n        _mint(msg.sender, opsSupply);\\n        _mint(address(this), lpSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function updateTaxStructure(uint8 _structure) external onlyOwner {\\n        require(\\n            _structure > 0 && _structure <= 5,\\n            \\\"Invalid Tax Structure: Value must be 1, 2, or 3\\\"\\n        );\\n        if (_structure == 1) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n        } else if (_structure == 2) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_2;\\n        } else if (_structure == 3) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_3;\\n        } else if (_structure == 4) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_4;\\n        } else if (_structure == 5) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_5;\\n        }\\n        emit UpdatedTaxStructure(_structure);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        automatedMarketMakerPairs[pair] = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool value\\n    ) external onlyOwner {\\n        require(\\n            pair != uniswapV2Pair,\\n            \\\"The pair cannot be removed from automatedMarketMakerPairs\\\"\\n        );\\n        _setAutomatedMarketMakerPair(pair, value);\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        // require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"amount must be greater than 0\\\");\\n\\n        if (!tradingActive) {\\n            require(\\n                _isExcludedFromFees[from] || _isExcludedFromFees[to],\\n                \\\"Trading is not active.\\\"\\n            );\\n        } else {\\n            require(!markedAsSniper[from], \\\"Snipers cannot transfer tokens\\\");\\n        }\\n\\n        if (v3LPProtectionEnabled) {\\n            if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\n                require(\\n                    from != address(uniswapV3Pair) &&\\n                        to != address(uniswapV3Pair),\\n                    \\\"V3 Pool is currently protected, transfers are disabled\\\"\\n                );\\n            }\\n        }\\n\\n        if (limitsInEffect) {\\n            if (\\n                to != address(0xdead) &&\\n                !_isExcludedFromFees[from] &&\\n                !_isExcludedFromFees[to]\\n            ) {\\n                //when buy\\n                if (automatedMarketMakerPairs[from]) {\\n                    require(\\n                        amount <= maxBuyAmount,\\n                        \\\"Buy transfer amount exceeds the max buy.\\\"\\n                    );\\n                }\\n                //when sell\\n                else if (automatedMarketMakerPairs[to]) {\\n                    require(\\n                        amount <= maxSellAmount,\\n                        \\\"Sell transfer amount exceeds the max sell.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]\\n        ) {\\n            swapping = true;\\n            swapBack();\\n            swapping = false;\\n        }\\n\\n        bool takeFee = true;\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        uint256 fees = 0;\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if (takeFee) {\\n            Tax memory tax = CURRENT_TAX_STRUCTURE;\\n            // on sell\\n\\n            if (automatedMarketMakerPairs[to] && tax.totalSellFee > 0) {\\n                fees = (amount * tax.totalSellFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsSellFee) /\\n                    tax.totalSellFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingSellFee) /\\n                    tax.totalSellFee;\\n            }\\n            // on buy\\n            else if (automatedMarketMakerPairs[from] && tax.totalBuyFee > 0) {\\n                fees = (amount * tax.totalBuyFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsBuyFee) /\\n                    tax.totalBuyFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingBuyFee) /\\n                    tax.totalBuyFee;\\n            }\\n\\n            if (fees > 0) {\\n                super._update(from, address(this), fees);\\n            }\\n\\n            amount -= fees;\\n        }\\n\\n        super._update(from, to, amount);\\n    }\\n\\n    function getExpectedEthForTokens(\\n        uint256 tokenAmount\\n    ) public view returns (uint256) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(\\n            tokenAmount,\\n            path\\n        );\\n        return amounts[1];\\n    }\\n\\n    function swapTokensForEth(\\n        uint256 tokenAmount,\\n        uint256 minOutputAmount\\n    ) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            minOutputAmount,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() private {\\n        if (block.number != lastSwapBlock) {\\n            lastSwapBlock = block.number;\\n            swapsThisBlock = 0;\\n        }\\n\\n        if (oncePerBlockEnabled && swapsThisBlock >= maxSwapsPerBlock) {\\n            return;\\n        }\\n\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 totalTokensToSwap = tokensForOperations + tokensForMarketing;\\n\\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\\n            return;\\n        }\\n\\n        if (contractBalance > swapTokensAtAmount * 4) {\\n            contractBalance = swapTokensAtAmount * 4;\\n        }\\n\\n        // Calculate the minimum output amount (e.g., 95% of expected output)\\n        uint256 expectedEthOutput = getExpectedEthForTokens(contractBalance);\\n        uint256 minOutputAmount = (expectedEthOutput * 95) / 100; // 5% slippage tolerance\\n\\n        swapTokensForEth(contractBalance, minOutputAmount);\\n\\n        uint256 ethBalance = address(this).balance;\\n        uint256 ethForOperations = (ethBalance * tokensForOperations) /\\n            totalTokensToSwap;\\n\\n        tokensForOperations = 0;\\n        tokensForMarketing = 0;\\n\\n        swapsThisBlock += 1;\\n\\n        Address.sendValue(payable(operationsAddress), ethForOperations);\\n        Address.sendValue(payable(marketingAddress), address(this).balance);\\n    }\\n\\n    function transferForeignToken(\\n        address _token,\\n        address _to\\n    ) external onlyOwner returns (bool _sent) {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_to != address(0), \\\"_to address cannot be 0\\\");\\n        require(_token != address(this), \\\"Can't withdraw LedgerAI token\\\");\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(_to, _contractBalance);\\n        emit TransferForeignToken(_token, _contractBalance);\\n        return true;\\n    }\\n\\n    function setOperationsAddress(\\n        address _operationsAddress\\n    ) external onlyOwner {\\n        require(\\n            _operationsAddress != address(0),\\n            \\\"_operationsAddress address cannot be 0\\\"\\n        );\\n        operationsAddress = payable(_operationsAddress);\\n        emit UpdatedOperationsAddress(_operationsAddress);\\n    }\\n\\n    function setMarketingAddress(address _marketingAddress) external onlyOwner {\\n        require(\\n            _marketingAddress != address(0),\\n            \\\"_marketingAddress address cannot be 0\\\"\\n        );\\n        marketingAddress = payable(_marketingAddress);\\n        emit UpdatedMarketingAddress(_marketingAddress);\\n    }\\n\\n    function removeLimits() external onlyOwner {\\n        limitsInEffect = false;\\n    }\\n\\n    function restoreLimits() external onlyOwner {\\n        limitsInEffect = true;\\n    }\\n\\n    function flagSniper(address wallet) external onlyOwner {\\n        require(!markedAsSniper[wallet], \\\"Wallet is already flagged.\\\");\\n        markedAsSniper[wallet] = true;\\n    }\\n\\n    function massFlagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = true;\\n        }\\n    }\\n\\n    function unflagSniper(address wallet) external onlyOwner {\\n        require(markedAsSniper[wallet], \\\"Wallet is already not marked.\\\");\\n        markedAsSniper[wallet] = false;\\n    }\\n\\n    function massUnflagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = false;\\n        }\\n    }\\n\\n    function recoverETH() external onlyOwner {\\n        bool success;\\n        (success, ) = address(msg.sender).call{value: address(this).balance}(\\n            \\\"\\\"\\n        );\\n        require(success, \\\"Failed to recover ETH\\\");\\n    }\\n\\n    function prepareLaunch() external onlyOwner {\\n        require(!tradingActive, \\\"Trading is already active, cannot relaunch.\\\");\\n\\n        // Check if V2 pair exists, if not create it\\n        address calculatedV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n            .getPair(address(this), uniswapV2Router.WETH());\\n\\n        if (calculatedV2Pair == address(0)) {\\n            // create pair\\n            uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n                .createPair(address(this), uniswapV2Router.WETH());\\n        } else {\\n            uniswapV2Pair = calculatedV2Pair;\\n        }\\n\\n        // Check if V3 pool exists, if not create it\\n        address calculatedV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n            .getPool(\\n                address(this),\\n                uniswapV2Router.WETH(),\\n                10000 // fee tier\\n            );\\n\\n        if (calculatedV3Pair == address(0)) {\\n            uniswapV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n                .createPool(address(this), uniswapV2Router.WETH(), 10000);\\n        } else {\\n            uniswapV3Pair = calculatedV3Pair;\\n        }\\n\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\n\\n        excludeFromFees(address(uniswapV2Router), true);\\n\\n        require(\\n            address(this).balance > 0,\\n            \\\"Must have ETH on contract to launch\\\"\\n        );\\n        require(\\n            balanceOf(address(this)) > 0,\\n            \\\"Must have Tokens on contract to launch\\\"\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        _approve(address(this), address(uniswapV3Router), type(uint256).max);\\n\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            balanceOf(address(this)),\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            msg.sender,\\n            block.timestamp\\n        );\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(!tradingActive, \\\"Cannot reenable trading\\\");\\n        tradingActive = true;\\n        swapEnabled = true;\\n        tradingActiveBlock = block.number;\\n        emit EnabledTrading();\\n    }\\n\\n    function prepareForMigration() external onlyOwner {\\n        limitsInEffect = false;\\n        swapTokensAtAmount = totalSupply();\\n        CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_FINAL;\\n        maxBuyAmount = totalSupply();\\n        maxSellAmount = totalSupply();\\n        if (balanceOf(address(this)) > 0) {\\n            super._update(address(this), msg.sender, balanceOf(address(this)));\\n        }\\n    }\\n\\n    function disableV3LPProtection() external onlyOwner {\\n        require(\\n            v3LPProtectionEnabled,\\n            \\\"V3 LP Protection already disabled forever!\\\"\\n        );\\n        v3LPProtectionEnabled = false;\\n    }\\n\\n    function setSwapRestrictions(\\n        bool _enabled,\\n        uint256 _maxSwaps\\n    ) external onlyOwner {\\n        require(_maxSwaps > 0, \\\"Max swaps per block must be greater than 0\\\");\\n        oncePerBlockEnabled = _enabled;\\n        maxSwapsPerBlock = _maxSwaps;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n * Ledger Ai  |  Improve Governance, Reduce Risk, and Strengthen Outcomes\\n * Ticker: $LEDGER\\n * TG: @LedgerAI_Aura\\n * X: x.com/LedgerAI_Aura\\n * Web: http://ledgerai.co/\\n */\\n\\npragma solidity 0.8.23;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./IUniswapV2Router02.sol\\\";\\nimport {IUniswapV3Router} from \\\"./IUniswapV3Router.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./IUniswapV2Factory.sol\\\";\\nimport {IUniswapV3Factory} from \\\"./IUniswapV3Factory.sol\\\";\\n\\ncontract Ledger is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    struct Tax {\\n        uint256 operationsBuyFee;\\n        uint256 operationsSellFee;\\n        uint256 marketingBuyFee;\\n        uint256 marketingSellFee;\\n        uint256 totalBuyFee;\\n        uint256 totalSellFee;\\n    }\\n\\n    Tax private TAX_STRUCTURE_1 = Tax(90, 90, 10, 10, 100, 100); // 10% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_2 = Tax(45, 45, 5, 5, 50, 50); // 5% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_3 = Tax(36, 36, 4, 4, 40, 40); // 4% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_4 = Tax(0, 45, 0, 5, 0, 50); // 0% BUY TAX, 5% SELL TAX\\n    Tax private TAX_STRUCTURE_5 = Tax(9, 9, 1, 1, 10, 10); // 1% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_FINAL = Tax(0, 0, 0, 0, 0, 0); // NO TAX\\n    Tax public CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n\\n    uint256 public maxBuyAmount;\\n    uint256 public maxSellAmount;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    IUniswapV3Router public immutable uniswapV3Router;\\n    address public uniswapV2Pair;\\n    address public uniswapV3Pair;\\n    bool private v3LPProtectionEnabled;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    address public operationsAddress;\\n    address public marketingAddress;\\n\\n    uint256 public tradingActiveBlock = 0;\\n    mapping(address => bool) public markedAsSniper;\\n\\n    bool public limitsInEffect = true;\\n    bool public tradingActive = false;\\n    bool public swapEnabled = false;\\n\\n    uint256 public tokensForOperations;\\n    uint256 public tokensForMarketing;\\n\\n    bool public oncePerBlockEnabled = true;\\n    uint256 private lastSwapBlock;\\n    uint256 public maxSwapsPerBlock = 1;\\n    uint256 private swapsThisBlock = 0;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event EnabledTrading();\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdatedOperationsAddress(address indexed newWallet);\\n    event UpdatedMarketingAddress(address indexed newWallet);\\n    event MaxTransactionExclusion(address _address, bool excluded);\\n    event OwnerForcedSwapBack(uint256 timestamp);\\n    event TransferForeignToken(address token, uint256 amount);\\n    event UpdatedTaxStructure(uint8 structure);\\n\\n    constructor(\\n        address _operationsWallet,\\n        address _marketingWallet\\n    ) payable ERC20(\\\"Ledger Ai\\\", \\\"LEDGER\\\") Ownable(msg.sender) {\\n        uint256 totalSupply = 3_141_592_654 * 1e18;\\n\\n        maxBuyAmount = (totalSupply * 2) / 100; // 2%\\n        maxSellAmount = (totalSupply * 1) / 100; // 1%\\n        swapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05 %\\n\\n        operationsAddress = address(_operationsWallet);\\n        marketingAddress = address(_marketingWallet);\\n\\n        // initialize V2 router\\n        uniswapV2Router = IUniswapV2Router02(\\n            address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\n        );\\n\\n        // initialize V3 router\\n        uniswapV3Router = IUniswapV3Router(\\n            address(0xE592427A0AEce92De3Edee1F18E0157C05861564)\\n        );\\n\\n        v3LPProtectionEnabled = true;\\n\\n        excludeFromFees(msg.sender, true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(address(0xdead), true);\\n        excludeFromFees(address(operationsAddress), true);\\n        excludeFromFees(address(marketingAddress), true);\\n\\n        uint256 opsSupply = (totalSupply * 75) / 100;\\n        uint256 lpSupply = totalSupply - opsSupply;\\n\\n        _mint(msg.sender, opsSupply);\\n        _mint(address(this), lpSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function updateTaxStructure(uint8 _structure) external onlyOwner {\\n        require(\\n            _structure > 0 && _structure <= 5,\\n            \\\"Invalid Tax Structure: Value must be 1, 2, or 3\\\"\\n        );\\n        if (_structure == 1) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n        } else if (_structure == 2) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_2;\\n        } else if (_structure == 3) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_3;\\n        } else if (_structure == 4) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_4;\\n        } else if (_structure == 5) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_5;\\n        }\\n        emit UpdatedTaxStructure(_structure);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        automatedMarketMakerPairs[pair] = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool value\\n    ) external onlyOwner {\\n        require(\\n            pair != uniswapV2Pair,\\n            \\\"The pair cannot be removed from automatedMarketMakerPairs\\\"\\n        );\\n        _setAutomatedMarketMakerPair(pair, value);\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        // require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"amount must be greater than 0\\\");\\n\\n        if (!tradingActive) {\\n            require(\\n                _isExcludedFromFees[from] || _isExcludedFromFees[to],\\n                \\\"Trading is not active.\\\"\\n            );\\n        } else {\\n            require(!markedAsSniper[from], \\\"Snipers cannot transfer tokens\\\");\\n        }\\n\\n        if (v3LPProtectionEnabled) {\\n            if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\n                require(\\n                    from != address(uniswapV3Pair) &&\\n                        to != address(uniswapV3Pair),\\n                    \\\"V3 Pool is currently protected, transfers are disabled\\\"\\n                );\\n            }\\n        }\\n\\n        if (limitsInEffect) {\\n            if (\\n                to != address(0xdead) &&\\n                !_isExcludedFromFees[from] &&\\n                !_isExcludedFromFees[to]\\n            ) {\\n                //when buy\\n                if (automatedMarketMakerPairs[from]) {\\n                    require(\\n                        amount <= maxBuyAmount,\\n                        \\\"Buy transfer amount exceeds the max buy.\\\"\\n                    );\\n                }\\n                //when sell\\n                else if (automatedMarketMakerPairs[to]) {\\n                    require(\\n                        amount <= maxSellAmount,\\n                        \\\"Sell transfer amount exceeds the max sell.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]\\n        ) {\\n            swapping = true;\\n            swapBack();\\n            swapping = false;\\n        }\\n\\n        bool takeFee = true;\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        uint256 fees = 0;\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if (takeFee) {\\n            Tax memory tax = CURRENT_TAX_STRUCTURE;\\n            // on sell\\n\\n            if (automatedMarketMakerPairs[to] && tax.totalSellFee > 0) {\\n                fees = (amount * tax.totalSellFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsSellFee) /\\n                    tax.totalSellFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingSellFee) /\\n                    tax.totalSellFee;\\n            }\\n            // on buy\\n            else if (automatedMarketMakerPairs[from] && tax.totalBuyFee > 0) {\\n                fees = (amount * tax.totalBuyFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsBuyFee) /\\n                    tax.totalBuyFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingBuyFee) /\\n                    tax.totalBuyFee;\\n            }\\n\\n            if (fees > 0) {\\n                super._update(from, address(this), fees);\\n            }\\n\\n            amount -= fees;\\n        }\\n\\n        super._update(from, to, amount);\\n    }\\n\\n    function getExpectedEthForTokens(\\n        uint256 tokenAmount\\n    ) public view returns (uint256) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(\\n            tokenAmount,\\n            path\\n        );\\n        return amounts[1];\\n    }\\n\\n    function swapTokensForEth(\\n        uint256 tokenAmount,\\n        uint256 minOutputAmount\\n    ) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            minOutputAmount,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() private {\\n        if (block.number != lastSwapBlock) {\\n            lastSwapBlock = block.number;\\n            swapsThisBlock = 0;\\n        }\\n\\n        if (oncePerBlockEnabled && swapsThisBlock >= maxSwapsPerBlock) {\\n            return;\\n        }\\n\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 totalTokensToSwap = tokensForOperations + tokensForMarketing;\\n\\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\\n            return;\\n        }\\n\\n        if (contractBalance > swapTokensAtAmount * 4) {\\n            contractBalance = swapTokensAtAmount * 4;\\n        }\\n\\n        // Calculate the minimum output amount (e.g., 95% of expected output)\\n        uint256 expectedEthOutput = getExpectedEthForTokens(contractBalance);\\n        uint256 minOutputAmount = (expectedEthOutput * 95) / 100; // 5% slippage tolerance\\n\\n        swapTokensForEth(contractBalance, minOutputAmount);\\n\\n        uint256 ethBalance = address(this).balance;\\n        uint256 ethForOperations = (ethBalance * tokensForOperations) /\\n            totalTokensToSwap;\\n\\n        tokensForOperations = 0;\\n        tokensForMarketing = 0;\\n\\n        swapsThisBlock += 1;\\n\\n        Address.sendValue(payable(operationsAddress), ethForOperations);\\n        Address.sendValue(payable(marketingAddress), address(this).balance);\\n    }\\n\\n    function transferForeignToken(\\n        address _token,\\n        address _to\\n    ) external onlyOwner returns (bool _sent) {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_to != address(0), \\\"_to address cannot be 0\\\");\\n        require(_token != address(this), \\\"Can't withdraw LedgerAI token\\\");\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(_to, _contractBalance);\\n        emit TransferForeignToken(_token, _contractBalance);\\n        return true;\\n    }\\n\\n    function setOperationsAddress(\\n        address _operationsAddress\\n    ) external onlyOwner {\\n        require(\\n            _operationsAddress != address(0),\\n            \\\"_operationsAddress address cannot be 0\\\"\\n        );\\n        operationsAddress = payable(_operationsAddress);\\n        emit UpdatedOperationsAddress(_operationsAddress);\\n    }\\n\\n    function setMarketingAddress(address _marketingAddress) external onlyOwner {\\n        require(\\n            _marketingAddress != address(0),\\n            \\\"_marketingAddress address cannot be 0\\\"\\n        );\\n        marketingAddress = payable(_marketingAddress);\\n        emit UpdatedMarketingAddress(_marketingAddress);\\n    }\\n\\n    function removeLimits() external onlyOwner {\\n        limitsInEffect = false;\\n    }\\n\\n    function restoreLimits() external onlyOwner {\\n        limitsInEffect = true;\\n    }\\n\\n    function flagSniper(address wallet) external onlyOwner {\\n        require(!markedAsSniper[wallet], \\\"Wallet is already flagged.\\\");\\n        markedAsSniper[wallet] = true;\\n    }\\n\\n    function massFlagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = true;\\n        }\\n    }\\n\\n    function unflagSniper(address wallet) external onlyOwner {\\n        require(markedAsSniper[wallet], \\\"Wallet is already not marked.\\\");\\n        markedAsSniper[wallet] = false;\\n    }\\n\\n    function massUnflagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = false;\\n        }\\n    }\\n\\n    function recoverETH() external onlyOwner {\\n        bool success;\\n        (success, ) = address(msg.sender).call{value: address(this).balance}(\\n            \\\"\\\"\\n        );\\n        require(success, \\\"Failed to recover ETH\\\");\\n    }\\n\\n    function prepareLaunch() external onlyOwner {\\n        require(!tradingActive, \\\"Trading is already active, cannot relaunch.\\\");\\n\\n        // Check if V2 pair exists, if not create it\\n        address calculatedV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n            .getPair(address(this), uniswapV2Router.WETH());\\n\\n        if (calculatedV2Pair == address(0)) {\\n            // create pair\\n            uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n                .createPair(address(this), uniswapV2Router.WETH());\\n        } else {\\n            uniswapV2Pair = calculatedV2Pair;\\n        }\\n\\n        // Check if V3 pool exists, if not create it\\n        address calculatedV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n            .getPool(\\n                address(this),\\n                uniswapV2Router.WETH(),\\n                10000 // fee tier\\n            );\\n\\n        if (calculatedV3Pair == address(0)) {\\n            uniswapV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n                .createPool(address(this), uniswapV2Router.WETH(), 10000);\\n        } else {\\n            uniswapV3Pair = calculatedV3Pair;\\n        }\\n\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\n\\n        excludeFromFees(address(uniswapV2Router), true);\\n\\n        require(\\n            address(this).balance > 0,\\n            \\\"Must have ETH on contract to launch\\\"\\n        );\\n        require(\\n            balanceOf(address(this)) > 0,\\n            \\\"Must have Tokens on contract to launch\\\"\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        _approve(address(this), address(uniswapV3Router), type(uint256).max);\\n\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            balanceOf(address(this)),\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            msg.sender,\\n            block.timestamp\\n        );\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(!tradingActive, \\\"Cannot reenable trading\\\");\\n        tradingActive = true;\\n        swapEnabled = true;\\n        tradingActiveBlock = block.number;\\n        emit EnabledTrading();\\n    }\\n\\n    function prepareForMigration() external onlyOwner {\\n        limitsInEffect = false;\\n        swapTokensAtAmount = totalSupply();\\n        CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_FINAL;\\n        maxBuyAmount = totalSupply();\\n        maxSellAmount = totalSupply();\\n        if (balanceOf(address(this)) > 0) {\\n            super._update(address(this), msg.sender, balanceOf(address(this)));\\n        }\\n    }\\n\\n    function disableV3LPProtection() external onlyOwner {\\n        require(\\n            v3LPProtectionEnabled,\\n            \\\"V3 LP Protection already disabled forever!\\\"\\n        );\\n        v3LPProtectionEnabled = false;\\n    }\\n\\n    function setSwapRestrictions(\\n        bool _enabled,\\n        uint256 _maxSwaps\\n    ) external onlyOwner {\\n        require(_maxSwaps > 0, \\\"Max swaps per block must be greater than 0\\\");\\n        oncePerBlockEnabled = _enabled;\\n        maxSwapsPerBlock = _maxSwaps;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    },
    "stealth_fee_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "mapping(address => bool) private _isexcludedfromfee",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\n/**\\n * Ledger Ai  |  Improve Governance, Reduce Risk, and Strengthen Outcomes\\n * Ticker: $LEDGER\\n * TG: @LedgerAI_Aura\\n * X: x.com/LedgerAI_Aura\\n * Web: http://ledgerai.co/\\n */\\n\\npragma solidity 0.8.23;\\n\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./IUniswapV2Router02.sol\\\";\\nimport {IUniswapV3Router} from \\\"./IUniswapV3Router.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./IUniswapV2Factory.sol\\\";\\nimport {IUniswapV3Factory} from \\\"./IUniswapV3Factory.sol\\\";\\n\\ncontract Ledger is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    struct Tax {\\n        uint256 operationsBuyFee;\\n        uint256 operationsSellFee;\\n        uint256 marketingBuyFee;\\n        uint256 marketingSellFee;\\n        uint256 totalBuyFee;\\n        uint256 totalSellFee;\\n    }\\n\\n    Tax private TAX_STRUCTURE_1 = Tax(90, 90, 10, 10, 100, 100); // 10% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_2 = Tax(45, 45, 5, 5, 50, 50); // 5% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_3 = Tax(36, 36, 4, 4, 40, 40); // 4% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_4 = Tax(0, 45, 0, 5, 0, 50); // 0% BUY TAX, 5% SELL TAX\\n    Tax private TAX_STRUCTURE_5 = Tax(9, 9, 1, 1, 10, 10); // 1% BUY/SELL TAX\\n    Tax private TAX_STRUCTURE_FINAL = Tax(0, 0, 0, 0, 0, 0); // NO TAX\\n    Tax public CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n\\n    uint256 public maxBuyAmount;\\n    uint256 public maxSellAmount;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    IUniswapV3Router public immutable uniswapV3Router;\\n    address public uniswapV2Pair;\\n    address public uniswapV3Pair;\\n    bool private v3LPProtectionEnabled;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    address public operationsAddress;\\n    address public marketingAddress;\\n\\n    uint256 public tradingActiveBlock = 0;\\n    mapping(address => bool) public markedAsSniper;\\n\\n    bool public limitsInEffect = true;\\n    bool public tradingActive = false;\\n    bool public swapEnabled = false;\\n\\n    uint256 public tokensForOperations;\\n    uint256 public tokensForMarketing;\\n\\n    bool public oncePerBlockEnabled = true;\\n    uint256 private lastSwapBlock;\\n    uint256 public maxSwapsPerBlock = 1;\\n    uint256 private swapsThisBlock = 0;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event EnabledTrading();\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdatedOperationsAddress(address indexed newWallet);\\n    event UpdatedMarketingAddress(address indexed newWallet);\\n    event MaxTransactionExclusion(address _address, bool excluded);\\n    event OwnerForcedSwapBack(uint256 timestamp);\\n    event TransferForeignToken(address token, uint256 amount);\\n    event UpdatedTaxStructure(uint8 structure);\\n\\n    constructor(\\n        address _operationsWallet,\\n        address _marketingWallet\\n    ) payable ERC20(\\\"Ledger Ai\\\", \\\"LEDGER\\\") Ownable(msg.sender) {\\n        uint256 totalSupply = 3_141_592_654 * 1e18;\\n\\n        maxBuyAmount = (totalSupply * 2) / 100; // 2%\\n        maxSellAmount = (totalSupply * 1) / 100; // 1%\\n        swapTokensAtAmount = (totalSupply * 5) / 10000; // 0.05 %\\n\\n        operationsAddress = address(_operationsWallet);\\n        marketingAddress = address(_marketingWallet);\\n\\n        // initialize V2 router\\n        uniswapV2Router = IUniswapV2Router02(\\n            address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\\n        );\\n\\n        // initialize V3 router\\n        uniswapV3Router = IUniswapV3Router(\\n            address(0xE592427A0AEce92De3Edee1F18E0157C05861564)\\n        );\\n\\n        v3LPProtectionEnabled = true;\\n\\n        excludeFromFees(msg.sender, true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(address(0xdead), true);\\n        excludeFromFees(address(operationsAddress), true);\\n        excludeFromFees(address(marketingAddress), true);\\n\\n        uint256 opsSupply = (totalSupply * 75) / 100;\\n        uint256 lpSupply = totalSupply - opsSupply;\\n\\n        _mint(msg.sender, opsSupply);\\n        _mint(address(this), lpSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function updateTaxStructure(uint8 _structure) external onlyOwner {\\n        require(\\n            _structure > 0 && _structure <= 5,\\n            \\\"Invalid Tax Structure: Value must be 1, 2, or 3\\\"\\n        );\\n        if (_structure == 1) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_1;\\n        } else if (_structure == 2) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_2;\\n        } else if (_structure == 3) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_3;\\n        } else if (_structure == 4) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_4;\\n        } else if (_structure == 5) {\\n            CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_5;\\n        }\\n        emit UpdatedTaxStructure(_structure);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        automatedMarketMakerPairs[pair] = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool value\\n    ) external onlyOwner {\\n        require(\\n            pair != uniswapV2Pair,\\n            \\\"The pair cannot be removed from automatedMarketMakerPairs\\\"\\n        );\\n        _setAutomatedMarketMakerPair(pair, value);\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        _isExcludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        // require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"amount must be greater than 0\\\");\\n\\n        if (!tradingActive) {\\n            require(\\n                _isExcludedFromFees[from] || _isExcludedFromFees[to],\\n                \\\"Trading is not active.\\\"\\n            );\\n        } else {\\n            require(!markedAsSniper[from], \\\"Snipers cannot transfer tokens\\\");\\n        }\\n\\n        if (v3LPProtectionEnabled) {\\n            if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\n                require(\\n                    from != address(uniswapV3Pair) &&\\n                        to != address(uniswapV3Pair),\\n                    \\\"V3 Pool is currently protected, transfers are disabled\\\"\\n                );\\n            }\\n        }\\n\\n        if (limitsInEffect) {\\n            if (\\n                to != address(0xdead) &&\\n                !_isExcludedFromFees[from] &&\\n                !_isExcludedFromFees[to]\\n            ) {\\n                //when buy\\n                if (automatedMarketMakerPairs[from]) {\\n                    require(\\n                        amount <= maxBuyAmount,\\n                        \\\"Buy transfer amount exceeds the max buy.\\\"\\n                    );\\n                }\\n                //when sell\\n                else if (automatedMarketMakerPairs[to]) {\\n                    require(\\n                        amount <= maxSellAmount,\\n                        \\\"Sell transfer amount exceeds the max sell.\\\"\\n                    );\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]\\n        ) {\\n            swapping = true;\\n            swapBack();\\n            swapping = false;\\n        }\\n\\n        bool takeFee = true;\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        uint256 fees = 0;\\n        // only take fees on buys/sells, do not take on wallet transfers\\n        if (takeFee) {\\n            Tax memory tax = CURRENT_TAX_STRUCTURE;\\n            // on sell\\n\\n            if (automatedMarketMakerPairs[to] && tax.totalSellFee > 0) {\\n                fees = (amount * tax.totalSellFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsSellFee) /\\n                    tax.totalSellFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingSellFee) /\\n                    tax.totalSellFee;\\n            }\\n            // on buy\\n            else if (automatedMarketMakerPairs[from] && tax.totalBuyFee > 0) {\\n                fees = (amount * tax.totalBuyFee) / 1000;\\n                tokensForOperations +=\\n                    (fees * tax.operationsBuyFee) /\\n                    tax.totalBuyFee;\\n\\n                tokensForMarketing +=\\n                    (fees * tax.marketingBuyFee) /\\n                    tax.totalBuyFee;\\n            }\\n\\n            if (fees > 0) {\\n                super._update(from, address(this), fees);\\n            }\\n\\n            amount -= fees;\\n        }\\n\\n        super._update(from, to, amount);\\n    }\\n\\n    function getExpectedEthForTokens(\\n        uint256 tokenAmount\\n    ) public view returns (uint256) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(\\n            tokenAmount,\\n            path\\n        );\\n        return amounts[1];\\n    }\\n\\n    function swapTokensForEth(\\n        uint256 tokenAmount,\\n        uint256 minOutputAmount\\n    ) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            minOutputAmount,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapBack() private {\\n        if (block.number != lastSwapBlock) {\\n            lastSwapBlock = block.number;\\n            swapsThisBlock = 0;\\n        }\\n\\n        if (oncePerBlockEnabled && swapsThisBlock >= maxSwapsPerBlock) {\\n            return;\\n        }\\n\\n        uint256 contractBalance = balanceOf(address(this));\\n        uint256 totalTokensToSwap = tokensForOperations + tokensForMarketing;\\n\\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\\n            return;\\n        }\\n\\n        if (contractBalance > swapTokensAtAmount * 4) {\\n            contractBalance = swapTokensAtAmount * 4;\\n        }\\n\\n        // Calculate the minimum output amount (e.g., 95% of expected output)\\n        uint256 expectedEthOutput = getExpectedEthForTokens(contractBalance);\\n        uint256 minOutputAmount = (expectedEthOutput * 95) / 100; // 5% slippage tolerance\\n\\n        swapTokensForEth(contractBalance, minOutputAmount);\\n\\n        uint256 ethBalance = address(this).balance;\\n        uint256 ethForOperations = (ethBalance * tokensForOperations) /\\n            totalTokensToSwap;\\n\\n        tokensForOperations = 0;\\n        tokensForMarketing = 0;\\n\\n        swapsThisBlock += 1;\\n\\n        Address.sendValue(payable(operationsAddress), ethForOperations);\\n        Address.sendValue(payable(marketingAddress), address(this).balance);\\n    }\\n\\n    function transferForeignToken(\\n        address _token,\\n        address _to\\n    ) external onlyOwner returns (bool _sent) {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(_to != address(0), \\\"_to address cannot be 0\\\");\\n        require(_token != address(this), \\\"Can't withdraw LedgerAI token\\\");\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(_to, _contractBalance);\\n        emit TransferForeignToken(_token, _contractBalance);\\n        return true;\\n    }\\n\\n    function setOperationsAddress(\\n        address _operationsAddress\\n    ) external onlyOwner {\\n        require(\\n            _operationsAddress != address(0),\\n            \\\"_operationsAddress address cannot be 0\\\"\\n        );\\n        operationsAddress = payable(_operationsAddress);\\n        emit UpdatedOperationsAddress(_operationsAddress);\\n    }\\n\\n    function setMarketingAddress(address _marketingAddress) external onlyOwner {\\n        require(\\n            _marketingAddress != address(0),\\n            \\\"_marketingAddress address cannot be 0\\\"\\n        );\\n        marketingAddress = payable(_marketingAddress);\\n        emit UpdatedMarketingAddress(_marketingAddress);\\n    }\\n\\n    function removeLimits() external onlyOwner {\\n        limitsInEffect = false;\\n    }\\n\\n    function restoreLimits() external onlyOwner {\\n        limitsInEffect = true;\\n    }\\n\\n    function flagSniper(address wallet) external onlyOwner {\\n        require(!markedAsSniper[wallet], \\\"Wallet is already flagged.\\\");\\n        markedAsSniper[wallet] = true;\\n    }\\n\\n    function massFlagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = true;\\n        }\\n    }\\n\\n    function unflagSniper(address wallet) external onlyOwner {\\n        require(markedAsSniper[wallet], \\\"Wallet is already not marked.\\\");\\n        markedAsSniper[wallet] = false;\\n    }\\n\\n    function massUnflagSnipers(address[] calldata wallets) external onlyOwner {\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            markedAsSniper[wallets[i]] = false;\\n        }\\n    }\\n\\n    function recoverETH() external onlyOwner {\\n        bool success;\\n        (success, ) = address(msg.sender).call{value: address(this).balance}(\\n            \\\"\\\"\\n        );\\n        require(success, \\\"Failed to recover ETH\\\");\\n    }\\n\\n    function prepareLaunch() external onlyOwner {\\n        require(!tradingActive, \\\"Trading is already active, cannot relaunch.\\\");\\n\\n        // Check if V2 pair exists, if not create it\\n        address calculatedV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n            .getPair(address(this), uniswapV2Router.WETH());\\n\\n        if (calculatedV2Pair == address(0)) {\\n            // create pair\\n            uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\\n                .createPair(address(this), uniswapV2Router.WETH());\\n        } else {\\n            uniswapV2Pair = calculatedV2Pair;\\n        }\\n\\n        // Check if V3 pool exists, if not create it\\n        address calculatedV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n            .getPool(\\n                address(this),\\n                uniswapV2Router.WETH(),\\n                10000 // fee tier\\n            );\\n\\n        if (calculatedV3Pair == address(0)) {\\n            uniswapV3Pair = IUniswapV3Factory(uniswapV3Router.factory())\\n                .createPool(address(this), uniswapV2Router.WETH(), 10000);\\n        } else {\\n            uniswapV3Pair = calculatedV3Pair;\\n        }\\n\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\n\\n        excludeFromFees(address(uniswapV2Router), true);\\n\\n        require(\\n            address(this).balance > 0,\\n            \\\"Must have ETH on contract to launch\\\"\\n        );\\n        require(\\n            balanceOf(address(this)) > 0,\\n            \\\"Must have Tokens on contract to launch\\\"\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        _approve(address(this), address(uniswapV3Router), type(uint256).max);\\n\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            balanceOf(address(this)),\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            msg.sender,\\n            block.timestamp\\n        );\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(!tradingActive, \\\"Cannot reenable trading\\\");\\n        tradingActive = true;\\n        swapEnabled = true;\\n        tradingActiveBlock = block.number;\\n        emit EnabledTrading();\\n    }\\n\\n    function prepareForMigration() external onlyOwner {\\n        limitsInEffect = false;\\n        swapTokensAtAmount = totalSupply();\\n        CURRENT_TAX_STRUCTURE = TAX_STRUCTURE_FINAL;\\n        maxBuyAmount = totalSupply();\\n        maxSellAmount = totalSupply();\\n        if (balanceOf(address(this)) > 0) {\\n            super._update(address(this), msg.sender, balanceOf(address(this)));\\n        }\\n    }\\n\\n    function disableV3LPProtection() external onlyOwner {\\n        require(\\n            v3LPProtectionEnabled,\\n            \\\"V3 LP Protection already disabled forever!\\\"\\n        );\\n        v3LPProtectionEnabled = false;\\n    }\\n\\n    function setSwapRestrictions(\\n        bool _enabled,\\n        uint256 _maxSwaps\\n    ) external onlyOwner {\\n        require(_maxSwaps > 0, \\\"Max swaps per block must be greater than 0\\\");\\n        oncePerBlockEnabled = _enabled;\\n        maxSwapsPerBlock = _maxSwaps;\\n    }\\n}\\n\"",
          "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
        }
      ]
    }
  }
}