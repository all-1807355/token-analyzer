{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n\\ncontract EllipsisToken2 is IERC20, Ownable {\\n    using Address for address;\\n\\n    string public constant symbol = \\\"EPX\\\";\\n    string public constant name = \\\"Ellipsis X\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n    uint256 public immutable maxTotalSupply;\\n    uint256 public immutable startTime;\\n\\n    IERC20 public immutable oldToken;\\n    uint256 public immutable migrationRatio;\\n    uint256 public totalMigrated;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    mapping(address => bool) public minters;\\n    uint256 public minterCount;\\n\\n    event TokensMigrated(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    );\\n    event MinterSet(\\n        address caller,\\n        address minter\\n    );\\n\\n    constructor(\\n        uint256 _startTime,\\n        uint256 _maxTotalSupply,\\n        IERC20 _oldToken,\\n        uint256 _migrationRatio\\n    ) {\\n        startTime = _startTime;\\n        maxTotalSupply = _maxTotalSupply;\\n        oldToken = _oldToken;\\n        migrationRatio = _migrationRatio;\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve a contract with token minter rights\\n        @dev Two minters can be set. The first is `MerkleDistributor` which handles\\n             the airdrop to v1 stakers. The second is `EllipsisLpStaking` which mints\\n             EPX as it is earned by LPs. Ownership of this contract is renounced\\n             after setting the second minter.\\n     */\\n    function addMinter(address _minter) external onlyOwner {\\n        require(_minter.isContract(), \\\"Minter must be a contract\\\");\\n        require(!minters[_minter], \\\"Minter already set\\\");\\n\\n        minters[_minter] = true;\\n        minterCount += 1;\\n\\n        emit MinterSet(msg.sender, _minter);\\n        if (minterCount == 2) renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        require(maxTotalSupply >= totalSupply, \\\"Max supply\\\");\\n\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Burn EPS tokens in order to receive EPX\\n        @dev This function may be called immediately, however EPX tokens\\n             cannot be transferred prior to `startTime`.\\n        @param _receiver Address to mint the new EPX balance to\\n        @param _amount Amount of EPS tokens to burn for EPX\\n        @return bool success\\n     */\\n    function migrate(address _receiver, uint256 _amount) external returns (bool) {\\n        oldToken.transferFrom(msg.sender, address(0), _amount);\\n\\n        uint256 newAmount = _amount * migrationRatio;\\n        totalMigrated += _amount;\\n        balanceOf[_receiver] += newAmount;\\n        totalSupply += newAmount;\\n\\n        emit Transfer(address(0), _receiver, newAmount);\\n        emit TokensMigrated(msg.sender, _receiver, _amount, newAmount);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(block.timestamp >= startTime, \\\"Transfers not yet enabled\\\");\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return bool success\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return bool success\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[_from][msg.sender];\\n        require(allowed >= _value, \\\"Insufficient allowance\\\");\\n        if (allowed != type(uint256).max) {\\n            allowance[_from][msg.sender] = allowed - _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n\\ncontract EllipsisToken2 is IERC20, Ownable {\\n    using Address for address;\\n\\n    string public constant symbol = \\\"EPX\\\";\\n    string public constant name = \\\"Ellipsis X\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n    uint256 public immutable maxTotalSupply;\\n    uint256 public immutable startTime;\\n\\n    IERC20 public immutable oldToken;\\n    uint256 public immutable migrationRatio;\\n    uint256 public totalMigrated;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    mapping(address => bool) public minters;\\n    uint256 public minterCount;\\n\\n    event TokensMigrated(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    );\\n    event MinterSet(\\n        address caller,\\n        address minter\\n    );\\n\\n    constructor(\\n        uint256 _startTime,\\n        uint256 _maxTotalSupply,\\n        IERC20 _oldToken,\\n        uint256 _migrationRatio\\n    ) {\\n        startTime = _startTime;\\n        maxTotalSupply = _maxTotalSupply;\\n        oldToken = _oldToken;\\n        migrationRatio = _migrationRatio;\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve a contract with token minter rights\\n        @dev Two minters can be set. The first is `MerkleDistributor` which handles\\n             the airdrop to v1 stakers. The second is `EllipsisLpStaking` which mints\\n             EPX as it is earned by LPs. Ownership of this contract is renounced\\n             after setting the second minter.\\n     */\\n    function addMinter(address _minter) external onlyOwner {\\n        require(_minter.isContract(), \\\"Minter must be a contract\\\");\\n        require(!minters[_minter], \\\"Minter already set\\\");\\n\\n        minters[_minter] = true;\\n        minterCount += 1;\\n\\n        emit MinterSet(msg.sender, _minter);\\n        if (minterCount == 2) renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        require(maxTotalSupply >= totalSupply, \\\"Max supply\\\");\\n\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Burn EPS tokens in order to receive EPX\\n        @dev This function may be called immediately, however EPX tokens\\n             cannot be transferred prior to `startTime`.\\n        @param _receiver Address to mint the new EPX balance to\\n        @param _amount Amount of EPS tokens to burn for EPX\\n        @return bool success\\n     */\\n    function migrate(address _receiver, uint256 _amount) external returns (bool) {\\n        oldToken.transferFrom(msg.sender, address(0), _amount);\\n\\n        uint256 newAmount = _amount * migrationRatio;\\n        totalMigrated += _amount;\\n        balanceOf[_receiver] += newAmount;\\n        totalSupply += newAmount;\\n\\n        emit Transfer(address(0), _receiver, newAmount);\\n        emit TokensMigrated(msg.sender, _receiver, _amount, newAmount);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(block.timestamp >= startTime, \\\"Transfers not yet enabled\\\");\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return bool success\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return bool success\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[_from][msg.sender];\\n        require(allowed >= _value, \\\"Insufficient allowance\\\");\\n        if (allowed != type(uint256).max) {\\n            allowance[_from][msg.sender] = allowed - _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n\\ncontract EllipsisToken2 is IERC20, Ownable {\\n    using Address for address;\\n\\n    string public constant symbol = \\\"EPX\\\";\\n    string public constant name = \\\"Ellipsis X\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n    uint256 public immutable maxTotalSupply;\\n    uint256 public immutable startTime;\\n\\n    IERC20 public immutable oldToken;\\n    uint256 public immutable migrationRatio;\\n    uint256 public totalMigrated;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    mapping(address => bool) public minters;\\n    uint256 public minterCount;\\n\\n    event TokensMigrated(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    );\\n    event MinterSet(\\n        address caller,\\n        address minter\\n    );\\n\\n    constructor(\\n        uint256 _startTime,\\n        uint256 _maxTotalSupply,\\n        IERC20 _oldToken,\\n        uint256 _migrationRatio\\n    ) {\\n        startTime = _startTime;\\n        maxTotalSupply = _maxTotalSupply;\\n        oldToken = _oldToken;\\n        migrationRatio = _migrationRatio;\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve a contract with token minter rights\\n        @dev Two minters can be set. The first is `MerkleDistributor` which handles\\n             the airdrop to v1 stakers. The second is `EllipsisLpStaking` which mints\\n             EPX as it is earned by LPs. Ownership of this contract is renounced\\n             after setting the second minter.\\n     */\\n    function addMinter(address _minter) external onlyOwner {\\n        require(_minter.isContract(), \\\"Minter must be a contract\\\");\\n        require(!minters[_minter], \\\"Minter already set\\\");\\n\\n        minters[_minter] = true;\\n        minterCount += 1;\\n\\n        emit MinterSet(msg.sender, _minter);\\n        if (minterCount == 2) renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        require(maxTotalSupply >= totalSupply, \\\"Max supply\\\");\\n\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Burn EPS tokens in order to receive EPX\\n        @dev This function may be called immediately, however EPX tokens\\n             cannot be transferred prior to `startTime`.\\n        @param _receiver Address to mint the new EPX balance to\\n        @param _amount Amount of EPS tokens to burn for EPX\\n        @return bool success\\n     */\\n    function migrate(address _receiver, uint256 _amount) external returns (bool) {\\n        oldToken.transferFrom(msg.sender, address(0), _amount);\\n\\n        uint256 newAmount = _amount * migrationRatio;\\n        totalMigrated += _amount;\\n        balanceOf[_receiver] += newAmount;\\n        totalSupply += newAmount;\\n\\n        emit Transfer(address(0), _receiver, newAmount);\\n        emit TokensMigrated(msg.sender, _receiver, _amount, newAmount);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(block.timestamp >= startTime, \\\"Transfers not yet enabled\\\");\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return bool success\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return bool success\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[_from][msg.sender];\\n        require(allowed >= _value, \\\"Insufficient allowance\\\");\\n        if (allowed != type(uint256).max) {\\n            allowance[_from][msg.sender] = allowed - _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\n\\ncontract EllipsisToken2 is IERC20, Ownable {\\n    using Address for address;\\n\\n    string public constant symbol = \\\"EPX\\\";\\n    string public constant name = \\\"Ellipsis X\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n    uint256 public immutable maxTotalSupply;\\n    uint256 public immutable startTime;\\n\\n    IERC20 public immutable oldToken;\\n    uint256 public immutable migrationRatio;\\n    uint256 public totalMigrated;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    mapping(address => bool) public minters;\\n    uint256 public minterCount;\\n\\n    event TokensMigrated(\\n        address indexed sender,\\n        address indexed receiver,\\n        uint256 oldAmount,\\n        uint256 newAmount\\n    );\\n    event MinterSet(\\n        address caller,\\n        address minter\\n    );\\n\\n    constructor(\\n        uint256 _startTime,\\n        uint256 _maxTotalSupply,\\n        IERC20 _oldToken,\\n        uint256 _migrationRatio\\n    ) {\\n        startTime = _startTime;\\n        maxTotalSupply = _maxTotalSupply;\\n        oldToken = _oldToken;\\n        migrationRatio = _migrationRatio;\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve a contract with token minter rights\\n        @dev Two minters can be set. The first is `MerkleDistributor` which handles\\n             the airdrop to v1 stakers. The second is `EllipsisLpStaking` which mints\\n             EPX as it is earned by LPs. Ownership of this contract is renounced\\n             after setting the second minter.\\n     */\\n    function addMinter(address _minter) external onlyOwner {\\n        require(_minter.isContract(), \\\"Minter must be a contract\\\");\\n        require(!minters[_minter], \\\"Minter already set\\\");\\n\\n        minters[_minter] = true;\\n        minterCount += 1;\\n\\n        emit MinterSet(msg.sender, _minter);\\n        if (minterCount == 2) renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        require(maxTotalSupply >= totalSupply, \\\"Max supply\\\");\\n\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Burn EPS tokens in order to receive EPX\\n        @dev This function may be called immediately, however EPX tokens\\n             cannot be transferred prior to `startTime`.\\n        @param _receiver Address to mint the new EPX balance to\\n        @param _amount Amount of EPS tokens to burn for EPX\\n        @return bool success\\n     */\\n    function migrate(address _receiver, uint256 _amount) external returns (bool) {\\n        oldToken.transferFrom(msg.sender, address(0), _amount);\\n\\n        uint256 newAmount = _amount * migrationRatio;\\n        totalMigrated += _amount;\\n        balanceOf[_receiver] += newAmount;\\n        totalSupply += newAmount;\\n\\n        emit Transfer(address(0), _receiver, newAmount);\\n        emit TokensMigrated(msg.sender, _receiver, _amount, newAmount);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(block.timestamp >= startTime, \\\"Transfers not yet enabled\\\");\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return bool success\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return bool success\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[_from][msg.sender];\\n        require(allowed >= _value, \\\"Insufficient allowance\\\");\\n        if (allowed != type(uint256).max) {\\n            allowance[_from][msg.sender] = allowed - _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}