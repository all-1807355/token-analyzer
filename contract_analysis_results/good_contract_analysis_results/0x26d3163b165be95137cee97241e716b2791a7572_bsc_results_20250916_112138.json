{
  "total_matches": 8,
  "patterns_found": {
    "minting_mechanics": {
      "count": 8,
      "snippets": [
        {
          "matched_code": "_mint(msg.sender, 2 ether)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_daofund, 500 ether)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_devfund, 358 ether)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(communityfund, _pending)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(devfund, _pending)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_farmingincentivefund, farming_pool_reward_allocation)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\n\\nimport \\\"./owner/Operator.sol\\\";\\n\\n/*\\n\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d     \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u255d     \u255a\u2588\u2588\u2554\u255d  \\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551   \\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d   \\n                                                                             \\nhttps://dibs.money\\n\\n*/\\ncontract DShare is ERC20Burnable, Operator {\\n    using SafeMath for uint256;\\n\\n    /*\\n        TOTAL MAX SUPPLY = 70,000 dSHAREs\\n        - 36000 dShares allocated to Dibs-BNB\\n        - 24000 dShares allocated to dShare-BNB\\n        - Airdop 500 dShares allocated to DAO wallet\\n        - Allocate 4500 dShares to DAO wallet for linear vesting\\n        - Airdrop 360 dShares to Dev wallet\\n        - Allocate 4640 dShares to Dev wallet for linear vesting\\n    */\\n    uint256 public constant FARMING_POOL_REWARD_ALLOCATION = 60000 ether;\\n    uint256 public constant COMMUNITY_FUND_POOL_ALLOCATION = 4500 ether;\\n    uint256 public constant DEV_FUND_POOL_ALLOCATION = 4640 ether;\\n\\n    uint256 public constant VESTING_DURATION = 365 days;\\n    uint256 public startTime;\\n    uint256 public endTime;\\n\\n    uint256 public communityFundRewardRate;\\n    uint256 public devFundRewardRate;\\n\\n    address public communityFund;\\n    address public devFund;\\n\\n    uint256 public communityFundLastClaimed;\\n    uint256 public devFundLastClaimed;\\n\\n    bool public rewardPoolDistributed = false;\\n\\n    constructor(uint256 _startTime, address _daoFund, address _devFund) public ERC20(\\\"DSHARE\\\", \\\"DSHARE\\\") {\\n        _mint(msg.sender, 2 ether);         // mint 2 DIBS Share for initial pools deployment and Piggybank initialization\\n        _mint(_daoFund, 500 ether);         // Airdop 500 Dshares allocated to DAO wallet\\n        _mint(_devFund, 358 ether);         // Airdop 358 Dshares allocated to DEV wallet + 2 dShare for initialization\\n\\n        startTime = _startTime;\\n        endTime = startTime + VESTING_DURATION;\\n\\n        communityFundLastClaimed = startTime;\\n        devFundLastClaimed = startTime;\\n\\n        communityFundRewardRate = COMMUNITY_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n        devFundRewardRate = DEV_FUND_POOL_ALLOCATION.div(VESTING_DURATION);\\n\\n        require(_devFund != address(0), \\\"Address cannot be 0\\\");\\n        devFund = _devFund;\\n\\n        require(_daoFund != address(0), \\\"Address cannot be 0\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setTreasuryFund(address _daoFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        communityFund = _daoFund;\\n    }\\n\\n    function setDevFund(address _devFund) external {\\n        require(msg.sender == devFund, \\\"!dev\\\");\\n        require(_devFund != address(0), \\\"zero\\\");\\n        devFund = _devFund;\\n    }\\n\\n    function unclaimedTreasuryFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (communityFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(communityFundLastClaimed).mul(communityFundRewardRate);\\n    }\\n\\n    function unclaimedDevFund() public view returns (uint256 _pending) {\\n        uint256 _now = block.timestamp;\\n        if (_now > endTime) _now = endTime;\\n        if (devFundLastClaimed >= _now) return 0;\\n        _pending = _now.sub(devFundLastClaimed).mul(devFundRewardRate);\\n    }\\n\\n    /**\\n     * @dev Claim pending rewards to community and dev fund\\n     */\\n    function claimRewards() external {\\n        uint256 _pending = unclaimedTreasuryFund();\\n        if (_pending > 0 && communityFund != address(0)) {\\n            _mint(communityFund, _pending);\\n            communityFundLastClaimed = block.timestamp;\\n        }\\n        _pending = unclaimedDevFund();\\n        if (_pending > 0 && devFund != address(0)) {\\n            _mint(devFund, _pending);\\n            devFundLastClaimed = block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     * @notice distribute to reward pool (only once)\\n     */\\n    function distributeReward(address _farmingIncentiveFund) external onlyOperator {\\n        require(!rewardPoolDistributed, \\\"only can distribute once\\\");\\n        require(_farmingIncentiveFund != address(0), \\\"!_farmingIncentiveFund\\\");\\n        rewardPoolDistributed = true;\\n        _mint(_farmingIncentiveFund, FARMING_POOL_REWARD_ALLOCATION);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        super.burn(amount);\\n    }\\n\\n    function governanceRecoverUnsupported(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _to\\n    ) external onlyOperator {\\n        _token.transfer(_to, _amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}