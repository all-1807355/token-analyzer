{
  "total_matches": 3,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.28;\\n\\nimport {ERC20} from \\\"protocol-v3/misc/ERC20.sol\\\";\\nimport {IERC20} from \\\"protocol-v3/misc/interfaces/IERC20.sol\\\";\\nimport {IDelegationToken, Delegation, Signature} from \\\"src/interfaces/IDelegationToken.sol\\\";\\n\\n/// @title  Delegation Token\\n/// @notice Extension of ERC20 to support token delegation\\n///         This extension keeps track of the current voting power delegated to each account. Voting power can be\\n///         delegated either by calling the `delegate` function directly, or by providing a signature to be\\n///         used with `delegateBySig`.\\n///\\n///         This enables onchain votes on external voting smart contracts leveraging storage proofs.\\n///\\n///         By default, token balance does not account for voting power. This makes transfers cheaper. Whether\\n///         an account has to self-delegate to vote depends on the voting contract implementation.\\n/// @author Modified from https://github.com/morpho-org/morpho-token\\ncontract DelegationToken is ERC20, IDelegationToken {\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @inheritdoc IDelegationToken\\n    mapping(address => address) public delegatee;\\n    /// @inheritdoc IDelegationToken\\n    mapping(address => uint256) public delegatedVotingPower;\\n    /// @inheritdoc IDelegationToken\\n    mapping(address => uint256) public delegationNonce;\\n\\n    constructor(uint8 decimals_) ERC20(decimals_) {}\\n\\n    /// @inheritdoc IDelegationToken\\n    function delegate(address newDelegatee) external {\\n        address delegator = msg.sender;\\n        _delegate(delegator, newDelegatee);\\n    }\\n\\n    /// @inheritdoc IDelegationToken\\n    function delegateWithSig(Delegation calldata delegation, Signature calldata signature) external {\\n        require(block.timestamp <= delegation.expiry, DelegatesExpiredSignature());\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), keccak256(abi.encode(DELEGATION_TYPEHASH, delegation)))\\n        );\\n        address delegator = ecrecover(digest, signature.v, signature.r, signature.s);\\n        require(delegator != address(0), InvalidSignature());\\n        require(delegation.nonce == delegationNonce[delegator]++, InvalidDelegationNonce());\\n\\n        _delegate(delegator, delegation.delegatee);\\n    }\\n\\n    /// @dev Delegates the balance of the `delegator` to `newDelegatee`.\\n    function _delegate(address delegator, address newDelegatee) internal {\\n        address oldDelegatee = delegatee[delegator];\\n        delegatee[delegator] = newDelegatee;\\n\\n        emit DelegateeChanged(delegator, oldDelegatee, newDelegatee);\\n        _moveDelegateVotes(oldDelegatee, newDelegatee, balanceOf(delegator));\\n    }\\n\\n    /// @dev Moves voting power when tokens are transferred.\\n    function transfer(address to, uint256 value) public override(ERC20, IERC20) returns (bool success) {\\n        success = super.transfer(to, value);\\n        _moveDelegateVotes(delegatee[msg.sender], delegatee[to], value);\\n    }\\n\\n    /// @dev Moves voting power when tokens are transferred.\\n    function transferFrom(address from, address to, uint256 value)\\n        public\\n        override(ERC20, IERC20)\\n        returns (bool success)\\n    {\\n        success = super.transferFrom(from, to, value);\\n        _moveDelegateVotes(delegatee[from], delegatee[to], value);\\n    }\\n\\n    /// @dev Adds voting power when tokens are minted.\\n    function mint(address to, uint256 value) public override(ERC20) {\\n        super.mint(to, value);\\n        _moveDelegateVotes(address(0), delegatee[to], value);\\n    }\\n\\n    /// @dev Removes voting power when tokens are burned.\\n    function burn(address from, uint256 value) public override(ERC20) {\\n        super.burn(from, value);\\n        _moveDelegateVotes(delegatee[from], address(0), value);\\n    }\\n\\n    /// @dev Moves delegated votes from one delegate to another.\\n    function _moveDelegateVotes(address from, address to, uint256 amount) internal {\\n        if (from != to && amount > 0) {\\n            if (from != address(0)) {\\n                uint256 oldValue = delegatedVotingPower[from];\\n                uint256 newValue = oldValue - amount;\\n                delegatedVotingPower[from] = newValue;\\n                emit DelegatedVotingPowerChanged(from, oldValue, newValue);\\n            }\\n            if (to != address(0)) {\\n                uint256 oldValue = delegatedVotingPower[to];\\n                uint256 newValue = oldValue + amount;\\n                delegatedVotingPower[to] = newValue;\\n                emit DelegatedVotingPowerChanged(to, oldValue, newValue);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.28;\\n\\nimport {Auth} from \\\"src/misc/Auth.sol\\\";\\nimport {EIP712Lib} from \\\"src/misc/libraries/EIP712Lib.sol\\\";\\nimport {SignatureLib} from \\\"src/misc/libraries/SignatureLib.sol\\\";\\n\\nimport {IERC20, IERC20Metadata, IERC20Permit} from \\\"src/misc/interfaces/IERC20.sol\\\";\\n\\n/// @title  ERC20\\n/// @notice Standard ERC-20 implementation, with mint/burn functionality and permit logic.\\n/// @author Modified from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\\ncontract ERC20 is Auth, IERC20Metadata, IERC20Permit {\\n    error FileUnrecognizedWhat();\\n\\n    /// @inheritdoc IERC20Metadata\\n    string public name;\\n    /// @inheritdoc IERC20Metadata\\n    string public symbol;\\n    /// @inheritdoc IERC20Metadata\\n    uint8 public immutable decimals;\\n    /// @inheritdoc IERC20\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) private balances;\\n\\n    /// @inheritdoc IERC20\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    /// @inheritdoc IERC20Permit\\n    mapping(address => uint256) public nonces;\\n\\n    // --- EIP712 ---\\n    bytes32 private immutable nameHash;\\n    bytes32 private immutable versionHash;\\n    uint256 public immutable deploymentChainId;\\n    bytes32 private immutable _DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    // --- Events ---\\n    event File(bytes32 indexed what, string data);\\n\\n    constructor(uint8 decimals_) Auth(msg.sender) {\\n        decimals = decimals_;\\n\\n        nameHash = keccak256(bytes(\\\"Centrifuge\\\"));\\n        versionHash = keccak256(bytes(\\\"1\\\"));\\n        deploymentChainId = block.chainid;\\n        _DOMAIN_SEPARATOR = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\\n    }\\n\\n    function _balanceOf(address user) internal view virtual returns (uint256) {\\n        return balances[user];\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function balanceOf(address user) public view virtual returns (uint256) {\\n        return _balanceOf(user);\\n    }\\n\\n    function _setBalance(address user, uint256 value) internal virtual {\\n        balances[user] = value;\\n    }\\n\\n    /// @inheritdoc IERC20Permit\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return block.chainid == deploymentChainId\\n            ? _DOMAIN_SEPARATOR\\n            : EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\\n    }\\n\\n    // --- Administration ---\\n    function file(bytes32 what, string memory data) public virtual auth {\\n        if (what == \\\"name\\\") name = data;\\n        else if (what == \\\"symbol\\\") symbol = data;\\n        else revert FileUnrecognizedWhat();\\n        emit File(what, data);\\n    }\\n\\n    // --- ERC20 Mutations ---\\n    /// @inheritdoc IERC20\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        uint256 balance = balanceOf(msg.sender);\\n        require(balance >= value, InsufficientBalance());\\n\\n        unchecked {\\n            _setBalance(msg.sender, _balanceOf(msg.sender) - value);\\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        return _transferFrom(msg.sender, from, to, value);\\n    }\\n\\n    function _transferFrom(address sender, address from, address to, uint256 value) internal virtual returns (bool) {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        uint256 balance = balanceOf(from);\\n        require(balance >= value, InsufficientBalance());\\n\\n        if (from != sender) {\\n            uint256 allowed = allowance[from][sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= value, InsufficientAllowance());\\n                unchecked {\\n                    allowance[from][sender] = allowed - value;\\n                }\\n            }\\n        }\\n\\n        unchecked {\\n            _setBalance(from, _balanceOf(from) - value);\\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    // --- Mint/Burn ---\\n    function mint(address to, uint256 value) public virtual auth {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        unchecked {\\n            // We don't need an overflow check here b/c balances[to] <= totalSupply\\n            // and there is an overflow check below\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n        totalSupply = totalSupply + value;\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function burn(address from, uint256 value) public virtual auth {\\n        uint256 balance = balanceOf(from);\\n        require(balance >= value, InsufficientBalance());\\n\\n        if (from != msg.sender) {\\n            uint256 allowed = allowance[from][msg.sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= value, InsufficientAllowance());\\n\\n                unchecked {\\n                    allowance[from][msg.sender] = allowed - value;\\n                }\\n            }\\n        }\\n\\n        unchecked {\\n            // We don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\\n            _setBalance(from, _balanceOf(from) - value);\\n            totalSupply = totalSupply - value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\\n        require(block.timestamp <= deadline, PermitExpired());\\n\\n        uint256 nonce;\\n        unchecked {\\n            nonce = nonces[owner]++;\\n        }\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\\n            )\\n        );\\n\\n        require(SignatureLib.isValidSignature(owner, digest, signature), InvalidPermit());\\n\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @inheritdoc IERC20Permit\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external\\n    {\\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.28;\\n\\nimport {Auth} from \\\"src/misc/Auth.sol\\\";\\nimport {EIP712Lib} from \\\"src/misc/libraries/EIP712Lib.sol\\\";\\nimport {SignatureLib} from \\\"src/misc/libraries/SignatureLib.sol\\\";\\n\\nimport {IERC20, IERC20Metadata, IERC20Permit} from \\\"src/misc/interfaces/IERC20.sol\\\";\\n\\n/// @title  ERC20\\n/// @notice Standard ERC-20 implementation, with mint/burn functionality and permit logic.\\n/// @author Modified from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\\ncontract ERC20 is Auth, IERC20Metadata, IERC20Permit {\\n    error FileUnrecognizedWhat();\\n\\n    /// @inheritdoc IERC20Metadata\\n    string public name;\\n    /// @inheritdoc IERC20Metadata\\n    string public symbol;\\n    /// @inheritdoc IERC20Metadata\\n    uint8 public immutable decimals;\\n    /// @inheritdoc IERC20\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) private balances;\\n\\n    /// @inheritdoc IERC20\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    /// @inheritdoc IERC20Permit\\n    mapping(address => uint256) public nonces;\\n\\n    // --- EIP712 ---\\n    bytes32 private immutable nameHash;\\n    bytes32 private immutable versionHash;\\n    uint256 public immutable deploymentChainId;\\n    bytes32 private immutable _DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    // --- Events ---\\n    event File(bytes32 indexed what, string data);\\n\\n    constructor(uint8 decimals_) Auth(msg.sender) {\\n        decimals = decimals_;\\n\\n        nameHash = keccak256(bytes(\\\"Centrifuge\\\"));\\n        versionHash = keccak256(bytes(\\\"1\\\"));\\n        deploymentChainId = block.chainid;\\n        _DOMAIN_SEPARATOR = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\\n    }\\n\\n    function _balanceOf(address user) internal view virtual returns (uint256) {\\n        return balances[user];\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function balanceOf(address user) public view virtual returns (uint256) {\\n        return _balanceOf(user);\\n    }\\n\\n    function _setBalance(address user, uint256 value) internal virtual {\\n        balances[user] = value;\\n    }\\n\\n    /// @inheritdoc IERC20Permit\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return block.chainid == deploymentChainId\\n            ? _DOMAIN_SEPARATOR\\n            : EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\\n    }\\n\\n    // --- Administration ---\\n    function file(bytes32 what, string memory data) public virtual auth {\\n        if (what == \\\"name\\\") name = data;\\n        else if (what == \\\"symbol\\\") symbol = data;\\n        else revert FileUnrecognizedWhat();\\n        emit File(what, data);\\n    }\\n\\n    // --- ERC20 Mutations ---\\n    /// @inheritdoc IERC20\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        uint256 balance = balanceOf(msg.sender);\\n        require(balance >= value, InsufficientBalance());\\n\\n        unchecked {\\n            _setBalance(msg.sender, _balanceOf(msg.sender) - value);\\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        return _transferFrom(msg.sender, from, to, value);\\n    }\\n\\n    function _transferFrom(address sender, address from, address to, uint256 value) internal virtual returns (bool) {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        uint256 balance = balanceOf(from);\\n        require(balance >= value, InsufficientBalance());\\n\\n        if (from != sender) {\\n            uint256 allowed = allowance[from][sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= value, InsufficientAllowance());\\n                unchecked {\\n                    allowance[from][sender] = allowed - value;\\n                }\\n            }\\n        }\\n\\n        unchecked {\\n            _setBalance(from, _balanceOf(from) - value);\\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    // --- Mint/Burn ---\\n    function mint(address to, uint256 value) public virtual auth {\\n        require(to != address(0) && to != address(this), InvalidAddress());\\n        unchecked {\\n            // We don't need an overflow check here b/c balances[to] <= totalSupply\\n            // and there is an overflow check below\\n            _setBalance(to, _balanceOf(to) + value);\\n        }\\n        totalSupply = totalSupply + value;\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function burn(address from, uint256 value) public virtual auth {\\n        uint256 balance = balanceOf(from);\\n        require(balance >= value, InsufficientBalance());\\n\\n        if (from != msg.sender) {\\n            uint256 allowed = allowance[from][msg.sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= value, InsufficientAllowance());\\n\\n                unchecked {\\n                    allowance[from][msg.sender] = allowed - value;\\n                }\\n            }\\n        }\\n\\n        unchecked {\\n            // We don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\\n            _setBalance(from, _balanceOf(from) - value);\\n            totalSupply = totalSupply - value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    // --- Approve by signature ---\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\\n        require(block.timestamp <= deadline, PermitExpired());\\n\\n        uint256 nonce;\\n        unchecked {\\n            nonce = nonces[owner]++;\\n        }\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\\n            )\\n        );\\n\\n        require(SignatureLib.isValidSignature(owner, digest, signature), InvalidPermit());\\n\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @inheritdoc IERC20Permit\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\\n        external\\n    {\\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}