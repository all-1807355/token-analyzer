{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: NOLICENSE\\npragma solidity 0.8.28;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./Interfaces/IRouter.sol\\\";\\nimport \\\"./Interfaces/IFactory.sol\\\";\\n\\ncontract Rezor is IERC20, Ownable {\\n\\n    uint256 private _totalSupply = 100 * 10**9 * 10**9;\\n    uint256 public constant swapTokensAtUSDCAmount = 250 ether;                                 // 250 USDC    \\n    uint256 public buyTax = 20;\\n    uint256 public sellTax = 20;\\n    uint256 public taxCollected;                                                          \\n        \\n    bool private transient swapping;\\n    bool public airdropClosed;\\n    uint8 private constant _decimals = 9;\\n\\n    address public constant developmentAddress = 0xfA717eABA5bA7b2C752E12BaF4ac978AaD438F79;\\n    address public immutable USDC;\\n\\n    IRouter public router;\\n    IRouter public router2;\\n\\n    string private constant _name = \\\"Rezor\\\";\\n    string private constant _symbol = \\\"RZR\\\";\\n\\n    mapping(address account => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _isPair;\\n    mapping(address => bool) private _isBot;\\n    mapping(address => bool) public canAirdrop;\\n    mapping(address => bool) public isAirdropped;\\n\\n    event FeesChanged();\\n    event BatchAirDropped(string _batchId);\\n    event AddressesMarketAsBot(address[] accounts);\\n    event AirdropControlSet(address[] _addr, bool[] _access);\\n\\n    modifier lockTheSwap {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    modifier hasAirdropControl(address _addr) {\\n        require(canAirdrop[_addr], \\\"Rezor::No access\\\");\\n        _;\\n    }\\n\\n    constructor (address routerAddress, address owner_, address _usdc, address router2_) Ownable(owner_) {\\n        require(routerAddress != address(0) && owner_ != address(0) && _usdc != address(0) && router2_!= address(0), \\\"Rezor::Invalid address\\\");\\n        IRouter _router = IRouter(routerAddress);\\n        IRouter _router2 = IRouter(router2_);\\n\\n        address _pair = IFactory(_router.factory())\\n            .createPair(address(this), _router.WETH());\\n\\n        router = _router;\\n        USDC = _usdc;\\n        router2 = _router2;\\n        _isPair[_pair] = true;\\n\\n        _balances[owner_] = _totalSupply;\\n        emit Transfer(address(0), owner_, _totalSupply);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) public view override returns (uint256) {\\n        return _allowances[_owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    function isPair(address account) public view returns(bool) {\\n        return _isPair[account];\\n    }\\n\\n    function _approve(address _owner, address spender, uint256 amount) private {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[_owner][spender] = amount;\\n        emit Approval(_owner, spender, amount);\\n    }\\n\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Zero amount\\\");\\n        require(amount <= balanceOf(from),\\\"Insufficient balance\\\");\\n        require(!_isBot[from] && !_isBot[to], \\\"Rezor::You are a bot\\\");\\n            \\n        if(!swapping) {\\n            // sell\\n            if(_isPair[to]) _tokenTransfer(from, to, amount, 1);\\n            // buy\\n            else if(_isPair[from]) _tokenTransfer(from, to, amount, 2);\\n            // transfer\\n            else _tokenTransfer(from, to, amount, 0);\\n        } else {\\n            _tokenTransfer(from, to, amount, 0);\\n        }\\n        \\n        if(!swapping && !_isPair[from] && !_isPair[to] && from != address(router) && from!= address(router2) && taxCollected > 0) {\\n            address[] memory path = new address[](2);\\n                path[0] = USDC;\\n                path[1] = router.WETH();\\n            uint _amountNative = router.getAmountsOut(swapTokensAtUSDCAmount, path)[1];\\n                path[0] = router2.WETH();\\n                path[1] = address(this);\\n            uint _amount = router2.getAmountsOut(_amountNative, path)[1];\\n            if(_amount <= taxCollected && _amount > 0) swapTokensForETH(_amount);\\n        }\\n\\n    }\\n\\n    function _tokenTransfer(address sender, address recipient, uint256 _amount, uint8 takeFee) private {\\n        if(takeFee == 0) {\\n          _standardTransfer(sender, recipient, _amount);\\n        } else if(takeFee == 1){\\n            _sellTransfer(sender, recipient, _amount);\\n        } else if(takeFee == 2) {\\n            _buyTransfer(sender, recipient, _amount);\\n        }\\n    }\\n\\n    function _standardTransfer(address spender, address receiver, uint256 _amount) private {\\n        _balances[spender] -= _amount;\\n        _balances[receiver] += _amount;\\n        emit Transfer(spender, receiver, _amount);\\n    }\\n\\n    function _sellTransfer(address spender, address receiver, uint256 _amount) private {\\n        uint256 taxAmount = _amount * sellTax / 1000;\\n        uint256 amount = _amount - taxAmount;\\n\\n        _balances[spender] -= _amount;\\n\\n        if(taxAmount > 0) {\\n            taxCollected += taxAmount;\\n            _balances[address(this)] += taxAmount;\\n            emit Transfer(spender, address(this), taxAmount);\\n        }\\n\\n        _balances[receiver] += amount;\\n        emit Transfer(spender, receiver, amount);\\n    }\\n\\n    function _buyTransfer(address spender, address receiver, uint256 _amount) private {\\n        uint256 taxAmount = _amount * buyTax / 1000;\\n        uint256 amount = _amount - taxAmount;\\n\\n        _balances[spender] -= _amount;\\n\\n        if(taxAmount > 0) {\\n            taxCollected += taxAmount;\\n            _balances[address(this)] += taxAmount;\\n            emit Transfer(spender, address(this), taxAmount);\\n        }\\n\\n        _balances[receiver] += amount;\\n        emit Transfer(spender, receiver, amount);\\n    }\\n\\n    function swapTokensForETH(uint256 tokenAmount) private lockTheSwap {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n                path[0] = address(this);\\n                path[1] = router.WETH();\\n\\n        _approve(address(this), address(router2), tokenAmount);\\n\\n        uint256 preBalance = address(this).balance;\\n        // make the swap\\n        router2.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 taxInETH = address(this).balance - preBalance;\\n    \\n        (bool success, ) = payable(developmentAddress).call{value: taxInETH}(\\\"\\\");\\n        require(success, 'Rezor::ETH_TRANSFER_FAILED');\\n        taxCollected -= tokenAmount;\\n    }\\n\\n    function setBuyTaxes(uint256 _buyTax) public onlyOwner {\\n        require(_buyTax < 21, \\\"Rezor::Max 2% tax allowed\\\");\\n        buyTax = _buyTax;\\n        emit FeesChanged();\\n    }\\n\\n    function setSellTaxes(uint256 _selltax) public onlyOwner {\\n        require(_selltax < 21, \\\"Rezor::Max 2% tax allowed\\\");\\n        sellTax = _selltax;\\n        emit FeesChanged();\\n    }\\n\\n    function bulkAntiBot(address[] memory accounts, bool state) external onlyOwner {\\n        require(accounts.length <= 100, \\\"Rezor::Invalid\\\");\\n        for(uint256 i = 0; i < accounts.length; i++){\\n            _isBot[accounts[i]] = state;\\n        }\\n\\n        emit AddressesMarketAsBot(accounts);\\n    }\\n  \\n    function airdropTokens(address[] memory recipients, uint256[] memory amounts, string memory _batchId) external hasAirdropControl(msg.sender) {\\n        require(!airdropClosed, \\\"Rezor::Airdrop closed\\\");\\n        require(recipients.length == amounts.length,\\\"Rezor::Invalid size\\\");\\n         address sender = owner();\\n\\n         for(uint256 i; i<recipients.length; i++) {\\n            address recipient = recipients[i];\\n\\n            require(balanceOf(sender) >= amounts[i], \\\"Rezor::Insufficient owner balance\\\");\\n            if(isAirdropped[recipient]) revert(\\\"Rezor::Already airdropped\\\");\\n\\n            isAirdropped[recipient] = true;\\n\\n            _balances[sender] -= amounts[i];\\n            _balances[recipient] += amounts[i];\\n            emit Transfer(sender, recipient, amounts[i]);\\n         }\\n\\n        emit BatchAirDropped(_batchId);\\n\\n    }\\n\\n    function setAirdropControl(address[] memory _addr, bool[] memory _access) external onlyOwner {\\n        require(_addr.length == _access.length, \\\"Rezor::Different length inputs\\\");\\n        for(uint i = 0; i< _addr.length; i++) {\\n            canAirdrop[_addr[i]] = _access[i];\\n        }\\n\\n        emit AirdropControlSet(_addr, _access);\\n    }\\n\\n    function closeAirdrop() external onlyOwner {\\n        require(!airdropClosed, \\\"Rezor::Already closed\\\");\\n        airdropClosed = true;\\n    }\\n\\n    function isBot(address account) public view returns(bool){\\n        return _isBot[account];\\n    }\\n\\n    function setRouterAndPair(address newRouter, address router2_, address newPair, bool isActive) external onlyOwner {\\n        require(newRouter != address(0) && newPair != address(0) && router2_ != address(0), \\\"Rezor::Invalid address\\\");\\n        router = IRouter(newRouter);\\n        router2 = IRouter(router2_);\\n        _isPair[newPair] = isActive;\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n}\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "router_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "modifier locktheswap",
          "function_context": "\"content\": \"// SPDX-License-Identifier: NOLICENSE\\npragma solidity 0.8.28;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./Interfaces/IRouter.sol\\\";\\nimport \\\"./Interfaces/IFactory.sol\\\";\\n\\ncontract Rezor is IERC20, Ownable {\\n\\n    uint256 private _totalSupply = 100 * 10**9 * 10**9;\\n    uint256 public constant swapTokensAtUSDCAmount = 250 ether;                                 // 250 USDC    \\n    uint256 public buyTax = 20;\\n    uint256 public sellTax = 20;\\n    uint256 public taxCollected;                                                          \\n        \\n    bool private transient swapping;\\n    bool public airdropClosed;\\n    uint8 private constant _decimals = 9;\\n\\n    address public constant developmentAddress = 0xfA717eABA5bA7b2C752E12BaF4ac978AaD438F79;\\n    address public immutable USDC;\\n\\n    IRouter public router;\\n    IRouter public router2;\\n\\n    string private constant _name = \\\"Rezor\\\";\\n    string private constant _symbol = \\\"RZR\\\";\\n\\n    mapping(address account => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _isPair;\\n    mapping(address => bool) private _isBot;\\n    mapping(address => bool) public canAirdrop;\\n    mapping(address => bool) public isAirdropped;\\n\\n    event FeesChanged();\\n    event BatchAirDropped(string _batchId);\\n    event AddressesMarketAsBot(address[] accounts);\\n    event AirdropControlSet(address[] _addr, bool[] _access);\\n\\n    modifier lockTheSwap {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    modifier hasAirdropControl(address _addr) {\\n        require(canAirdrop[_addr], \\\"Rezor::No access\\\");\\n        _;\\n    }\\n\\n    constructor (address routerAddress, address owner_, address _usdc, address router2_) Ownable(owner_) {\\n        require(routerAddress != address(0) && owner_ != address(0) && _usdc != address(0) && router2_!= address(0), \\\"Rezor::Invalid address\\\");\\n        IRouter _router = IRouter(routerAddress);\\n        IRouter _router2 = IRouter(router2_);\\n\\n        address _pair = IFactory(_router.factory())\\n            .createPair(address(this), _router.WETH());\\n\\n        router = _router;\\n        USDC = _usdc;\\n        router2 = _router2;\\n        _isPair[_pair] = true;\\n\\n        _balances[owner_] = _totalSupply;\\n        emit Transfer(address(0), owner_, _totalSupply);\\n    }\\n\\n    function name() public pure returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() public pure returns (string memory) {\\n        return _symbol;\\n    }\\n    function decimals() public pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address _owner, address spender) public view override returns (uint256) {\\n        return _allowances[_owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    function isPair(address account) public view returns(bool) {\\n        return _isPair[account];\\n    }\\n\\n    function _approve(address _owner, address spender, uint256 amount) private {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[_owner][spender] = amount;\\n        emit Approval(_owner, spender, amount);\\n    }\\n\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Zero amount\\\");\\n        require(amount <= balanceOf(from),\\\"Insufficient balance\\\");\\n        require(!_isBot[from] && !_isBot[to], \\\"Rezor::You are a bot\\\");\\n            \\n        if(!swapping) {\\n            // sell\\n            if(_isPair[to]) _tokenTransfer(from, to, amount, 1);\\n            // buy\\n            else if(_isPair[from]) _tokenTransfer(from, to, amount, 2);\\n            // transfer\\n            else _tokenTransfer(from, to, amount, 0);\\n        } else {\\n            _tokenTransfer(from, to, amount, 0);\\n        }\\n        \\n        if(!swapping && !_isPair[from] && !_isPair[to] && from != address(router) && from!= address(router2) && taxCollected > 0) {\\n            address[] memory path = new address[](2);\\n                path[0] = USDC;\\n                path[1] = router.WETH();\\n            uint _amountNative = router.getAmountsOut(swapTokensAtUSDCAmount, path)[1];\\n                path[0] = router2.WETH();\\n                path[1] = address(this);\\n            uint _amount = router2.getAmountsOut(_amountNative, path)[1];\\n            if(_amount <= taxCollected && _amount > 0) swapTokensForETH(_amount);\\n        }\\n\\n    }\\n\\n    function _tokenTransfer(address sender, address recipient, uint256 _amount, uint8 takeFee) private {\\n        if(takeFee == 0) {\\n          _standardTransfer(sender, recipient, _amount);\\n        } else if(takeFee == 1){\\n            _sellTransfer(sender, recipient, _amount);\\n        } else if(takeFee == 2) {\\n            _buyTransfer(sender, recipient, _amount);\\n        }\\n    }\\n\\n    function _standardTransfer(address spender, address receiver, uint256 _amount) private {\\n        _balances[spender] -= _amount;\\n        _balances[receiver] += _amount;\\n        emit Transfer(spender, receiver, _amount);\\n    }\\n\\n    function _sellTransfer(address spender, address receiver, uint256 _amount) private {\\n        uint256 taxAmount = _amount * sellTax / 1000;\\n        uint256 amount = _amount - taxAmount;\\n\\n        _balances[spender] -= _amount;\\n\\n        if(taxAmount > 0) {\\n            taxCollected += taxAmount;\\n            _balances[address(this)] += taxAmount;\\n            emit Transfer(spender, address(this), taxAmount);\\n        }\\n\\n        _balances[receiver] += amount;\\n        emit Transfer(spender, receiver, amount);\\n    }\\n\\n    function _buyTransfer(address spender, address receiver, uint256 _amount) private {\\n        uint256 taxAmount = _amount * buyTax / 1000;\\n        uint256 amount = _amount - taxAmount;\\n\\n        _balances[spender] -= _amount;\\n\\n        if(taxAmount > 0) {\\n            taxCollected += taxAmount;\\n            _balances[address(this)] += taxAmount;\\n            emit Transfer(spender, address(this), taxAmount);\\n        }\\n\\n        _balances[receiver] += amount;\\n        emit Transfer(spender, receiver, amount);\\n    }\\n\\n    function swapTokensForETH(uint256 tokenAmount) private lockTheSwap {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n                path[0] = address(this);\\n                path[1] = router.WETH();\\n\\n        _approve(address(this), address(router2), tokenAmount);\\n\\n        uint256 preBalance = address(this).balance;\\n        // make the swap\\n        router2.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 taxInETH = address(this).balance - preBalance;\\n    \\n        (bool success, ) = payable(developmentAddress).call{value: taxInETH}(\\\"\\\");\\n        require(success, 'Rezor::ETH_TRANSFER_FAILED');\\n        taxCollected -= tokenAmount;\\n    }\\n\\n    function setBuyTaxes(uint256 _buyTax) public onlyOwner {\\n        require(_buyTax < 21, \\\"Rezor::Max 2% tax allowed\\\");\\n        buyTax = _buyTax;\\n        emit FeesChanged();\\n    }\\n\\n    function setSellTaxes(uint256 _selltax) public onlyOwner {\\n        require(_selltax < 21, \\\"Rezor::Max 2% tax allowed\\\");\\n        sellTax = _selltax;\\n        emit FeesChanged();\\n    }\\n\\n    function bulkAntiBot(address[] memory accounts, bool state) external onlyOwner {\\n        require(accounts.length <= 100, \\\"Rezor::Invalid\\\");\\n        for(uint256 i = 0; i < accounts.length; i++){\\n            _isBot[accounts[i]] = state;\\n        }\\n\\n        emit AddressesMarketAsBot(accounts);\\n    }\\n  \\n    function airdropTokens(address[] memory recipients, uint256[] memory amounts, string memory _batchId) external hasAirdropControl(msg.sender) {\\n        require(!airdropClosed, \\\"Rezor::Airdrop closed\\\");\\n        require(recipients.length == amounts.length,\\\"Rezor::Invalid size\\\");\\n         address sender = owner();\\n\\n         for(uint256 i; i<recipients.length; i++) {\\n            address recipient = recipients[i];\\n\\n            require(balanceOf(sender) >= amounts[i], \\\"Rezor::Insufficient owner balance\\\");\\n            if(isAirdropped[recipient]) revert(\\\"Rezor::Already airdropped\\\");\\n\\n            isAirdropped[recipient] = true;\\n\\n            _balances[sender] -= amounts[i];\\n            _balances[recipient] += amounts[i];\\n            emit Transfer(sender, recipient, amounts[i]);\\n         }\\n\\n        emit BatchAirDropped(_batchId);\\n\\n    }\\n\\n    function setAirdropControl(address[] memory _addr, bool[] memory _access) external onlyOwner {\\n        require(_addr.length == _access.length, \\\"Rezor::Different length inputs\\\");\\n        for(uint i = 0; i< _addr.length; i++) {\\n            canAirdrop[_addr[i]] = _access[i];\\n        }\\n\\n        emit AirdropControlSet(_addr, _access);\\n    }\\n\\n    function closeAirdrop() external onlyOwner {\\n        require(!airdropClosed, \\\"Rezor::Already closed\\\");\\n        airdropClosed = true;\\n    }\\n\\n    function isBot(address account) public view returns(bool){\\n        return _isBot[account];\\n    }\\n\\n    function setRouterAndPair(address newRouter, address router2_, address newPair, bool isActive) external onlyOwner {\\n        require(newRouter != address(0) && newPair != address(0) && router2_ != address(0), \\\"Rezor::Invalid address\\\");\\n        router = IRouter(newRouter);\\n        router2 = IRouter(router2_);\\n        _isPair[newPair] = isActive;\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n}\"",
          "pattern": "modifier\\s+lockTheSwap"
        }
      ]
    }
  }
}