{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IEdenToken.sol\\\";\\nimport \\\"./lib/AccessControl.sol\\\";\\n\\n/**\\n * @title EdenToken\\n * @dev ERC-20 with minting + add-ons to allow for offchain signing\\n * See EIP-712, EIP-2612, and EIP-3009 for details\\n */\\ncontract EdenToken is AccessControl, IEdenToken {\\n    /// @notice EIP-20 token name for this token\\n    string public override name = \\\"Eden\\\";\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public override symbol = \\\"EDEN\\\";\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public override constant decimals = 18;\\n\\n    /// @notice Total number of tokens in circulation\\n    uint256 public override totalSupply;\\n\\n    /// @notice Max total supply\\n    uint256 public constant override maxSupply = 250_000_000e18; // 250 million\\n\\n    /// @notice Minter role\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    /// @notice Address which may change token metadata\\n    address public override metadataManager;\\n\\n    /// @dev Allowance amounts on behalf of others\\n    mapping (address => mapping (address => uint256)) public override allowance;\\n\\n    /// @dev Official record of token balanceOf for each account\\n    mapping (address => uint256) public override balanceOf;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    /// keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 public constant override DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    \\n    /// @notice The EIP-712 version hash\\n    /// keccak256(\\\"1\\\");\\n    bytes32 public constant override VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @notice The EIP-712 typehash for permit (EIP-2612)\\n    /// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\\n    /// keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\");\\n    bytes32 public constant override TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n    /// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\\n    /// keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n    bytes32 public constant override RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public override nonces;\\n\\n    /// @dev authorizer address > nonce > state (true = used / false = unused)\\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\\n\\n    /**\\n     * @notice Construct a new Eden token\\n     * @param _admin Default admin role\\n     */\\n    constructor(address _admin) {\\n        metadataManager = _admin;\\n        emit MetadataManagerChanged(address(0), metadataManager);\\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    }\\n\\n    /**\\n     * @notice Change the metadataManager address\\n     * @param newMetadataManager The address of the new metadata manager\\n     * @return true if successful\\n     */\\n    function setMetadataManager(address newMetadataManager) external override returns (bool) {\\n        require(msg.sender == metadataManager, \\\"Eden::setMetadataManager: only MM can change MM\\\");\\n        emit MetadataManagerChanged(metadataManager, newMetadataManager);\\n        metadataManager = newMetadataManager;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Mint new tokens\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to be minted\\n     * @return Boolean indicating success of mint\\n     */\\n    function mint(address dst, uint256 amount) external override returns (bool) {\\n        require(hasRole(MINTER_ROLE, msg.sender), \\\"Eden::mint: only minters can mint\\\");\\n        require(totalSupply + amount <= maxSupply, \\\"Eden::mint: exceeds max supply\\\");\\n        require(dst != address(0), \\\"Eden::mint: cannot transfer to the zero address\\\");\\n\\n        totalSupply = totalSupply + amount;\\n        balanceOf[dst] = balanceOf[dst] + amount;\\n        emit Transfer(address(0), dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burn tokens\\n     * @param amount The number of tokens to burn\\n     * @return Boolean indicating success of burn\\n     */\\n    function burn(uint256 amount) external override returns (bool) {\\n        balanceOf[msg.sender] = balanceOf[msg.sender] - amount;\\n        totalSupply = totalSupply - amount;\\n        \\n        emit Transfer(msg.sender, address(0), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Update the token name and symbol\\n     * @param tokenName The new name for the token\\n     * @param tokenSymbol The new symbol for the token\\n     * @return true if successful\\n     */\\n    function updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external override returns (bool) {\\n        require(msg.sender == metadataManager, \\\"Eden::updateTokenMeta: only MM can update token metadata\\\");\\n        name = tokenName;\\n        symbol = tokenSymbol;\\n        emit TokenMetaUpdated(name, symbol);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase the allowance by a given amount\\n     * @param spender Spender's address\\n     * @param addedValue Amount of increase in allowance\\n     * @return True if successful\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        external override\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender, \\n            spender, \\n            allowance[msg.sender][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease the allowance by a given amount\\n     * @param spender Spender's address\\n     * @param subtractedValue Amount of decrease in allowance\\n     * @return True if successful\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external override\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            allowance[msg.sender][spender] - subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Triggers an approval from owner to spender\\n     * @param owner The address to approve from\\n     * @param spender The address to be approved\\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function permit(\\n        address owner, \\n        address spender, \\n        uint256 value, \\n        uint256 deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"Eden::permit: signature expired\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\\n        _validateSignedData(owner, encodeData, v, r, s);\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) external override returns (bool) {\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\\n        address spender = msg.sender;\\n        uint256 spenderAllowance = allowance[src][spender];\\n\\n        if (spender != src && spenderAllowance != type(uint256).max) {\\n            uint256 newAllowance = spenderAllowance - amount;\\n            allowance[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer tokens with a signed authorization\\n     * @param from Payer's address (Authorizer)\\n     * @param to Payee's address\\n     * @param value Amount to be transferred\\n     * @param validAfter The time after which this is valid (unix time)\\n     * @param validBefore The time before which this is valid (unix time)\\n     * @param nonce Unique nonce\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(block.timestamp > validAfter, \\\"Eden::transferWithAuth: auth not yet valid\\\");\\n        require(block.timestamp < validBefore, \\\"Eden::transferWithAuth: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"Eden::transferWithAuth: auth already used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transferTokens(from, to, value);\\n    }\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer\\n     * @dev This has an additional check to ensure that the payee's address matches\\n     * the caller of this function to prevent front-running attacks.\\n     * @param from Payer's address (Authorizer)\\n     * @param to Payee's address\\n     * @param value Amount to be transferred\\n     * @param validAfter The time after which this is valid (unix time)\\n     * @param validBefore The time before which this is valid (unix time)\\n     * @param nonce Unique nonce\\n     * @param v v of the signature\\n     * @param r r of the signature\\n     * @param s s of the signature\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(to == msg.sender, \\\"Eden::receiveWithAuth: caller must be the payee\\\");\\n        require(block.timestamp > validAfter, \\\"Eden::receiveWithAuth: auth not yet valid\\\");\\n        require(block.timestamp < validBefore, \\\"Eden::receiveWithAuth: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"Eden::receiveWithAuth: auth already used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transferTokens(from, to, value);\\n    }\\n\\n    /**\\n     * @notice EIP-712 Domain separator\\n     * @return Separator\\n     */\\n    function getDomainSeparator() public view override returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                VERSION_HASH,\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Recovers address from signed data and validates the signature\\n     * @param signer Address that signed the data\\n     * @param encodeData Data signed by the address\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                getDomainSeparator(),\\n                encodeData\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \\\"Eden::validateSig: invalid signature\\\");\\n    }\\n\\n    /**\\n     * @notice Approval implementation\\n     * @param owner The address of the account which owns tokens\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"Eden::_approve: approve from the zero address\\\");\\n        require(spender != address(0), \\\"Eden::_approve: approve to the zero address\\\");\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer implementation\\n     * @param from The address of the account which owns tokens\\n     * @param to The address of the account which is receiving tokens\\n     * @param value The number of tokens that are being transferred\\n     */\\n    function _transferTokens(address from, address to, uint256 value) internal {\\n        require(to != address(0), \\\"Eden::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(from, to, value);\\n    }\\n}\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IEdenToken.sol\\\";\\nimport \\\"./lib/AccessControl.sol\\\";\\n\\n/**\\n * @title EdenToken\\n * @dev ERC-20 with minting + add-ons to allow for offchain signing\\n * See EIP-712, EIP-2612, and EIP-3009 for details\\n */\\ncontract EdenToken is AccessControl, IEdenToken {\\n    /// @notice EIP-20 token name for this token\\n    string public override name = \\\"Eden\\\";\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public override symbol = \\\"EDEN\\\";\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public override constant decimals = 18;\\n\\n    /// @notice Total number of tokens in circulation\\n    uint256 public override totalSupply;\\n\\n    /// @notice Max total supply\\n    uint256 public constant override maxSupply = 250_000_000e18; // 250 million\\n\\n    /// @notice Minter role\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    /// @notice Address which may change token metadata\\n    address public override metadataManager;\\n\\n    /// @dev Allowance amounts on behalf of others\\n    mapping (address => mapping (address => uint256)) public override allowance;\\n\\n    /// @dev Official record of token balanceOf for each account\\n    mapping (address => uint256) public override balanceOf;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    /// keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\n    bytes32 public constant override DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    \\n    /// @notice The EIP-712 version hash\\n    /// keccak256(\\\"1\\\");\\n    bytes32 public constant override VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @notice The EIP-712 typehash for permit (EIP-2612)\\n    /// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice The EIP-712 typehash for transferWithAuthorization (EIP-3009)\\n    /// keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\");\\n    bytes32 public constant override TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\n\\n    /// @notice The EIP-712 typehash for receiveWithAuthorization (EIP-3009)\\n    /// keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\n    bytes32 public constant override RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public override nonces;\\n\\n    /// @dev authorizer address > nonce > state (true = used / false = unused)\\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\\n\\n    /**\\n     * @notice Construct a new Eden token\\n     * @param _admin Default admin role\\n     */\\n    constructor(address _admin) {\\n        metadataManager = _admin;\\n        emit MetadataManagerChanged(address(0), metadataManager);\\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\\n    }\\n\\n    /**\\n     * @notice Change the metadataManager address\\n     * @param newMetadataManager The address of the new metadata manager\\n     * @return true if successful\\n     */\\n    function setMetadataManager(address newMetadataManager) external override returns (bool) {\\n        require(msg.sender == metadataManager, \\\"Eden::setMetadataManager: only MM can change MM\\\");\\n        emit MetadataManagerChanged(metadataManager, newMetadataManager);\\n        metadataManager = newMetadataManager;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Mint new tokens\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to be minted\\n     * @return Boolean indicating success of mint\\n     */\\n    function mint(address dst, uint256 amount) external override returns (bool) {\\n        require(hasRole(MINTER_ROLE, msg.sender), \\\"Eden::mint: only minters can mint\\\");\\n        require(totalSupply + amount <= maxSupply, \\\"Eden::mint: exceeds max supply\\\");\\n        require(dst != address(0), \\\"Eden::mint: cannot transfer to the zero address\\\");\\n\\n        totalSupply = totalSupply + amount;\\n        balanceOf[dst] = balanceOf[dst] + amount;\\n        emit Transfer(address(0), dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burn tokens\\n     * @param amount The number of tokens to burn\\n     * @return Boolean indicating success of burn\\n     */\\n    function burn(uint256 amount) external override returns (bool) {\\n        balanceOf[msg.sender] = balanceOf[msg.sender] - amount;\\n        totalSupply = totalSupply - amount;\\n        \\n        emit Transfer(msg.sender, address(0), amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Update the token name and symbol\\n     * @param tokenName The new name for the token\\n     * @param tokenSymbol The new symbol for the token\\n     * @return true if successful\\n     */\\n    function updateTokenMetadata(string memory tokenName, string memory tokenSymbol) external override returns (bool) {\\n        require(msg.sender == metadataManager, \\\"Eden::updateTokenMeta: only MM can update token metadata\\\");\\n        name = tokenName;\\n        symbol = tokenSymbol;\\n        emit TokenMetaUpdated(name, symbol);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     * and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * It is recommended to use increaseAllowance and decreaseAllowance instead\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase the allowance by a given amount\\n     * @param spender Spender's address\\n     * @param addedValue Amount of increase in allowance\\n     * @return True if successful\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        external override\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender, \\n            spender, \\n            allowance[msg.sender][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease the allowance by a given amount\\n     * @param spender Spender's address\\n     * @param subtractedValue Amount of decrease in allowance\\n     * @return True if successful\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        external override\\n        returns (bool)\\n    {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            allowance[msg.sender][spender] - subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Triggers an approval from owner to spender\\n     * @param owner The address to approve from\\n     * @param spender The address to be approved\\n     * @param value The number of tokens that are approved (2^256-1 means infinite)\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function permit(\\n        address owner, \\n        address spender, \\n        uint256 value, \\n        uint256 deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, \\\"Eden::permit: signature expired\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\\n        _validateSignedData(owner, encodeData, v, r, s);\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint256 amount) external override returns (bool) {\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param amount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint256 amount) external override returns (bool) {\\n        address spender = msg.sender;\\n        uint256 spenderAllowance = allowance[src][spender];\\n\\n        if (spender != src && spenderAllowance != type(uint256).max) {\\n            uint256 newAllowance = spenderAllowance - amount;\\n            allowance[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer tokens with a signed authorization\\n     * @param from Payer's address (Authorizer)\\n     * @param to Payee's address\\n     * @param value Amount to be transferred\\n     * @param validAfter The time after which this is valid (unix time)\\n     * @param validBefore The time before which this is valid (unix time)\\n     * @param nonce Unique nonce\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function transferWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(block.timestamp > validAfter, \\\"Eden::transferWithAuth: auth not yet valid\\\");\\n        require(block.timestamp < validBefore, \\\"Eden::transferWithAuth: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"Eden::transferWithAuth: auth already used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transferTokens(from, to, value);\\n    }\\n\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer\\n     * @dev This has an additional check to ensure that the payee's address matches\\n     * the caller of this function to prevent front-running attacks.\\n     * @param from Payer's address (Authorizer)\\n     * @param to Payee's address\\n     * @param value Amount to be transferred\\n     * @param validAfter The time after which this is valid (unix time)\\n     * @param validBefore The time before which this is valid (unix time)\\n     * @param nonce Unique nonce\\n     * @param v v of the signature\\n     * @param r r of the signature\\n     * @param s s of the signature\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(to == msg.sender, \\\"Eden::receiveWithAuth: caller must be the payee\\\");\\n        require(block.timestamp > validAfter, \\\"Eden::receiveWithAuth: auth not yet valid\\\");\\n        require(block.timestamp < validBefore, \\\"Eden::receiveWithAuth: auth expired\\\");\\n        require(!authorizationState[from][nonce],  \\\"Eden::receiveWithAuth: auth already used\\\");\\n\\n        bytes32 encodeData = keccak256(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\\n        _validateSignedData(from, encodeData, v, r, s);\\n\\n        authorizationState[from][nonce] = true;\\n        emit AuthorizationUsed(from, nonce);\\n\\n        _transferTokens(from, to, value);\\n    }\\n\\n    /**\\n     * @notice EIP-712 Domain separator\\n     * @return Separator\\n     */\\n    function getDomainSeparator() public view override returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name)),\\n                VERSION_HASH,\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Recovers address from signed data and validates the signature\\n     * @param signer Address that signed the data\\n     * @param encodeData Data signed by the address\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                getDomainSeparator(),\\n                encodeData\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \\\"Eden::validateSig: invalid signature\\\");\\n    }\\n\\n    /**\\n     * @notice Approval implementation\\n     * @param owner The address of the account which owns tokens\\n     * @param spender The address of the account which may transfer tokens\\n     * @param amount The number of tokens that are approved (2^256-1 means infinite)\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal {\\n        require(owner != address(0), \\\"Eden::_approve: approve from the zero address\\\");\\n        require(spender != address(0), \\\"Eden::_approve: approve to the zero address\\\");\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer implementation\\n     * @param from The address of the account which owns tokens\\n     * @param to The address of the account which is receiving tokens\\n     * @param value The number of tokens that are being transferred\\n     */\\n    function _transferTokens(address from, address to, uint256 value) internal {\\n        require(to != address(0), \\\"Eden::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(from, to, value);\\n    }\\n}\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}