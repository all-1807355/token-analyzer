{
  "total_matches": 3,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n\\ncontract DotDot is IERC20, Ownable {\\n\\n    string public constant name = \\\"DotDot\\\";\\n    string public constant symbol = \\\"DDD\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    mapping(address => bool) public minters;\\n\\n    event MintersSet(address[] minters);\\n\\n    constructor() {\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve contracts to mint and renounce ownership\\n        @dev Permission should be given to `LpDepositor, `EpxDepositIncentives` and `CoreMinter`\\n     */\\n    function setMinters(address[] calldata _minters) external onlyOwner {\\n        for (uint256 i = 0; i < _minters.length; i++) {\\n            minters[_minters[i]] = true;\\n        }\\n\\n        emit MintersSet(_minters);\\n        renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return Success boolean\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return Success boolean\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(allowance[_from][msg.sender] >= _value, \\\"Insufficient allowance\\\");\\n        if (allowance[_from][msg.sender] != type(uint).max) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n\\ncontract DotDot is IERC20, Ownable {\\n\\n    string public constant name = \\\"DotDot\\\";\\n    string public constant symbol = \\\"DDD\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    mapping(address => bool) public minters;\\n\\n    event MintersSet(address[] minters);\\n\\n    constructor() {\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve contracts to mint and renounce ownership\\n        @dev Permission should be given to `LpDepositor, `EpxDepositIncentives` and `CoreMinter`\\n     */\\n    function setMinters(address[] calldata _minters) external onlyOwner {\\n        for (uint256 i = 0; i < _minters.length; i++) {\\n            minters[_minters[i]] = true;\\n        }\\n\\n        emit MintersSet(_minters);\\n        renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return Success boolean\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return Success boolean\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(allowance[_from][msg.sender] >= _value, \\\"Insufficient allowance\\\");\\n        if (allowance[_from][msg.sender] != type(uint).max) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n\\ncontract DotDot is IERC20, Ownable {\\n\\n    string public constant name = \\\"DotDot\\\";\\n    string public constant symbol = \\\"DDD\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    mapping(address => bool) public minters;\\n\\n    event MintersSet(address[] minters);\\n\\n    constructor() {\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    /**\\n        @notice Approve contracts to mint and renounce ownership\\n        @dev Permission should be given to `LpDepositor, `EpxDepositIncentives` and `CoreMinter`\\n     */\\n    function setMinters(address[] calldata _minters) external onlyOwner {\\n        for (uint256 i = 0; i < _minters.length; i++) {\\n            minters[_minters[i]] = true;\\n        }\\n\\n        emit MintersSet(_minters);\\n        renounceOwnership();\\n    }\\n\\n    function mint(address _to, uint256 _value) external returns (bool) {\\n        require(minters[msg.sender], \\\"Not a minter\\\");\\n        balanceOf[_to] += _value;\\n        totalSupply += _value;\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return Success boolean\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return Success boolean\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(allowance[_from][msg.sender] >= _value, \\\"Insufficient allowance\\\");\\n        if (allowance[_from][msg.sender] != type(uint).max) {\\n            allowance[_from][msg.sender] -= _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}