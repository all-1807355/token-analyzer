{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "function mint(address account, uint256 amount) public onlyAdmin {\n        require(account != address(0), \"INVALID_ADDRESS\");\n        // If we're using maxSupply, we need to make sure we respect it\n        // mintableSupply = 0 means mint at will\n        if (mintableSupply > 0) {\n            require(amount <= mintableSupply, \"INVALID_AMOUNT\");\n            // We need to reduce the amount only if we're using the limit, if not just leave it be\n            mintableSupply -= amount;\n        }\n        _mint(account, amount);\n    }",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "function mint(address account, uint256 amount) public onlyAdmin {\n        require(account != address(0), \"INVALID_ADDRESS\");\n        // If we're using maxSupply, we need to make sure we respect it\n        // mintableSupply = 0 means mint at will\n        if (mintableSupply > 0) {\n            require(amount <= mintableSupply, \"INVALID_AMOUNT\");\n            // We need to reduce the amount only if we're using the limit, if not just leave it be\n            mintableSupply -= amount;\n        }\n        _mint(account, amount);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}