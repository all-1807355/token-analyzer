{
  "total_matches": 1,
  "patterns_found": {
    "honeypot_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "assembly {\\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n            let size := returndatasize\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n                case 0 {\\n                    revert",
          "function_context": "\"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./BerryGetters.sol\\\";\\n\\n/**\\n* @title Berry Master\\n* @dev This is the Master contract with all berry getter functions and delegate call to Berry.\\n* The logic for the functions on this contract is saved on the BerryGettersLibrary, BerryTransfer,\\n* BerryGettersLibrary, and BerryStake\\n*/\\ncontract BerryMaster is BerryGetters {\\n    event NewBerryAddress(address _newBerry);\\n\\n    /**\\n    * @dev The constructor sets the original `berryStorageOwner` of the contract to the sender\\n    * account, the berry contract to the Berry master address and owner to the Berry master owner address\\n    * @param _berryContract is the address for the berry contract\\n    */\\n    constructor(address _berryContract) public {\\n        berry.init();\\n        berry.addressVars[keccak256(\\\"_owner\\\")] = msg.sender;\\n        berry.addressVars[keccak256(\\\"_deity\\\")] = msg.sender;\\n        berry.addressVars[keccak256(\\\"berryContract\\\")] = _berryContract;\\n        emit NewBerryAddress(_berryContract);\\n    }\\n\\n    /**\\n    * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\\n    * @dev Only needs to be in library\\n    * @param _newDeity the new Deity in the contract\\n    */\\n\\n    function changeDeity(address _newDeity) external {\\n        berry.changeDeity(_newDeity);\\n    }\\n\\n    /**\\n    * @dev  allows for the deity to make fast upgrades.  Deity should be 0 address if decentralized\\n    * @param _berryContract the address of the new Berry Contract\\n    */\\n    function changeBerryContract(address _berryContract) external {\\n        berry.changeBerryContract(_berryContract);\\n    }\\n\\n    /**\\n    * @dev This is the fallback function that allows contracts to call the berry contract at the address stored\\n    */\\n    function() external payable {\\n        address addr = berry.addressVars[keccak256(\\\"berryContract\\\")];\\n        bytes memory _calldata = msg.data;\\n        assembly {\\n            let result := delegatecall(not(0), addr, add(_calldata, 0x20), mload(_calldata), 0, 0)\\n            let size := returndatasize\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        }
      ]
    }
  }
}