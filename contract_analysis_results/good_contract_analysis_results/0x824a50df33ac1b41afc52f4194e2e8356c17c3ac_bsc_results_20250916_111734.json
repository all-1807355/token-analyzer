{
  "total_matches": 7,
  "patterns_found": {
    "minting_mechanics": {
      "count": 7,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"erc-payable-token/contracts/token/ERC1363/ERC1363.sol\\\";\\n\\ncontract Token is ERC1363, ERC20Permit, Pausable, AccessControl {\\n    uint8 private _decimals;\\n    uint256 private _tTotal; // token total\\n    uint256 private _rTotal; // reflection total\\n\\n    mapping(address => uint256) private _rOwned; // reflection balance\\n\\n    // no burn and distribution if transfer to these addresses\\n    mapping(address => bool) private _isNoIncomeFee;\\n    uint256 private _distributionPercent;\\n    uint256 private _burnPercent;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant UNPAUSED_ROLE = keccak256(\\\"UNPAUSED_ROLE\\\");\\n\\n    event DistributionPercentChanged(uint256 value);\\n    event BurnPercentChanged(uint256 value);\\n    event NoIncomeFeeRoleGranted(address indexed account);\\n    event NoIncomeFeeRoleRevoked(address indexed account);\\n    event Distribution(address indexed account, uint256 value);\\n\\n    modifier notPaused() {\\n        if (paused()) {\\n            require(\\n                hasRole(UNPAUSED_ROLE, _msgSender()),\\n                \\\"can't perform an action\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimal,\\n        uint256 tTotal,\\n        uint256 tMax,\\n        uint256 dPercent,\\n        uint256 bPercent\\n    ) ERC20(name, ticker) ERC20Permit(name) {\\n        // init supply\\n        _decimals = decimal;\\n\\n        require(tTotal <= tMax, \\\"max initial supply exceeded\\\");\\n        _tTotal = tTotal * 10**decimal;\\n        uint256 _tMax = tMax * 10**decimal;\\n        _rTotal = (type(uint256).max / _tMax) * _tTotal;\\n\\n        // set fee percents\\n        require(10 <= dPercent && dPercent <= 100 && 10 <= bPercent && bPercent <= 100, \\n            \\\"incorrect fee percent\\\"\\n        );\\n        _distributionPercent = dPercent;\\n        emit DistributionPercentChanged(dPercent);\\n        _burnPercent = bPercent;\\n        emit BurnPercentChanged(bPercent);\\n\\n        // set roles\\n        _setRoleAdmin(ADMIN_ROLE, OWNER_ROLE);\\n        _setRoleAdmin(UNPAUSED_ROLE, ADMIN_ROLE);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        _setupRole(ADMIN_ROLE, _msgSender());\\n        _setupRole(UNPAUSED_ROLE, _msgSender());\\n\\n        // mint inital supply\\n        _rOwned[_msgSender()] = _rTotal;\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    // base logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    // transfer logic ---------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function setDistributionPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _distributionPercent = percent;\\n        emit DistributionPercentChanged(percent);\\n    }\\n\\n    function setBurnPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _burnPercent = percent;\\n        emit BurnPercentChanged(percent);\\n    }\\n\\n    function distributionPercent() external view returns (uint256) {\\n        return _distributionPercent;\\n    }\\n\\n    function burnPercent() external view returns (uint256) {\\n        return _burnPercent;\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n            (, uint256 rTransferAmount, , ) = _getValues(tAmount);\\n            return rTransferAmount - rBurnAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function isNoIncomeFee(address account) external view returns (bool) {\\n        return _isNoIncomeFee[account];\\n    }\\n\\n    function grantNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(!_isNoIncomeFee[account], \\\"Account is already no income fee\\\");\\n        _isNoIncomeFee[account] = true;\\n        emit NoIncomeFeeRoleGranted(account);\\n    }\\n\\n    function revokeNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(_isNoIncomeFee[account], \\\"Account is not no income fee\\\");\\n        _isNoIncomeFee[account] = false;\\n        emit NoIncomeFeeRoleRevoked(account);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override(ERC20) notPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_isNoIncomeFee[recipient]) {\\n            _transferWithoutFee(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        (uint256 tBurnAmount, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n        _tTotal -= tBurnAmount;\\n        _rTotal -= rBurnAmount;\\n\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount) = _getValues(tAmount);\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rTransferAmount - rBurnAmount;\\n\\n        // distribute fee\\n        _rTotal -= rFee;\\n\\n        emit Transfer(sender, recipient, tTransferAmount - tBurnAmount);\\n        emit Transfer(sender, address(0), tBurnAmount);\\n        emit Distribution(sender, tAmount - tTransferAmount);\\n    }\\n\\n    function _transferWithoutFee(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rAmount;\\n        emit Transfer(sender, recipient, tAmount);\\n    }\\n\\n    function _getBurnValues(uint256 tAmount) private view returns (uint256, uint256) {\\n        uint256 tBurnAmount = (tAmount * _burnPercent) / 1000;\\n        uint256 currentRate = _getRate();\\n        uint256 rBurnAmount = tBurnAmount * currentRate;\\n        return (tBurnAmount, rBurnAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * _distributionPercent) / 1000;\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        return _rTotal / _tTotal;\\n    }\\n\\n    function transferAll(address recipient) external returns (bool) {\\n        _transfer(_msgSender(), recipient, tokenFromReflection(_rOwned[_msgSender()]));\\n        return true;\\n    }\\n\\n    function transferAllFrom(address account, address recipient) external returns (bool) {\\n        uint256 tAmount = tokenFromReflection(_rOwned[account]);\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"transfer amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _transfer(account, recipient, tAmount);\\n        return true;\\n    }\\n\\n    // for initial token distribution (swap from old token)\\n    function multisend(\\n        address[] memory recipients,\\n        uint256[] memory tAmounts\\n    ) external onlyRole(OWNER_ROLE) {\\n        require(recipients.length <= 200, \\\"More than 200 recipients\\\");\\n\\n        uint256 rTotal;\\n        uint256 rAmount;\\n        uint256 currentRate = _getRate();\\n\\n        uint8 i = 0;\\n        for (i; i < recipients.length; i++) {\\n            rAmount = tAmounts[i] * currentRate;\\n            rTotal += rAmount;\\n            _rOwned[recipients[i]] += rAmount;\\n            emit Transfer(_msgSender(), recipients[i], tAmounts[i]);\\n        }\\n\\n        _rOwned[_msgSender()] -= rTotal;\\n    }\\n\\n    // burn logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        _tTotal -= tAmount;\\n\\n        emit Transfer(account, address(0), tAmount);\\n    }\\n\\n    function burn(uint256 tAmount) external {\\n        _burn(_msgSender(), tAmount);\\n    }\\n\\n    function burnFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _burn(account, tAmount);\\n    }\\n\\n    // mint logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _mint(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"mint to the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] += rAmount;\\n        _rTotal += rAmount; // overflow if tMax (max supply) from constructor exceeded\\n        _tTotal += tAmount;\\n\\n        emit Transfer(address(0), account, tAmount);\\n    }\\n\\n    function mint(address account, uint256 tAmount) external onlyRole(OWNER_ROLE) {\\n        _mint(account, tAmount);\\n    }\\n\\n    // distribute logic -------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _distribute(address account, uint256 tAmount) internal {\\n        (uint256 rAmount, , , ) = _getValues(tAmount);\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        emit Distribution(account, tAmount);\\n    }\\n\\n    function distribute(uint256 tAmount) external {\\n        _distribute(_msgSender(), tAmount);\\n    }\\n\\n    function distributeFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"distribute amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _distribute(account, tAmount);\\n    }\\n\\n    // denomination logic -----------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function denominate(uint256 rate) external onlyRole(OWNER_ROLE) {\\n        _tTotal /= rate;\\n    }\\n\\n    // pause logic ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function pauseTrigger() external onlyRole(OWNER_ROLE) {\\n        if (paused()) {\\n            _unpause();\\n        } else {\\n            _pause();\\n        }\\n    }\\n\\n    // interface support ------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override(AccessControl, ERC1363) returns (bool) {\\n        return AccessControl.supportsInterface(interfaceId) || ERC1363.supportsInterface(interfaceId);\\n    }\\n\\n    // stuck funds ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function stuckFundsTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyRole(OWNER_ROLE) returns (bool) {\\n        return IERC20(token).transfer(to, amount);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 tamount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"erc-payable-token/contracts/token/ERC1363/ERC1363.sol\\\";\\n\\ncontract Token is ERC1363, ERC20Permit, Pausable, AccessControl {\\n    uint8 private _decimals;\\n    uint256 private _tTotal; // token total\\n    uint256 private _rTotal; // reflection total\\n\\n    mapping(address => uint256) private _rOwned; // reflection balance\\n\\n    // no burn and distribution if transfer to these addresses\\n    mapping(address => bool) private _isNoIncomeFee;\\n    uint256 private _distributionPercent;\\n    uint256 private _burnPercent;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant UNPAUSED_ROLE = keccak256(\\\"UNPAUSED_ROLE\\\");\\n\\n    event DistributionPercentChanged(uint256 value);\\n    event BurnPercentChanged(uint256 value);\\n    event NoIncomeFeeRoleGranted(address indexed account);\\n    event NoIncomeFeeRoleRevoked(address indexed account);\\n    event Distribution(address indexed account, uint256 value);\\n\\n    modifier notPaused() {\\n        if (paused()) {\\n            require(\\n                hasRole(UNPAUSED_ROLE, _msgSender()),\\n                \\\"can't perform an action\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimal,\\n        uint256 tTotal,\\n        uint256 tMax,\\n        uint256 dPercent,\\n        uint256 bPercent\\n    ) ERC20(name, ticker) ERC20Permit(name) {\\n        // init supply\\n        _decimals = decimal;\\n\\n        require(tTotal <= tMax, \\\"max initial supply exceeded\\\");\\n        _tTotal = tTotal * 10**decimal;\\n        uint256 _tMax = tMax * 10**decimal;\\n        _rTotal = (type(uint256).max / _tMax) * _tTotal;\\n\\n        // set fee percents\\n        require(10 <= dPercent && dPercent <= 100 && 10 <= bPercent && bPercent <= 100, \\n            \\\"incorrect fee percent\\\"\\n        );\\n        _distributionPercent = dPercent;\\n        emit DistributionPercentChanged(dPercent);\\n        _burnPercent = bPercent;\\n        emit BurnPercentChanged(bPercent);\\n\\n        // set roles\\n        _setRoleAdmin(ADMIN_ROLE, OWNER_ROLE);\\n        _setRoleAdmin(UNPAUSED_ROLE, ADMIN_ROLE);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        _setupRole(ADMIN_ROLE, _msgSender());\\n        _setupRole(UNPAUSED_ROLE, _msgSender());\\n\\n        // mint inital supply\\n        _rOwned[_msgSender()] = _rTotal;\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    // base logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    // transfer logic ---------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function setDistributionPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _distributionPercent = percent;\\n        emit DistributionPercentChanged(percent);\\n    }\\n\\n    function setBurnPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _burnPercent = percent;\\n        emit BurnPercentChanged(percent);\\n    }\\n\\n    function distributionPercent() external view returns (uint256) {\\n        return _distributionPercent;\\n    }\\n\\n    function burnPercent() external view returns (uint256) {\\n        return _burnPercent;\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n            (, uint256 rTransferAmount, , ) = _getValues(tAmount);\\n            return rTransferAmount - rBurnAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function isNoIncomeFee(address account) external view returns (bool) {\\n        return _isNoIncomeFee[account];\\n    }\\n\\n    function grantNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(!_isNoIncomeFee[account], \\\"Account is already no income fee\\\");\\n        _isNoIncomeFee[account] = true;\\n        emit NoIncomeFeeRoleGranted(account);\\n    }\\n\\n    function revokeNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(_isNoIncomeFee[account], \\\"Account is not no income fee\\\");\\n        _isNoIncomeFee[account] = false;\\n        emit NoIncomeFeeRoleRevoked(account);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override(ERC20) notPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_isNoIncomeFee[recipient]) {\\n            _transferWithoutFee(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        (uint256 tBurnAmount, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n        _tTotal -= tBurnAmount;\\n        _rTotal -= rBurnAmount;\\n\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount) = _getValues(tAmount);\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rTransferAmount - rBurnAmount;\\n\\n        // distribute fee\\n        _rTotal -= rFee;\\n\\n        emit Transfer(sender, recipient, tTransferAmount - tBurnAmount);\\n        emit Transfer(sender, address(0), tBurnAmount);\\n        emit Distribution(sender, tAmount - tTransferAmount);\\n    }\\n\\n    function _transferWithoutFee(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rAmount;\\n        emit Transfer(sender, recipient, tAmount);\\n    }\\n\\n    function _getBurnValues(uint256 tAmount) private view returns (uint256, uint256) {\\n        uint256 tBurnAmount = (tAmount * _burnPercent) / 1000;\\n        uint256 currentRate = _getRate();\\n        uint256 rBurnAmount = tBurnAmount * currentRate;\\n        return (tBurnAmount, rBurnAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * _distributionPercent) / 1000;\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        return _rTotal / _tTotal;\\n    }\\n\\n    function transferAll(address recipient) external returns (bool) {\\n        _transfer(_msgSender(), recipient, tokenFromReflection(_rOwned[_msgSender()]));\\n        return true;\\n    }\\n\\n    function transferAllFrom(address account, address recipient) external returns (bool) {\\n        uint256 tAmount = tokenFromReflection(_rOwned[account]);\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"transfer amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _transfer(account, recipient, tAmount);\\n        return true;\\n    }\\n\\n    // for initial token distribution (swap from old token)\\n    function multisend(\\n        address[] memory recipients,\\n        uint256[] memory tAmounts\\n    ) external onlyRole(OWNER_ROLE) {\\n        require(recipients.length <= 200, \\\"More than 200 recipients\\\");\\n\\n        uint256 rTotal;\\n        uint256 rAmount;\\n        uint256 currentRate = _getRate();\\n\\n        uint8 i = 0;\\n        for (i; i < recipients.length; i++) {\\n            rAmount = tAmounts[i] * currentRate;\\n            rTotal += rAmount;\\n            _rOwned[recipients[i]] += rAmount;\\n            emit Transfer(_msgSender(), recipients[i], tAmounts[i]);\\n        }\\n\\n        _rOwned[_msgSender()] -= rTotal;\\n    }\\n\\n    // burn logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        _tTotal -= tAmount;\\n\\n        emit Transfer(account, address(0), tAmount);\\n    }\\n\\n    function burn(uint256 tAmount) external {\\n        _burn(_msgSender(), tAmount);\\n    }\\n\\n    function burnFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _burn(account, tAmount);\\n    }\\n\\n    // mint logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _mint(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"mint to the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] += rAmount;\\n        _rTotal += rAmount; // overflow if tMax (max supply) from constructor exceeded\\n        _tTotal += tAmount;\\n\\n        emit Transfer(address(0), account, tAmount);\\n    }\\n\\n    function mint(address account, uint256 tAmount) external onlyRole(OWNER_ROLE) {\\n        _mint(account, tAmount);\\n    }\\n\\n    // distribute logic -------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _distribute(address account, uint256 tAmount) internal {\\n        (uint256 rAmount, , , ) = _getValues(tAmount);\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        emit Distribution(account, tAmount);\\n    }\\n\\n    function distribute(uint256 tAmount) external {\\n        _distribute(_msgSender(), tAmount);\\n    }\\n\\n    function distributeFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"distribute amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _distribute(account, tAmount);\\n    }\\n\\n    // denomination logic -----------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function denominate(uint256 rate) external onlyRole(OWNER_ROLE) {\\n        _tTotal /= rate;\\n    }\\n\\n    // pause logic ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function pauseTrigger() external onlyRole(OWNER_ROLE) {\\n        if (paused()) {\\n            _unpause();\\n        } else {\\n            _pause();\\n        }\\n    }\\n\\n    // interface support ------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override(AccessControl, ERC1363) returns (bool) {\\n        return AccessControl.supportsInterface(interfaceId) || ERC1363.supportsInterface(interfaceId);\\n    }\\n\\n    // stuck funds ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function stuckFundsTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyRole(OWNER_ROLE) returns (bool) {\\n        return IERC20(token).transfer(to, amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, tamount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"erc-payable-token/contracts/token/ERC1363/ERC1363.sol\\\";\\n\\ncontract Token is ERC1363, ERC20Permit, Pausable, AccessControl {\\n    uint8 private _decimals;\\n    uint256 private _tTotal; // token total\\n    uint256 private _rTotal; // reflection total\\n\\n    mapping(address => uint256) private _rOwned; // reflection balance\\n\\n    // no burn and distribution if transfer to these addresses\\n    mapping(address => bool) private _isNoIncomeFee;\\n    uint256 private _distributionPercent;\\n    uint256 private _burnPercent;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant UNPAUSED_ROLE = keccak256(\\\"UNPAUSED_ROLE\\\");\\n\\n    event DistributionPercentChanged(uint256 value);\\n    event BurnPercentChanged(uint256 value);\\n    event NoIncomeFeeRoleGranted(address indexed account);\\n    event NoIncomeFeeRoleRevoked(address indexed account);\\n    event Distribution(address indexed account, uint256 value);\\n\\n    modifier notPaused() {\\n        if (paused()) {\\n            require(\\n                hasRole(UNPAUSED_ROLE, _msgSender()),\\n                \\\"can't perform an action\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimal,\\n        uint256 tTotal,\\n        uint256 tMax,\\n        uint256 dPercent,\\n        uint256 bPercent\\n    ) ERC20(name, ticker) ERC20Permit(name) {\\n        // init supply\\n        _decimals = decimal;\\n\\n        require(tTotal <= tMax, \\\"max initial supply exceeded\\\");\\n        _tTotal = tTotal * 10**decimal;\\n        uint256 _tMax = tMax * 10**decimal;\\n        _rTotal = (type(uint256).max / _tMax) * _tTotal;\\n\\n        // set fee percents\\n        require(10 <= dPercent && dPercent <= 100 && 10 <= bPercent && bPercent <= 100, \\n            \\\"incorrect fee percent\\\"\\n        );\\n        _distributionPercent = dPercent;\\n        emit DistributionPercentChanged(dPercent);\\n        _burnPercent = bPercent;\\n        emit BurnPercentChanged(bPercent);\\n\\n        // set roles\\n        _setRoleAdmin(ADMIN_ROLE, OWNER_ROLE);\\n        _setRoleAdmin(UNPAUSED_ROLE, ADMIN_ROLE);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        _setupRole(ADMIN_ROLE, _msgSender());\\n        _setupRole(UNPAUSED_ROLE, _msgSender());\\n\\n        // mint inital supply\\n        _rOwned[_msgSender()] = _rTotal;\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    // base logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    // transfer logic ---------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function setDistributionPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _distributionPercent = percent;\\n        emit DistributionPercentChanged(percent);\\n    }\\n\\n    function setBurnPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _burnPercent = percent;\\n        emit BurnPercentChanged(percent);\\n    }\\n\\n    function distributionPercent() external view returns (uint256) {\\n        return _distributionPercent;\\n    }\\n\\n    function burnPercent() external view returns (uint256) {\\n        return _burnPercent;\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n            (, uint256 rTransferAmount, , ) = _getValues(tAmount);\\n            return rTransferAmount - rBurnAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function isNoIncomeFee(address account) external view returns (bool) {\\n        return _isNoIncomeFee[account];\\n    }\\n\\n    function grantNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(!_isNoIncomeFee[account], \\\"Account is already no income fee\\\");\\n        _isNoIncomeFee[account] = true;\\n        emit NoIncomeFeeRoleGranted(account);\\n    }\\n\\n    function revokeNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(_isNoIncomeFee[account], \\\"Account is not no income fee\\\");\\n        _isNoIncomeFee[account] = false;\\n        emit NoIncomeFeeRoleRevoked(account);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override(ERC20) notPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_isNoIncomeFee[recipient]) {\\n            _transferWithoutFee(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        (uint256 tBurnAmount, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n        _tTotal -= tBurnAmount;\\n        _rTotal -= rBurnAmount;\\n\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount) = _getValues(tAmount);\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rTransferAmount - rBurnAmount;\\n\\n        // distribute fee\\n        _rTotal -= rFee;\\n\\n        emit Transfer(sender, recipient, tTransferAmount - tBurnAmount);\\n        emit Transfer(sender, address(0), tBurnAmount);\\n        emit Distribution(sender, tAmount - tTransferAmount);\\n    }\\n\\n    function _transferWithoutFee(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rAmount;\\n        emit Transfer(sender, recipient, tAmount);\\n    }\\n\\n    function _getBurnValues(uint256 tAmount) private view returns (uint256, uint256) {\\n        uint256 tBurnAmount = (tAmount * _burnPercent) / 1000;\\n        uint256 currentRate = _getRate();\\n        uint256 rBurnAmount = tBurnAmount * currentRate;\\n        return (tBurnAmount, rBurnAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * _distributionPercent) / 1000;\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        return _rTotal / _tTotal;\\n    }\\n\\n    function transferAll(address recipient) external returns (bool) {\\n        _transfer(_msgSender(), recipient, tokenFromReflection(_rOwned[_msgSender()]));\\n        return true;\\n    }\\n\\n    function transferAllFrom(address account, address recipient) external returns (bool) {\\n        uint256 tAmount = tokenFromReflection(_rOwned[account]);\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"transfer amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _transfer(account, recipient, tAmount);\\n        return true;\\n    }\\n\\n    // for initial token distribution (swap from old token)\\n    function multisend(\\n        address[] memory recipients,\\n        uint256[] memory tAmounts\\n    ) external onlyRole(OWNER_ROLE) {\\n        require(recipients.length <= 200, \\\"More than 200 recipients\\\");\\n\\n        uint256 rTotal;\\n        uint256 rAmount;\\n        uint256 currentRate = _getRate();\\n\\n        uint8 i = 0;\\n        for (i; i < recipients.length; i++) {\\n            rAmount = tAmounts[i] * currentRate;\\n            rTotal += rAmount;\\n            _rOwned[recipients[i]] += rAmount;\\n            emit Transfer(_msgSender(), recipients[i], tAmounts[i]);\\n        }\\n\\n        _rOwned[_msgSender()] -= rTotal;\\n    }\\n\\n    // burn logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        _tTotal -= tAmount;\\n\\n        emit Transfer(account, address(0), tAmount);\\n    }\\n\\n    function burn(uint256 tAmount) external {\\n        _burn(_msgSender(), tAmount);\\n    }\\n\\n    function burnFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _burn(account, tAmount);\\n    }\\n\\n    // mint logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _mint(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"mint to the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] += rAmount;\\n        _rTotal += rAmount; // overflow if tMax (max supply) from constructor exceeded\\n        _tTotal += tAmount;\\n\\n        emit Transfer(address(0), account, tAmount);\\n    }\\n\\n    function mint(address account, uint256 tAmount) external onlyRole(OWNER_ROLE) {\\n        _mint(account, tAmount);\\n    }\\n\\n    // distribute logic -------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _distribute(address account, uint256 tAmount) internal {\\n        (uint256 rAmount, , , ) = _getValues(tAmount);\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        emit Distribution(account, tAmount);\\n    }\\n\\n    function distribute(uint256 tAmount) external {\\n        _distribute(_msgSender(), tAmount);\\n    }\\n\\n    function distributeFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"distribute amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _distribute(account, tAmount);\\n    }\\n\\n    // denomination logic -----------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function denominate(uint256 rate) external onlyRole(OWNER_ROLE) {\\n        _tTotal /= rate;\\n    }\\n\\n    // pause logic ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function pauseTrigger() external onlyRole(OWNER_ROLE) {\\n        if (paused()) {\\n            _unpause();\\n        } else {\\n            _pause();\\n        }\\n    }\\n\\n    // interface support ------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override(AccessControl, ERC1363) returns (bool) {\\n        return AccessControl.supportsInterface(interfaceId) || ERC1363.supportsInterface(interfaceId);\\n    }\\n\\n    // stuck funds ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function stuckFundsTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyRole(OWNER_ROLE) returns (bool) {\\n        return IERC20(token).transfer(to, amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"erc-payable-token/contracts/token/ERC1363/ERC1363.sol\\\";\\n\\ncontract Token is ERC1363, ERC20Permit, Pausable, AccessControl {\\n    uint8 private _decimals;\\n    uint256 private _tTotal; // token total\\n    uint256 private _rTotal; // reflection total\\n\\n    mapping(address => uint256) private _rOwned; // reflection balance\\n\\n    // no burn and distribution if transfer to these addresses\\n    mapping(address => bool) private _isNoIncomeFee;\\n    uint256 private _distributionPercent;\\n    uint256 private _burnPercent;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant UNPAUSED_ROLE = keccak256(\\\"UNPAUSED_ROLE\\\");\\n\\n    event DistributionPercentChanged(uint256 value);\\n    event BurnPercentChanged(uint256 value);\\n    event NoIncomeFeeRoleGranted(address indexed account);\\n    event NoIncomeFeeRoleRevoked(address indexed account);\\n    event Distribution(address indexed account, uint256 value);\\n\\n    modifier notPaused() {\\n        if (paused()) {\\n            require(\\n                hasRole(UNPAUSED_ROLE, _msgSender()),\\n                \\\"can't perform an action\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimal,\\n        uint256 tTotal,\\n        uint256 tMax,\\n        uint256 dPercent,\\n        uint256 bPercent\\n    ) ERC20(name, ticker) ERC20Permit(name) {\\n        // init supply\\n        _decimals = decimal;\\n\\n        require(tTotal <= tMax, \\\"max initial supply exceeded\\\");\\n        _tTotal = tTotal * 10**decimal;\\n        uint256 _tMax = tMax * 10**decimal;\\n        _rTotal = (type(uint256).max / _tMax) * _tTotal;\\n\\n        // set fee percents\\n        require(10 <= dPercent && dPercent <= 100 && 10 <= bPercent && bPercent <= 100, \\n            \\\"incorrect fee percent\\\"\\n        );\\n        _distributionPercent = dPercent;\\n        emit DistributionPercentChanged(dPercent);\\n        _burnPercent = bPercent;\\n        emit BurnPercentChanged(bPercent);\\n\\n        // set roles\\n        _setRoleAdmin(ADMIN_ROLE, OWNER_ROLE);\\n        _setRoleAdmin(UNPAUSED_ROLE, ADMIN_ROLE);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        _setupRole(ADMIN_ROLE, _msgSender());\\n        _setupRole(UNPAUSED_ROLE, _msgSender());\\n\\n        // mint inital supply\\n        _rOwned[_msgSender()] = _rTotal;\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    // base logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    // transfer logic ---------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function setDistributionPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _distributionPercent = percent;\\n        emit DistributionPercentChanged(percent);\\n    }\\n\\n    function setBurnPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _burnPercent = percent;\\n        emit BurnPercentChanged(percent);\\n    }\\n\\n    function distributionPercent() external view returns (uint256) {\\n        return _distributionPercent;\\n    }\\n\\n    function burnPercent() external view returns (uint256) {\\n        return _burnPercent;\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n            (, uint256 rTransferAmount, , ) = _getValues(tAmount);\\n            return rTransferAmount - rBurnAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function isNoIncomeFee(address account) external view returns (bool) {\\n        return _isNoIncomeFee[account];\\n    }\\n\\n    function grantNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(!_isNoIncomeFee[account], \\\"Account is already no income fee\\\");\\n        _isNoIncomeFee[account] = true;\\n        emit NoIncomeFeeRoleGranted(account);\\n    }\\n\\n    function revokeNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(_isNoIncomeFee[account], \\\"Account is not no income fee\\\");\\n        _isNoIncomeFee[account] = false;\\n        emit NoIncomeFeeRoleRevoked(account);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override(ERC20) notPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_isNoIncomeFee[recipient]) {\\n            _transferWithoutFee(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        (uint256 tBurnAmount, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n        _tTotal -= tBurnAmount;\\n        _rTotal -= rBurnAmount;\\n\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount) = _getValues(tAmount);\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rTransferAmount - rBurnAmount;\\n\\n        // distribute fee\\n        _rTotal -= rFee;\\n\\n        emit Transfer(sender, recipient, tTransferAmount - tBurnAmount);\\n        emit Transfer(sender, address(0), tBurnAmount);\\n        emit Distribution(sender, tAmount - tTransferAmount);\\n    }\\n\\n    function _transferWithoutFee(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rAmount;\\n        emit Transfer(sender, recipient, tAmount);\\n    }\\n\\n    function _getBurnValues(uint256 tAmount) private view returns (uint256, uint256) {\\n        uint256 tBurnAmount = (tAmount * _burnPercent) / 1000;\\n        uint256 currentRate = _getRate();\\n        uint256 rBurnAmount = tBurnAmount * currentRate;\\n        return (tBurnAmount, rBurnAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * _distributionPercent) / 1000;\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        return _rTotal / _tTotal;\\n    }\\n\\n    function transferAll(address recipient) external returns (bool) {\\n        _transfer(_msgSender(), recipient, tokenFromReflection(_rOwned[_msgSender()]));\\n        return true;\\n    }\\n\\n    function transferAllFrom(address account, address recipient) external returns (bool) {\\n        uint256 tAmount = tokenFromReflection(_rOwned[account]);\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"transfer amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _transfer(account, recipient, tAmount);\\n        return true;\\n    }\\n\\n    // for initial token distribution (swap from old token)\\n    function multisend(\\n        address[] memory recipients,\\n        uint256[] memory tAmounts\\n    ) external onlyRole(OWNER_ROLE) {\\n        require(recipients.length <= 200, \\\"More than 200 recipients\\\");\\n\\n        uint256 rTotal;\\n        uint256 rAmount;\\n        uint256 currentRate = _getRate();\\n\\n        uint8 i = 0;\\n        for (i; i < recipients.length; i++) {\\n            rAmount = tAmounts[i] * currentRate;\\n            rTotal += rAmount;\\n            _rOwned[recipients[i]] += rAmount;\\n            emit Transfer(_msgSender(), recipients[i], tAmounts[i]);\\n        }\\n\\n        _rOwned[_msgSender()] -= rTotal;\\n    }\\n\\n    // burn logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        _tTotal -= tAmount;\\n\\n        emit Transfer(account, address(0), tAmount);\\n    }\\n\\n    function burn(uint256 tAmount) external {\\n        _burn(_msgSender(), tAmount);\\n    }\\n\\n    function burnFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _burn(account, tAmount);\\n    }\\n\\n    // mint logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _mint(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"mint to the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] += rAmount;\\n        _rTotal += rAmount; // overflow if tMax (max supply) from constructor exceeded\\n        _tTotal += tAmount;\\n\\n        emit Transfer(address(0), account, tAmount);\\n    }\\n\\n    function mint(address account, uint256 tAmount) external onlyRole(OWNER_ROLE) {\\n        _mint(account, tAmount);\\n    }\\n\\n    // distribute logic -------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _distribute(address account, uint256 tAmount) internal {\\n        (uint256 rAmount, , , ) = _getValues(tAmount);\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        emit Distribution(account, tAmount);\\n    }\\n\\n    function distribute(uint256 tAmount) external {\\n        _distribute(_msgSender(), tAmount);\\n    }\\n\\n    function distributeFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"distribute amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _distribute(account, tAmount);\\n    }\\n\\n    // denomination logic -----------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function denominate(uint256 rate) external onlyRole(OWNER_ROLE) {\\n        _tTotal /= rate;\\n    }\\n\\n    // pause logic ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function pauseTrigger() external onlyRole(OWNER_ROLE) {\\n        if (paused()) {\\n            _unpause();\\n        } else {\\n            _pause();\\n        }\\n    }\\n\\n    // interface support ------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override(AccessControl, ERC1363) returns (bool) {\\n        return AccessControl.supportsInterface(interfaceId) || ERC1363.supportsInterface(interfaceId);\\n    }\\n\\n    // stuck funds ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function stuckFundsTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyRole(OWNER_ROLE) returns (bool) {\\n        return IERC20(token).transfer(to, amount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\nimport \\\"erc-payable-token/contracts/token/ERC1363/ERC1363.sol\\\";\\n\\ncontract Token is ERC1363, ERC20Permit, Pausable, AccessControl {\\n    uint8 private _decimals;\\n    uint256 private _tTotal; // token total\\n    uint256 private _rTotal; // reflection total\\n\\n    mapping(address => uint256) private _rOwned; // reflection balance\\n\\n    // no burn and distribution if transfer to these addresses\\n    mapping(address => bool) private _isNoIncomeFee;\\n    uint256 private _distributionPercent;\\n    uint256 private _burnPercent;\\n\\n    bytes32 public constant OWNER_ROLE = keccak256(\\\"OWNER_ROLE\\\");\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n    bytes32 public constant UNPAUSED_ROLE = keccak256(\\\"UNPAUSED_ROLE\\\");\\n\\n    event DistributionPercentChanged(uint256 value);\\n    event BurnPercentChanged(uint256 value);\\n    event NoIncomeFeeRoleGranted(address indexed account);\\n    event NoIncomeFeeRoleRevoked(address indexed account);\\n    event Distribution(address indexed account, uint256 value);\\n\\n    modifier notPaused() {\\n        if (paused()) {\\n            require(\\n                hasRole(UNPAUSED_ROLE, _msgSender()),\\n                \\\"can't perform an action\\\"\\n            );\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name,\\n        string memory ticker,\\n        uint8 decimal,\\n        uint256 tTotal,\\n        uint256 tMax,\\n        uint256 dPercent,\\n        uint256 bPercent\\n    ) ERC20(name, ticker) ERC20Permit(name) {\\n        // init supply\\n        _decimals = decimal;\\n\\n        require(tTotal <= tMax, \\\"max initial supply exceeded\\\");\\n        _tTotal = tTotal * 10**decimal;\\n        uint256 _tMax = tMax * 10**decimal;\\n        _rTotal = (type(uint256).max / _tMax) * _tTotal;\\n\\n        // set fee percents\\n        require(10 <= dPercent && dPercent <= 100 && 10 <= bPercent && bPercent <= 100, \\n            \\\"incorrect fee percent\\\"\\n        );\\n        _distributionPercent = dPercent;\\n        emit DistributionPercentChanged(dPercent);\\n        _burnPercent = bPercent;\\n        emit BurnPercentChanged(bPercent);\\n\\n        // set roles\\n        _setRoleAdmin(ADMIN_ROLE, OWNER_ROLE);\\n        _setRoleAdmin(UNPAUSED_ROLE, ADMIN_ROLE);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(OWNER_ROLE, _msgSender());\\n        _setupRole(ADMIN_ROLE, _msgSender());\\n        _setupRole(UNPAUSED_ROLE, _msgSender());\\n\\n        // mint inital supply\\n        _rOwned[_msgSender()] = _rTotal;\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\n    }\\n\\n    // base logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    // transfer logic ---------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function setDistributionPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _distributionPercent = percent;\\n        emit DistributionPercentChanged(percent);\\n    }\\n\\n    function setBurnPercent(uint256 percent) external onlyRole(OWNER_ROLE) {\\n        require(10 <= percent && percent <= 100, \\\"incorrect fee percent\\\"); // 1% <= percent <= 10%\\n        _burnPercent = percent;\\n        emit BurnPercentChanged(percent);\\n    }\\n\\n    function distributionPercent() external view returns (uint256) {\\n        return _distributionPercent;\\n    }\\n\\n    function burnPercent() external view returns (uint256) {\\n        return _burnPercent;\\n    }\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n            (, uint256 rTransferAmount, , ) = _getValues(tAmount);\\n            return rTransferAmount - rBurnAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount <= _rTotal, \\\"Amount must be less than total reflections\\\");\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function isNoIncomeFee(address account) external view returns (bool) {\\n        return _isNoIncomeFee[account];\\n    }\\n\\n    function grantNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(!_isNoIncomeFee[account], \\\"Account is already no income fee\\\");\\n        _isNoIncomeFee[account] = true;\\n        emit NoIncomeFeeRoleGranted(account);\\n    }\\n\\n    function revokeNoIncomeFee(address account) external onlyRole(ADMIN_ROLE) {\\n        require(_isNoIncomeFee[account], \\\"Account is not no income fee\\\");\\n        _isNoIncomeFee[account] = false;\\n        emit NoIncomeFeeRoleRevoked(account);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal override(ERC20) notPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_isNoIncomeFee[recipient]) {\\n            _transferWithoutFee(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n    }\\n\\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\\n        (uint256 tBurnAmount, uint256 rBurnAmount) = _getBurnValues(tAmount);\\n        _tTotal -= tBurnAmount;\\n        _rTotal -= rBurnAmount;\\n\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount) = _getValues(tAmount);\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rTransferAmount - rBurnAmount;\\n\\n        // distribute fee\\n        _rTotal -= rFee;\\n\\n        emit Transfer(sender, recipient, tTransferAmount - tBurnAmount);\\n        emit Transfer(sender, address(0), tBurnAmount);\\n        emit Distribution(sender, tAmount - tTransferAmount);\\n    }\\n\\n    function _transferWithoutFee(address sender, address recipient, uint256 tAmount) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[sender] -= rAmount;\\n        _rOwned[recipient] += rAmount;\\n        emit Transfer(sender, recipient, tAmount);\\n    }\\n\\n    function _getBurnValues(uint256 tAmount) private view returns (uint256, uint256) {\\n        uint256 tBurnAmount = (tAmount * _burnPercent) / 1000;\\n        uint256 currentRate = _getRate();\\n        uint256 rBurnAmount = tBurnAmount * currentRate;\\n        return (tBurnAmount, rBurnAmount);\\n    }\\n\\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = (tAmount * _distributionPercent) / 1000;\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        return _rTotal / _tTotal;\\n    }\\n\\n    function transferAll(address recipient) external returns (bool) {\\n        _transfer(_msgSender(), recipient, tokenFromReflection(_rOwned[_msgSender()]));\\n        return true;\\n    }\\n\\n    function transferAllFrom(address account, address recipient) external returns (bool) {\\n        uint256 tAmount = tokenFromReflection(_rOwned[account]);\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"transfer amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _transfer(account, recipient, tAmount);\\n        return true;\\n    }\\n\\n    // for initial token distribution (swap from old token)\\n    function multisend(\\n        address[] memory recipients,\\n        uint256[] memory tAmounts\\n    ) external onlyRole(OWNER_ROLE) {\\n        require(recipients.length <= 200, \\\"More than 200 recipients\\\");\\n\\n        uint256 rTotal;\\n        uint256 rAmount;\\n        uint256 currentRate = _getRate();\\n\\n        uint8 i = 0;\\n        for (i; i < recipients.length; i++) {\\n            rAmount = tAmounts[i] * currentRate;\\n            rTotal += rAmount;\\n            _rOwned[recipients[i]] += rAmount;\\n            emit Transfer(_msgSender(), recipients[i], tAmounts[i]);\\n        }\\n\\n        _rOwned[_msgSender()] -= rTotal;\\n    }\\n\\n    // burn logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _burn(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"burn from the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        _tTotal -= tAmount;\\n\\n        emit Transfer(account, address(0), tAmount);\\n    }\\n\\n    function burn(uint256 tAmount) external {\\n        _burn(_msgSender(), tAmount);\\n    }\\n\\n    function burnFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _burn(account, tAmount);\\n    }\\n\\n    // mint logic -------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _mint(address account, uint256 tAmount) internal notPaused override {\\n        require(account != address(0), \\\"mint to the zero address\\\");\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rAmount = tAmount * currentRate;\\n        _rOwned[account] += rAmount;\\n        _rTotal += rAmount; // overflow if tMax (max supply) from constructor exceeded\\n        _tTotal += tAmount;\\n\\n        emit Transfer(address(0), account, tAmount);\\n    }\\n\\n    function mint(address account, uint256 tAmount) external onlyRole(OWNER_ROLE) {\\n        _mint(account, tAmount);\\n    }\\n\\n    // distribute logic -------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function _distribute(address account, uint256 tAmount) internal {\\n        (uint256 rAmount, , , ) = _getValues(tAmount);\\n        _rOwned[account] -= rAmount;\\n        _rTotal -= rAmount;\\n        emit Distribution(account, tAmount);\\n    }\\n\\n    function distribute(uint256 tAmount) external {\\n        _distribute(_msgSender(), tAmount);\\n    }\\n\\n    function distributeFrom(address account, uint256 tAmount) external {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= tAmount, \\\"distribute amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - tAmount);\\n        _distribute(account, tAmount);\\n    }\\n\\n    // denomination logic -----------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function denominate(uint256 rate) external onlyRole(OWNER_ROLE) {\\n        _tTotal /= rate;\\n    }\\n\\n    // pause logic ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function pauseTrigger() external onlyRole(OWNER_ROLE) {\\n        if (paused()) {\\n            _unpause();\\n        } else {\\n            _pause();\\n        }\\n    }\\n\\n    // interface support ------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override(AccessControl, ERC1363) returns (bool) {\\n        return AccessControl.supportsInterface(interfaceId) || ERC1363.supportsInterface(interfaceId);\\n    }\\n\\n    // stuck funds ------------------------------------------------------------\\n    // ------------------------------------------------------------------------\\n\\n    function stuckFundsTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyRole(OWNER_ROLE) returns (bool) {\\n        return IERC20(token).transfer(to, amount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}