{
  "total_matches": 7,
  "patterns_found": {
    "minting_mechanics": {
      "count": 7,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================= FRAXShares (FXS) =========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author(s)\\n// Travis Moore: https://github.com/FortisFortuna\\n// Jason Huan: https://github.com/jasonhuan\\n// Sam Kazemian: https://github.com/samkazemian\\n\\n// Reviewer(s) / Contributor(s)\\n// Sam Sun: https://github.com/samczsun\\n\\nimport \\\"../lib/Common/Context.sol\\\";\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\n// import \\\"../Frax/Frax.sol\\\";\\nimport \\\"../lib/Staking/Owned.sol\\\";\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\n\\ncontract USH is ERC20Custom, AccessControl, Owned {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    //address public FRAXStablecoinAdd;\\n    \\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\n\\n    address public timelock_address; // Governance timelock address\\n    //FRAXStablecoin private FRAX;\\n\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\n\\n    // A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    // A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    // The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // modifier onlyPools() {\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\n    //     _;\\n    // } \\n    \\n    modifier onlyByOwnGov() {\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor (\\n        string memory _name,\\n        string memory _symbol, \\n        address _creator_address,\\n        address _timelock_address\\n    ) public Owned(_creator_address){\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _mint(_creator_address, genesis_supply);\\n\\n        // Do a checkpoint for the owner\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\n        timelock_address = new_timelock;\\n    }\\n    \\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\n\\n    //     emit FRAXAddressSet(frax_contract_address);\\n    // }\\n    \\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n    //     if(trackingVotes){\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\n    //     }\\n\\n    //     super._mint(m_address, m_amount);\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\n    // }\\n\\n    // // This function is what other frax pools will call to burn FXS \\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n    //     if(trackingVotes){\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\n    //     }\\n\\n    //     super._burnFrom(b_address, b_amount);\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\n    // }\\n\\n    function toggleVotes() external onlyByOwnGov {\\n        trackingVotes = !trackingVotes;\\n    }\\n\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\n        }\\n\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(sender, recipient, uint96(amount));\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    // From compound's _moveDelegates\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[voter] = nCheckpoints + 1;\\n      }\\n\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    \\n    /// @notice An event thats emitted when a voters account's vote balance changes\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\n\\n    // // Track FXS burned\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // // Track FXS minted\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    // event FRAXAddressSet(address addr);\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.11;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\nimport \\\"../Utils/Address.sol\\\";\\n\\n// Due to compiling issues, _name, _symbol, and _decimals were removed\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Custom is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_creator_address, genesis_supply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================= FRAXShares (FXS) =========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author(s)\\n// Travis Moore: https://github.com/FortisFortuna\\n// Jason Huan: https://github.com/jasonhuan\\n// Sam Kazemian: https://github.com/samkazemian\\n\\n// Reviewer(s) / Contributor(s)\\n// Sam Sun: https://github.com/samczsun\\n\\nimport \\\"../lib/Common/Context.sol\\\";\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\n// import \\\"../Frax/Frax.sol\\\";\\nimport \\\"../lib/Staking/Owned.sol\\\";\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\n\\ncontract USH is ERC20Custom, AccessControl, Owned {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    //address public FRAXStablecoinAdd;\\n    \\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\n\\n    address public timelock_address; // Governance timelock address\\n    //FRAXStablecoin private FRAX;\\n\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\n\\n    // A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    // A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    // The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // modifier onlyPools() {\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\n    //     _;\\n    // } \\n    \\n    modifier onlyByOwnGov() {\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor (\\n        string memory _name,\\n        string memory _symbol, \\n        address _creator_address,\\n        address _timelock_address\\n    ) public Owned(_creator_address){\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _mint(_creator_address, genesis_supply);\\n\\n        // Do a checkpoint for the owner\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\n        timelock_address = new_timelock;\\n    }\\n    \\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\n\\n    //     emit FRAXAddressSet(frax_contract_address);\\n    // }\\n    \\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n    //     if(trackingVotes){\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\n    //     }\\n\\n    //     super._mint(m_address, m_amount);\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\n    // }\\n\\n    // // This function is what other frax pools will call to burn FXS \\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n    //     if(trackingVotes){\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\n    //     }\\n\\n    //     super._burnFrom(b_address, b_amount);\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\n    // }\\n\\n    function toggleVotes() external onlyByOwnGov {\\n        trackingVotes = !trackingVotes;\\n    }\\n\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\n        }\\n\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(sender, recipient, uint96(amount));\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    // From compound's _moveDelegates\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[voter] = nCheckpoints + 1;\\n      }\\n\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    \\n    /// @notice An event thats emitted when a voters account's vote balance changes\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\n\\n    // // Track FXS burned\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // // Track FXS minted\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    // event FRAXAddressSet(address addr);\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================= FRAXShares (FXS) =========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author(s)\\n// Travis Moore: https://github.com/FortisFortuna\\n// Jason Huan: https://github.com/jasonhuan\\n// Sam Kazemian: https://github.com/samkazemian\\n\\n// Reviewer(s) / Contributor(s)\\n// Sam Sun: https://github.com/samczsun\\n\\nimport \\\"../lib/Common/Context.sol\\\";\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\n// import \\\"../Frax/Frax.sol\\\";\\nimport \\\"../lib/Staking/Owned.sol\\\";\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\n\\ncontract USH is ERC20Custom, AccessControl, Owned {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    //address public FRAXStablecoinAdd;\\n    \\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\n\\n    address public timelock_address; // Governance timelock address\\n    //FRAXStablecoin private FRAX;\\n\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\n\\n    // A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    // A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    // The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // modifier onlyPools() {\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\n    //     _;\\n    // } \\n    \\n    modifier onlyByOwnGov() {\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor (\\n        string memory _name,\\n        string memory _symbol, \\n        address _creator_address,\\n        address _timelock_address\\n    ) public Owned(_creator_address){\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _mint(_creator_address, genesis_supply);\\n\\n        // Do a checkpoint for the owner\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\n        timelock_address = new_timelock;\\n    }\\n    \\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\n\\n    //     emit FRAXAddressSet(frax_contract_address);\\n    // }\\n    \\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n    //     if(trackingVotes){\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\n    //     }\\n\\n    //     super._mint(m_address, m_amount);\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\n    // }\\n\\n    // // This function is what other frax pools will call to burn FXS \\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n    //     if(trackingVotes){\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\n    //     }\\n\\n    //     super._burnFrom(b_address, b_amount);\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\n    // }\\n\\n    function toggleVotes() external onlyByOwnGov {\\n        trackingVotes = !trackingVotes;\\n    }\\n\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\n        }\\n\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(sender, recipient, uint96(amount));\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    // From compound's _moveDelegates\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[voter] = nCheckpoints + 1;\\n      }\\n\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    \\n    /// @notice An event thats emitted when a voters account's vote balance changes\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\n\\n    // // Track FXS burned\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // // Track FXS minted\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    // event FRAXAddressSet(address addr);\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address m_address, uint256 m_amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================= FRAXShares (FXS) =========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author(s)\\n// Travis Moore: https://github.com/FortisFortuna\\n// Jason Huan: https://github.com/jasonhuan\\n// Sam Kazemian: https://github.com/samkazemian\\n\\n// Reviewer(s) / Contributor(s)\\n// Sam Sun: https://github.com/samczsun\\n\\nimport \\\"../lib/Common/Context.sol\\\";\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\n// import \\\"../Frax/Frax.sol\\\";\\nimport \\\"../lib/Staking/Owned.sol\\\";\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\n\\ncontract USH is ERC20Custom, AccessControl, Owned {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    //address public FRAXStablecoinAdd;\\n    \\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\n\\n    address public timelock_address; // Governance timelock address\\n    //FRAXStablecoin private FRAX;\\n\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\n\\n    // A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    // A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    // The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // modifier onlyPools() {\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\n    //     _;\\n    // } \\n    \\n    modifier onlyByOwnGov() {\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor (\\n        string memory _name,\\n        string memory _symbol, \\n        address _creator_address,\\n        address _timelock_address\\n    ) public Owned(_creator_address){\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _mint(_creator_address, genesis_supply);\\n\\n        // Do a checkpoint for the owner\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\n        timelock_address = new_timelock;\\n    }\\n    \\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\n\\n    //     emit FRAXAddressSet(frax_contract_address);\\n    // }\\n    \\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n    //     if(trackingVotes){\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\n    //     }\\n\\n    //     super._mint(m_address, m_amount);\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\n    // }\\n\\n    // // This function is what other frax pools will call to burn FXS \\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n    //     if(trackingVotes){\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\n    //     }\\n\\n    //     super._burnFrom(b_address, b_amount);\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\n    // }\\n\\n    function toggleVotes() external onlyByOwnGov {\\n        trackingVotes = !trackingVotes;\\n    }\\n\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\n        }\\n\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(sender, recipient, uint96(amount));\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    // From compound's _moveDelegates\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[voter] = nCheckpoints + 1;\\n      }\\n\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    \\n    /// @notice An event thats emitted when a voters account's vote balance changes\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\n\\n    // // Track FXS burned\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // // Track FXS minted\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    // event FRAXAddressSet(address addr);\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(m_address, m_amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// ====================================================================\\n// |     ______                   _______                             |\\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\\\/ __ `/ __ \\\\/ ___/ _ \\\\  |\\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\\n// | /_/   /_/   \\\\__,_/_/|_|  /_/   /_/_/ /_/\\\\__,_/_/ /_/\\\\___/\\\\___/   |\\n// |                                                                  |\\n// ====================================================================\\n// ========================= FRAXShares (FXS) =========================\\n// ====================================================================\\n// Frax Finance: https://github.com/FraxFinance\\n\\n// Primary Author(s)\\n// Travis Moore: https://github.com/FortisFortuna\\n// Jason Huan: https://github.com/jasonhuan\\n// Sam Kazemian: https://github.com/samkazemian\\n\\n// Reviewer(s) / Contributor(s)\\n// Sam Sun: https://github.com/samczsun\\n\\nimport \\\"../lib/Common/Context.sol\\\";\\nimport \\\"../lib/ERC20/ERC20Custom.sol\\\";\\nimport \\\"../lib/ERC20/IERC20.sol\\\";\\n// import \\\"../Frax/Frax.sol\\\";\\nimport \\\"../lib/Staking/Owned.sol\\\";\\nimport \\\"../lib/Math/SafeMath.sol\\\";\\nimport \\\"../lib/Governance/AccessControl.sol\\\";\\n\\ncontract USH is ERC20Custom, AccessControl, Owned {\\n    using SafeMath for uint256;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    //address public FRAXStablecoinAdd;\\n    \\n    uint256 public constant genesis_supply = 143500000e18; // 143.5M is printed upon genesis\\n\\n    address public timelock_address; // Governance timelock address\\n    //FRAXStablecoin private FRAX;\\n\\n    bool public trackingVotes = true; // Tracking votes (only change if need to disable votes)\\n\\n    // A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    // A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    // The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    // modifier onlyPools() {\\n    //    require(FRAX.frax_pools(msg.sender) == true, \\\"Only frax pools can mint new FRAX\\\");\\n    //     _;\\n    // } \\n    \\n    modifier onlyByOwnGov() {\\n        require(msg.sender == owner || msg.sender == timelock_address, \\\"You are not an owner or the governance timelock\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor (\\n        string memory _name,\\n        string memory _symbol, \\n        address _creator_address,\\n        address _timelock_address\\n    ) public Owned(_creator_address){\\n        require((_timelock_address != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        timelock_address = _timelock_address;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _mint(_creator_address, genesis_supply);\\n\\n        // Do a checkpoint for the owner\\n        _writeCheckpoint(_creator_address, 0, 0, uint96(genesis_supply));\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n    function setTimelock(address new_timelock) external onlyByOwnGov {\\n        require(new_timelock != address(0), \\\"Timelock address cannot be 0\\\");\\n        timelock_address = new_timelock;\\n    }\\n    \\n    // function setFRAXAddress(address frax_contract_address) external onlyByOwnGov {\\n    //     require(frax_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n    //     FRAX = FRAXStablecoin(frax_contract_address);\\n\\n    //     emit FRAXAddressSet(frax_contract_address);\\n    // }\\n    \\n    function mint(address to, uint256 amount) public onlyByOwnGov {\\n        _mint(to, amount);\\n    }\\n    \\n    // This function is what other frax pools will call to mint new FXS (similar to the FRAX mint) \\n    // function pool_mint(address m_address, uint256 m_amount) external onlyPools {        \\n    //     if(trackingVotes){\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = add96(srcRepOld, uint96(m_amount), \\\"pool_mint new votes overflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // mint new votes\\n    //         trackVotes(address(this), m_address, uint96(m_amount));\\n    //     }\\n\\n    //     super._mint(m_address, m_amount);\\n    //     emit FXSMinted(address(this), m_address, m_amount);\\n    // }\\n\\n    // // This function is what other frax pools will call to burn FXS \\n    // function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n    //     if(trackingVotes){\\n    //         trackVotes(b_address, address(this), uint96(b_amount));\\n    //         uint32 srcRepNum = numCheckpoints[address(this)];\\n    //         uint96 srcRepOld = srcRepNum > 0 ? checkpoints[address(this)][srcRepNum - 1].votes : 0;\\n    //         uint96 srcRepNew = sub96(srcRepOld, uint96(b_amount), \\\"pool_burn_from new votes underflows\\\");\\n    //         _writeCheckpoint(address(this), srcRepNum, srcRepOld, srcRepNew); // burn votes\\n    //     }\\n\\n    //     super._burnFrom(b_address, b_amount);\\n    //     emit FXSBurned(b_address, address(this), b_amount);\\n    // }\\n\\n    function toggleVotes() external onlyByOwnGov {\\n        trackingVotes = !trackingVotes;\\n    }\\n\\n    /* ========== OVERRIDDEN PUBLIC FUNCTIONS ========== */\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(_msgSender(), recipient, uint96(amount));\\n        }\\n\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if(trackingVotes){\\n            // Transfer votes\\n            trackVotes(sender, recipient, uint96(amount));\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n\\n        return true;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber < block.number, \\\"USH::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    // From compound's _moveDelegates\\n    // Keep track of votes. \\\"Delegates\\\" is a misnomer here\\n    function trackVotes(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"USH::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"USH::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address voter, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"USH::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints > 0 && checkpoints[voter][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[voter][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[voter][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[voter] = nCheckpoints + 1;\\n      }\\n\\n      emit VoterVotesChanged(voter, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    \\n    /// @notice An event thats emitted when a voters account's vote balance changes\\n    event VoterVotesChanged(address indexed voter, uint previousBalance, uint newBalance);\\n\\n    // // Track FXS burned\\n    // event FXSBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // // Track FXS minted\\n    // event FXSMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    // event FRAXAddressSet(address addr);\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.11;\\n\\nimport \\\"../Common/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../Math/SafeMath.sol\\\";\\nimport \\\"../Utils/Address.sol\\\";\\n\\n// Due to compiling issues, _name, _symbol, and _decimals were removed\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Custom is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}