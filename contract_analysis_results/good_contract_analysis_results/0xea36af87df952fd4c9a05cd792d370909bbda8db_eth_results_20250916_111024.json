{
  "total_matches": 3,
  "patterns_found": {
    "honeypot_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "assembly {\\n            result := number()\\n            // branch-less out-of-gas revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\n/// @notice ERC20 with votes based on ERC5805 and ERC6372.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20Votes.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Votes.sol)\\nabstract contract ERC20Votes is ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The timepoint is in the future.\\n    error ERC5805FutureLookup();\\n\\n    /// @dev The ERC5805 signature to set a delegate has expired.\\n    error ERC5805DelegateSignatureExpired();\\n\\n    /// @dev The ERC5805 signature to set a delegate is invalid.\\n    error ERC5805DelegateInvalidSignature();\\n\\n    /// @dev Out-of-bounds access for the checkpoints.\\n    error ERC5805CheckpointIndexOutOfBounds();\\n\\n    /// @dev Arithmetic overflow when pushing a new checkpoint.\\n    error ERC5805CheckpointValueOverflow();\\n\\n    /// @dev Arithmetic underflow when pushing a new checkpoint.\\n    error ERC5805CheckpointValueUnderflow();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The delegate of `delegator` is changed from `from` to `to`.\\n    event DelegateChanged(address indexed delegator, address indexed from, address indexed to);\\n\\n    /// @dev The votes balance of `delegate` is changed from `oldValue` to `newValue`.\\n    event DelegateVotesChanged(address indexed delegate, uint256 oldValue, uint256 newValue);\\n\\n    /// @dev `keccak256(bytes(\\\"DelegateChanged(address,address,address)\\\"))`.\\n    uint256 private constant _DELEGATE_CHANGED_EVENT_SIGNATURE =\\n        0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f;\\n\\n    /// @dev `keccak256(bytes(\\\"DelegateVotesChanged(address,uint256,uint256)\\\"))`.\\n    uint256 private constant _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE =\\n        0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\")`.\\n    bytes32 private constant _ERC5805_DELEGATION_TYPEHASH =\\n        0xe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The slot of a delegate is given by:\\n    /// ```\\n    ///     mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\\n    ///     mstore(0x00, account)\\n    ///     let delegateSlot := keccak256(0x0c, 0x18)\\n    /// ```\\n    /// The checkpoints length slot of a delegate is given by:\\n    /// ```\\n    ///     mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\\n    ///     mstore(0x00, delegate)\\n    ///     let lengthSlot := keccak256(0x0c, 0x17)\\n    ///     let length := and(0xffffffffffff, shr(48, sload(lengthSlot)))\\n    /// ```\\n    /// The total checkpoints length slot is `_ERC20_VOTES_MASTER_SLOT_SEED << 96`.\\n    ///\\n    /// The `i`-th checkpoint slot is given by:\\n    /// ```\\n    ///     let checkpointSlot := add(i, lengthSlot)\\n    ///     let key := and(sload(checkpointSlot), 0xffffffffffff)\\n    ///     let value := shr(96, sload(checkpointSlot))\\n    ///     if eq(value, address()) { value := sload(not(checkpointSlot)) }\\n    /// ```\\n    uint256 private constant _ERC20_VOTES_MASTER_SLOT_SEED = 0xff466c9f;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ERC6372                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the clock mode.\\n    function CLOCK_MODE() public view virtual returns (string memory) {\\n        return \\\"mode=blocknumber&from=default\\\";\\n    }\\n\\n    /// @dev Returns the current clock.\\n    function clock() public view virtual returns (uint48 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := number()\\n            // Branch-less out-of-gas revert if `block.number >= 2 ** 48`.\\n            returndatacopy(returndatasize(), returndatasize(), sub(0, shr(48, number())))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ERC5805                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the latest amount of voting units for `account`.\\n    function getVotes(address account) public view virtual returns (uint256) {\\n        return _checkpointLatest(_delegateCheckpointsSlot(account));\\n    }\\n\\n    /// @dev Returns the latest amount of voting units `account` has before or during `timepoint`.\\n    function getPastVotes(address account, uint256 timepoint)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\\n        return _checkpointUpperLookupRecent(_delegateCheckpointsSlot(account), timepoint);\\n    }\\n\\n    /// @dev Returns the current voting delegate of `delegator`.\\n    function delegates(address delegator) public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\\n            mstore(0x00, delegator)\\n            result := sload(keccak256(0x0c, 0x18))\\n        }\\n    }\\n\\n    /// @dev Set the voting delegate of the caller to `delegatee`.\\n    function delegate(address delegatee) public virtual {\\n        _delegate(msg.sender, delegatee);\\n    }\\n\\n    /// @dev Sets the voting delegate of the signature signer to `delegatee`.\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        address signer;\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if gt(timestamp(), expiry) {\\n                mstore(0x00, 0x3480e9e1) // `ERC5805DelegateSignatureExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40)\\n            // Prepare the struct hash.\\n            mstore(0x00, _ERC5805_DELEGATION_TYPEHASH)\\n            mstore(0x20, shr(96, shl(96, delegatee)))\\n            mstore(0x40, nonce)\\n            mstore(0x60, expiry)\\n            mstore(0x40, keccak256(0x00, 0x80))\\n            mstore(0x00, 0x1901) // Store \\\"\\\\x19\\\\x01\\\".\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x20, keccak256(m, 0xa0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x1e, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            signer := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            expiry := iszero(returndatasize()) // Reuse `expiry` to denote `ecrecover` failure.\\n        }\\n        if ((nonces(signer) ^ nonce) | expiry != 0) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x1838d95c) // `ERC5805DelegateInvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _incrementNonce(signer);\\n        _delegate(signer, delegatee);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              OTHER VOTE PUBLIC VIEW FUNCTIONS              */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of checkpoints for `account`.\\n    function checkpointCount(address account) public view virtual returns (uint256 result) {\\n        result = _delegateCheckpointsSlot(account);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(208, shl(160, sload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the voting checkpoint for `account` at index `i`.\\n    function checkpointAt(address account, uint256 i)\\n        public\\n        view\\n        virtual\\n        returns (uint48 checkpointClock, uint256 checkpointValue)\\n    {\\n        uint256 lengthSlot = _delegateCheckpointsSlot(account);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(lt(i, shr(208, shl(160, sload(lengthSlot))))) {\\n                mstore(0x00, 0x86df9d10) // `ERC5805CheckpointIndexOutOfBounds()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let checkpointPacked := sload(add(i, lengthSlot))\\n            checkpointClock := and(0xffffffffffff, checkpointPacked)\\n            checkpointValue := shr(96, checkpointPacked)\\n            if eq(checkpointValue, address()) { checkpointValue := sload(not(add(i, lengthSlot))) }\\n        }\\n    }\\n\\n    /// @dev Returns the latest amount of total voting units.\\n    function getVotesTotalSupply() public view virtual returns (uint256) {\\n        return _checkpointLatest(_ERC20_VOTES_MASTER_SLOT_SEED << 96);\\n    }\\n\\n    /// @dev Returns the latest amount of total voting units before or during `timepoint`.\\n    function getPastVotesTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\\n        if (timepoint >= clock()) _revertERC5805FutureLookup();\\n        return _checkpointUpperLookupRecent(_ERC20_VOTES_MASTER_SLOT_SEED << 96, timepoint);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of voting units `delegator` has control over.\\n    /// Override if you need a different formula.\\n    function _getVotingUnits(address delegator) internal view virtual returns (uint256) {\\n        return balanceOf(delegator);\\n    }\\n\\n    /// @dev ERC20 after token transfer internal hook.\\n    function _afterTokenTransfer(address from, address to, uint256 amount)\\n        internal\\n        virtual\\n        override\\n    {\\n        _transferVotingUnits(from, to, amount);\\n    }\\n\\n    /// @dev Used in `_afterTokenTransfer(address from, address to, uint256 amount)`.\\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\\n        if (from == address(0)) {\\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, true);\\n        }\\n        if (to == address(0)) {\\n            _checkpointPushDiff(_ERC20_VOTES_MASTER_SLOT_SEED << 96, clock(), amount, false);\\n        }\\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\\n    }\\n\\n    /// @dev Transfer `amount` of delegated votes from `from` to `to`.\\n    /// Emits a {DelegateVotesChanged} event for each change of delegated votes.\\n    function _moveDelegateVotes(address from, address to, uint256 amount) internal virtual {\\n        if (amount == uint256(0)) return;\\n        (uint256 fromCleaned, uint256 toCleaned) = (uint256(uint160(from)), uint256(uint160(to)));\\n        if (fromCleaned == toCleaned) return;\\n        if (fromCleaned != 0) {\\n            (uint256 oldValue, uint256 newValue) =\\n                _checkpointPushDiff(_delegateCheckpointsSlot(from), clock(), amount, false);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Emit the {DelegateVotesChanged} event.\\n                mstore(0x00, oldValue)\\n                mstore(0x20, newValue)\\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, fromCleaned)\\n            }\\n        }\\n        if (toCleaned != 0) {\\n            (uint256 oldValue, uint256 newValue) =\\n                _checkpointPushDiff(_delegateCheckpointsSlot(to), clock(), amount, true);\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Emit the {DelegateVotesChanged} event.\\n                mstore(0x00, oldValue)\\n                mstore(0x20, newValue)\\n                log2(0x00, 0x40, _DELEGATE_VOTES_CHANGED_EVENT_SIGNATURE, toCleaned)\\n            }\\n        }\\n    }\\n\\n    /// @dev Delegates all of `account`'s voting units to `delegatee`.\\n    /// Emits the {DelegateChanged} and {DelegateVotesChanged} events.\\n    function _delegate(address account, address delegatee) internal virtual {\\n        address from;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let to := shr(96, shl(96, delegatee))\\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\\n            mstore(0x00, account)\\n            let delegateSlot := keccak256(0x0c, 0x18)\\n            from := sload(delegateSlot)\\n            sstore(delegateSlot, to)\\n            // Emit the {DelegateChanged} event.\\n            log4(0x00, 0x00, _DELEGATE_CHANGED_EVENT_SIGNATURE, shr(96, mload(0x0c)), from, to)\\n        }\\n        _moveDelegateVotes(from, delegatee, _getVotingUnits(account));\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the delegate checkpoints slot for `account`.\\n    function _delegateCheckpointsSlot(address account) private pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x04, _ERC20_VOTES_MASTER_SLOT_SEED)\\n            mstore(0x00, account)\\n            result := keccak256(0x0c, 0x17)\\n        }\\n    }\\n\\n    /// @dev Pushes a checkpoint.\\n    function _checkpointPushDiff(uint256 lengthSlot, uint256 key, uint256 amount, bool isAdd)\\n        private\\n        returns (uint256 oldValue, uint256 newValue)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let lengthSlotPacked := sload(lengthSlot)\\n            for { let n := shr(208, shl(160, lengthSlotPacked)) } 1 {} {\\n                if iszero(n) {\\n                    if iszero(or(isAdd, iszero(amount))) {\\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    newValue := amount\\n                    if iszero(or(eq(newValue, address()), shr(160, newValue))) {\\n                        sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, newValue)))\\n                        break\\n                    }\\n                    sstore(lengthSlot, or(or(key, shl(48, 1)), shl(96, address())))\\n                    sstore(not(lengthSlot), newValue)\\n                    break\\n                }\\n                let checkpointSlot := add(sub(n, 1), lengthSlot)\\n                let lastPacked := sload(checkpointSlot)\\n                oldValue := shr(96, lastPacked)\\n                if eq(oldValue, address()) { oldValue := sload(not(checkpointSlot)) }\\n                for {} 1 {} {\\n                    if iszero(isAdd) {\\n                        newValue := sub(oldValue, amount)\\n                        if iszero(gt(newValue, oldValue)) { break }\\n                        mstore(0x00, 0x5915f686) // `ERC5805CheckpointValueUnderflow()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    newValue := add(oldValue, amount)\\n                    if iszero(lt(newValue, oldValue)) { break }\\n                    mstore(0x00, 0x9dbbeb75) // `ERC5805CheckpointValueOverflow()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                let lastKey := and(0xffffffffffff, lastPacked)\\n                if iszero(eq(lastKey, key)) {\\n                    n := add(1, n)\\n                    checkpointSlot := add(1, checkpointSlot)\\n                    sstore(lengthSlot, add(shl(48, 1), lengthSlotPacked))\\n                }\\n                if or(gt(lastKey, key), shr(48, n)) { invalid() }\\n                if iszero(or(eq(newValue, address()), shr(160, newValue))) {\\n                    sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, newValue)))\\n                    break\\n                }\\n                sstore(checkpointSlot, or(or(key, shl(48, n)), shl(96, address())))\\n                sstore(not(checkpointSlot), newValue)\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the latest value in the checkpoints.\\n    function _checkpointLatest(uint256 lengthSlot) private view returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := shr(208, shl(160, sload(lengthSlot)))\\n            if result {\\n                lengthSlot := add(sub(result, 1), lengthSlot) // Reuse for `checkpointSlot`.\\n                result := shr(96, sload(lengthSlot))\\n                if eq(result, address()) { result := sload(not(lengthSlot)) }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns checkpoint value with the largest key that is less than or equal to `key`.\\n    function _checkpointUpperLookupRecent(uint256 lengthSlot, uint256 key)\\n        private\\n        view\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let l := 0 // Low.\\n            let h := shr(208, shl(160, sload(lengthSlot))) // High.\\n            // Start the binary search nearer to the right to optimize for recent checkpoints.\\n            for {} iszero(lt(h, 6)) {} {\\n                let m := shl(4, lt(0xffff, h))\\n                m := shl(shr(1, or(m, shl(3, lt(0xff, shr(m, h))))), 16)\\n                m := shr(1, add(m, div(h, m)))\\n                m := shr(1, add(m, div(h, m)))\\n                m := shr(1, add(m, div(h, m)))\\n                m := shr(1, add(m, div(h, m)))\\n                m := shr(1, add(m, div(h, m)))\\n                m := sub(h, shr(1, add(m, div(h, m)))) // Approx `h - sqrt(h)`.\\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\\n                    l := add(1, m)\\n                    break\\n                }\\n                h := m\\n                break\\n            }\\n            // Binary search.\\n            for {} lt(l, h) {} {\\n                let m := shr(1, add(l, h)) // Won't overflow in practice.\\n                if iszero(lt(key, and(sload(add(m, lengthSlot)), 0xffffffffffff))) {\\n                    l := add(1, m)\\n                    continue\\n                }\\n                h := m\\n            }\\n            let checkpointSlot := add(sub(h, 1), lengthSlot)\\n            result := mul(iszero(iszero(h)), shr(96, sload(checkpointSlot)))\\n            if eq(result, address()) { result := sload(not(checkpointSlot)) }\\n        }\\n    }\\n\\n    /// @dev Reverts with `ERC5805FutureLookup()`.\\n    function _revertERC5805FutureLookup() private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xf9874464) // `ERC5805FutureLookup()`.\\n            revert(0x1c, 0x04)\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        }
      ]
    },
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "_mint(_mintto, _totalsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport {ERC20Votes} from \\\"solady/src/tokens/ERC20Votes.sol\\\";\\n\\n/**\\n * @title Kpop Token Contract\\n *\\n * @author Niftydude\\n *\\n * @notice This contract implements the ERC20 KPop token.\\n */\\ncontract KPop is ERC20Votes {\\n    string private symbol_;\\n    string private name_;\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Initializes contract by minting the specified amount of tokens to the specified address.\\n     *\\n     * @param _totalSupply amount of tokens to mint in wei\\n     * @param _mintTo address to mint tokens to\\n     * @param _name name of the token\\n     * @param _symbol symbol of the token\\n     */\\n    constructor(\\n        uint256 _totalSupply,\\n        address _mintTo,\\n        string memory _name,\\n        string memory _symbol\\n    ) {\\n        symbol_ = _symbol;\\n        name_ = _name;\\n\\n        _mint(_mintTo, _totalSupply);\\n    }\\n\\n    /**\\n     * @notice Burns the specified amount of tokens from the caller's account.\\n     *\\n     * @param _amount The amount of tokens to burn.\\n     */\\n    function burn(uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns the specified amount of tokens from the specified account.\\n     *\\n     * @param _account The address of the account to burn tokens from.\\n     * @param _amount The amount of tokens to burn.\\n     */\\n    function burnFrom(address _account, uint256 _amount) public virtual {\\n        _spendAllowance(_account, msg.sender, _amount);\\n        _burn(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Override the transfer function to prevent transferring to the zero address.\\n     *\\n     * @param _to The address of the account to transfer tokens to.\\n     * @param _amount The amount of tokens to transfer.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        if (_to == address(0)) revert ERC20InvalidReceiver(address(0));\\n\\n        return super.transfer(_to, _amount);\\n    }\\n\\n    /**\\n     * @notice Override the transferFrom function to prevent transferring to the zero address.\\n     *\\n     * @param _from The address of the account to transfer tokens from.\\n     * @param _to The address of the account to transfer tokens to.\\n     * @param _amount The amount of tokens to transfer.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        if (_to == address(0)) revert ERC20InvalidReceiver(address(0));\\n\\n        return super.transferFrom(_from, _to, _amount);\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token.\\n     */\\n    function name() public view override returns (string memory) {\\n        return name_;\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return symbol_;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address to, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\\n///   minting and transferring zero tokens, as well as self-approvals.\\n///   For performance, this implementation WILL NOT revert for such actions.\\n///   Please add any checks with overrides if desired.\\n/// - The `permit` function uses the ecrecover precompile (0x1).\\n///\\n/// If you are overriding:\\n/// - NEVER violate the ERC20 invariant:\\n///   the total sum of all balances must be equal to `totalSupply()`.\\n/// - Check that the overridden function is actually used in the function you want to\\n///   change the behavior of. Much of the code has been manually inlined for performance.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /// @dev The allowance of Permit2 is fixed at infinity.\\n    error Permit2AllowanceIsFixedAtInfinity();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\\n\\n    /// @dev `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n    bytes32 private constant _DOMAIN_TYPEHASH =\\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev `keccak256(\\\"1\\\")`.\\n    /// If you need to use a different version, override `_versionHash`.\\n    bytes32 private constant _DEFAULT_VERSION_HASH =\\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\\n\\n    /// @dev `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @dev The canonical Permit2 address.\\n    /// For signature-based allowance granting for single transaction ERC20 `transferFrom`.\\n    /// Enabled by default. To disable, override `_givePermit2InfiniteAllowance()`.\\n    /// [Github](https://github.com/Uniswap/permit2)\\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\\n    address internal constant _PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return type(uint256).max;\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        // Code duplication is for zero-cost abstraction if possible.\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                if iszero(eq(caller(), _PERMIT2)) {\\n                    // Compute the allowance slot and load its value.\\n                    mstore(0x20, caller())\\n                    mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                    let allowanceSlot := keccak256(0x0c, 0x34)\\n                    let allowance_ := sload(allowanceSlot)\\n                    // If the allowance is not the maximum uint256 value.\\n                    if not(allowance_) {\\n                        // Revert if the amount to be transferred exceeds the allowance.\\n                        if gt(amount, allowance_) {\\n                            mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                            revert(0x1c, 0x04)\\n                        }\\n                        // Subtract and store the updated allowance.\\n                        sstore(allowanceSlot, sub(allowance_, amount))\\n                    }\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let from_ := shl(96, from)\\n                // Compute the allowance slot and load its value.\\n                mstore(0x20, caller())\\n                mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n                let allowanceSlot := keccak256(0x0c, 0x34)\\n                let allowance_ := sload(allowanceSlot)\\n                // If the allowance is not the maximum uint256 value.\\n                if not(allowance_) {\\n                    // Revert if the amount to be transferred exceeds the allowance.\\n                    if gt(amount, allowance_) {\\n                        mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    // Subtract and store the updated allowance.\\n                    sstore(allowanceSlot, sub(allowance_, amount))\\n                }\\n                // Compute the balance slot and load its value.\\n                mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n                let fromBalanceSlot := keccak256(0x0c, 0x20)\\n                let fromBalance := sload(fromBalanceSlot)\\n                // Revert if insufficient balance.\\n                if gt(amount, fromBalance) {\\n                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated balance.\\n                sstore(fromBalanceSlot, sub(fromBalance, amount))\\n                // Compute the balance slot of `to`.\\n                mstore(0x00, to)\\n                let toBalanceSlot := keccak256(0x0c, 0x20)\\n                // Add and store the updated balance of `to`.\\n                // Will not overflow because the sum of all user balances\\n                // cannot exceed the maximum uint256 value.\\n                sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n                // Emit the {Transfer} event.\\n                mstore(0x20, amount)\\n                log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n            }\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev For more performance, override to return the constant value\\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\\n\\n    /// @dev If you need a different value, override this function.\\n    function _versionHash() internal view virtual returns (bytes32 result) {\\n        result = _DEFAULT_VERSION_HASH;\\n    }\\n\\n    /// @dev For inheriting contracts to increment the nonce.\\n    function _incrementNonce(address owner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            sstore(nonceSlot, add(1, sload(nonceSlot)))\\n        }\\n    }\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && value != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(value)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Revert if the block timestamp is greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Prepare the domain separator.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            mstore(0x2e, keccak256(m, 0xa0))\\n            // Prepare the struct hash.\\n            mstore(m, _PERMIT_TYPEHASH)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            mstore(0x4e, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0x00, keccak256(0x2c, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            let t := staticcall(gas(), 1, 0x00, 0x80, 0x20, 0x20)\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        bytes32 nameHash = _constantNameHash();\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\\n        bytes32 versionHash = _versionHash();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Grab the free memory pointer.\\n            mstore(m, _DOMAIN_TYPEHASH)\\n            mstore(add(m, 0x20), nameHash)\\n            mstore(add(m, 0x40), versionHash)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            if (spender == _PERMIT2) return; // Do nothing, as allowance is infinite.\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if not(allowance_) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (_givePermit2InfiniteAllowance()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // If `spender == _PERMIT2 && amount != type(uint256).max`.\\n                if iszero(or(xor(shr(96, shl(96, spender)), _PERMIT2), iszero(not(amount)))) {\\n                    mstore(0x00, 0x3f68539a) // `Permit2AllowanceIsFixedAtInfinity()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          PERMIT2                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns whether to fix the Permit2 contract's allowance at infinity.\\n    ///\\n    /// This value should be kept constant after contract initialization,\\n    /// or else the actual allowance values may not match with the {Approval} events.\\n    /// For best performance, return a compile-time constant for zero-cost abstraction.\\n    function _givePermit2InfiniteAllowance() internal view virtual returns (bool) {\\n        return true;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}