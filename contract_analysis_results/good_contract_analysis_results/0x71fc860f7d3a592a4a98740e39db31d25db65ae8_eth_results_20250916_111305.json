{
  "total_matches": 4,
  "patterns_found": {
    "honeypot_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "assembly {\n            // copy msg.data. we take full control of memory in this inline assembly\n            // block because it will not return to solidity code. we overwrite the\n            // solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n            // copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert",
          "function_context": "function _delegate(address implementation) internal {\n        //solium-disable-next-line\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize)\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize)\n\n            switch result\n                // delegatecall returns 0 on error.\n                case 0 {\n                    revert(0, returndatasize)\n                }\n                default {\n                    return(0, returndatasize)\n                }\n        }\n    }",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        }
      ]
    },
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_account, _amount)",
          "function_context": "function mintOnDeposit(address _account, uint256 _amount) external onlyLendingPool {\n\n        //cumulates the balance of the user\n        (,\n        ,\n        uint256 balanceIncrease,\n        uint256 index) = cumulateBalanceInternal(_account);\n\n         //if the user is redirecting his interest towards someone else,\n        //we update the redirected balance of the redirection address by adding the accrued interest\n        //and the amount deposited\n        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);\n\n        //mint an equivalent amount of tokens to cover the new deposit\n        _mint(_account, _amount);\n\n        emit MintOnDeposit(_account, _amount, balanceIncrease, index);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}