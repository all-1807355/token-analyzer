{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(\\n        address spender,\\n        uint256 allowance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\ninterface IERC721Errors {\\n    error ERC721InvalidOwner(address owner);\\n\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    error ERC721InvalidSender(address sender);\\n\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    error ERC721InvalidApprover(address approver);\\n\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\ninterface IERC1155Errors {\\n    error ERC1155InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed,\\n        uint256 tokenId\\n    );\\n\\n    error ERC1155InvalidSender(address sender);\\n\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    error ERC1155InvalidApprover(address approver);\\n\\n    error ERC1155InvalidOperator(address operator);\\n\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256))\\n        private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        bool emitEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\nlibrary Errors {\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    error FailedCall();\\n\\n    error FailedDeployment();\\n\\n    error MissingPrecompile(address);\\n}\\n\\nlibrary Address {\\n    error AddressEmptyCode(address target);\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata) private pure {\\n        if (returndata.length > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    error SafeERC20FailedOperation(address token);\\n\\n    error SafeERC20FailedDecreaseAllowance(\\n        address spender,\\n        uint256 currentAllowance,\\n        uint256 requestedDecrease\\n    );\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeCall(token.transferFrom, (from, to, value))\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 requestedDecrease\\n    ) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    requestedDecrease\\n                );\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        bytes memory approvalCall = abi.encodeCall(\\n            token.approve,\\n            (spender, value)\\n        );\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeCall(token.approve, (spender, 0))\\n            );\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    function transferAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function approveAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (\\n            returnSize == 0 ? address(token).code.length == 0 : returnValue != 1\\n        ) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturnBool(\\n        IERC20 token,\\n        bytes memory data\\n    ) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return\\n            success &&\\n            (\\n                returnSize == 0\\n                    ? address(token).code.length > 0\\n                    : returnValue == 1\\n            );\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract CATS is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public liquidityTaxBuy;\\n    uint256 public liquidityTaxSell;\\n    uint256 public liquidityTaxAmount;\\n\\n    uint256 public marketingTaxBuy;\\n    uint256 public marketingTaxSell;\\n    uint256 public marketingTaxAmount;\\n\\n    uint256 public immutable denominator;\\n\\n    address public marketingWallet;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    bool public isSwapBackEnabled;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\n    bool public isLiquified;\\n    uint256 public timeLiquify;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) private _isAutomatedMarketMakerPair;\\n    mapping(address => bool) private _isExcludedFromMaxWallet;\\n\\n    modifier inSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    event UpdateBuyTax(uint256 liquidityTaxBuy, uint256 marketingTaxBuy);\\n    event UpdateSellTax(uint256 liquidityTaxBuy, uint256 marketingTaxSell);\\n    event UpdateMarketingWallet(address indexed marketingWallet);\\n    event UpdateSwapTokensAtAmount(uint256 swapTokensAtAmount);\\n    event UpdateSwapBackStatus(bool status);\\n    event UpdateExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdateAutomatedMarketMakerPair(address indexed pair, bool status);\\n    event UpdateExcludedFromMaxWallet(address indexed account, bool isExcluded);\\n\\n    constructor() ERC20(\\\"GoldenCat\\\", \\\"CATS\\\") Ownable(getOwnerAddress()) {\\n        _mint(owner(), 690_690_000_000 * (10 ** 9));\\n\\n        liquidityTaxBuy = 100;\\n        liquidityTaxSell = 100;\\n\\n        marketingTaxBuy = 400;\\n        marketingTaxSell = 400;\\n\\n        denominator = 10_000;\\n\\n        marketingWallet = 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n\\n        swapTokensAtAmount = (totalSupply() * 1) / 10_000;\\n        isSwapBackEnabled = true;\\n\\n        address router = getRouterAddress();\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n        address DEAD = address(0xdead);\\n        address ZERO = address(0x0);\\n\\n        _isExcludedFromFees[address(this)] = true;\\n        _isExcludedFromFees[address(uniswapV2Router)] = true;\\n        _isExcludedFromFees[address(owner())] = true;\\n        _isExcludedFromFees[address(DEAD)] = true;\\n        _isExcludedFromFees[address(ZERO)] = true;\\n\\n        _isAutomatedMarketMakerPair[address(uniswapV2Pair)] = true;\\n\\n        _isExcludedFromMaxWallet[address(this)] = true;\\n        _isExcludedFromMaxWallet[address(uniswapV2Pair)] = true;\\n        _isExcludedFromMaxWallet[address(owner())] = true;\\n        _isExcludedFromMaxWallet[address(DEAD)] = true;\\n        _isExcludedFromMaxWallet[address(ZERO)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function getOwnerAddress() public view returns (address) {\\n        if (block.chainid == 56 || block.chainid == 1) {\\n            return 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function getRouterAddress() public view returns (address) {\\n        if (block.chainid == 56) {\\n            return 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n        } else if (block.chainid == 97) {\\n            return 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\n        } else if (block.chainid == 1 || block.chainid == 5) {\\n            return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n        } else {\\n            revert(\\\"Cannot found router on this network\\\");\\n        }\\n    }\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.safeTransfer(msg.sender, balance);\\n    }\\n\\n    function setBuyTax(\\n        uint256 _liquidityTaxBuy,\\n        uint256 _marketingTaxBuy\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxBuy != _liquidityTaxBuy ||\\n                marketingTaxBuy != _marketingTaxBuy,\\n            \\\"Buy Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxBuy + _marketingTaxBuy <= 2000,\\n            \\\"Buy Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxBuy = _liquidityTaxBuy;\\n        marketingTaxBuy = _marketingTaxBuy;\\n\\n        emit UpdateBuyTax(_liquidityTaxBuy, _marketingTaxBuy);\\n    }\\n\\n    function setSellTax(\\n        uint256 _liquidityTaxSell,\\n        uint256 _marketingTaxSell\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxSell != _liquidityTaxSell ||\\n                marketingTaxSell != _marketingTaxSell,\\n            \\\"Sell Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxSell + _marketingTaxSell <= 2000,\\n            \\\"Sell Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxSell = _liquidityTaxSell;\\n        marketingTaxSell = _marketingTaxSell;\\n\\n        emit UpdateSellTax(_liquidityTaxSell, _marketingTaxSell);\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external onlyOwner {\\n        require(\\n            _marketingWallet != marketingWallet,\\n            \\\"Marketing wallet is already that address\\\"\\n        );\\n        require(\\n            _marketingWallet != address(0),\\n            \\\"Marketing wallet cannot be the zero address\\\"\\n        );\\n        require(\\n            !isContract(_marketingWallet),\\n            \\\"Marketing wallet cannot be a contract\\\"\\n        );\\n\\n        marketingWallet = _marketingWallet;\\n        emit UpdateMarketingWallet(_marketingWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        require(\\n            swapTokensAtAmount != amount,\\n            \\\"SwapTokensAtAmount already on that amount\\\"\\n        );\\n        require(amount >= 1, \\\"Amount must be equal or greater than 1 Wei\\\");\\n\\n        swapTokensAtAmount = amount;\\n\\n        emit UpdateSwapTokensAtAmount(amount);\\n    }\\n\\n    function toggleSwapBack(bool status) external onlyOwner {\\n        require(isSwapBackEnabled != status, \\\"SwapBack already on status\\\");\\n\\n        isSwapBackEnabled = status;\\n        emit UpdateSwapBackStatus(status);\\n    }\\n\\n    function setExcludedFromMaxWallet(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromMaxWallet[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromMaxWallet[account] = excluded;\\n\\n        emit UpdateExcludedFromMaxWallet(account, excluded);\\n    }\\n\\n    function isExcludedFromMaxWallet(\\n        address account\\n    ) public view returns (bool) {\\n        return _isExcludedFromMaxWallet[account];\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool status\\n    ) public onlyOwner {\\n        require(\\n            _isAutomatedMarketMakerPair[pair] != status,\\n            \\\"Pair address is already the value of 'status'\\\"\\n        );\\n        _isAutomatedMarketMakerPair[pair] = status;\\n\\n        emit UpdateAutomatedMarketMakerPair(pair, status);\\n    }\\n\\n    function isAutomatedMarketMakerPair(\\n        address pair\\n    ) public view returns (bool) {\\n        return _isAutomatedMarketMakerPair[pair];\\n    }\\n\\n    function setExcludeFromFees(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromFees[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromFees[account] = excluded;\\n\\n        emit UpdateExcludeFromFees(account, excluded);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal override {\\n        if (from == address(0) || to == address(0)) {\\n            super._update(from, to, value);\\n            return;\\n        }\\n        if (value == 0) {\\n            super._update(from, to, 0);\\n            return;\\n        }\\n\\n        if (to == uniswapV2Pair) {\\n            timeLiquify = block.timestamp;\\n            isLiquified = true;\\n        }\\n\\n        if (\\n            !_isExcludedFromMaxWallet[to] &&\\n            !isAutomatedMarketMakerPair(to) &&\\n            isLiquified &&\\n            block.timestamp < timeLiquify + 1 hours\\n        ) {\\n            require(\\n                balanceOf(to) + value <= (totalSupply() * 1) / 100,\\n                \\\"Max wallet balance exceeded\\\"\\n            );\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            !swapping &&\\n            _isAutomatedMarketMakerPair[to] &&\\n            isSwapBackEnabled &&\\n            from != owner() &&\\n            to != owner() &&\\n            liquidityTaxAmount + marketingTaxAmount > 0\\n        ) {\\n            swapBack();\\n        }\\n\\n        bool takeFee = true;\\n\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to] || swapping) {\\n            takeFee = false;\\n        }\\n\\n        if (takeFee) {\\n            uint256 marketingTax = 0;\\n            uint256 liquidityTax = 0;\\n\\n            if (_isAutomatedMarketMakerPair[from]) {\\n                liquidityTax = (liquidityTaxBuy * value) / denominator;\\n                marketingTax = (marketingTaxBuy * value) / denominator;\\n            } else if (_isAutomatedMarketMakerPair[to]) {\\n                liquidityTax = (liquidityTaxSell * value) / denominator;\\n                marketingTax = (marketingTaxSell * value) / denominator;\\n            }\\n\\n            marketingTaxAmount += marketingTax;\\n            liquidityTaxAmount += liquidityTax;\\n\\n            uint256 contractTax = marketingTax + liquidityTax;\\n\\n            if (contractTax > 0) {\\n                value -= contractTax;\\n                super._update(from, address(this), contractTax);\\n            }\\n        }\\n\\n        super._update(from, to, value);\\n    }\\n\\n    function swapBack() internal inSwap {\\n        address[] memory pathWallet = new address[](2);\\n        pathWallet[0] = address(this);\\n        pathWallet[1] = uniswapV2Router.WETH();\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        uint256 totalTaxAmount = marketingTaxAmount + liquidityTaxAmount;\\n\\n        uint256 marketingTokenAmount = (contractTokenBalance *\\n            (marketingTaxAmount)) / totalTaxAmount;\\n\\n        uint256 liquidityTokenAmount = (contractTokenBalance -\\n            marketingTokenAmount);\\n\\n        if (marketingTokenAmount > 0) {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        marketingTokenAmount,\\n                        0,\\n                        pathWallet,\\n                        address(marketingWallet),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n        }\\n\\n        if (liquidityTokenAmount > 0) {\\n            uint256 half = liquidityTokenAmount / 2;\\n            uint256 otherHalf = liquidityTokenAmount - half;\\n\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        half,\\n                        0,\\n                        pathWallet,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n\\n            uint256 contractEthBalance = address(this).balance;\\n\\n            if (contractEthBalance > 0) {\\n                try\\n                    uniswapV2Router.addLiquidityETH{value: contractEthBalance}(\\n                        address(this),\\n                        otherHalf,\\n                        0,\\n                        0,\\n                        address(0xdead),\\n                        block.timestamp\\n                    )\\n                {} catch {}\\n            }\\n        }\\n\\n        marketingTaxAmount = 0;\\n        liquidityTaxAmount = 0;\\n    }\\n\\n    function manualSwapBack() external {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        require(contractTokenBalance > 0, \\\"Cant Swap Back 0 Token!\\\");\\n\\n        swapBack();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(owner()",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(\\n        address spender,\\n        uint256 allowance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\ninterface IERC721Errors {\\n    error ERC721InvalidOwner(address owner);\\n\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    error ERC721InvalidSender(address sender);\\n\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    error ERC721InvalidApprover(address approver);\\n\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\ninterface IERC1155Errors {\\n    error ERC1155InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed,\\n        uint256 tokenId\\n    );\\n\\n    error ERC1155InvalidSender(address sender);\\n\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    error ERC1155InvalidApprover(address approver);\\n\\n    error ERC1155InvalidOperator(address operator);\\n\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256))\\n        private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        bool emitEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\nlibrary Errors {\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    error FailedCall();\\n\\n    error FailedDeployment();\\n\\n    error MissingPrecompile(address);\\n}\\n\\nlibrary Address {\\n    error AddressEmptyCode(address target);\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata) private pure {\\n        if (returndata.length > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    error SafeERC20FailedOperation(address token);\\n\\n    error SafeERC20FailedDecreaseAllowance(\\n        address spender,\\n        uint256 currentAllowance,\\n        uint256 requestedDecrease\\n    );\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeCall(token.transferFrom, (from, to, value))\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 requestedDecrease\\n    ) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    requestedDecrease\\n                );\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        bytes memory approvalCall = abi.encodeCall(\\n            token.approve,\\n            (spender, value)\\n        );\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeCall(token.approve, (spender, 0))\\n            );\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    function transferAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function approveAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (\\n            returnSize == 0 ? address(token).code.length == 0 : returnValue != 1\\n        ) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturnBool(\\n        IERC20 token,\\n        bytes memory data\\n    ) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return\\n            success &&\\n            (\\n                returnSize == 0\\n                    ? address(token).code.length > 0\\n                    : returnValue == 1\\n            );\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract CATS is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public liquidityTaxBuy;\\n    uint256 public liquidityTaxSell;\\n    uint256 public liquidityTaxAmount;\\n\\n    uint256 public marketingTaxBuy;\\n    uint256 public marketingTaxSell;\\n    uint256 public marketingTaxAmount;\\n\\n    uint256 public immutable denominator;\\n\\n    address public marketingWallet;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    bool public isSwapBackEnabled;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\n    bool public isLiquified;\\n    uint256 public timeLiquify;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) private _isAutomatedMarketMakerPair;\\n    mapping(address => bool) private _isExcludedFromMaxWallet;\\n\\n    modifier inSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    event UpdateBuyTax(uint256 liquidityTaxBuy, uint256 marketingTaxBuy);\\n    event UpdateSellTax(uint256 liquidityTaxBuy, uint256 marketingTaxSell);\\n    event UpdateMarketingWallet(address indexed marketingWallet);\\n    event UpdateSwapTokensAtAmount(uint256 swapTokensAtAmount);\\n    event UpdateSwapBackStatus(bool status);\\n    event UpdateExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdateAutomatedMarketMakerPair(address indexed pair, bool status);\\n    event UpdateExcludedFromMaxWallet(address indexed account, bool isExcluded);\\n\\n    constructor() ERC20(\\\"GoldenCat\\\", \\\"CATS\\\") Ownable(getOwnerAddress()) {\\n        _mint(owner(), 690_690_000_000 * (10 ** 9));\\n\\n        liquidityTaxBuy = 100;\\n        liquidityTaxSell = 100;\\n\\n        marketingTaxBuy = 400;\\n        marketingTaxSell = 400;\\n\\n        denominator = 10_000;\\n\\n        marketingWallet = 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n\\n        swapTokensAtAmount = (totalSupply() * 1) / 10_000;\\n        isSwapBackEnabled = true;\\n\\n        address router = getRouterAddress();\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n        address DEAD = address(0xdead);\\n        address ZERO = address(0x0);\\n\\n        _isExcludedFromFees[address(this)] = true;\\n        _isExcludedFromFees[address(uniswapV2Router)] = true;\\n        _isExcludedFromFees[address(owner())] = true;\\n        _isExcludedFromFees[address(DEAD)] = true;\\n        _isExcludedFromFees[address(ZERO)] = true;\\n\\n        _isAutomatedMarketMakerPair[address(uniswapV2Pair)] = true;\\n\\n        _isExcludedFromMaxWallet[address(this)] = true;\\n        _isExcludedFromMaxWallet[address(uniswapV2Pair)] = true;\\n        _isExcludedFromMaxWallet[address(owner())] = true;\\n        _isExcludedFromMaxWallet[address(DEAD)] = true;\\n        _isExcludedFromMaxWallet[address(ZERO)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function getOwnerAddress() public view returns (address) {\\n        if (block.chainid == 56 || block.chainid == 1) {\\n            return 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function getRouterAddress() public view returns (address) {\\n        if (block.chainid == 56) {\\n            return 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n        } else if (block.chainid == 97) {\\n            return 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\n        } else if (block.chainid == 1 || block.chainid == 5) {\\n            return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n        } else {\\n            revert(\\\"Cannot found router on this network\\\");\\n        }\\n    }\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.safeTransfer(msg.sender, balance);\\n    }\\n\\n    function setBuyTax(\\n        uint256 _liquidityTaxBuy,\\n        uint256 _marketingTaxBuy\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxBuy != _liquidityTaxBuy ||\\n                marketingTaxBuy != _marketingTaxBuy,\\n            \\\"Buy Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxBuy + _marketingTaxBuy <= 2000,\\n            \\\"Buy Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxBuy = _liquidityTaxBuy;\\n        marketingTaxBuy = _marketingTaxBuy;\\n\\n        emit UpdateBuyTax(_liquidityTaxBuy, _marketingTaxBuy);\\n    }\\n\\n    function setSellTax(\\n        uint256 _liquidityTaxSell,\\n        uint256 _marketingTaxSell\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxSell != _liquidityTaxSell ||\\n                marketingTaxSell != _marketingTaxSell,\\n            \\\"Sell Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxSell + _marketingTaxSell <= 2000,\\n            \\\"Sell Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxSell = _liquidityTaxSell;\\n        marketingTaxSell = _marketingTaxSell;\\n\\n        emit UpdateSellTax(_liquidityTaxSell, _marketingTaxSell);\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external onlyOwner {\\n        require(\\n            _marketingWallet != marketingWallet,\\n            \\\"Marketing wallet is already that address\\\"\\n        );\\n        require(\\n            _marketingWallet != address(0),\\n            \\\"Marketing wallet cannot be the zero address\\\"\\n        );\\n        require(\\n            !isContract(_marketingWallet),\\n            \\\"Marketing wallet cannot be a contract\\\"\\n        );\\n\\n        marketingWallet = _marketingWallet;\\n        emit UpdateMarketingWallet(_marketingWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        require(\\n            swapTokensAtAmount != amount,\\n            \\\"SwapTokensAtAmount already on that amount\\\"\\n        );\\n        require(amount >= 1, \\\"Amount must be equal or greater than 1 Wei\\\");\\n\\n        swapTokensAtAmount = amount;\\n\\n        emit UpdateSwapTokensAtAmount(amount);\\n    }\\n\\n    function toggleSwapBack(bool status) external onlyOwner {\\n        require(isSwapBackEnabled != status, \\\"SwapBack already on status\\\");\\n\\n        isSwapBackEnabled = status;\\n        emit UpdateSwapBackStatus(status);\\n    }\\n\\n    function setExcludedFromMaxWallet(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromMaxWallet[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromMaxWallet[account] = excluded;\\n\\n        emit UpdateExcludedFromMaxWallet(account, excluded);\\n    }\\n\\n    function isExcludedFromMaxWallet(\\n        address account\\n    ) public view returns (bool) {\\n        return _isExcludedFromMaxWallet[account];\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool status\\n    ) public onlyOwner {\\n        require(\\n            _isAutomatedMarketMakerPair[pair] != status,\\n            \\\"Pair address is already the value of 'status'\\\"\\n        );\\n        _isAutomatedMarketMakerPair[pair] = status;\\n\\n        emit UpdateAutomatedMarketMakerPair(pair, status);\\n    }\\n\\n    function isAutomatedMarketMakerPair(\\n        address pair\\n    ) public view returns (bool) {\\n        return _isAutomatedMarketMakerPair[pair];\\n    }\\n\\n    function setExcludeFromFees(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromFees[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromFees[account] = excluded;\\n\\n        emit UpdateExcludeFromFees(account, excluded);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal override {\\n        if (from == address(0) || to == address(0)) {\\n            super._update(from, to, value);\\n            return;\\n        }\\n        if (value == 0) {\\n            super._update(from, to, 0);\\n            return;\\n        }\\n\\n        if (to == uniswapV2Pair) {\\n            timeLiquify = block.timestamp;\\n            isLiquified = true;\\n        }\\n\\n        if (\\n            !_isExcludedFromMaxWallet[to] &&\\n            !isAutomatedMarketMakerPair(to) &&\\n            isLiquified &&\\n            block.timestamp < timeLiquify + 1 hours\\n        ) {\\n            require(\\n                balanceOf(to) + value <= (totalSupply() * 1) / 100,\\n                \\\"Max wallet balance exceeded\\\"\\n            );\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            !swapping &&\\n            _isAutomatedMarketMakerPair[to] &&\\n            isSwapBackEnabled &&\\n            from != owner() &&\\n            to != owner() &&\\n            liquidityTaxAmount + marketingTaxAmount > 0\\n        ) {\\n            swapBack();\\n        }\\n\\n        bool takeFee = true;\\n\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to] || swapping) {\\n            takeFee = false;\\n        }\\n\\n        if (takeFee) {\\n            uint256 marketingTax = 0;\\n            uint256 liquidityTax = 0;\\n\\n            if (_isAutomatedMarketMakerPair[from]) {\\n                liquidityTax = (liquidityTaxBuy * value) / denominator;\\n                marketingTax = (marketingTaxBuy * value) / denominator;\\n            } else if (_isAutomatedMarketMakerPair[to]) {\\n                liquidityTax = (liquidityTaxSell * value) / denominator;\\n                marketingTax = (marketingTaxSell * value) / denominator;\\n            }\\n\\n            marketingTaxAmount += marketingTax;\\n            liquidityTaxAmount += liquidityTax;\\n\\n            uint256 contractTax = marketingTax + liquidityTax;\\n\\n            if (contractTax > 0) {\\n                value -= contractTax;\\n                super._update(from, address(this), contractTax);\\n            }\\n        }\\n\\n        super._update(from, to, value);\\n    }\\n\\n    function swapBack() internal inSwap {\\n        address[] memory pathWallet = new address[](2);\\n        pathWallet[0] = address(this);\\n        pathWallet[1] = uniswapV2Router.WETH();\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        uint256 totalTaxAmount = marketingTaxAmount + liquidityTaxAmount;\\n\\n        uint256 marketingTokenAmount = (contractTokenBalance *\\n            (marketingTaxAmount)) / totalTaxAmount;\\n\\n        uint256 liquidityTokenAmount = (contractTokenBalance -\\n            marketingTokenAmount);\\n\\n        if (marketingTokenAmount > 0) {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        marketingTokenAmount,\\n                        0,\\n                        pathWallet,\\n                        address(marketingWallet),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n        }\\n\\n        if (liquidityTokenAmount > 0) {\\n            uint256 half = liquidityTokenAmount / 2;\\n            uint256 otherHalf = liquidityTokenAmount - half;\\n\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        half,\\n                        0,\\n                        pathWallet,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n\\n            uint256 contractEthBalance = address(this).balance;\\n\\n            if (contractEthBalance > 0) {\\n                try\\n                    uniswapV2Router.addLiquidityETH{value: contractEthBalance}(\\n                        address(this),\\n                        otherHalf,\\n                        0,\\n                        0,\\n                        address(0xdead),\\n                        block.timestamp\\n                    )\\n                {} catch {}\\n            }\\n        }\\n\\n        marketingTaxAmount = 0;\\n        liquidityTaxAmount = 0;\\n    }\\n\\n    function manualSwapBack() external {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        require(contractTokenBalance > 0, \\\"Cant Swap Back 0 Token!\\\");\\n\\n        swapBack();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    },
    "stealth_fee_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "mapping(address => bool) private _isexcludedfromfee",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(\\n        address spender,\\n        uint256 allowance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\ninterface IERC721Errors {\\n    error ERC721InvalidOwner(address owner);\\n\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    error ERC721InvalidSender(address sender);\\n\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    error ERC721InvalidApprover(address approver);\\n\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\ninterface IERC1155Errors {\\n    error ERC1155InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed,\\n        uint256 tokenId\\n    );\\n\\n    error ERC1155InvalidSender(address sender);\\n\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    error ERC1155InvalidApprover(address approver);\\n\\n    error ERC1155InvalidOperator(address operator);\\n\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256))\\n        private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        bool emitEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\nlibrary Errors {\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    error FailedCall();\\n\\n    error FailedDeployment();\\n\\n    error MissingPrecompile(address);\\n}\\n\\nlibrary Address {\\n    error AddressEmptyCode(address target);\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata) private pure {\\n        if (returndata.length > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    error SafeERC20FailedOperation(address token);\\n\\n    error SafeERC20FailedDecreaseAllowance(\\n        address spender,\\n        uint256 currentAllowance,\\n        uint256 requestedDecrease\\n    );\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeCall(token.transferFrom, (from, to, value))\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 requestedDecrease\\n    ) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    requestedDecrease\\n                );\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        bytes memory approvalCall = abi.encodeCall(\\n            token.approve,\\n            (spender, value)\\n        );\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeCall(token.approve, (spender, 0))\\n            );\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    function transferAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function approveAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (\\n            returnSize == 0 ? address(token).code.length == 0 : returnValue != 1\\n        ) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturnBool(\\n        IERC20 token,\\n        bytes memory data\\n    ) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return\\n            success &&\\n            (\\n                returnSize == 0\\n                    ? address(token).code.length > 0\\n                    : returnValue == 1\\n            );\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract CATS is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public liquidityTaxBuy;\\n    uint256 public liquidityTaxSell;\\n    uint256 public liquidityTaxAmount;\\n\\n    uint256 public marketingTaxBuy;\\n    uint256 public marketingTaxSell;\\n    uint256 public marketingTaxAmount;\\n\\n    uint256 public immutable denominator;\\n\\n    address public marketingWallet;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    bool public isSwapBackEnabled;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\n    bool public isLiquified;\\n    uint256 public timeLiquify;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) private _isAutomatedMarketMakerPair;\\n    mapping(address => bool) private _isExcludedFromMaxWallet;\\n\\n    modifier inSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    event UpdateBuyTax(uint256 liquidityTaxBuy, uint256 marketingTaxBuy);\\n    event UpdateSellTax(uint256 liquidityTaxBuy, uint256 marketingTaxSell);\\n    event UpdateMarketingWallet(address indexed marketingWallet);\\n    event UpdateSwapTokensAtAmount(uint256 swapTokensAtAmount);\\n    event UpdateSwapBackStatus(bool status);\\n    event UpdateExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdateAutomatedMarketMakerPair(address indexed pair, bool status);\\n    event UpdateExcludedFromMaxWallet(address indexed account, bool isExcluded);\\n\\n    constructor() ERC20(\\\"GoldenCat\\\", \\\"CATS\\\") Ownable(getOwnerAddress()) {\\n        _mint(owner(), 690_690_000_000 * (10 ** 9));\\n\\n        liquidityTaxBuy = 100;\\n        liquidityTaxSell = 100;\\n\\n        marketingTaxBuy = 400;\\n        marketingTaxSell = 400;\\n\\n        denominator = 10_000;\\n\\n        marketingWallet = 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n\\n        swapTokensAtAmount = (totalSupply() * 1) / 10_000;\\n        isSwapBackEnabled = true;\\n\\n        address router = getRouterAddress();\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n        address DEAD = address(0xdead);\\n        address ZERO = address(0x0);\\n\\n        _isExcludedFromFees[address(this)] = true;\\n        _isExcludedFromFees[address(uniswapV2Router)] = true;\\n        _isExcludedFromFees[address(owner())] = true;\\n        _isExcludedFromFees[address(DEAD)] = true;\\n        _isExcludedFromFees[address(ZERO)] = true;\\n\\n        _isAutomatedMarketMakerPair[address(uniswapV2Pair)] = true;\\n\\n        _isExcludedFromMaxWallet[address(this)] = true;\\n        _isExcludedFromMaxWallet[address(uniswapV2Pair)] = true;\\n        _isExcludedFromMaxWallet[address(owner())] = true;\\n        _isExcludedFromMaxWallet[address(DEAD)] = true;\\n        _isExcludedFromMaxWallet[address(ZERO)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function getOwnerAddress() public view returns (address) {\\n        if (block.chainid == 56 || block.chainid == 1) {\\n            return 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function getRouterAddress() public view returns (address) {\\n        if (block.chainid == 56) {\\n            return 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n        } else if (block.chainid == 97) {\\n            return 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\n        } else if (block.chainid == 1 || block.chainid == 5) {\\n            return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n        } else {\\n            revert(\\\"Cannot found router on this network\\\");\\n        }\\n    }\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.safeTransfer(msg.sender, balance);\\n    }\\n\\n    function setBuyTax(\\n        uint256 _liquidityTaxBuy,\\n        uint256 _marketingTaxBuy\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxBuy != _liquidityTaxBuy ||\\n                marketingTaxBuy != _marketingTaxBuy,\\n            \\\"Buy Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxBuy + _marketingTaxBuy <= 2000,\\n            \\\"Buy Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxBuy = _liquidityTaxBuy;\\n        marketingTaxBuy = _marketingTaxBuy;\\n\\n        emit UpdateBuyTax(_liquidityTaxBuy, _marketingTaxBuy);\\n    }\\n\\n    function setSellTax(\\n        uint256 _liquidityTaxSell,\\n        uint256 _marketingTaxSell\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxSell != _liquidityTaxSell ||\\n                marketingTaxSell != _marketingTaxSell,\\n            \\\"Sell Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxSell + _marketingTaxSell <= 2000,\\n            \\\"Sell Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxSell = _liquidityTaxSell;\\n        marketingTaxSell = _marketingTaxSell;\\n\\n        emit UpdateSellTax(_liquidityTaxSell, _marketingTaxSell);\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external onlyOwner {\\n        require(\\n            _marketingWallet != marketingWallet,\\n            \\\"Marketing wallet is already that address\\\"\\n        );\\n        require(\\n            _marketingWallet != address(0),\\n            \\\"Marketing wallet cannot be the zero address\\\"\\n        );\\n        require(\\n            !isContract(_marketingWallet),\\n            \\\"Marketing wallet cannot be a contract\\\"\\n        );\\n\\n        marketingWallet = _marketingWallet;\\n        emit UpdateMarketingWallet(_marketingWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        require(\\n            swapTokensAtAmount != amount,\\n            \\\"SwapTokensAtAmount already on that amount\\\"\\n        );\\n        require(amount >= 1, \\\"Amount must be equal or greater than 1 Wei\\\");\\n\\n        swapTokensAtAmount = amount;\\n\\n        emit UpdateSwapTokensAtAmount(amount);\\n    }\\n\\n    function toggleSwapBack(bool status) external onlyOwner {\\n        require(isSwapBackEnabled != status, \\\"SwapBack already on status\\\");\\n\\n        isSwapBackEnabled = status;\\n        emit UpdateSwapBackStatus(status);\\n    }\\n\\n    function setExcludedFromMaxWallet(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromMaxWallet[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromMaxWallet[account] = excluded;\\n\\n        emit UpdateExcludedFromMaxWallet(account, excluded);\\n    }\\n\\n    function isExcludedFromMaxWallet(\\n        address account\\n    ) public view returns (bool) {\\n        return _isExcludedFromMaxWallet[account];\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool status\\n    ) public onlyOwner {\\n        require(\\n            _isAutomatedMarketMakerPair[pair] != status,\\n            \\\"Pair address is already the value of 'status'\\\"\\n        );\\n        _isAutomatedMarketMakerPair[pair] = status;\\n\\n        emit UpdateAutomatedMarketMakerPair(pair, status);\\n    }\\n\\n    function isAutomatedMarketMakerPair(\\n        address pair\\n    ) public view returns (bool) {\\n        return _isAutomatedMarketMakerPair[pair];\\n    }\\n\\n    function setExcludeFromFees(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromFees[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromFees[account] = excluded;\\n\\n        emit UpdateExcludeFromFees(account, excluded);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal override {\\n        if (from == address(0) || to == address(0)) {\\n            super._update(from, to, value);\\n            return;\\n        }\\n        if (value == 0) {\\n            super._update(from, to, 0);\\n            return;\\n        }\\n\\n        if (to == uniswapV2Pair) {\\n            timeLiquify = block.timestamp;\\n            isLiquified = true;\\n        }\\n\\n        if (\\n            !_isExcludedFromMaxWallet[to] &&\\n            !isAutomatedMarketMakerPair(to) &&\\n            isLiquified &&\\n            block.timestamp < timeLiquify + 1 hours\\n        ) {\\n            require(\\n                balanceOf(to) + value <= (totalSupply() * 1) / 100,\\n                \\\"Max wallet balance exceeded\\\"\\n            );\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            !swapping &&\\n            _isAutomatedMarketMakerPair[to] &&\\n            isSwapBackEnabled &&\\n            from != owner() &&\\n            to != owner() &&\\n            liquidityTaxAmount + marketingTaxAmount > 0\\n        ) {\\n            swapBack();\\n        }\\n\\n        bool takeFee = true;\\n\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to] || swapping) {\\n            takeFee = false;\\n        }\\n\\n        if (takeFee) {\\n            uint256 marketingTax = 0;\\n            uint256 liquidityTax = 0;\\n\\n            if (_isAutomatedMarketMakerPair[from]) {\\n                liquidityTax = (liquidityTaxBuy * value) / denominator;\\n                marketingTax = (marketingTaxBuy * value) / denominator;\\n            } else if (_isAutomatedMarketMakerPair[to]) {\\n                liquidityTax = (liquidityTaxSell * value) / denominator;\\n                marketingTax = (marketingTaxSell * value) / denominator;\\n            }\\n\\n            marketingTaxAmount += marketingTax;\\n            liquidityTaxAmount += liquidityTax;\\n\\n            uint256 contractTax = marketingTax + liquidityTax;\\n\\n            if (contractTax > 0) {\\n                value -= contractTax;\\n                super._update(from, address(this), contractTax);\\n            }\\n        }\\n\\n        super._update(from, to, value);\\n    }\\n\\n    function swapBack() internal inSwap {\\n        address[] memory pathWallet = new address[](2);\\n        pathWallet[0] = address(this);\\n        pathWallet[1] = uniswapV2Router.WETH();\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        uint256 totalTaxAmount = marketingTaxAmount + liquidityTaxAmount;\\n\\n        uint256 marketingTokenAmount = (contractTokenBalance *\\n            (marketingTaxAmount)) / totalTaxAmount;\\n\\n        uint256 liquidityTokenAmount = (contractTokenBalance -\\n            marketingTokenAmount);\\n\\n        if (marketingTokenAmount > 0) {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        marketingTokenAmount,\\n                        0,\\n                        pathWallet,\\n                        address(marketingWallet),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n        }\\n\\n        if (liquidityTokenAmount > 0) {\\n            uint256 half = liquidityTokenAmount / 2;\\n            uint256 otherHalf = liquidityTokenAmount - half;\\n\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        half,\\n                        0,\\n                        pathWallet,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n\\n            uint256 contractEthBalance = address(this).balance;\\n\\n            if (contractEthBalance > 0) {\\n                try\\n                    uniswapV2Router.addLiquidityETH{value: contractEthBalance}(\\n                        address(this),\\n                        otherHalf,\\n                        0,\\n                        0,\\n                        address(0xdead),\\n                        block.timestamp\\n                    )\\n                {} catch {}\\n            }\\n        }\\n\\n        marketingTaxAmount = 0;\\n        liquidityTaxAmount = 0;\\n    }\\n\\n    function manualSwapBack() external {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        require(contractTokenBalance > 0, \\\"Cant Swap Back 0 Token!\\\");\\n\\n        swapBack();\\n    }\\n}\\n\"",
          "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
        }
      ]
    },
    "liquidity_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "function removeliquidity(\\n        address tokena,\\n        address tokenb,\\n        uint liquidity,\\n        uint amountamin,\\n        uint amountbmin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amounta, uint amountb);\\n    function removeliquidityeth(\\n        address token,\\n        uint liquidity,\\n        uint amounttokenmin,\\n        uint amountethmin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amounttoken, uint amounteth);\\n    function removeliquiditywithpermit(\\n        address tokena,\\n        address tokenb,\\n        uint liquidity,\\n        uint amountamin,\\n        uint amountbmin,\\n        address to,\\n        uint deadline,\\n        bool approvemax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amounta, uint amountb);\\n    function removeliquidityethwithpermit(\\n        address token,\\n        uint liquidity,\\n        uint amounttokenmin,\\n        uint amountethmin,\\n        address to,\\n        uint deadline,\\n        bool approvemax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amounttoken, uint amounteth);\\n    function swapexacttokensfortokens(\\n        uint amountin,\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swaptokensforexacttokens(\\n        uint amountout,\\n        uint amountinmax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapexactethfortokens(\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swaptokensforexacteth(\\n        uint amountout,\\n        uint amountinmax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapexacttokensforeth(\\n        uint amountin,\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapethforexacttokens(\\n        uint amountout,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amounta,\\n        uint reservea,\\n        uint reserveb\\n    ) external pure returns (uint amountb);\\n    function getamountout(\\n        uint amountin,\\n        uint reservein,\\n        uint reserveout\\n    ) external pure returns (uint amountout);\\n    function getamountin(\\n        uint amountout,\\n        uint reservein,\\n        uint reserveout\\n    ) external pure returns (uint amountin);\\n    function getamountsout(\\n        uint amountin,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n    function getamountsin(\\n        uint amountout,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface iuniswapv2router02 is iuniswapv2router01 {\\n    function removeliquidityethsupportingfeeontransfertokens(\\n        address token,\\n        uint liquidity,\\n        uint amounttokenmin,\\n        uint amountethmin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amounteth);\\n    function removeliquidityethwithpermitsupportingfeeontransfertokens(\\n        address token,\\n        uint liquidity,\\n        uint amounttokenmin,\\n        uint amountethmin,\\n        address to,\\n        uint deadline,\\n        bool approvemax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amounteth);\\n\\n    function swapexacttokensfortokenssupportingfeeontransfertokens(\\n        uint amountin,\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapexactethfortokenssupportingfeeontransfertokens(\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapexacttokensforethsupportingfeeontransfertokens(\\n        uint amountin,\\n        uint amountoutmin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract cats is erc20, ownable {\\n    using safeerc20 for ierc20;\\n\\n    uint256 public liquiditytaxbuy;\\n    uint256 public liquiditytaxsell;\\n    uint256 public liquiditytaxamount;\\n\\n    uint256 public marketingtaxbuy;\\n    uint256 public marketingtaxsell;\\n    uint256 public marketingtaxamount;\\n\\n    uint256 public immutable denominator;\\n\\n    address public marketingwallet;\\n\\n    bool private swapping;\\n    uint256 public swaptokensatamount;\\n    bool public isswapbackenabled;\\n\\n    iuniswapv2router02 public immutable uniswapv2router;\\n    address public immutable uniswapv2pair;\\n\\n    bool public isliquified;\\n    uint256 public timeliquify;\\n\\n    mapping(address => bool) private _isexcludedfromfees;\\n    mapping(address => bool) private _isautomatedmarketmakerpair;\\n    mapping(address => bool) private _isexcludedfrommaxwallet;\\n\\n    modifier inswap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    event updatebuytax(uint256 liquiditytaxbuy, uint256 marketingtaxbuy);\\n    event updateselltax(uint256 liquiditytaxbuy, uint256 marketingtaxsell);\\n    event updatemarketingwallet(address indexed marketingwallet);\\n    event updateswaptokensatamount(uint256 swaptokensatamount);\\n    event updateswapbackstatus(bool status);\\n    event updateexcludefromfees(address indexed account, bool isexcluded);\\n    event updateautomatedmarketmakerpair(address indexed pair, bool status);\\n    event updateexcludedfrommaxwallet(address indexed account, bool isexcluded);\\n\\n    constructor() erc20(\\\"goldencat\\\", \\\"cats\\\") ownable(getowneraddress()) {\\n        _mint(owner(), 690_690_000_000 * (10 ** 9));\\n\\n        liquiditytaxbuy = 100;\\n        liquiditytaxsell = 100;\\n\\n        marketingtaxbuy = 400;\\n        marketingtaxsell = 400;\\n\\n        denominator = 10_000;\\n\\n        marketingwallet = 0xe54376794dbc69d965ac4294108ff9316eaba284;\\n\\n        swaptokensatamount = (totalsupply() * 1) / 10_000;\\n        isswapbackenabled = true;\\n\\n        address router = getrouteraddress();\\n        uniswapv2router = iuniswapv2router02(router);\\n        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(\\n            address(this),\\n            uniswapv2router.weth()\\n        );\\n\\n        _approve(address(this), address(uniswapv2router), type(uint256).max);\\n\\n        address dead = address(0xdead);\\n        address zero = address(0x0);\\n\\n        _isexcludedfromfees[address(this)] = true;\\n        _isexcludedfromfees[address(uniswapv2router)] = true;\\n        _isexcludedfromfees[address(owner())] = true;\\n        _isexcludedfromfees[address(dead)] = true;\\n        _isexcludedfromfees[address(zero)] = true;\\n\\n        _isautomatedmarketmakerpair[address(uniswapv2pair)] = true;\\n\\n        _isexcludedfrommaxwallet[address(this)] = true;\\n        _isexcludedfrommaxwallet[address(uniswapv2pair)] = true;\\n        _isexcludedfrommaxwallet[address(owner())] = true;\\n        _isexcludedfrommaxwallet[address(dead)] = true;\\n        _isexcludedfrommaxwallet[address(zero)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function iscontract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function getowneraddress() public view returns (address) {\\n        if (block.chainid == 56 || block.chainid == 1) {\\n            return 0xe54376794dbc69d965ac4294108ff9316eaba284;\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function getrouteraddress() public view returns (address) {\\n        if (block.chainid == 56) {\\n            return 0x10ed43c718714eb63d5aa57b78b54704e256024e;\\n        } else if (block.chainid == 97) {\\n            return 0xd99d1c33f9fc3444f8101754abc46c52416550d1;\\n        } else if (block.chainid == 1 || block.chainid == 5) {\\n            return 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\\n        } else {\\n            revert(\\\"cannot found router on this network\\\");\\n        }\\n    }\\n\\n    function claimstucktokens(address token) external onlyowner {\\n        require(token != address(this), \\\"owner cannot claim native tokens\\\");\\n\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        ierc20 erc20token = ierc20(token);\\n        uint256 balance = erc20token.balanceof(address(this));\\n        erc20token.safetransfer(msg.sender, balance);\\n    }\\n\\n    function setbuytax(\\n        uint256 _liquiditytaxbuy,\\n        uint256 _marketingtaxbuy\\n    ) external onlyowner {\\n        require(\\n            liquiditytaxbuy != _liquiditytaxbuy ||\\n                marketingtaxbuy != _marketingtaxbuy,\\n            \\\"buy tax already on that amount\\\"\\n        );\\n        require(\\n            _liquiditytaxbuy + _marketingtaxbuy <= 2000,\\n            \\\"buy tax cannot be more than 20%\\\"\\n        );\\n\\n        liquiditytaxbuy = _liquiditytaxbuy;\\n        marketingtaxbuy = _marketingtaxbuy;\\n\\n        emit updatebuytax(_liquiditytaxbuy, _marketingtaxbuy);\\n    }\\n\\n    function setselltax(\\n        uint256 _liquiditytaxsell,\\n        uint256 _marketingtaxsell\\n    ) external onlyowner {\\n        require(\\n            liquiditytaxsell != _liquiditytaxsell ||\\n                marketingtaxsell != _marketingtaxsell,\\n            \\\"sell tax already on that amount\\\"\\n        );\\n        require(\\n            _liquiditytaxsell + _marketingtaxsell <= 2000,\\n            \\\"sell tax cannot be more than 20%\\\"\\n        );\\n\\n        liquiditytaxsell = _liquiditytaxsell;\\n        marketingtaxsell = _marketingtaxsell;\\n\\n        emit updateselltax(_liquiditytaxsell, _marketingtaxsell);\\n    }\\n\\n    function setmarketingwallet(address _marketingwallet) external onlyowner {\\n        require(\\n            _marketingwallet != marketingwallet,\\n            \\\"marketing wallet is already that address\\\"\\n        );\\n        require(\\n            _marketingwallet != address(0),\\n            \\\"marketing wallet cannot be the zero address\\\"\\n        );\\n        require(\\n            !iscontract(_marketingwallet),\\n            \\\"marketing wallet cannot be a contract\\\"\\n        );\\n\\n        marketingwallet = _marketingwallet;\\n        emit updatemarketingwallet(_marketingwallet);\\n    }\\n\\n    function setswaptokensatamount(uint256 amount) external onlyowner {\\n        require(\\n            swaptokensatamount != amount,\\n            \\\"swaptokensatamount already on that amount\\\"\\n        );\\n        require(amount >= 1, \\\"amount must be equal or greater than 1 wei\\\");\\n\\n        swaptokensatamount = amount;\\n\\n        emit updateswaptokensatamount(amount);\\n    }\\n\\n    function toggleswapback(bool status) external onlyowner {\\n        require(isswapbackenabled != status, \\\"swapback already on status\\\");\\n\\n        isswapbackenabled = status;\\n        emit updateswapbackstatus(status);\\n    }\\n\\n    function setexcludedfrommaxwallet(\\n        address account,\\n        bool excluded\\n    ) external onlyowner {\\n        require(\\n            _isexcludedfrommaxwallet[account] != excluded,\\n            \\\"account is already the value of 'excluded'\\\"\\n        );\\n        _isexcludedfrommaxwallet[account] = excluded;\\n\\n        emit updateexcludedfrommaxwallet(account, excluded);\\n    }\\n\\n    function isexcludedfrommaxwallet(\\n        address account\\n    ) public view returns (bool) {\\n        return _isexcludedfrommaxwallet[account];\\n    }\\n\\n    function setautomatedmarketmakerpair(\\n        address pair,\\n        bool status\\n    ) public onlyowner {\\n        require(\\n            _isautomatedmarketmakerpair[pair] != status,\\n            \\\"pair address is already the value of 'status'\\\"\\n        );\\n        _isautomatedmarketmakerpair[pair] = status;\\n\\n        emit updateautomatedmarketmakerpair(pair, status);\\n    }\\n\\n    function isautomatedmarketmakerpair(\\n        address pair\\n    ) public view returns (bool) {\\n        return _isautomatedmarketmakerpair[pair];\\n    }\\n\\n    function setexcludefromfees(\\n        address account,\\n        bool excluded\\n    ) external onlyowner",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(\\n        address spender,\\n        uint256 allowance,\\n        uint256 needed\\n    );\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\ninterface IERC721Errors {\\n    error ERC721InvalidOwner(address owner);\\n\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    error ERC721InvalidSender(address sender);\\n\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    error ERC721InvalidApprover(address approver);\\n\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\ninterface IERC1155Errors {\\n    error ERC1155InsufficientBalance(\\n        address sender,\\n        uint256 balance,\\n        uint256 needed,\\n        uint256 tokenId\\n    );\\n\\n    error ERC1155InvalidSender(address sender);\\n\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    error ERC1155InvalidApprover(address approver);\\n\\n    error ERC1155InvalidOperator(address operator);\\n\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256))\\n        private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        bool emitEvent\\n    ) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    function transferAndCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approveAndCall(\\n        address spender,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\nlibrary Errors {\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    error FailedCall();\\n\\n    error FailedDeployment();\\n\\n    error MissingPrecompile(address);\\n}\\n\\nlibrary Address {\\n    error AddressEmptyCode(address target);\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata) private pure {\\n        if (returndata.length > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    error SafeERC20FailedOperation(address token);\\n\\n    error SafeERC20FailedDecreaseAllowance(\\n        address spender,\\n        uint256 currentAllowance,\\n        uint256 requestedDecrease\\n    );\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeCall(token.transferFrom, (from, to, value))\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 requestedDecrease\\n    ) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    requestedDecrease\\n                );\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    function forceApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        bytes memory approvalCall = abi.encodeCall(\\n            token.approve,\\n            (spender, value)\\n        );\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeCall(token.approve, (spender, 0))\\n            );\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    function transferAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function approveAndCallRelaxed(\\n        IERC1363 token,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (\\n            returnSize == 0 ? address(token).code.length == 0 : returnValue != 1\\n        ) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    function _callOptionalReturnBool(\\n        IERC20 token,\\n        bytes memory data\\n    ) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(\\n                gas(),\\n                token,\\n                0,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0x20\\n            )\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return\\n            success &&\\n            (\\n                returnSize == 0\\n                    ? address(token).code.length > 0\\n                    : returnValue == 1\\n            );\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint\\n    );\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract CATS is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public liquidityTaxBuy;\\n    uint256 public liquidityTaxSell;\\n    uint256 public liquidityTaxAmount;\\n\\n    uint256 public marketingTaxBuy;\\n    uint256 public marketingTaxSell;\\n    uint256 public marketingTaxAmount;\\n\\n    uint256 public immutable denominator;\\n\\n    address public marketingWallet;\\n\\n    bool private swapping;\\n    uint256 public swapTokensAtAmount;\\n    bool public isSwapBackEnabled;\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\n    bool public isLiquified;\\n    uint256 public timeLiquify;\\n\\n    mapping(address => bool) private _isExcludedFromFees;\\n    mapping(address => bool) private _isAutomatedMarketMakerPair;\\n    mapping(address => bool) private _isExcludedFromMaxWallet;\\n\\n    modifier inSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    event UpdateBuyTax(uint256 liquidityTaxBuy, uint256 marketingTaxBuy);\\n    event UpdateSellTax(uint256 liquidityTaxBuy, uint256 marketingTaxSell);\\n    event UpdateMarketingWallet(address indexed marketingWallet);\\n    event UpdateSwapTokensAtAmount(uint256 swapTokensAtAmount);\\n    event UpdateSwapBackStatus(bool status);\\n    event UpdateExcludeFromFees(address indexed account, bool isExcluded);\\n    event UpdateAutomatedMarketMakerPair(address indexed pair, bool status);\\n    event UpdateExcludedFromMaxWallet(address indexed account, bool isExcluded);\\n\\n    constructor() ERC20(\\\"GoldenCat\\\", \\\"CATS\\\") Ownable(getOwnerAddress()) {\\n        _mint(owner(), 690_690_000_000 * (10 ** 9));\\n\\n        liquidityTaxBuy = 100;\\n        liquidityTaxSell = 100;\\n\\n        marketingTaxBuy = 400;\\n        marketingTaxSell = 400;\\n\\n        denominator = 10_000;\\n\\n        marketingWallet = 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n\\n        swapTokensAtAmount = (totalSupply() * 1) / 10_000;\\n        isSwapBackEnabled = true;\\n\\n        address router = getRouterAddress();\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n        address DEAD = address(0xdead);\\n        address ZERO = address(0x0);\\n\\n        _isExcludedFromFees[address(this)] = true;\\n        _isExcludedFromFees[address(uniswapV2Router)] = true;\\n        _isExcludedFromFees[address(owner())] = true;\\n        _isExcludedFromFees[address(DEAD)] = true;\\n        _isExcludedFromFees[address(ZERO)] = true;\\n\\n        _isAutomatedMarketMakerPair[address(uniswapV2Pair)] = true;\\n\\n        _isExcludedFromMaxWallet[address(this)] = true;\\n        _isExcludedFromMaxWallet[address(uniswapV2Pair)] = true;\\n        _isExcludedFromMaxWallet[address(owner())] = true;\\n        _isExcludedFromMaxWallet[address(DEAD)] = true;\\n        _isExcludedFromMaxWallet[address(ZERO)] = true;\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 9;\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function getOwnerAddress() public view returns (address) {\\n        if (block.chainid == 56 || block.chainid == 1) {\\n            return 0xe54376794dbC69d965ac4294108fF9316eAbA284;\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function getRouterAddress() public view returns (address) {\\n        if (block.chainid == 56) {\\n            return 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n        } else if (block.chainid == 97) {\\n            return 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\n        } else if (block.chainid == 1 || block.chainid == 5) {\\n            return 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n        } else {\\n            revert(\\\"Cannot found router on this network\\\");\\n        }\\n    }\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.safeTransfer(msg.sender, balance);\\n    }\\n\\n    function setBuyTax(\\n        uint256 _liquidityTaxBuy,\\n        uint256 _marketingTaxBuy\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxBuy != _liquidityTaxBuy ||\\n                marketingTaxBuy != _marketingTaxBuy,\\n            \\\"Buy Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxBuy + _marketingTaxBuy <= 2000,\\n            \\\"Buy Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxBuy = _liquidityTaxBuy;\\n        marketingTaxBuy = _marketingTaxBuy;\\n\\n        emit UpdateBuyTax(_liquidityTaxBuy, _marketingTaxBuy);\\n    }\\n\\n    function setSellTax(\\n        uint256 _liquidityTaxSell,\\n        uint256 _marketingTaxSell\\n    ) external onlyOwner {\\n        require(\\n            liquidityTaxSell != _liquidityTaxSell ||\\n                marketingTaxSell != _marketingTaxSell,\\n            \\\"Sell Tax already on that amount\\\"\\n        );\\n        require(\\n            _liquidityTaxSell + _marketingTaxSell <= 2000,\\n            \\\"Sell Tax cannot be more than 20%\\\"\\n        );\\n\\n        liquidityTaxSell = _liquidityTaxSell;\\n        marketingTaxSell = _marketingTaxSell;\\n\\n        emit UpdateSellTax(_liquidityTaxSell, _marketingTaxSell);\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external onlyOwner {\\n        require(\\n            _marketingWallet != marketingWallet,\\n            \\\"Marketing wallet is already that address\\\"\\n        );\\n        require(\\n            _marketingWallet != address(0),\\n            \\\"Marketing wallet cannot be the zero address\\\"\\n        );\\n        require(\\n            !isContract(_marketingWallet),\\n            \\\"Marketing wallet cannot be a contract\\\"\\n        );\\n\\n        marketingWallet = _marketingWallet;\\n        emit UpdateMarketingWallet(_marketingWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        require(\\n            swapTokensAtAmount != amount,\\n            \\\"SwapTokensAtAmount already on that amount\\\"\\n        );\\n        require(amount >= 1, \\\"Amount must be equal or greater than 1 Wei\\\");\\n\\n        swapTokensAtAmount = amount;\\n\\n        emit UpdateSwapTokensAtAmount(amount);\\n    }\\n\\n    function toggleSwapBack(bool status) external onlyOwner {\\n        require(isSwapBackEnabled != status, \\\"SwapBack already on status\\\");\\n\\n        isSwapBackEnabled = status;\\n        emit UpdateSwapBackStatus(status);\\n    }\\n\\n    function setExcludedFromMaxWallet(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromMaxWallet[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromMaxWallet[account] = excluded;\\n\\n        emit UpdateExcludedFromMaxWallet(account, excluded);\\n    }\\n\\n    function isExcludedFromMaxWallet(\\n        address account\\n    ) public view returns (bool) {\\n        return _isExcludedFromMaxWallet[account];\\n    }\\n\\n    function setAutomatedMarketMakerPair(\\n        address pair,\\n        bool status\\n    ) public onlyOwner {\\n        require(\\n            _isAutomatedMarketMakerPair[pair] != status,\\n            \\\"Pair address is already the value of 'status'\\\"\\n        );\\n        _isAutomatedMarketMakerPair[pair] = status;\\n\\n        emit UpdateAutomatedMarketMakerPair(pair, status);\\n    }\\n\\n    function isAutomatedMarketMakerPair(\\n        address pair\\n    ) public view returns (bool) {\\n        return _isAutomatedMarketMakerPair[pair];\\n    }\\n\\n    function setExcludeFromFees(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        require(\\n            _isExcludedFromFees[account] != excluded,\\n            \\\"Account is already the value of 'excluded'\\\"\\n        );\\n        _isExcludedFromFees[account] = excluded;\\n\\n        emit UpdateExcludeFromFees(account, excluded);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal override {\\n        if (from == address(0) || to == address(0)) {\\n            super._update(from, to, value);\\n            return;\\n        }\\n        if (value == 0) {\\n            super._update(from, to, 0);\\n            return;\\n        }\\n\\n        if (to == uniswapV2Pair) {\\n            timeLiquify = block.timestamp;\\n            isLiquified = true;\\n        }\\n\\n        if (\\n            !_isExcludedFromMaxWallet[to] &&\\n            !isAutomatedMarketMakerPair(to) &&\\n            isLiquified &&\\n            block.timestamp < timeLiquify + 1 hours\\n        ) {\\n            require(\\n                balanceOf(to) + value <= (totalSupply() * 1) / 100,\\n                \\\"Max wallet balance exceeded\\\"\\n            );\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if (\\n            canSwap &&\\n            !swapping &&\\n            _isAutomatedMarketMakerPair[to] &&\\n            isSwapBackEnabled &&\\n            from != owner() &&\\n            to != owner() &&\\n            liquidityTaxAmount + marketingTaxAmount > 0\\n        ) {\\n            swapBack();\\n        }\\n\\n        bool takeFee = true;\\n\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to] || swapping) {\\n            takeFee = false;\\n        }\\n\\n        if (takeFee) {\\n            uint256 marketingTax = 0;\\n            uint256 liquidityTax = 0;\\n\\n            if (_isAutomatedMarketMakerPair[from]) {\\n                liquidityTax = (liquidityTaxBuy * value) / denominator;\\n                marketingTax = (marketingTaxBuy * value) / denominator;\\n            } else if (_isAutomatedMarketMakerPair[to]) {\\n                liquidityTax = (liquidityTaxSell * value) / denominator;\\n                marketingTax = (marketingTaxSell * value) / denominator;\\n            }\\n\\n            marketingTaxAmount += marketingTax;\\n            liquidityTaxAmount += liquidityTax;\\n\\n            uint256 contractTax = marketingTax + liquidityTax;\\n\\n            if (contractTax > 0) {\\n                value -= contractTax;\\n                super._update(from, address(this), contractTax);\\n            }\\n        }\\n\\n        super._update(from, to, value);\\n    }\\n\\n    function swapBack() internal inSwap {\\n        address[] memory pathWallet = new address[](2);\\n        pathWallet[0] = address(this);\\n        pathWallet[1] = uniswapV2Router.WETH();\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        uint256 totalTaxAmount = marketingTaxAmount + liquidityTaxAmount;\\n\\n        uint256 marketingTokenAmount = (contractTokenBalance *\\n            (marketingTaxAmount)) / totalTaxAmount;\\n\\n        uint256 liquidityTokenAmount = (contractTokenBalance -\\n            marketingTokenAmount);\\n\\n        if (marketingTokenAmount > 0) {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        marketingTokenAmount,\\n                        0,\\n                        pathWallet,\\n                        address(marketingWallet),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n        }\\n\\n        if (liquidityTokenAmount > 0) {\\n            uint256 half = liquidityTokenAmount / 2;\\n            uint256 otherHalf = liquidityTokenAmount - half;\\n\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        half,\\n                        0,\\n                        pathWallet,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {}\\n\\n            uint256 contractEthBalance = address(this).balance;\\n\\n            if (contractEthBalance > 0) {\\n                try\\n                    uniswapV2Router.addLiquidityETH{value: contractEthBalance}(\\n                        address(this),\\n                        otherHalf,\\n                        0,\\n                        0,\\n                        address(0xdead),\\n                        block.timestamp\\n                    )\\n                {} catch {}\\n            }\\n        }\\n\\n        marketingTaxAmount = 0;\\n        liquidityTaxAmount = 0;\\n    }\\n\\n    function manualSwapBack() external {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        require(contractTokenBalance > 0, \\\"Cant Swap Back 0 Token!\\\");\\n\\n        swapBack();\\n    }\\n}\\n\"",
          "pattern": "function\\s+removeLiquidity.*onlyOwner"
        }
      ]
    }
  }
}