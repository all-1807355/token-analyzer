{
  "total_matches": 26,
  "patterns_found": {
    "honeypot_mechanics": {
      "count": 23,
      "snippets": [
        {
          "matched_code": "assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkmirrorcontract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `linkmirrorcontractfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logtransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenuri()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x00, 0xe2c79281) // `totalnftsupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceofnft(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x00, 0x6352211e) // `ownerof(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approvenft(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x00, 0x081812fc) // `getapproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setapprovalforall(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isapprovedforall(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferfromnft(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404Mirror\\n/// @notice DN404Mirror provides an interface for interacting with the\\n/// NFT tokens in a DN404 implementation.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in the base DN404 contract.\\ncontract DN404Mirror {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\\n\\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /// @dev `keccak256(bytes(\\\"ApprovalForAll(address,address,bool)\\\"))`.\\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when a call for an NFT function did not originate\\n    /// from the base DN404 contract.\\n    error SenderNotBase();\\n\\n    /// @dev Thrown when a call for an NFT function did not originate from the deployer.\\n    error SenderNotDeployer();\\n\\n    /// @dev Thrown when transferring an NFT to a contract address that\\n    /// does not implement ERC721Receiver.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /// @dev Thrown when linking to the DN404 base contract and the\\n    /// DN404 supportsInterface check fails or the call reverts.\\n    error CannotLink();\\n\\n    /// @dev Thrown when a linkMirrorContract call is received and the\\n    /// NFT mirror contract has already been linked to a DN404 base contract.\\n    error AlreadyLinked();\\n\\n    /// @dev Thrown when retrieving the base DN404 address when a link has not\\n    /// been established.\\n    error NotLinked();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct contain the NFT mirror contract storage.\\n    struct DN404NFTStorage {\\n        address baseERC20;\\n        address deployer;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404NFTStorage.\\n    function _getDN404NFTStorage() internal pure virtual returns (DN404NFTStorage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_MIRROR_STORAGE\\\")))`.\\n            $.slot := 0x3602298b8c10b01230 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CONSTRUCTOR                         */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    constructor(address deployer) {\\n        // For non-proxies, we will store the deployer so that only the deployer can\\n        // link the base contract.\\n        _getDN404NFTStorage().deployer = deployer;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     ERC721 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the token collection name from the base DN404 contract.\\n    function name() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x06fdde03) // `name()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the token collection symbol from the base DN404 contract.\\n    function symbol() public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x00, 0x95d89b41) // `symbol()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id` from\\n    /// the base DN404 contract.\\n    function tokenURI(uint256 id) public view virtual returns (string memory result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(0x20, id)\\n            mstore(0x00, 0xc87b56dd) // `tokenURI()`.\\n            if iszero(staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x00)) {\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            returndatacopy(0x00, 0x00, 0x20)\\n            returndatacopy(result, mload(0x00), 0x20)\\n            returndatacopy(add(result, 0x20), add(mload(0x00), 0x20), mload(result))\\n            mstore(0x40, add(add(result, 0x20), mload(result)))\\n        }\\n    }\\n\\n    /// @dev Returns the total NFT supply from the base DN404 contract.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0xe2c79281) // `totalNFTSupply()`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x04, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the number of NFT tokens owned by `owner` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - `owner` must not be the zero address.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, shr(96, shl(96, owner)))\\n            mstore(0x00, 0xf5b100ea) // `balanceOfNFT(address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the owner of token `id` from the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function ownerOf(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x6352211e) // `ownerOf(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id` in\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    /// - The caller must be the owner of the token,\\n    ///   or an approved operator for the token owner.\\n    ///\\n    /// Emits an {Approval} event.\\n    function approve(address spender, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            spender := shr(96, shl(96, spender))\\n            let m := mload(0x40)\\n            mstore(0x00, 0xd10b6e0c) // `approveNFT(address,uint256,address)`.\\n            mstore(0x20, spender)\\n            mstore(0x40, id)\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(\\n                    gt(returndatasize(), 0x1f),\\n                    call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n            // Emit the {Approval} event.\\n            log4(codesize(), 0x00, _APPROVAL_EVENT_SIGNATURE, shr(96, mload(0x0c)), spender, id)\\n        }\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id` from\\n    /// the base DN404 contract.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function getApproved(uint256 id) public view virtual returns (address result) {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x081812fc) // `getApproved(uint256)`.\\n            mstore(0x20, id)\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x24, 0x00, 0x20))\\n            ) {\\n                returndatacopy(mload(0x40), 0x00, returndatasize())\\n                revert(mload(0x40), returndatasize())\\n            }\\n            result := shr(96, mload(0x0c))\\n        }\\n    }\\n\\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller in\\n    /// the base DN404 contract.\\n    ///\\n    /// Emits an {ApprovalForAll} event.\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            operator := shr(96, shl(96, operator))\\n            let m := mload(0x40)\\n            mstore(0x00, 0x813500fc) // `setApprovalForAll(address,bool,address)`.\\n            mstore(0x20, operator)\\n            mstore(0x40, iszero(iszero(approved)))\\n            mstore(0x60, caller())\\n            if iszero(\\n                and(eq(mload(0x00), 1), call(gas(), base, callvalue(), 0x1c, 0x64, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {ApprovalForAll} event.\\n            log3(0x40, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner` from\\n    /// the base DN404 contract.\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        returns (bool result)\\n    {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            mstore(0x40, operator)\\n            mstore(0x2c, shl(96, owner))\\n            mstore(0x0c, 0xe985e9c5000000000000000000000000) // `isApprovedForAll(address,address)`.\\n            if iszero(\\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), base, 0x1c, 0x44, 0x00, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            result := iszero(iszero(mload(0x00)))\\n        }\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        address base = baseERC20();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            from := shr(96, shl(96, from))\\n            to := shr(96, shl(96, to))\\n            let m := mload(0x40)\\n            mstore(m, 0xe5eb36c8) // `transferFromNFT(address,address,uint256,address)`.\\n            mstore(add(m, 0x20), from)\\n            mstore(add(m, 0x40), to)\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), caller())\\n            if iszero(\\n                and(eq(mload(m), 1), call(gas(), base, callvalue(), add(m, 0x1c), 0x84, m, 0x20))\\n            ) {\\n                returndatacopy(m, 0x00, returndatasize())\\n                revert(m, returndatasize())\\n            }\\n            // Emit the {Transfer} event.\\n            log4(codesize(), 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \\\"\\\")`.\\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    /// - The caller must be the owner of the token, or be approved to manage the token.\\n    /// - If `to` refers to a smart contract, it must implement\\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\\n        public\\n        virtual\\n    {\\n        transferFrom(from, to, id);\\n\\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\\n    }\\n\\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\\n    /// See: https://eips.ethereum.org/EIPS/eip-165\\n    /// This function call must use less than 30000 gas.\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, interfaceId)\\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the base DN404 contract.\\n    function baseERC20() public view virtual returns (address base) {\\n        base = _getDN404NFTStorage().baseERC20;\\n        if (base == address(0)) revert NotLinked();\\n    }\\n\\n    /// @dev Fallback modifier to execute calls from the base DN404 contract.\\n    modifier dn404NFTFallback() virtual {\\n        DN404NFTStorage storage $ = _getDN404NFTStorage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `logTransfer(uint256[])`.\\n        if (fnSelector == 0x263c69d6) {\\n            if (msg.sender != $.baseERC20) revert SenderNotBase();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When returndatacopy copies 1 or more out-of-bounds bytes, it reverts.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), 0x20))\\n                let o := add(0x24, calldataload(0x04)) // Packed logs offset.\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), o))\\n                let end := add(o, shl(5, calldataload(sub(o, 0x20))))\\n                returndatacopy(0x00, returndatasize(), lt(calldatasize(), end))\\n\\n                for {} iszero(eq(o, end)) { o := add(0x20, o) } {\\n                    let d := calldataload(o) // Entry in the packed logs.\\n                    let a := shr(96, d) // The address.\\n                    let b := and(1, d) // Whether it is a burn.\\n                    log4(\\n                        codesize(),\\n                        0x00,\\n                        _TRANSFER_EVENT_SIGNATURE,\\n                        mul(a, b),\\n                        mul(a, iszero(b)),\\n                        shr(168, shl(160, d))\\n                    )\\n                }\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        // `linkMirrorContract(address)`.\\n        if (fnSelector == 0x0f4599e5) {\\n            if ($.deployer != address(0)) {\\n                if (address(uint160(_calldataload(0x04))) != $.deployer) {\\n                    revert SenderNotDeployer();\\n                }\\n            }\\n            if ($.baseERC20 != address(0)) revert AlreadyLinked();\\n            $.baseERC20 = msg.sender;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20)\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from base DN404 contract.\\n    fallback() external payable virtual dn404NFTFallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\\n    /// Reverts if the target does not support the function correctly.\\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\\n        private\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the calldata.\\n            let m := mload(0x40)\\n            let onERC721ReceivedSelector := 0x150b7a02\\n            mstore(m, onERC721ReceivedSelector)\\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\\n            mstore(add(m, 0x60), id)\\n            mstore(add(m, 0x80), 0x80)\\n            let n := mload(data)\\n            mstore(add(m, 0xa0), n)\\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\\n            // Revert if the call reverts.\\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\\n                if returndatasize() {\\n                    // Bubble up the revert if the call reverts.\\n                    returndatacopy(m, 0x00, returndatasize())\\n                    revert(m, returndatasize())\\n                }\\n            }\\n            // Load the returndata and compare it.\\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ethtransferfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            // transfer all the eth and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ethtransferfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            if iszero(call(gasstipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // store the address in scratch space.\\n                mstore8(0x0b, 0x73) // opcode `push20`.\\n                mstore8(0x20, 0xff) // opcode `selfdestruct`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(gas_stipend_no_grief, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // store the address in scratch space.\\n                mstore8(0x0b, 0x73) // opcode `push20`.\\n                mstore8(0x20, 0xff) // opcode `selfdestruct`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            let m := mload(0x40) // cache the free memory pointer.\\n            mstore(0x60, amount) // store the `amount` argument.\\n            mstore(0x40, to) // store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferfrom(address,address,uint256)`.\\n            // perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `transferfromfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            let m := mload(0x40) // cache the free memory pointer.\\n            mstore(0x40, to) // store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceof(address)`.\\n            // read the balance, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // at least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `transferfromfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `transferfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x00, 0x70a08231) // store the function selector of `balanceof(address)`.\\n            mstore(0x20, address()) // store the address of the current contract.\\n            // read the balance, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // at least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `transferfailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `approvefailed()`.\\n                revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        },
        {
          "matched_code": "assembly {\\n            mstore(0x14, to) // store the `to` argument.\\n            mstore(0x34, amount) // store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // the arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // reset the approval.\\n                mstore(0x34, amount) // store back the original `amount`.\\n                // retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `approvefailed()`.\\n                    revert",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n///   responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\\n    //\\n    // The regular variants:\\n    // - Forwards all remaining gas to the target.\\n    // - Reverts if the target reverts.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The force variants:\\n    // - Forwards with an optional gas stipend\\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\\n    // - If the target reverts, or if the gas stipend is exhausted,\\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\\n    // - Reverts if the current contract has insufficient balance.\\n    //\\n    // The try variants:\\n    // - Forwards with a mandatory gas stipend.\\n    // - Instead of reverting, returns whether the transfer succeeded.\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`.\\n    function safeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer all the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if lt(selfbalance(), amount) {\\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\\n    function forceSafeTransferAllETH(address to) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            // Read the balance, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x14, to) // Store the `to` argument.\\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\\n            // Perform the transfer, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, reverting upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\\n    /// Reverts upon failure.\\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n            // Perform the approval, retrying upon failure.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                mstore(0x34, 0) // Store 0 for the `amount`.\\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\\n                mstore(0x34, amount) // Store back the original `amount`.\\n                // Retry the approval, reverting upon failure.\\n                if iszero(\\n                    and(\\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                    )\\n                ) {\\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\\n\"",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        }
      ]
    },
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "_mint(address to, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @title DN404\\n/// @notice DN404 is a hybrid ERC20 and ERC721 implementation that mints\\n/// and burns NFTs based on an account's ERC20 token balance.\\n///\\n/// @author vectorized.eth (@optimizoor)\\n/// @author Quit (@0xQuit)\\n/// @author Michael Amadi (@AmadiMichaels)\\n/// @author cygaar (@0xCygaar)\\n/// @author Thomas (@0xjustadev)\\n/// @author Harrison (@PopPunkOnChain)\\n///\\n/// @dev Note:\\n/// - The ERC721 data is stored in this base DN404 contract, however a\\n///   DN404Mirror contract ***MUST*** be deployed and linked during\\n///   initialization.\\nabstract contract DN404 {\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                           EVENTS                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev Emitted when `target` sets their skipNFT flag to `status`.\\n    event SkipNFTSet(address indexed target, bool status);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Thrown when attempting to double-initialize the contract.\\n    error DNAlreadyInitialized();\\n\\n    /// @dev Thrown when attempting to transfer or burn more tokens than sender's balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Thrown when a spender attempts to transfer tokens with an insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev Thrown when minting an amount of tokens that would overflow the max tokens.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev Thrown when the caller for a fallback NFT function is not the mirror contract.\\n    error SenderNotMirror();\\n\\n    /// @dev Thrown when attempting to transfer tokens to the zero address.\\n    error TransferToZeroAddress();\\n\\n    /// @dev Thrown when the mirror address provided for initialization is the zero address.\\n    error MirrorAddressIsZero();\\n\\n    /// @dev Thrown when the link call to the mirror contract reverts.\\n    error LinkMirrorContractFailed();\\n\\n    /// @dev Thrown when setting an NFT token approval\\n    /// and the caller is not the owner or an approved operator.\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT\\n    /// and the caller is not the owner or an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /// @dev Thrown when transferring an NFT and the from address is not the current owner.\\n    error TransferFromIncorrectOwner();\\n\\n    /// @dev Thrown when checking the owner or approved address for an non-existent NFT.\\n    error TokenDoesNotExist();\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         CONSTANTS                          */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Amount of token balance that is equal to one NFT.\\n    uint256 internal constant _WAD = 10 ** 18;\\n\\n    /// @dev The maximum token ID allowed for an NFT.\\n    uint256 internal constant _MAX_TOKEN_ID = 0xffffffff;\\n\\n    /// @dev The maximum possible token supply.\\n    uint256 internal constant _MAX_SUPPLY = 10 ** 18 * 0xffffffff - 1;\\n\\n    /// @dev The flag to denote that the address data is initialized.\\n    uint8 internal constant _ADDRESS_DATA_INITIALIZED_FLAG = 1 << 0;\\n\\n    /// @dev The flag to denote that the address should skip NFTs.\\n    uint8 internal constant _ADDRESS_DATA_SKIP_NFT_FLAG = 1 << 1;\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                          STORAGE                           */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing an address's token data and settings.\\n    struct AddressData {\\n        // Auxiliary data.\\n        uint88 aux;\\n        // Flags for `initialized` and `skipNFT`.\\n        uint8 flags;\\n        // The alias for the address. Zero means absence of an alias.\\n        uint32 addressAlias;\\n        // The number of NFT tokens.\\n        uint32 ownedLength;\\n        // The token balance in wei.\\n        uint96 balance;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev Struct containing the base token contract storage.\\n    struct DN404Storage {\\n        // Current number of address aliases assigned.\\n        uint32 numAliases;\\n        // Next token ID to assign for an NFT mint.\\n        uint32 nextTokenId;\\n        // Total supply of minted NFTs.\\n        uint32 totalNFTSupply;\\n        // Total supply of tokens.\\n        uint96 totalSupply;\\n        // Address of the NFT mirror contract.\\n        address mirrorERC721;\\n        // Mapping of a user alias number to their address.\\n        mapping(uint32 => address) aliasToAddress;\\n        // Mapping of user operator approvals for NFTs.\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        // Mapping of NFT token approvals to approved operators.\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping of user allowances for token spenders.\\n        mapping(address => mapping(address => uint256)) allowance;\\n        // Mapping of NFT token IDs owned by an address.\\n        mapping(address => Uint32Map) owned;\\n        // Even indices: owner aliases. Odd indices: owned indices.\\n        Uint32Map oo;\\n        // Mapping of user account AddressData\\n        mapping(address => AddressData) addressData;\\n    }\\n\\n    /// @dev Returns a storage pointer for DN404Storage.\\n    function _getDN404Storage() internal pure virtual returns (DN404Storage storage $) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `uint72(bytes9(keccak256(\\\"DN404_STORAGE\\\")))`.\\n            $.slot := 0xa20d6e21d0e5255308 // Truncate to 9 bytes to reduce bytecode size.\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                         INITIALIZER                        */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Initializes the DN404 contract with an\\n    /// `initialTokenSupply`, `initialTokenOwner` and `mirror` NFT contract address.\\n    function _initializeDN404(\\n        uint256 initialTokenSupply,\\n        address initialSupplyOwner,\\n        address mirror\\n    ) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if ($.nextTokenId != 0) revert DNAlreadyInitialized();\\n\\n        if (mirror == address(0)) revert MirrorAddressIsZero();\\n        _linkMirrorContract(mirror);\\n\\n        $.nextTokenId = 1;\\n        $.mirrorERC721 = mirror;\\n\\n        if (initialTokenSupply > 0) {\\n            if (initialSupplyOwner == address(0)) revert TransferToZeroAddress();\\n            if (initialTokenSupply > _MAX_SUPPLY) revert TotalSupplyOverflow();\\n\\n            $.totalSupply = uint96(initialTokenSupply);\\n            AddressData storage initialOwnerAddressData = _addressData(initialSupplyOwner);\\n            initialOwnerAddressData.balance = uint96(initialTokenSupply);\\n\\n            emit Transfer(address(0), initialSupplyOwner, initialTokenSupply);\\n\\n            _setSkipNFT(initialSupplyOwner, true);\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*               METADATA FUNCTIONS TO OVERRIDE               */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the decimals places of the token. Always 18.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return uint256(_getDN404Storage().totalSupply);\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].balance;\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _getDN404Storage().allowance[owner][spender];\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        $.allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 allowed = $.allowance[from][msg.sender];\\n\\n        if (allowed != type(uint256).max) {\\n            if (amount > allowed) revert InsufficientAllowance();\\n            unchecked {\\n                $.allowance[from][msg.sender] = allowed - amount;\\n            }\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        unchecked {\\n            uint256 currentTokenSupply = uint256($.totalSupply) + amount;\\n            if (amount > _MAX_SUPPLY || currentTokenSupply > _MAX_SUPPLY) {\\n                revert TotalSupplyOverflow();\\n            }\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            uint256 toBalance = toAddressData.balance + amount;\\n            toAddressData.balance = uint96(toBalance);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = toAddressData.ownedLength;\\n                uint256 toEnd = toBalance / _WAD;\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(_zeroFloorSub(toEnd, toIndex));\\n\\n                if (packedLogs.logs.length != 0) {\\n                    uint256 maxNFTId = $.totalSupply / _WAD;\\n                    uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                    uint256 id = $.nextTokenId;\\n                    $.totalNFTSupply += uint32(packedLogs.logs.length);\\n                    toAddressData.ownedLength = uint32(toEnd);\\n                    // Mint loop.\\n                    do {\\n                        while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                            if (++id > maxNFTId) id = 1;\\n                        }\\n                        _set(toOwned, toIndex, uint32(id));\\n                        _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                        _packedLogsAppend(packedLogs, to, id, 0);\\n                        if (++id > maxNFTId) id = 1;\\n                    } while (toIndex != toEnd);\\n                    $.nextTokenId = uint32(id);\\n                    _packedLogsSend(packedLogs, $.mirrorERC721);\\n                }\\n            }\\n        }\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n\\n        uint256 fromBalance = fromAddressData.balance;\\n        if (amount > fromBalance) revert InsufficientBalance();\\n\\n        uint256 currentTokenSupply = $.totalSupply;\\n\\n        unchecked {\\n            fromBalance -= amount;\\n            fromAddressData.balance = uint96(fromBalance);\\n            currentTokenSupply -= amount;\\n            $.totalSupply = uint96(currentTokenSupply);\\n\\n            Uint32Map storage fromOwned = $.owned[from];\\n            uint256 fromIndex = fromAddressData.ownedLength;\\n            uint256 nftAmountToBurn = _zeroFloorSub(fromIndex, fromBalance / _WAD);\\n\\n            if (nftAmountToBurn != 0) {\\n                $.totalNFTSupply -= uint32(nftAmountToBurn);\\n\\n                _PackedLogs memory packedLogs = _packedLogsMalloc(nftAmountToBurn);\\n\\n                uint256 fromEnd = fromIndex - nftAmountToBurn;\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n\\n                fromAddressData.ownedLength = uint32(fromIndex);\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    ///\\n    /// Will burn sender NFTs if balance after transfer is less than\\n    /// the amount required to support the current NFT balance.\\n    ///\\n    /// Will mint NFTs to `to` if the recipient's new balance supports\\n    /// additional NFTs ***AND*** the `to` address's skipNFT flag is\\n    /// set to false.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        _TransferTemps memory t;\\n        t.fromOwnedLength = fromAddressData.ownedLength;\\n        t.toOwnedLength = toAddressData.ownedLength;\\n        t.fromBalance = fromAddressData.balance;\\n\\n        if (amount > t.fromBalance) revert InsufficientBalance();\\n\\n        unchecked {\\n            t.fromBalance -= amount;\\n            fromAddressData.balance = uint96(t.fromBalance);\\n            toAddressData.balance = uint96(t.toBalance = toAddressData.balance + amount);\\n\\n            t.nftAmountToBurn = _zeroFloorSub(t.fromOwnedLength, t.fromBalance / _WAD);\\n\\n            if (toAddressData.flags & _ADDRESS_DATA_SKIP_NFT_FLAG == 0) {\\n                if (from == to) t.toOwnedLength = t.fromOwnedLength - t.nftAmountToBurn;\\n                t.nftAmountToMint = _zeroFloorSub(t.toBalance / _WAD, t.toOwnedLength);\\n            }\\n\\n            _PackedLogs memory packedLogs = _packedLogsMalloc(t.nftAmountToBurn + t.nftAmountToMint);\\n\\n            if (t.nftAmountToBurn != 0) {\\n                Uint32Map storage fromOwned = $.owned[from];\\n                uint256 fromIndex = t.fromOwnedLength;\\n                uint256 fromEnd = fromIndex - t.nftAmountToBurn;\\n                $.totalNFTSupply -= uint32(t.nftAmountToBurn);\\n                fromAddressData.ownedLength = uint32(fromEnd);\\n                // Burn loop.\\n                do {\\n                    uint256 id = _get(fromOwned, --fromIndex);\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, 0, 0);\\n                    delete $.tokenApprovals[id];\\n                    _packedLogsAppend(packedLogs, from, id, 1);\\n                } while (fromIndex != fromEnd);\\n            }\\n\\n            if (t.nftAmountToMint != 0) {\\n                Uint32Map storage toOwned = $.owned[to];\\n                uint256 toIndex = t.toOwnedLength;\\n                uint256 toEnd = toIndex + t.nftAmountToMint;\\n                uint32 toAlias = _registerAndResolveAlias(toAddressData, to);\\n                uint256 maxNFTId = $.totalSupply / _WAD;\\n                uint256 id = $.nextTokenId;\\n                $.totalNFTSupply += uint32(t.nftAmountToMint);\\n                toAddressData.ownedLength = uint32(toEnd);\\n                // Mint loop.\\n                do {\\n                    while (_get($.oo, _ownershipIndex(id)) != 0) {\\n                        if (++id > maxNFTId) id = 1;\\n                    }\\n                    _set(toOwned, toIndex, uint32(id));\\n                    _setOwnerAliasAndOwnedIndex($.oo, id, toAlias, uint32(toIndex++));\\n                    _packedLogsAppend(packedLogs, to, id, 0);\\n                    if (++id > maxNFTId) id = 1;\\n                } while (toIndex != toEnd);\\n                $.nextTokenId = uint32(id);\\n            }\\n\\n            if (packedLogs.logs.length != 0) {\\n                _packedLogsSend(packedLogs, $.mirrorERC721);\\n            }\\n        }\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @dev Transfers token `id` from `from` to `to`.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - Call must originate from the mirror contract.\\n    /// - Token `id` must exist.\\n    /// - `from` must be the owner of the token.\\n    /// - `to` cannot be the zero address.\\n    ///   `msgSender` must be the owner of the token, or be approved to manage the token.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _transferFromNFT(address from, address to, uint256 id, address msgSender)\\n        internal\\n        virtual\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (from != owner) revert TransferFromIncorrectOwner();\\n\\n        if (msgSender != from) {\\n            if (!$.operatorApprovals[from][msgSender]) {\\n                if (msgSender != $.tokenApprovals[id]) {\\n                    revert TransferCallerNotOwnerNorApproved();\\n                }\\n            }\\n        }\\n\\n        AddressData storage fromAddressData = _addressData(from);\\n        AddressData storage toAddressData = _addressData(to);\\n\\n        fromAddressData.balance -= uint96(_WAD);\\n\\n        unchecked {\\n            toAddressData.balance += uint96(_WAD);\\n\\n            _set($.oo, _ownershipIndex(id), _registerAndResolveAlias(toAddressData, to));\\n            delete $.tokenApprovals[id];\\n\\n            uint256 updatedId = _get($.owned[from], --fromAddressData.ownedLength);\\n            _set($.owned[from], _get($.oo, _ownedIndex(id)), uint32(updatedId));\\n\\n            uint256 n = toAddressData.ownedLength++;\\n            _set($.oo, _ownedIndex(updatedId), _get($.oo, _ownedIndex(id)));\\n            _set($.owned[to], n, uint32(id));\\n            _set($.oo, _ownedIndex(id), uint32(n));\\n        }\\n\\n        emit Transfer(from, to, _WAD);\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                 DATA HITCHHIKING FUNCTIONS                 */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the auxiliary data for `owner`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _getAux(address owner) internal view virtual returns (uint88) {\\n        return _getDN404Storage().addressData[owner].aux;\\n    }\\n\\n    /// @dev Set the auxiliary data for `owner` to `value`.\\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\\n    function _setAux(address owner, uint88 value) internal virtual {\\n        _getDN404Storage().addressData[owner].aux = value;\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     SKIP NFT FUNCTIONS                     */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns true if account `a` will skip NFT minting on token mints and transfers.\\n    /// Returns false if account `a` will mint NFTs on token mints and transfers.\\n    function getSkipNFT(address a) public view virtual returns (bool) {\\n        AddressData storage d = _getDN404Storage().addressData[a];\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) return _hasCode(a);\\n        return d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0;\\n    }\\n\\n    /// @dev Sets the caller's skipNFT flag to `skipNFT`\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function setSkipNFT(bool skipNFT) public virtual {\\n        _setSkipNFT(msg.sender, skipNFT);\\n    }\\n\\n    /// @dev Internal function to set account `a` skipNFT flag to `state`\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    ///\\n    /// Emits a {SkipNFTSet} event.\\n    function _setSkipNFT(address a, bool state) internal virtual {\\n        AddressData storage d = _addressData(a);\\n        if ((d.flags & _ADDRESS_DATA_SKIP_NFT_FLAG != 0) != state) {\\n            d.flags ^= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n        }\\n        emit SkipNFTSet(a, state);\\n    }\\n\\n    /// @dev Returns a storage data pointer for account `a` AddressData\\n    ///\\n    /// Initializes account `a` AddressData if it is not currently initialized.\\n    function _addressData(address a) internal virtual returns (AddressData storage d) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        d = $.addressData[a];\\n\\n        if (d.flags & _ADDRESS_DATA_INITIALIZED_FLAG == 0) {\\n            uint8 flags = _ADDRESS_DATA_INITIALIZED_FLAG;\\n            if (_hasCode(a)) flags |= _ADDRESS_DATA_SKIP_NFT_FLAG;\\n            d.flags = flags;\\n        }\\n    }\\n\\n    /// @dev Returns the `addressAlias` of account `to`.\\n    ///\\n    /// Assigns and registers the next alias if `to` alias was not previously registered.\\n    function _registerAndResolveAlias(AddressData storage toAddressData, address to)\\n        internal\\n        virtual\\n        returns (uint32 addressAlias)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n        addressAlias = toAddressData.addressAlias;\\n        if (addressAlias == 0) {\\n            addressAlias = ++$.numAliases;\\n            toAddressData.addressAlias = addressAlias;\\n            $.aliasToAddress[addressAlias] = to;\\n        }\\n    }\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                     MIRROR OPERATIONS                      */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Returns the address of the mirror NFT contract.\\n    function mirrorERC721() public view virtual returns (address) {\\n        return _getDN404Storage().mirrorERC721;\\n    }\\n\\n    /// @dev Returns the total NFT supply.\\n    function _totalNFTSupply() internal view virtual returns (uint256) {\\n        return _getDN404Storage().totalNFTSupply;\\n    }\\n\\n    /// @dev Returns `owner` NFT balance.\\n    function _balanceOfNFT(address owner) internal view virtual returns (uint256) {\\n        return _getDN404Storage().addressData[owner].ownedLength;\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    /// Returns the zero address instead of reverting if the token does not exist.\\n    function _ownerAt(uint256 id) internal view virtual returns (address) {\\n        DN404Storage storage $ = _getDN404Storage();\\n        return $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n    }\\n\\n    /// @dev Returns the owner of token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _ownerAt(id);\\n    }\\n\\n    /// @dev Returns if token `id` exists.\\n    function _exists(uint256 id) internal view virtual returns (bool) {\\n        return _ownerAt(id) != address(0);\\n    }\\n\\n    /// @dev Returns the account approved to manage token `id`.\\n    ///\\n    /// Requirements:\\n    /// - Token `id` must exist.\\n    function _getApproved(uint256 id) internal view virtual returns (address) {\\n        if (!_exists(id)) revert TokenDoesNotExist();\\n        return _getDN404Storage().tokenApprovals[id];\\n    }\\n\\n    /// @dev Sets `spender` as the approved account to manage token `id`, using `msgSender`.\\n    ///\\n    /// Requirements:\\n    /// - `msgSender` must be the owner or an approved operator for the token owner.\\n    function _approveNFT(address spender, uint256 id, address msgSender)\\n        internal\\n        virtual\\n        returns (address)\\n    {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        address owner = $.aliasToAddress[_get($.oo, _ownershipIndex(id))];\\n\\n        if (msgSender != owner) {\\n            if (!$.operatorApprovals[owner][msgSender]) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n        }\\n\\n        $.tokenApprovals[id] = spender;\\n\\n        return owner;\\n    }\\n\\n    /// @dev Approve or remove the `operator` as an operator for `msgSender`,\\n    /// without authorization checks.\\n    function _setApprovalForAll(address operator, bool approved, address msgSender)\\n        internal\\n        virtual\\n    {\\n        _getDN404Storage().operatorApprovals[msgSender][operator] = approved;\\n    }\\n\\n    /// @dev Calls the mirror contract to link it to this contract.\\n    ///\\n    /// Reverts if the call to the mirror contract reverts.\\n    function _linkMirrorContract(address mirror) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x0f4599e5) // `linkMirrorContract(address)`.\\n            mstore(0x20, caller())\\n            if iszero(and(eq(mload(0x00), 1), call(gas(), mirror, 0, 0x1c, 0x24, 0x00, 0x20))) {\\n                mstore(0x00, 0xd125259c) // `LinkMirrorContractFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback modifier to dispatch calls from the mirror NFT contract\\n    /// to internal functions in this contract.\\n    modifier dn404Fallback() virtual {\\n        DN404Storage storage $ = _getDN404Storage();\\n\\n        uint256 fnSelector = _calldataload(0x00) >> 224;\\n\\n        // `isApprovedForAll(address,address)`.\\n        if (fnSelector == 0xe985e9c5) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x44) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n            address operator = address(uint160(_calldataload(0x24)));\\n\\n            _return($.operatorApprovals[owner][operator] ? 1 : 0);\\n        }\\n        // `ownerOf(uint256)`.\\n        if (fnSelector == 0x6352211e) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_ownerOf(id)));\\n        }\\n        // `transferFromNFT(address,address,uint256,address)`.\\n        if (fnSelector == 0xe5eb36c8) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x84) revert();\\n\\n            address from = address(uint160(_calldataload(0x04)));\\n            address to = address(uint160(_calldataload(0x24)));\\n            uint256 id = _calldataload(0x44);\\n            address msgSender = address(uint160(_calldataload(0x64)));\\n\\n            _transferFromNFT(from, to, id, msgSender);\\n            _return(1);\\n        }\\n        // `setApprovalForAll(address,bool,address)`.\\n        if (fnSelector == 0x813500fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            bool status = _calldataload(0x24) != 0;\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _setApprovalForAll(spender, status, msgSender);\\n            _return(1);\\n        }\\n        // `approveNFT(address,uint256,address)`.\\n        if (fnSelector == 0xd10b6e0c) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x64) revert();\\n\\n            address spender = address(uint160(_calldataload(0x04)));\\n            uint256 id = _calldataload(0x24);\\n            address msgSender = address(uint160(_calldataload(0x44)));\\n\\n            _return(uint160(_approveNFT(spender, id, msgSender)));\\n        }\\n        // `getApproved(uint256)`.\\n        if (fnSelector == 0x081812fc) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            uint256 id = _calldataload(0x04);\\n\\n            _return(uint160(_getApproved(id)));\\n        }\\n        // `balanceOfNFT(address)`.\\n        if (fnSelector == 0xf5b100ea) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x24) revert();\\n\\n            address owner = address(uint160(_calldataload(0x04)));\\n\\n            _return(_balanceOfNFT(owner));\\n        }\\n        // `totalNFTSupply()`.\\n        if (fnSelector == 0xe2c79281) {\\n            if (msg.sender != $.mirrorERC721) revert SenderNotMirror();\\n            if (msg.data.length < 0x04) revert();\\n\\n            _return(_totalNFTSupply());\\n        }\\n        // `implementsDN404()`.\\n        if (fnSelector == 0xb7a94eb8) {\\n            _return(1);\\n        }\\n        _;\\n    }\\n\\n    /// @dev Fallback function for calls from mirror NFT contract.\\n    fallback() external payable virtual dn404Fallback {}\\n\\n    receive() external payable virtual {}\\n\\n    /*\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-\u00ab-*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb-\u00bb*/\\n\\n    /// @dev Struct containing packed log data for `Transfer` events to be\\n    /// emitted by the mirror NFT contract.\\n    struct _PackedLogs {\\n        uint256[] logs;\\n        uint256 offset;\\n    }\\n\\n    /// @dev Initiates memory allocation for packed logs with `n` log items.\\n    function _packedLogsMalloc(uint256 n) private pure returns (_PackedLogs memory p) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := add(mload(0x40), 0x40) // Offset by 2 words for `_packedLogsSend`.\\n            mstore(logs, n)\\n            let offset := add(0x20, logs)\\n            mstore(0x40, add(offset, shl(5, n)))\\n            mstore(p, logs)\\n            mstore(add(0x20, p), offset)\\n        }\\n    }\\n\\n    /// @dev Adds a packed log item to `p` with address `a`, token `id` and burn flag `burnBit`.\\n    function _packedLogsAppend(_PackedLogs memory p, address a, uint256 id, uint256 burnBit)\\n        private\\n        pure\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let offset := mload(add(0x20, p))\\n            mstore(offset, or(or(shl(96, a), shl(8, id)), burnBit))\\n            mstore(add(0x20, p), add(offset, 0x20))\\n        }\\n    }\\n\\n    /// @dev Calls the `mirror` NFT contract to emit Transfer events for packed logs `p`.\\n    function _packedLogsSend(_PackedLogs memory p, address mirror) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let logs := mload(p)\\n            let o := sub(logs, 0x40) // Start of calldata to send.\\n            mstore(o, 0x263c69d6) // `logTransfer(uint256[])`.\\n            mstore(add(o, 0x20), 0x20) // Offset of `logs` in the calldata to send.\\n            let n := add(0x44, shl(5, mload(logs))) // Length of calldata to send.\\n            if iszero(and(eq(mload(o), 1), call(gas(), mirror, 0, add(o, 0x1c), n, o, 0x20))) {\\n                revert(o, 0x00)\\n            }\\n        }\\n    }\\n\\n    /// @dev Struct of temporary variables for transfers.\\n    struct _TransferTemps {\\n        uint256 nftAmountToBurn;\\n        uint256 nftAmountToMint;\\n        uint256 fromBalance;\\n        uint256 toBalance;\\n        uint256 fromOwnedLength;\\n        uint256 toOwnedLength;\\n    }\\n\\n    /// @dev Returns if `a` has bytecode of non-zero length.\\n    function _hasCode(address a) private view returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := extcodesize(a) // Can handle dirty upper bits.\\n        }\\n    }\\n\\n    /// @dev Returns the calldata value at `offset`.\\n    function _calldataload(uint256 offset) private pure returns (uint256 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := calldataload(offset)\\n        }\\n    }\\n\\n    /// @dev Executes a return opcode to return `x` and end the current call frame.\\n    function _return(uint256 x) private pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, x)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function _zeroFloorSub(uint256 x, uint256 y) private pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns `i << 1`.\\n    function _ownershipIndex(uint256 i) private pure returns (uint256) {\\n        return i << 1;\\n    }\\n\\n    /// @dev Returns `(i << 1) + 1`.\\n    function _ownedIndex(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return (i << 1) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function _get(Uint32Map storage map, uint256 index) private view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function _set(Uint32Map storage map, uint256 index, uint32 value) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Sets the owner alias and the owned index together.\\n    function _setOwnerAliasAndOwnedIndex(\\n        Uint32Map storage map,\\n        uint256 id,\\n        uint32 ownership,\\n        uint32 ownedIndex\\n    ) private {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let value := or(shl(32, ownedIndex), and(0xffffffff, ownership))\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, id))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(id, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}