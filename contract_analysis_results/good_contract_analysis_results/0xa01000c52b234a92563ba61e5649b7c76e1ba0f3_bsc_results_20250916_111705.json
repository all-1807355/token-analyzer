{
  "total_matches": 5,
  "patterns_found": {
    "honeypot_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "assembly {\n      // copy msg.data. we take full control of memory in this inline assembly\n      // block because it will not return to solidity code. we overwrite the\n      // solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert",
          "function_context": "function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }",
          "pattern": "assembly\\s*{\\s*[^}]*gas\\s*[^}]*revert"
        }
      ]
    },
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(creator_, totalsupply_)",
          "function_context": "function __MappableToken_init(address factory_, address creator_, string memory name_, string memory symbol_, uint8 decimals_, uint256 totalSupply_) external initializer {\n        __Context_init_unchained();\n\t\t__ERC20_init_unchained(name_, symbol_);\n\t\t_setupDecimals(decimals_);\n\t\t_mint(creator_, totalSupply_);\n\t\t__MappableToken_init_unchained(factory_, creator_);\n\t}",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, volume)",
          "function_context": "function _receive(address to, uint256 volume) virtual override internal {\n        _mint(to, volume);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}