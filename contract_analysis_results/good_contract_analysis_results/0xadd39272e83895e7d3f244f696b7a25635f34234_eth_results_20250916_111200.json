{
  "total_matches": 8,
  "patterns_found": {
    "minting_mechanics": {
      "count": 8,
      "snippets": [
        {
          "matched_code": "_mint(0x708c0f9c7250d07ffe15f10b3e81d86394e8b698, presalereserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(0x1134f2ad3a29b580cfca29cf6f39925317ee8cd5, stakingreserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(0x29eb0158cc8fd8ab19d097081d3d3411ebe51b91, marketingreserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(0x929a7d8e85d0e7f26b5c942c0764e8f4a941a0a0, liquidityreserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(0xe26dc11e9b5327688e7c69c2b95fc6defb1c106f, projectfinancereserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(0x5723b1bb76fab4eca495c3ab208109149f847060, chaininventoryreserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\\ncontract Token is Context, IERC20Metadata, Ownable {\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n\\n  string private _name;\\n  string private _symbol;\\n  uint8 private constant _decimals = 18;\\n  uint256 public constant presaleReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant stakingReserve = 2_400_000_000 * (10 ** _decimals);\\n  uint256 public constant marketingReserve = 1_600_000_000 * (10 ** _decimals);\\n  uint256 public constant liquidityReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant projectFinanceReserve = 800_000_000 * (10 ** _decimals);\\n  uint256 public constant chainInventoryReserve = 800_000_000 * (10 ** _decimals);\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor() {\\n    _name = 'Pepe Unchained';\\n    _symbol = 'PEPU';\\n    _mint(0x708C0F9C7250D07fFE15F10B3e81D86394e8b698, presaleReserve);\\n    _mint(0x1134f2aD3A29b580cfca29cf6F39925317EE8cd5, stakingReserve);\\n    _mint(0x29Eb0158CC8Fd8Ab19D097081D3D3411EbE51B91, marketingReserve);\\n    _mint(0x929a7d8E85D0e7F26B5c942C0764E8f4A941A0A0, liquidityReserve);\\n    _mint(0xE26dC11e9b5327688e7C69C2b95Fc6DEfb1C106f, projectFinanceReserve);\\n    _mint(0x5723B1Bb76fAb4eCA495C3Ab208109149F847060, chainInventoryReserve);\\n  }\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   * @return The name of the token.\\n   */\\n  function name() public view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   * @return The symbol of the token.\\n   */\\n  function symbol() public view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals used for token display.\\n   * @return The number of decimals.\\n   */\\n  function decimals() public view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total supply of the token.\\n   * @return The total supply.\\n   */\\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the balance of the specified account.\\n   * @param account The address to check the balance for.\\n   * @return The balance of the account.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from the caller to a specified recipient.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount of tokens that the spender is allowed to spend on behalf of the owner.\\n   * @param from The address that approves the spending.\\n   * @param to The address that is allowed to spend.\\n   * @return The remaining allowance for the spender.\\n   */\\n  function allowance(address from, address to) public view virtual override returns (uint256) {\\n    return _allowances[from][to];\\n  }\\n\\n  /**\\n   * @dev Approves the specified address to spend the specified amount of tokens on behalf of the caller.\\n   * @param to The address to approve the spending for.\\n   * @param amount The amount of tokens to approve.\\n   * @return A boolean value indicating whether the approval was successful.\\n   */\\n  function approve(address to, uint256 amount) public virtual override returns (bool) {\\n    _approve(_msgSender(), to, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens from one address to another.\\n   * @param sender The address to transfer tokens from.\\n   * @param recipient The address to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   * @return A boolean value indicating whether the transfer was successful.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\\n    require(currentAllowance >= amount, 'ERC20: transfer amount exceeds allowance');\\n    unchecked {\\n      _approve(sender, _msgSender(), currentAllowance - amount);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increases the allowance of the specified address to spend tokens on behalf of the caller.\\n   * @param to The address to increase the allowance for.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   * @return A boolean value indicating whether the increase was successful.\\n   */\\n  function increaseAllowance(address to, uint256 addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), to, _allowances[_msgSender()][to] + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decreases the allowance granted by the owner of the tokens to `to` account.\\n   * @param to The account allowed to spend the tokens.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   * @return A boolean value indicating whether the operation succeeded.\\n   */\\n  function decreaseAllowance(address to, uint256 subtractedValue) public virtual returns (bool) {\\n    uint256 currentAllowance = _allowances[_msgSender()][to];\\n    require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');\\n    unchecked {\\n      _approve(_msgSender(), to, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfers `amount` tokens from `sender` to `recipient`.\\n   * @param sender The account to transfer tokens from.\\n   * @param recipient The account to transfer tokens to.\\n   * @param amount The amount of tokens to transfer.\\n   */\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(amount > 0, 'ERC20: transfer amount zero');\\n    require(sender != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      _balances[sender] = senderBalance - amount;\\n    }\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Creates `amount` tokens and assigns them to `account`.\\n   * @param account The account to assign the newly created tokens to.\\n   * @param amount The amount of tokens to create.\\n   */\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _totalSupply += amount;\\n    _balances[account] += amount;\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n   * @param account The account to burn tokens from.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function _burn(address account, uint256 amount) internal virtual {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    uint256 accountBalance = _balances[account];\\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\\n    unchecked {\\n      _balances[account] = accountBalance - amount;\\n    }\\n    _totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller's account, reducing the total supply.\\n   * @param amount The amount of tokens to burn.\\n   */\\n  function burn(uint256 amount) external {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `to` over the caller's tokens.\\n   * @param from The account granting the allowance.\\n   * @param to The account allowed to spend the tokens.\\n   * @param amount The amount of tokens to allow.\\n   */\\n  function _approve(address from, address to, uint256 amount) internal virtual {\\n    require(from != address(0), 'ERC20: approve from the zero address');\\n    require(to != address(0), 'ERC20: approve to the zero address');\\n\\n    _allowances[from][to] = amount;\\n    emit Approval(from, to, amount);\\n  }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}