{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n    unchecked {\\r\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n    }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n            unchecked {\\r\\n                _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n    unchecked {\\r\\n        _balances[sender] = senderBalance - amount;\\r\\n    }\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IDexRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint256 amountToken,\\r\\n        uint256 amountETH,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IDexFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n    external\\r\\n    returns (address pair);\\r\\n}\\r\\n\\r\\ncontract Furo is ERC20, Ownable {\\r\\n    uint256 public maxSwapsPerBlock = 150;\\r\\n    uint256 private swapsInCurrentBlock;\\r\\n    uint256 private lastTradeBlock;\\r\\n\\r\\n    event MaxSwapsPerBlockUpdated(uint256 newValue);\\r\\n\\r\\n    uint256 public maxBuyAmount;\\r\\n\\r\\n    IDexFactory public immutable uniswapV2Factory;\\r\\n    IDexRouter public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public immutable WETH;\\r\\n\\r\\n    bool private swapping;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public swapTokensLastBlock;\\r\\n\\r\\n    address public treasuryAddress;\\r\\n\\r\\n    uint256 public tradingActiveBlock = 0;\\r\\n    uint256 public tradingActivatedAtTimestamp = 0;\\r\\n\\r\\n    bool public limitsInEffect;\\r\\n    bool public tradingActive;\\r\\n    bool public swapFeesOncePerBlock;\\r\\n\\r\\n    address public sniperBotsGuard;\\r\\n    mapping(address => bool) public isSniperBot;\\r\\n\\r\\n    uint256 public buyFee;\\r\\n    uint256 public sellFee;\\r\\n\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    EnumerableSet.AddressSet private _holders;\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n    event EnabledTrading();\\r\\n    event RemovedLimits();\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    event UpdatedMaxBuyAmount(uint256 newAmount);\\r\\n    event UpdatedTreasuryAddress(address indexed newWallet);\\r\\n    event MaxTransactionExclusion(address _address, bool excluded);\\r\\n    event SwapFeeCollected(uint256 amount);\\r\\n    event SwapBackResult(uint256 amountIn, uint256 amountOut);\\r\\n    event TransferForeignToken(address token, uint256 amount);\\r\\n    event TreasuryTransferFailed(uint256 amount);\\r\\n\\r\\n    event IsSniperBotSet(address account, bool isSniper);\\r\\n    event SniperBotsGuardSet(address account);\\r\\n\\r\\n    event SwapFeesOncePerBlockSet(bool newSetting);\\r\\n    event SetSwapThreshold(uint256 newAmount);\\r\\n\\r\\n    bool public maxSwapsPerBlockFreezeForever;\\r\\n\\r\\n    function setSwapFeesOncePerBlock(bool newSetting) external {\\r\\n        require(\\r\\n            msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change swapFeesOncePerBlock\\\");\\r\\n        swapFeesOncePerBlock = newSetting;\\r\\n        emit SwapFeesOncePerBlockSet(newSetting);\\r\\n    }\\r\\n\\r\\n    bool public newSniperBotDisabledForever;\\r\\n    event NewSniperBotDisabledForever();\\r\\n\\r\\n    function disableNewSniperBotForever() external onlyOwner {\\r\\n        newSniperBotDisabledForever = true;\\r\\n        emit NewSniperBotDisabledForever();\\r\\n    }\\r\\n\\r\\n    function setSniperBot(address account, bool isSniper) external {\\r\\n        require(\\r\\n            msg.sender == sniperBotsGuard || msg.sender == owner(),\\r\\n            \\\"Only owner or sniperBotsGuard can set sniper bots\\\");\\r\\n        if (newSniperBotDisabledForever) {\\r\\n            require(!isSniper, \\\"New sniper bots are disabled forever\\\");\\r\\n        }\\r\\n        isSniperBot[account] = isSniper;\\r\\n        emit IsSniperBotSet(account, isSniper);\\r\\n    }\\r\\n\\r\\n    function setSniperBotsGuard(address account) external {\\r\\n        require(\\r\\n            msg.sender == owner() || msg.sender == sniperBotsGuard,\\r\\n            \\\"Only owner or sniperBotsGuard can set sniper bots guard\\\");\\r\\n        sniperBotsGuard = account;\\r\\n        emit SniperBotsGuardSet(account);\\r\\n    }\\r\\n\\r\\n    constructor() ERC20('Furo', 'Furo') {\\r\\n        address newOwner = msg.sender;\\r\\n        sniperBotsGuard = newOwner;\\r\\n\\r\\n        IDexRouter _uniswapV2Router = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        _excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        uniswapV2Factory = IDexFactory(_uniswapV2Router.factory());\\r\\n        WETH = _uniswapV2Router.WETH();\\r\\n        uniswapV2Pair = uniswapV2Factory.createPair(address(this), WETH);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n\\r\\n        uint256 totalSupply = 1_000_000_000 * (10**18);\\r\\n\\r\\n        maxBuyAmount = totalSupply * 80 / 100 / 100;  // 0.8% of total supply\\r\\n        swapTokensAtAmount = totalSupply * 1 / 1_000_000;  // very small amount\\r\\n        limitsInEffect = true;\\r\\n\\r\\n        buyFee = 22 * 10000 / 100;\\r\\n        sellFee = 22 * 10000 / 100;\\r\\n\\r\\n        _excludeFromMaxTransaction(newOwner, true);\\r\\n        _excludeFromMaxTransaction(address(this), true);\\r\\n        _excludeFromMaxTransaction(address(0xdead), true);\\r\\n\\r\\n        treasuryAddress = address(newOwner);\\r\\n\\r\\n        excludeFromFees(newOwner, true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        excludeFromFees(treasuryAddress, true);\\r\\n\\r\\n        _createInitialSupply(newOwner, totalSupply);\\r\\n        // Add initial holder to holders list\\r\\n        _updateHolderList(newOwner);\\r\\n        transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000) / 1e18, \\\"Cannot set max buy amount lower than 0.1%\\\");\\r\\n        maxBuyAmount = newNum * (10**18);\\r\\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\\r\\n    }\\r\\n\\r\\n    function getFees() external view returns (uint256, uint256) {\\r\\n        return (buyFee, sellFee);\\r\\n    }\\r\\n\\r\\n    bool public feesLocked = false;\\r\\n    event FeesLocked();\\r\\n\\r\\n    function lockFees() external onlyOwner {\\r\\n        feesLocked = true;\\r\\n        emit FeesLocked();\\r\\n    }\\r\\n\\r\\n    bool public feesOnlyLower = false;\\r\\n    event FeesOnlyLower();\\r\\n\\r\\n    function setFeesOnlyLower(bool _feesOnlyLower) external onlyOwner {\\r\\n        feesOnlyLower = _feesOnlyLower;\\r\\n        emit FeesOnlyLower();\\r\\n    }\\r\\n\\r\\n    function setFees(uint256 _buyFee, uint256 _sellFee) external onlyOwner {\\r\\n        require(!feesLocked, \\\"Fees are locked\\\");\\r\\n        require(_buyFee <= 10000 * 40 / 100, \\\"High fee\\\");\\r\\n        require(_sellFee <= 10000 * 40 / 100, \\\"High fee\\\");\\r\\n        if (feesOnlyLower) {\\r\\n            require(_buyFee <= buyFee, \\\"Buy fee can only be lowered\\\");\\r\\n            require(_sellFee <= sellFee, \\\"Sell fee can only be lowered\\\");\\r\\n        }\\r\\n        buyFee = _buyFee;\\r\\n        sellFee = _sellFee;\\r\\n    }\\r\\n\\r\\n    function removeLimits() external onlyOwner {\\r\\n        limitsInEffect = false;\\r\\n        emit RemovedLimits();\\r\\n    }\\r\\n\\r\\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\\r\\n        emit MaxTransactionExclusion(updAds, isExcluded);\\r\\n    }\\r\\n\\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\\r\\n        if(!isEx){\\r\\n            require(updAds != uniswapV2Pair, \\\"Cannot remove uniswap pair from max txn\\\");\\r\\n        }\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n\\r\\n    function setSwapThresholdUnits(uint256 newAmount) external {\\r\\n        require(msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change swapThreshold\\\");\\r\\n        swapTokensAtAmount = newAmount * 10**18;\\r\\n        emit SetSwapThreshold(swapTokensAtAmount);\\r\\n    }\\r\\n\\r\\n    function transferForeignToken(address _token, address _to) public returns (bool _sent) {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        require(msg.sender == treasuryAddress,\\r\\n            \\\"only treasuryAddress can withdraw\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\r\\n        emit TransferForeignToken(_token, _contractBalance);\\r\\n    }\\r\\n\\r\\n    function withdrawStuckETH() public {\\r\\n        require(msg.sender == treasuryAddress, \\\"only treasuryAddress can withdraw\\\");\\r\\n        bool success;\\r\\n        (success,) = address(msg.sender).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function _getBuyFee() public view returns (uint256) {\\r\\n        return buyFee;\\r\\n    }\\r\\n\\r\\n    function _getSellFee() public view returns (uint256) {\\r\\n        return sellFee;\\r\\n    }\\r\\n\\r\\n    // ---------- Holders management ----------\\r\\n    function _updateHolderList(address holder) internal {\\r\\n        if (holder == address(0)) return;\\r\\n        uint256 bal = balanceOf(holder);\\r\\n        if (bal > 0) {\\r\\n            _holders.add(holder);\\r\\n        } else {\\r\\n            _holders.remove(holder);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function holdersLength() external view returns (uint256) {\\r\\n        return _holders.length();\\r\\n    }\\r\\n\\r\\n    function holderByIndex(uint256 index) external view returns (address) {\\r\\n        require(index < _holders.length(), \\\"Index out of bounds\\\");\\r\\n        return _holders.at(index);\\r\\n    }\\r\\n\\r\\n    function holders() external view returns (address[] memory) {\\r\\n        return _holders.values();\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"amount must be greater than 0\\\");\\r\\n\\r\\n        require(!isSniperBot[from] && !isSniperBot[to], \\\"Sniper bots are not allowed\\\");\\r\\n\\r\\n        {\\r\\n            uint256 currentBlock = block.number;\\r\\n            if (currentBlock != lastTradeBlock) {\\r\\n                swapsInCurrentBlock = 0;\\r\\n                lastTradeBlock = currentBlock;\\r\\n            }\\r\\n\\r\\n            bool isBuy  = automatedMarketMakerPairs[from];\\r\\n            bool isSell = automatedMarketMakerPairs[to];\\r\\n\\r\\n            if (isBuy || isSell) {\\r\\n                swapsInCurrentBlock += 1;\\r\\n                require(maxSwapsPerBlock == 0 || swapsInCurrentBlock <= maxSwapsPerBlock,\\r\\n                        \\\"Max swaps per block exceeded\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(limitsInEffect){\\r\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead)){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedMaxTransactionAmount[from] || _isExcludedMaxTransactionAmount[to], \\\"Trading is not active.\\\");\\r\\n                    require(from == owner(), \\\"Trading is not enabled\\\");\\r\\n                }\\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                    require(amount <= maxBuyAmount, \\\"Buy transfer amount exceeds the max buy.\\\");\\r\\n                }\\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                }\\r\\n                else if (!_isExcludedMaxTransactionAmount[to] && !_isExcludedMaxTransactionAmount[from]){\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n\\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if(\\r\\n            canSwap &&\\r\\n            tradingActive &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            _swapBack();\\r\\n            swapping = false;\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n\\r\\n        // only take fees on Trades, not on wallet transfers\\r\\n\\r\\n        if(takeFee && tradingActiveBlock>0 && (block.number>tradingActiveBlock)) {\\r\\n            uint256 fees = 0;\\r\\n\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && _getSellFee() > 0) {\\r\\n                fees = amount * _getSellFee() / 10000;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && _getBuyFee() > 0) {\\r\\n                fees = amount * _getBuyFee() / 10000;\\r\\n            }\\r\\n\\r\\n            if(fees > 0){\\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n\\r\\n            amount -= fees;\\r\\n\\r\\n            emit SwapFeeCollected(fees);\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n\\r\\n        // Update holders list\\r\\n        _updateHolderList(from);\\r\\n        _updateHolderList(to);\\r\\n        _updateHolderList(address(this));\\r\\n    }\\r\\n\\r\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n\\r\\n        _approve(\\r\\n            address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        uint ethBalanceBeforeSwap = address(this).balance;\\r\\n\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        emit SwapBackResult(tokenAmount, address(this).balance - ethBalanceBeforeSwap);\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\\r\\n        require(pair != uniswapV2Pair,\\r\\n            \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n\\r\\n        _excludeFromMaxTransaction(pair, value);\\r\\n\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function setTreasuryAddress(address _TreasuryAddress) external {\\r\\n        require(\\r\\n            msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change treasuryAddress\\\"\\r\\n        );\\r\\n        require(_TreasuryAddress != address(0),\\r\\n            \\\"_TreasuryAddress address cannot be 0\\\");\\r\\n        treasuryAddress = payable(_TreasuryAddress);\\r\\n        emit UpdatedTreasuryAddress(_TreasuryAddress);\\r\\n    }\\r\\n\\r\\n    event SwapTokensLastBlockSet(uint256 newBlock);\\r\\n    event SkipSwapBecauseOfBlock();\\r\\n\\r\\n    uint256 public maxMilliEthForFeeSwapInTx = 1000;\\r\\n    event MaxMilliEthForFeeSwapInTxUpdated(uint256 newMaxMilliEthForFeeSwapInTx);\\r\\n    function setMaxMilliEthForFeeSwapInTx(uint256 newMaxMilliEthForFeeSwapInTx) external onlyOwner {\\r\\n        maxMilliEthForFeeSwapInTx = newMaxMilliEthForFeeSwapInTx;\\r\\n        emit MaxMilliEthForFeeSwapInTxUpdated(newMaxMilliEthForFeeSwapInTx);\\r\\n    }\\r\\n\\r\\n    bool public feeSellEnabled = false;\\r\\n    event FeeSellEnabled();\\r\\n\\r\\n    function enableFeeSell() external onlyOwner {\\r\\n        feeSellEnabled = true;\\r\\n        emit FeeSellEnabled();\\r\\n    }\\r\\n\\r\\n    function _swapBack() private {\\r\\n        if ((tradingActivatedAtTimestamp != 0) || (!feeSellEnabled)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 tokensToSwap = balanceOf(address(this));\\r\\n        if(tokensToSwap == 0) {return;}\\r\\n\\r\\n        if (swapFeesOncePerBlock && swapTokensLastBlock == block.number) {\\r\\n            emit SkipSwapBecauseOfBlock();\\r\\n            return;\\r\\n        }\\r\\n        swapTokensLastBlock = block.number;\\r\\n        emit SwapTokensLastBlockSet(block.number);\\r\\n\\r\\n        address[] memory _path = new address[](2);\\r\\n        _path[0] = WETH;\\r\\n        _path[1] = address(this);\\r\\n\\r\\n        /* ------------------------------------------------------------------\\r\\n           1) Per-transaction swap limit (maxMilliEthForFeeSwapInTx)\\r\\n        ------------------------------------------------------------------ */\\r\\n        if (maxMilliEthForFeeSwapInTx != 0) {\\r\\n            uint256 maxWeiPerTx = maxMilliEthForFeeSwapInTx * 1e18 / 1000; // milli-ETH \u2192 wei\\r\\n            uint256 _maxTokenAmountTx = uniswapV2Router.getAmountsOut(maxWeiPerTx, _path)[1];\\r\\n            if (tokensToSwap > _maxTokenAmountTx) {\\r\\n                tokensToSwap = _maxTokenAmountTx;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (tokensToSwap == 0) {return;}\\r\\n\\r\\n        _swapTokensForEth(tokensToSwap);\\r\\n        if (address(this).balance > 0) {\\r\\n            uint256 contractEthBalance = address(this).balance;\\r\\n            (bool success,) = address(treasuryAddress).call{value: contractEthBalance}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                // leave ETH on contract; will attempt again on next swap\\r\\n                emit TreasuryTransferFailed(contractEthBalance);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function makeManualSwap() external {\\r\\n        require(_msgSender() == treasuryAddress,\\r\\n            \\\"Only treasuryAddress can manually swap\\\");\\r\\n        uint256 tokenBalance = balanceOf(address(this));\\r\\n        if(tokenBalance > 0){\\r\\n            swapping = true;\\r\\n            _swapBack();\\r\\n            swapping = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        require(!tradingActive, \\\"Cannot re enable trading\\\");\\r\\n        tradingActive = true;\\r\\n        emit EnabledTrading();\\r\\n        tradingActiveBlock = block.number;\\r\\n        tradingActivatedAtTimestamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setMaxTotalSwapsPerBlock(uint256 newValue) external onlyOwner {\\r\\n        require(!maxSwapsPerBlockFreezeForever, \\\"forever freeze is enabled\\\");\\r\\n        maxSwapsPerBlock = newValue;\\r\\n        emit MaxSwapsPerBlockUpdated(newValue);\\r\\n    }\\r\\n\\r\\n    function freezeMaxSwapsPerBlockForever() external onlyOwner {\\r\\n        maxSwapsPerBlockFreezeForever = true;\\r\\n    }\\r\\n}\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "stealth_fee_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "mapping (address => bool) private _isexcludedfromfee",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.8;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\r\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\r\\n    unchecked {\\r\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\r\\n    }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\r\\n            unchecked {\\r\\n                _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        uint256 senderBalance = _balances[sender];\\r\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n    unchecked {\\r\\n        _balances[sender] = senderBalance - amount;\\r\\n    }\\r\\n        _balances[recipient] += amount;\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[account] += amount;\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IDexRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint256 amountToken,\\r\\n        uint256 amountETH,\\r\\n        uint256 liquidity\\r\\n    );\\r\\n\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IDexFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n    external\\r\\n    returns (address pair);\\r\\n}\\r\\n\\r\\ncontract Furo is ERC20, Ownable {\\r\\n    uint256 public maxSwapsPerBlock = 150;\\r\\n    uint256 private swapsInCurrentBlock;\\r\\n    uint256 private lastTradeBlock;\\r\\n\\r\\n    event MaxSwapsPerBlockUpdated(uint256 newValue);\\r\\n\\r\\n    uint256 public maxBuyAmount;\\r\\n\\r\\n    IDexFactory public immutable uniswapV2Factory;\\r\\n    IDexRouter public immutable uniswapV2Router;\\r\\n    address public immutable uniswapV2Pair;\\r\\n    address public immutable WETH;\\r\\n\\r\\n    bool private swapping;\\r\\n    uint256 public swapTokensAtAmount;\\r\\n    uint256 public swapTokensLastBlock;\\r\\n\\r\\n    address public treasuryAddress;\\r\\n\\r\\n    uint256 public tradingActiveBlock = 0;\\r\\n    uint256 public tradingActivatedAtTimestamp = 0;\\r\\n\\r\\n    bool public limitsInEffect;\\r\\n    bool public tradingActive;\\r\\n    bool public swapFeesOncePerBlock;\\r\\n\\r\\n    address public sniperBotsGuard;\\r\\n    mapping(address => bool) public isSniperBot;\\r\\n\\r\\n    uint256 public buyFee;\\r\\n    uint256 public sellFee;\\r\\n\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    EnumerableSet.AddressSet private _holders;\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n    event EnabledTrading();\\r\\n    event RemovedLimits();\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    event UpdatedMaxBuyAmount(uint256 newAmount);\\r\\n    event UpdatedTreasuryAddress(address indexed newWallet);\\r\\n    event MaxTransactionExclusion(address _address, bool excluded);\\r\\n    event SwapFeeCollected(uint256 amount);\\r\\n    event SwapBackResult(uint256 amountIn, uint256 amountOut);\\r\\n    event TransferForeignToken(address token, uint256 amount);\\r\\n    event TreasuryTransferFailed(uint256 amount);\\r\\n\\r\\n    event IsSniperBotSet(address account, bool isSniper);\\r\\n    event SniperBotsGuardSet(address account);\\r\\n\\r\\n    event SwapFeesOncePerBlockSet(bool newSetting);\\r\\n    event SetSwapThreshold(uint256 newAmount);\\r\\n\\r\\n    bool public maxSwapsPerBlockFreezeForever;\\r\\n\\r\\n    function setSwapFeesOncePerBlock(bool newSetting) external {\\r\\n        require(\\r\\n            msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change swapFeesOncePerBlock\\\");\\r\\n        swapFeesOncePerBlock = newSetting;\\r\\n        emit SwapFeesOncePerBlockSet(newSetting);\\r\\n    }\\r\\n\\r\\n    bool public newSniperBotDisabledForever;\\r\\n    event NewSniperBotDisabledForever();\\r\\n\\r\\n    function disableNewSniperBotForever() external onlyOwner {\\r\\n        newSniperBotDisabledForever = true;\\r\\n        emit NewSniperBotDisabledForever();\\r\\n    }\\r\\n\\r\\n    function setSniperBot(address account, bool isSniper) external {\\r\\n        require(\\r\\n            msg.sender == sniperBotsGuard || msg.sender == owner(),\\r\\n            \\\"Only owner or sniperBotsGuard can set sniper bots\\\");\\r\\n        if (newSniperBotDisabledForever) {\\r\\n            require(!isSniper, \\\"New sniper bots are disabled forever\\\");\\r\\n        }\\r\\n        isSniperBot[account] = isSniper;\\r\\n        emit IsSniperBotSet(account, isSniper);\\r\\n    }\\r\\n\\r\\n    function setSniperBotsGuard(address account) external {\\r\\n        require(\\r\\n            msg.sender == owner() || msg.sender == sniperBotsGuard,\\r\\n            \\\"Only owner or sniperBotsGuard can set sniper bots guard\\\");\\r\\n        sniperBotsGuard = account;\\r\\n        emit SniperBotsGuardSet(account);\\r\\n    }\\r\\n\\r\\n    constructor() ERC20('Furo', 'Furo') {\\r\\n        address newOwner = msg.sender;\\r\\n        sniperBotsGuard = newOwner;\\r\\n\\r\\n        IDexRouter _uniswapV2Router = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        _excludeFromMaxTransaction(address(_uniswapV2Router), true);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        uniswapV2Factory = IDexFactory(_uniswapV2Router.factory());\\r\\n        WETH = _uniswapV2Router.WETH();\\r\\n        uniswapV2Pair = uniswapV2Factory.createPair(address(this), WETH);\\r\\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\\r\\n\\r\\n        uint256 totalSupply = 1_000_000_000 * (10**18);\\r\\n\\r\\n        maxBuyAmount = totalSupply * 80 / 100 / 100;  // 0.8% of total supply\\r\\n        swapTokensAtAmount = totalSupply * 1 / 1_000_000;  // very small amount\\r\\n        limitsInEffect = true;\\r\\n\\r\\n        buyFee = 22 * 10000 / 100;\\r\\n        sellFee = 22 * 10000 / 100;\\r\\n\\r\\n        _excludeFromMaxTransaction(newOwner, true);\\r\\n        _excludeFromMaxTransaction(address(this), true);\\r\\n        _excludeFromMaxTransaction(address(0xdead), true);\\r\\n\\r\\n        treasuryAddress = address(newOwner);\\r\\n\\r\\n        excludeFromFees(newOwner, true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(address(0xdead), true);\\r\\n        excludeFromFees(treasuryAddress, true);\\r\\n\\r\\n        _createInitialSupply(newOwner, totalSupply);\\r\\n        // Add initial holder to holders list\\r\\n        _updateHolderList(newOwner);\\r\\n        transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\\r\\n        require(newNum >= (totalSupply() * 1 / 1000) / 1e18, \\\"Cannot set max buy amount lower than 0.1%\\\");\\r\\n        maxBuyAmount = newNum * (10**18);\\r\\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\\r\\n    }\\r\\n\\r\\n    function getFees() external view returns (uint256, uint256) {\\r\\n        return (buyFee, sellFee);\\r\\n    }\\r\\n\\r\\n    bool public feesLocked = false;\\r\\n    event FeesLocked();\\r\\n\\r\\n    function lockFees() external onlyOwner {\\r\\n        feesLocked = true;\\r\\n        emit FeesLocked();\\r\\n    }\\r\\n\\r\\n    bool public feesOnlyLower = false;\\r\\n    event FeesOnlyLower();\\r\\n\\r\\n    function setFeesOnlyLower(bool _feesOnlyLower) external onlyOwner {\\r\\n        feesOnlyLower = _feesOnlyLower;\\r\\n        emit FeesOnlyLower();\\r\\n    }\\r\\n\\r\\n    function setFees(uint256 _buyFee, uint256 _sellFee) external onlyOwner {\\r\\n        require(!feesLocked, \\\"Fees are locked\\\");\\r\\n        require(_buyFee <= 10000 * 40 / 100, \\\"High fee\\\");\\r\\n        require(_sellFee <= 10000 * 40 / 100, \\\"High fee\\\");\\r\\n        if (feesOnlyLower) {\\r\\n            require(_buyFee <= buyFee, \\\"Buy fee can only be lowered\\\");\\r\\n            require(_sellFee <= sellFee, \\\"Sell fee can only be lowered\\\");\\r\\n        }\\r\\n        buyFee = _buyFee;\\r\\n        sellFee = _sellFee;\\r\\n    }\\r\\n\\r\\n    function removeLimits() external onlyOwner {\\r\\n        limitsInEffect = false;\\r\\n        emit RemovedLimits();\\r\\n    }\\r\\n\\r\\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\\r\\n        emit MaxTransactionExclusion(updAds, isExcluded);\\r\\n    }\\r\\n\\r\\n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\\r\\n        if(!isEx){\\r\\n            require(updAds != uniswapV2Pair, \\\"Cannot remove uniswap pair from max txn\\\");\\r\\n        }\\r\\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\\r\\n    }\\r\\n\\r\\n    function setSwapThresholdUnits(uint256 newAmount) external {\\r\\n        require(msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change swapThreshold\\\");\\r\\n        swapTokensAtAmount = newAmount * 10**18;\\r\\n        emit SetSwapThreshold(swapTokensAtAmount);\\r\\n    }\\r\\n\\r\\n    function transferForeignToken(address _token, address _to) public returns (bool _sent) {\\r\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\r\\n        require(msg.sender == treasuryAddress,\\r\\n            \\\"only treasuryAddress can withdraw\\\");\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\r\\n        emit TransferForeignToken(_token, _contractBalance);\\r\\n    }\\r\\n\\r\\n    function withdrawStuckETH() public {\\r\\n        require(msg.sender == treasuryAddress, \\\"only treasuryAddress can withdraw\\\");\\r\\n        bool success;\\r\\n        (success,) = address(msg.sender).call{value: address(this).balance}(\\\"\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function _getBuyFee() public view returns (uint256) {\\r\\n        return buyFee;\\r\\n    }\\r\\n\\r\\n    function _getSellFee() public view returns (uint256) {\\r\\n        return sellFee;\\r\\n    }\\r\\n\\r\\n    // ---------- Holders management ----------\\r\\n    function _updateHolderList(address holder) internal {\\r\\n        if (holder == address(0)) return;\\r\\n        uint256 bal = balanceOf(holder);\\r\\n        if (bal > 0) {\\r\\n            _holders.add(holder);\\r\\n        } else {\\r\\n            _holders.remove(holder);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function holdersLength() external view returns (uint256) {\\r\\n        return _holders.length();\\r\\n    }\\r\\n\\r\\n    function holderByIndex(uint256 index) external view returns (address) {\\r\\n        require(index < _holders.length(), \\\"Index out of bounds\\\");\\r\\n        return _holders.at(index);\\r\\n    }\\r\\n\\r\\n    function holders() external view returns (address[] memory) {\\r\\n        return _holders.values();\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"amount must be greater than 0\\\");\\r\\n\\r\\n        require(!isSniperBot[from] && !isSniperBot[to], \\\"Sniper bots are not allowed\\\");\\r\\n\\r\\n        {\\r\\n            uint256 currentBlock = block.number;\\r\\n            if (currentBlock != lastTradeBlock) {\\r\\n                swapsInCurrentBlock = 0;\\r\\n                lastTradeBlock = currentBlock;\\r\\n            }\\r\\n\\r\\n            bool isBuy  = automatedMarketMakerPairs[from];\\r\\n            bool isSell = automatedMarketMakerPairs[to];\\r\\n\\r\\n            if (isBuy || isSell) {\\r\\n                swapsInCurrentBlock += 1;\\r\\n                require(maxSwapsPerBlock == 0 || swapsInCurrentBlock <= maxSwapsPerBlock,\\r\\n                        \\\"Max swaps per block exceeded\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(limitsInEffect){\\r\\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead)){\\r\\n                if(!tradingActive){\\r\\n                    require(_isExcludedMaxTransactionAmount[from] || _isExcludedMaxTransactionAmount[to], \\\"Trading is not active.\\\");\\r\\n                    require(from == owner(), \\\"Trading is not enabled\\\");\\r\\n                }\\r\\n                //when buy\\r\\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\\r\\n                    require(amount <= maxBuyAmount, \\\"Buy transfer amount exceeds the max buy.\\\");\\r\\n                }\\r\\n                //when sell\\r\\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\\r\\n                }\\r\\n                else if (!_isExcludedMaxTransactionAmount[to] && !_isExcludedMaxTransactionAmount[from]){\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n\\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n\\r\\n        if(\\r\\n            canSwap &&\\r\\n            tradingActive &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            !_isExcludedFromFees[from] &&\\r\\n            !_isExcludedFromFees[to]\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            _swapBack();\\r\\n            swapping = false;\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n\\r\\n        // only take fees on Trades, not on wallet transfers\\r\\n\\r\\n        if(takeFee && tradingActiveBlock>0 && (block.number>tradingActiveBlock)) {\\r\\n            uint256 fees = 0;\\r\\n\\r\\n            // on sell\\r\\n            if (automatedMarketMakerPairs[to] && _getSellFee() > 0) {\\r\\n                fees = amount * _getSellFee() / 10000;\\r\\n            }\\r\\n            // on buy\\r\\n            else if(automatedMarketMakerPairs[from] && _getBuyFee() > 0) {\\r\\n                fees = amount * _getBuyFee() / 10000;\\r\\n            }\\r\\n\\r\\n            if(fees > 0){\\r\\n                super._transfer(from, address(this), fees);\\r\\n            }\\r\\n\\r\\n            amount -= fees;\\r\\n\\r\\n            emit SwapFeeCollected(fees);\\r\\n        }\\r\\n\\r\\n        super._transfer(from, to, amount);\\r\\n\\r\\n        // Update holders list\\r\\n        _updateHolderList(from);\\r\\n        _updateHolderList(to);\\r\\n        _updateHolderList(address(this));\\r\\n    }\\r\\n\\r\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n\\r\\n        _approve(\\r\\n            address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        uint ethBalanceBeforeSwap = address(this).balance;\\r\\n\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        emit SwapBackResult(tokenAmount, address(this).balance - ethBalanceBeforeSwap);\\r\\n    }\\r\\n\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\\r\\n        require(pair != uniswapV2Pair,\\r\\n            \\\"The pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n\\r\\n        _excludeFromMaxTransaction(pair, value);\\r\\n\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    function setTreasuryAddress(address _TreasuryAddress) external {\\r\\n        require(\\r\\n            msg.sender == treasuryAddress || msg.sender == owner(),\\r\\n            \\\"only treasuryAddress or owner can change treasuryAddress\\\"\\r\\n        );\\r\\n        require(_TreasuryAddress != address(0),\\r\\n            \\\"_TreasuryAddress address cannot be 0\\\");\\r\\n        treasuryAddress = payable(_TreasuryAddress);\\r\\n        emit UpdatedTreasuryAddress(_TreasuryAddress);\\r\\n    }\\r\\n\\r\\n    event SwapTokensLastBlockSet(uint256 newBlock);\\r\\n    event SkipSwapBecauseOfBlock();\\r\\n\\r\\n    uint256 public maxMilliEthForFeeSwapInTx = 1000;\\r\\n    event MaxMilliEthForFeeSwapInTxUpdated(uint256 newMaxMilliEthForFeeSwapInTx);\\r\\n    function setMaxMilliEthForFeeSwapInTx(uint256 newMaxMilliEthForFeeSwapInTx) external onlyOwner {\\r\\n        maxMilliEthForFeeSwapInTx = newMaxMilliEthForFeeSwapInTx;\\r\\n        emit MaxMilliEthForFeeSwapInTxUpdated(newMaxMilliEthForFeeSwapInTx);\\r\\n    }\\r\\n\\r\\n    bool public feeSellEnabled = false;\\r\\n    event FeeSellEnabled();\\r\\n\\r\\n    function enableFeeSell() external onlyOwner {\\r\\n        feeSellEnabled = true;\\r\\n        emit FeeSellEnabled();\\r\\n    }\\r\\n\\r\\n    function _swapBack() private {\\r\\n        if ((tradingActivatedAtTimestamp != 0) || (!feeSellEnabled)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 tokensToSwap = balanceOf(address(this));\\r\\n        if(tokensToSwap == 0) {return;}\\r\\n\\r\\n        if (swapFeesOncePerBlock && swapTokensLastBlock == block.number) {\\r\\n            emit SkipSwapBecauseOfBlock();\\r\\n            return;\\r\\n        }\\r\\n        swapTokensLastBlock = block.number;\\r\\n        emit SwapTokensLastBlockSet(block.number);\\r\\n\\r\\n        address[] memory _path = new address[](2);\\r\\n        _path[0] = WETH;\\r\\n        _path[1] = address(this);\\r\\n\\r\\n        /* ------------------------------------------------------------------\\r\\n           1) Per-transaction swap limit (maxMilliEthForFeeSwapInTx)\\r\\n        ------------------------------------------------------------------ */\\r\\n        if (maxMilliEthForFeeSwapInTx != 0) {\\r\\n            uint256 maxWeiPerTx = maxMilliEthForFeeSwapInTx * 1e18 / 1000; // milli-ETH \u2192 wei\\r\\n            uint256 _maxTokenAmountTx = uniswapV2Router.getAmountsOut(maxWeiPerTx, _path)[1];\\r\\n            if (tokensToSwap > _maxTokenAmountTx) {\\r\\n                tokensToSwap = _maxTokenAmountTx;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (tokensToSwap == 0) {return;}\\r\\n\\r\\n        _swapTokensForEth(tokensToSwap);\\r\\n        if (address(this).balance > 0) {\\r\\n            uint256 contractEthBalance = address(this).balance;\\r\\n            (bool success,) = address(treasuryAddress).call{value: contractEthBalance}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                // leave ETH on contract; will attempt again on next swap\\r\\n                emit TreasuryTransferFailed(contractEthBalance);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function makeManualSwap() external {\\r\\n        require(_msgSender() == treasuryAddress,\\r\\n            \\\"Only treasuryAddress can manually swap\\\");\\r\\n        uint256 tokenBalance = balanceOf(address(this));\\r\\n        if(tokenBalance > 0){\\r\\n            swapping = true;\\r\\n            _swapBack();\\r\\n            swapping = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // once enabled, can never be turned off\\r\\n    function enableTrading() external onlyOwner {\\r\\n        require(!tradingActive, \\\"Cannot re enable trading\\\");\\r\\n        tradingActive = true;\\r\\n        emit EnabledTrading();\\r\\n        tradingActiveBlock = block.number;\\r\\n        tradingActivatedAtTimestamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setMaxTotalSwapsPerBlock(uint256 newValue) external onlyOwner {\\r\\n        require(!maxSwapsPerBlockFreezeForever, \\\"forever freeze is enabled\\\");\\r\\n        maxSwapsPerBlock = newValue;\\r\\n        emit MaxSwapsPerBlockUpdated(newValue);\\r\\n    }\\r\\n\\r\\n    function freezeMaxSwapsPerBlockForever() external onlyOwner {\\r\\n        maxSwapsPerBlockFreezeForever = true;\\r\\n    }\\r\\n}\"",
          "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
        }
      ]
    }
  }
}