{
  "total_matches": 7,
  "patterns_found": {
    "minting_mechanics": {
      "count": 7,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/// @author thirdweb\\n\\n//   $$\\\\     $$\\\\       $$\\\\                 $$\\\\                         $$\\\\\\n//   $$ |    $$ |      \\\\__|                $$ |                        $$ |\\n// $$$$$$\\\\   $$$$$$$\\\\  $$\\\\  $$$$$$\\\\   $$$$$$$ |$$\\\\  $$\\\\  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\\\n// \\\\_$$  _|  $$  __$$\\\\ $$ |$$  __$$\\\\ $$  __$$ |$$ | $$ | $$ |$$  __$$\\\\ $$  __$$\\\\\\n//   $$ |    $$ |  $$ |$$ |$$ |  \\\\__|$$ /  $$ |$$ | $$ | $$ |$$$$$$$$ |$$ |  $$ |\\n//   $$ |$$\\\\ $$ |  $$ |$$ |$$ |      $$ |  $$ |$$ | $$ | $$ |$$   ____|$$ |  $$ |\\n//   \\\\$$$$  |$$ |  $$ |$$ |$$ |      \\\\$$$$$$$ |\\\\$$$$$\\\\$$$$  |\\\\$$$$$$$\\\\ $$$$$$$  |\\n//    \\\\____/ \\\\__|  \\\\__|\\\\__|\\\\__|       \\\\_______| \\\\_____\\\\____/  \\\\_______|\\\\_______/\\n\\n//Interface\\nimport { ITokenERC20 } from \\\"../interface/token/ITokenERC20.sol\\\";\\n\\nimport \\\"../../infra/interface/IThirdwebContract.sol\\\";\\nimport \\\"../../extension/interface/IPlatformFee.sol\\\";\\nimport \\\"../../extension/interface/IPrimarySale.sol\\\";\\n\\n// Token\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\\\";\\n\\n// Security\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n// Signature utils\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\n\\n// Meta transactions\\nimport \\\"../../external-deps/openzeppelin/metatx/ERC2771ContextUpgradeable.sol\\\";\\n\\n// Utils\\nimport \\\"../../extension/Multicall.sol\\\";\\nimport \\\"../../lib/CurrencyTransferLib.sol\\\";\\nimport \\\"../../lib/FeeType.sol\\\";\\n\\ncontract TokenERC20 is\\n    Initializable,\\n    IThirdwebContract,\\n    IPrimarySale,\\n    IPlatformFee,\\n    ReentrancyGuardUpgradeable,\\n    ERC2771ContextUpgradeable,\\n    Multicall,\\n    ERC20BurnableUpgradeable,\\n    ERC20VotesUpgradeable,\\n    ITokenERC20,\\n    AccessControlEnumerableUpgradeable\\n{\\n    using ECDSAUpgradeable for bytes32;\\n\\n    bytes32 private constant MODULE_TYPE = bytes32(\\\"TokenERC20\\\");\\n    uint256 private constant VERSION = 1;\\n\\n    bytes32 private constant TYPEHASH =\\n        keccak256(\\n            \\\"MintRequest(address to,address primarySaleRecipient,uint256 quantity,uint256 price,address currency,uint128 validityStartTimestamp,uint128 validityEndTimestamp,bytes32 uid)\\\"\\n        );\\n\\n    bytes32 internal constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 internal constant TRANSFER_ROLE = keccak256(\\\"TRANSFER_ROLE\\\");\\n\\n    /// @dev Returns the URI for the storefront-level metadata of the contract.\\n    string public contractURI;\\n\\n    /// @dev Max bps in the thirdweb system\\n    uint128 internal constant MAX_BPS = 10_000;\\n\\n    /// @dev The % of primary sales collected by the contract as fees.\\n    uint128 private platformFeeBps;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address internal platformFeeRecipient;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address public primarySaleRecipient;\\n\\n    /// @dev Mapping from mint request UID => whether the mint request is processed.\\n    mapping(bytes32 => bool) private minted;\\n\\n    constructor() initializer {}\\n\\n    /// @dev Initializes the contract, like a constructor.\\n    function initialize(\\n        address _defaultAdmin,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        address[] memory _trustedForwarders,\\n        address _primarySaleRecipient,\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external initializer {\\n        __ReentrancyGuard_init();\\n        __ERC2771Context_init_unchained(_trustedForwarders);\\n        __ERC20Permit_init(_name);\\n        __ERC20_init_unchained(_name, _symbol);\\n\\n        contractURI = _contractURI;\\n        primarySaleRecipient = _primarySaleRecipient;\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n        platformFeeBps = uint128(_platformFeeBps);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, _defaultAdmin);\\n        _setupRole(MINTER_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, address(0));\\n    }\\n\\n    /// @dev Returns the module type of the contract.\\n    function contractType() external pure virtual returns (bytes32) {\\n        return MODULE_TYPE;\\n    }\\n\\n    /// @dev Returns the version of the contract.\\n    function contractVersion() external pure virtual returns (uint8) {\\n        return uint8(VERSION);\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /// @dev Runs on every transfer.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (!hasRole(TRANSFER_ROLE, address(0)) && from != address(0) && to != address(0)) {\\n            require(hasRole(TRANSFER_ROLE, from) || hasRole(TRANSFER_ROLE, to), \\\"transfers restricted.\\\");\\n        }\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._mint(account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mintTo(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"not minter.\\\");\\n        _mintTo(to, amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is signed by an account holding MINTER_ROLE (at the time of the function call).\\n    function verify(MintRequest calldata _req, bytes calldata _signature) public view returns (bool, address) {\\n        address signer = recoverAddress(_req, _signature);\\n        return (!minted[_req.uid] && hasRole(MINTER_ROLE, signer), signer);\\n    }\\n\\n    /// @dev Mints tokens according to the provided mint request.\\n    function mintWithSignature(MintRequest calldata _req, bytes calldata _signature) external payable nonReentrant {\\n        address signer = verifyRequest(_req, _signature);\\n        address receiver = _req.to;\\n\\n        collectPrice(_req);\\n\\n        _mintTo(receiver, _req.quantity);\\n\\n        emit TokensMintedWithSignature(signer, receiver, _req);\\n    }\\n\\n    /// @dev Lets a module admin set the default recipient of all primary sales.\\n    function setPrimarySaleRecipient(address _saleRecipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        primarySaleRecipient = _saleRecipient;\\n        emit PrimarySaleRecipientUpdated(_saleRecipient);\\n    }\\n\\n    /// @dev Lets a module admin update the fees on primary sales.\\n    function setPlatformFeeInfo(\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n\\n        platformFeeBps = uint64(_platformFeeBps);\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        emit PlatformFeeInfoUpdated(_platformFeeRecipient, _platformFeeBps);\\n    }\\n\\n    /// @dev Returns the platform fee bps and recipient.\\n    function getPlatformFeeInfo() external view returns (address, uint16) {\\n        return (platformFeeRecipient, uint16(platformFeeBps));\\n    }\\n\\n    /// @dev Collects and distributes the primary sale value of tokens being claimed.\\n    function collectPrice(MintRequest calldata _req) internal {\\n        if (_req.price == 0) {\\n            require(msg.value == 0, \\\"!Value\\\");\\n            return;\\n        }\\n\\n        uint256 platformFees = (_req.price * platformFeeBps) / MAX_BPS;\\n\\n        if (_req.currency == CurrencyTransferLib.NATIVE_TOKEN) {\\n            require(msg.value == _req.price, \\\"must send total price.\\\");\\n        } else {\\n            require(msg.value == 0, \\\"msg value not zero\\\");\\n        }\\n\\n        address saleRecipient = _req.primarySaleRecipient == address(0)\\n            ? primarySaleRecipient\\n            : _req.primarySaleRecipient;\\n\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), platformFeeRecipient, platformFees);\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), saleRecipient, _req.price - platformFees);\\n    }\\n\\n    /// @dev Mints `amount` of tokens to `to`\\n    function _mintTo(address _to, uint256 _amount) internal {\\n        _mint(_to, _amount);\\n        emit TokensMinted(_to, _amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is valid.\\n    function verifyRequest(MintRequest calldata _req, bytes calldata _signature) internal returns (address) {\\n        (bool success, address signer) = verify(_req, _signature);\\n        require(success, \\\"invalid signature\\\");\\n\\n        require(\\n            _req.validityStartTimestamp <= block.timestamp && _req.validityEndTimestamp >= block.timestamp,\\n            \\\"request expired\\\"\\n        );\\n        require(_req.to != address(0), \\\"recipient undefined\\\");\\n        require(_req.quantity > 0, \\\"zero quantity\\\");\\n\\n        minted[_req.uid] = true;\\n\\n        return signer;\\n    }\\n\\n    /// @dev Returns the address of the signer of the mint request.\\n    function recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\\n\\n    /// @dev Resolves 'stack too deep' error in `recoverAddress`.\\n    function _encodeRequest(MintRequest calldata _req) internal pure returns (bytes memory) {\\n        return\\n            abi.encode(\\n                TYPEHASH,\\n                _req.to,\\n                _req.primarySaleRecipient,\\n                _req.quantity,\\n                _req.price,\\n                _req.currency,\\n                _req.validityStartTimestamp,\\n                _req.validityEndTimestamp,\\n                _req.uid\\n            );\\n    }\\n\\n    /// @dev Sets contract URI for the storefront-level metadata of the contract.\\n    function setContractURI(string calldata _uri) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        contractURI = _uri;\\n    }\\n\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable, Multicall)\\n        returns (address sender)\\n    {\\n        return ERC2771ContextUpgradeable._msgSender();\\n    }\\n\\n    function _msgData()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (bytes calldata)\\n    {\\n        return ERC2771ContextUpgradeable._msgData();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/// @author thirdweb\\n\\n//   $$\\\\     $$\\\\       $$\\\\                 $$\\\\                         $$\\\\\\n//   $$ |    $$ |      \\\\__|                $$ |                        $$ |\\n// $$$$$$\\\\   $$$$$$$\\\\  $$\\\\  $$$$$$\\\\   $$$$$$$ |$$\\\\  $$\\\\  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\\\n// \\\\_$$  _|  $$  __$$\\\\ $$ |$$  __$$\\\\ $$  __$$ |$$ | $$ | $$ |$$  __$$\\\\ $$  __$$\\\\\\n//   $$ |    $$ |  $$ |$$ |$$ |  \\\\__|$$ /  $$ |$$ | $$ | $$ |$$$$$$$$ |$$ |  $$ |\\n//   $$ |$$\\\\ $$ |  $$ |$$ |$$ |      $$ |  $$ |$$ | $$ | $$ |$$   ____|$$ |  $$ |\\n//   \\\\$$$$  |$$ |  $$ |$$ |$$ |      \\\\$$$$$$$ |\\\\$$$$$\\\\$$$$  |\\\\$$$$$$$\\\\ $$$$$$$  |\\n//    \\\\____/ \\\\__|  \\\\__|\\\\__|\\\\__|       \\\\_______| \\\\_____\\\\____/  \\\\_______|\\\\_______/\\n\\n//Interface\\nimport { ITokenERC20 } from \\\"../interface/token/ITokenERC20.sol\\\";\\n\\nimport \\\"../../infra/interface/IThirdwebContract.sol\\\";\\nimport \\\"../../extension/interface/IPlatformFee.sol\\\";\\nimport \\\"../../extension/interface/IPrimarySale.sol\\\";\\n\\n// Token\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\\\";\\n\\n// Security\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n// Signature utils\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\n\\n// Meta transactions\\nimport \\\"../../external-deps/openzeppelin/metatx/ERC2771ContextUpgradeable.sol\\\";\\n\\n// Utils\\nimport \\\"../../extension/Multicall.sol\\\";\\nimport \\\"../../lib/CurrencyTransferLib.sol\\\";\\nimport \\\"../../lib/FeeType.sol\\\";\\n\\ncontract TokenERC20 is\\n    Initializable,\\n    IThirdwebContract,\\n    IPrimarySale,\\n    IPlatformFee,\\n    ReentrancyGuardUpgradeable,\\n    ERC2771ContextUpgradeable,\\n    Multicall,\\n    ERC20BurnableUpgradeable,\\n    ERC20VotesUpgradeable,\\n    ITokenERC20,\\n    AccessControlEnumerableUpgradeable\\n{\\n    using ECDSAUpgradeable for bytes32;\\n\\n    bytes32 private constant MODULE_TYPE = bytes32(\\\"TokenERC20\\\");\\n    uint256 private constant VERSION = 1;\\n\\n    bytes32 private constant TYPEHASH =\\n        keccak256(\\n            \\\"MintRequest(address to,address primarySaleRecipient,uint256 quantity,uint256 price,address currency,uint128 validityStartTimestamp,uint128 validityEndTimestamp,bytes32 uid)\\\"\\n        );\\n\\n    bytes32 internal constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 internal constant TRANSFER_ROLE = keccak256(\\\"TRANSFER_ROLE\\\");\\n\\n    /// @dev Returns the URI for the storefront-level metadata of the contract.\\n    string public contractURI;\\n\\n    /// @dev Max bps in the thirdweb system\\n    uint128 internal constant MAX_BPS = 10_000;\\n\\n    /// @dev The % of primary sales collected by the contract as fees.\\n    uint128 private platformFeeBps;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address internal platformFeeRecipient;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address public primarySaleRecipient;\\n\\n    /// @dev Mapping from mint request UID => whether the mint request is processed.\\n    mapping(bytes32 => bool) private minted;\\n\\n    constructor() initializer {}\\n\\n    /// @dev Initializes the contract, like a constructor.\\n    function initialize(\\n        address _defaultAdmin,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        address[] memory _trustedForwarders,\\n        address _primarySaleRecipient,\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external initializer {\\n        __ReentrancyGuard_init();\\n        __ERC2771Context_init_unchained(_trustedForwarders);\\n        __ERC20Permit_init(_name);\\n        __ERC20_init_unchained(_name, _symbol);\\n\\n        contractURI = _contractURI;\\n        primarySaleRecipient = _primarySaleRecipient;\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n        platformFeeBps = uint128(_platformFeeBps);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, _defaultAdmin);\\n        _setupRole(MINTER_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, address(0));\\n    }\\n\\n    /// @dev Returns the module type of the contract.\\n    function contractType() external pure virtual returns (bytes32) {\\n        return MODULE_TYPE;\\n    }\\n\\n    /// @dev Returns the version of the contract.\\n    function contractVersion() external pure virtual returns (uint8) {\\n        return uint8(VERSION);\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /// @dev Runs on every transfer.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (!hasRole(TRANSFER_ROLE, address(0)) && from != address(0) && to != address(0)) {\\n            require(hasRole(TRANSFER_ROLE, from) || hasRole(TRANSFER_ROLE, to), \\\"transfers restricted.\\\");\\n        }\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._mint(account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mintTo(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"not minter.\\\");\\n        _mintTo(to, amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is signed by an account holding MINTER_ROLE (at the time of the function call).\\n    function verify(MintRequest calldata _req, bytes calldata _signature) public view returns (bool, address) {\\n        address signer = recoverAddress(_req, _signature);\\n        return (!minted[_req.uid] && hasRole(MINTER_ROLE, signer), signer);\\n    }\\n\\n    /// @dev Mints tokens according to the provided mint request.\\n    function mintWithSignature(MintRequest calldata _req, bytes calldata _signature) external payable nonReentrant {\\n        address signer = verifyRequest(_req, _signature);\\n        address receiver = _req.to;\\n\\n        collectPrice(_req);\\n\\n        _mintTo(receiver, _req.quantity);\\n\\n        emit TokensMintedWithSignature(signer, receiver, _req);\\n    }\\n\\n    /// @dev Lets a module admin set the default recipient of all primary sales.\\n    function setPrimarySaleRecipient(address _saleRecipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        primarySaleRecipient = _saleRecipient;\\n        emit PrimarySaleRecipientUpdated(_saleRecipient);\\n    }\\n\\n    /// @dev Lets a module admin update the fees on primary sales.\\n    function setPlatformFeeInfo(\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n\\n        platformFeeBps = uint64(_platformFeeBps);\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        emit PlatformFeeInfoUpdated(_platformFeeRecipient, _platformFeeBps);\\n    }\\n\\n    /// @dev Returns the platform fee bps and recipient.\\n    function getPlatformFeeInfo() external view returns (address, uint16) {\\n        return (platformFeeRecipient, uint16(platformFeeBps));\\n    }\\n\\n    /// @dev Collects and distributes the primary sale value of tokens being claimed.\\n    function collectPrice(MintRequest calldata _req) internal {\\n        if (_req.price == 0) {\\n            require(msg.value == 0, \\\"!Value\\\");\\n            return;\\n        }\\n\\n        uint256 platformFees = (_req.price * platformFeeBps) / MAX_BPS;\\n\\n        if (_req.currency == CurrencyTransferLib.NATIVE_TOKEN) {\\n            require(msg.value == _req.price, \\\"must send total price.\\\");\\n        } else {\\n            require(msg.value == 0, \\\"msg value not zero\\\");\\n        }\\n\\n        address saleRecipient = _req.primarySaleRecipient == address(0)\\n            ? primarySaleRecipient\\n            : _req.primarySaleRecipient;\\n\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), platformFeeRecipient, platformFees);\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), saleRecipient, _req.price - platformFees);\\n    }\\n\\n    /// @dev Mints `amount` of tokens to `to`\\n    function _mintTo(address _to, uint256 _amount) internal {\\n        _mint(_to, _amount);\\n        emit TokensMinted(_to, _amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is valid.\\n    function verifyRequest(MintRequest calldata _req, bytes calldata _signature) internal returns (address) {\\n        (bool success, address signer) = verify(_req, _signature);\\n        require(success, \\\"invalid signature\\\");\\n\\n        require(\\n            _req.validityStartTimestamp <= block.timestamp && _req.validityEndTimestamp >= block.timestamp,\\n            \\\"request expired\\\"\\n        );\\n        require(_req.to != address(0), \\\"recipient undefined\\\");\\n        require(_req.quantity > 0, \\\"zero quantity\\\");\\n\\n        minted[_req.uid] = true;\\n\\n        return signer;\\n    }\\n\\n    /// @dev Returns the address of the signer of the mint request.\\n    function recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\\n\\n    /// @dev Resolves 'stack too deep' error in `recoverAddress`.\\n    function _encodeRequest(MintRequest calldata _req) internal pure returns (bytes memory) {\\n        return\\n            abi.encode(\\n                TYPEHASH,\\n                _req.to,\\n                _req.primarySaleRecipient,\\n                _req.quantity,\\n                _req.price,\\n                _req.currency,\\n                _req.validityStartTimestamp,\\n                _req.validityEndTimestamp,\\n                _req.uid\\n            );\\n    }\\n\\n    /// @dev Sets contract URI for the storefront-level metadata of the contract.\\n    function setContractURI(string calldata _uri) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        contractURI = _uri;\\n    }\\n\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable, Multicall)\\n        returns (address sender)\\n    {\\n        return ERC2771ContextUpgradeable._msgSender();\\n    }\\n\\n    function _msgData()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (bytes calldata)\\n    {\\n        return ERC2771ContextUpgradeable._msgData();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/// @author thirdweb\\n\\n//   $$\\\\     $$\\\\       $$\\\\                 $$\\\\                         $$\\\\\\n//   $$ |    $$ |      \\\\__|                $$ |                        $$ |\\n// $$$$$$\\\\   $$$$$$$\\\\  $$\\\\  $$$$$$\\\\   $$$$$$$ |$$\\\\  $$\\\\  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\\\n// \\\\_$$  _|  $$  __$$\\\\ $$ |$$  __$$\\\\ $$  __$$ |$$ | $$ | $$ |$$  __$$\\\\ $$  __$$\\\\\\n//   $$ |    $$ |  $$ |$$ |$$ |  \\\\__|$$ /  $$ |$$ | $$ | $$ |$$$$$$$$ |$$ |  $$ |\\n//   $$ |$$\\\\ $$ |  $$ |$$ |$$ |      $$ |  $$ |$$ | $$ | $$ |$$   ____|$$ |  $$ |\\n//   \\\\$$$$  |$$ |  $$ |$$ |$$ |      \\\\$$$$$$$ |\\\\$$$$$\\\\$$$$  |\\\\$$$$$$$\\\\ $$$$$$$  |\\n//    \\\\____/ \\\\__|  \\\\__|\\\\__|\\\\__|       \\\\_______| \\\\_____\\\\____/  \\\\_______|\\\\_______/\\n\\n//Interface\\nimport { ITokenERC20 } from \\\"../interface/token/ITokenERC20.sol\\\";\\n\\nimport \\\"../../infra/interface/IThirdwebContract.sol\\\";\\nimport \\\"../../extension/interface/IPlatformFee.sol\\\";\\nimport \\\"../../extension/interface/IPrimarySale.sol\\\";\\n\\n// Token\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\\\";\\n\\n// Security\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n// Signature utils\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\\\";\\n\\n// Meta transactions\\nimport \\\"../../external-deps/openzeppelin/metatx/ERC2771ContextUpgradeable.sol\\\";\\n\\n// Utils\\nimport \\\"../../extension/Multicall.sol\\\";\\nimport \\\"../../lib/CurrencyTransferLib.sol\\\";\\nimport \\\"../../lib/FeeType.sol\\\";\\n\\ncontract TokenERC20 is\\n    Initializable,\\n    IThirdwebContract,\\n    IPrimarySale,\\n    IPlatformFee,\\n    ReentrancyGuardUpgradeable,\\n    ERC2771ContextUpgradeable,\\n    Multicall,\\n    ERC20BurnableUpgradeable,\\n    ERC20VotesUpgradeable,\\n    ITokenERC20,\\n    AccessControlEnumerableUpgradeable\\n{\\n    using ECDSAUpgradeable for bytes32;\\n\\n    bytes32 private constant MODULE_TYPE = bytes32(\\\"TokenERC20\\\");\\n    uint256 private constant VERSION = 1;\\n\\n    bytes32 private constant TYPEHASH =\\n        keccak256(\\n            \\\"MintRequest(address to,address primarySaleRecipient,uint256 quantity,uint256 price,address currency,uint128 validityStartTimestamp,uint128 validityEndTimestamp,bytes32 uid)\\\"\\n        );\\n\\n    bytes32 internal constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 internal constant TRANSFER_ROLE = keccak256(\\\"TRANSFER_ROLE\\\");\\n\\n    /// @dev Returns the URI for the storefront-level metadata of the contract.\\n    string public contractURI;\\n\\n    /// @dev Max bps in the thirdweb system\\n    uint128 internal constant MAX_BPS = 10_000;\\n\\n    /// @dev The % of primary sales collected by the contract as fees.\\n    uint128 private platformFeeBps;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address internal platformFeeRecipient;\\n\\n    /// @dev The adress that receives all primary sales value.\\n    address public primarySaleRecipient;\\n\\n    /// @dev Mapping from mint request UID => whether the mint request is processed.\\n    mapping(bytes32 => bool) private minted;\\n\\n    constructor() initializer {}\\n\\n    /// @dev Initializes the contract, like a constructor.\\n    function initialize(\\n        address _defaultAdmin,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        address[] memory _trustedForwarders,\\n        address _primarySaleRecipient,\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external initializer {\\n        __ReentrancyGuard_init();\\n        __ERC2771Context_init_unchained(_trustedForwarders);\\n        __ERC20Permit_init(_name);\\n        __ERC20_init_unchained(_name, _symbol);\\n\\n        contractURI = _contractURI;\\n        primarySaleRecipient = _primarySaleRecipient;\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n        platformFeeBps = uint128(_platformFeeBps);\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, _defaultAdmin);\\n        _setupRole(MINTER_ROLE, _defaultAdmin);\\n        _setupRole(TRANSFER_ROLE, address(0));\\n    }\\n\\n    /// @dev Returns the module type of the contract.\\n    function contractType() external pure virtual returns (bytes32) {\\n        return MODULE_TYPE;\\n    }\\n\\n    /// @dev Returns the version of the contract.\\n    function contractVersion() external pure virtual returns (uint8) {\\n        return uint8(VERSION);\\n    }\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /// @dev Runs on every transfer.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (!hasRole(TRANSFER_ROLE, address(0)) && from != address(0) && to != address(0)) {\\n            require(hasRole(TRANSFER_ROLE, from) || hasRole(TRANSFER_ROLE, to), \\\"transfers restricted.\\\");\\n        }\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._mint(account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20VotesUpgradeable) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mintTo(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"not minter.\\\");\\n        _mintTo(to, amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is signed by an account holding MINTER_ROLE (at the time of the function call).\\n    function verify(MintRequest calldata _req, bytes calldata _signature) public view returns (bool, address) {\\n        address signer = recoverAddress(_req, _signature);\\n        return (!minted[_req.uid] && hasRole(MINTER_ROLE, signer), signer);\\n    }\\n\\n    /// @dev Mints tokens according to the provided mint request.\\n    function mintWithSignature(MintRequest calldata _req, bytes calldata _signature) external payable nonReentrant {\\n        address signer = verifyRequest(_req, _signature);\\n        address receiver = _req.to;\\n\\n        collectPrice(_req);\\n\\n        _mintTo(receiver, _req.quantity);\\n\\n        emit TokensMintedWithSignature(signer, receiver, _req);\\n    }\\n\\n    /// @dev Lets a module admin set the default recipient of all primary sales.\\n    function setPrimarySaleRecipient(address _saleRecipient) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        primarySaleRecipient = _saleRecipient;\\n        emit PrimarySaleRecipientUpdated(_saleRecipient);\\n    }\\n\\n    /// @dev Lets a module admin update the fees on primary sales.\\n    function setPlatformFeeInfo(\\n        address _platformFeeRecipient,\\n        uint256 _platformFeeBps\\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        require(_platformFeeBps <= MAX_BPS, \\\"exceeds MAX_BPS\\\");\\n\\n        platformFeeBps = uint64(_platformFeeBps);\\n        platformFeeRecipient = _platformFeeRecipient;\\n\\n        emit PlatformFeeInfoUpdated(_platformFeeRecipient, _platformFeeBps);\\n    }\\n\\n    /// @dev Returns the platform fee bps and recipient.\\n    function getPlatformFeeInfo() external view returns (address, uint16) {\\n        return (platformFeeRecipient, uint16(platformFeeBps));\\n    }\\n\\n    /// @dev Collects and distributes the primary sale value of tokens being claimed.\\n    function collectPrice(MintRequest calldata _req) internal {\\n        if (_req.price == 0) {\\n            require(msg.value == 0, \\\"!Value\\\");\\n            return;\\n        }\\n\\n        uint256 platformFees = (_req.price * platformFeeBps) / MAX_BPS;\\n\\n        if (_req.currency == CurrencyTransferLib.NATIVE_TOKEN) {\\n            require(msg.value == _req.price, \\\"must send total price.\\\");\\n        } else {\\n            require(msg.value == 0, \\\"msg value not zero\\\");\\n        }\\n\\n        address saleRecipient = _req.primarySaleRecipient == address(0)\\n            ? primarySaleRecipient\\n            : _req.primarySaleRecipient;\\n\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), platformFeeRecipient, platformFees);\\n        CurrencyTransferLib.transferCurrency(_req.currency, _msgSender(), saleRecipient, _req.price - platformFees);\\n    }\\n\\n    /// @dev Mints `amount` of tokens to `to`\\n    function _mintTo(address _to, uint256 _amount) internal {\\n        _mint(_to, _amount);\\n        emit TokensMinted(_to, _amount);\\n    }\\n\\n    /// @dev Verifies that a mint request is valid.\\n    function verifyRequest(MintRequest calldata _req, bytes calldata _signature) internal returns (address) {\\n        (bool success, address signer) = verify(_req, _signature);\\n        require(success, \\\"invalid signature\\\");\\n\\n        require(\\n            _req.validityStartTimestamp <= block.timestamp && _req.validityEndTimestamp >= block.timestamp,\\n            \\\"request expired\\\"\\n        );\\n        require(_req.to != address(0), \\\"recipient undefined\\\");\\n        require(_req.quantity > 0, \\\"zero quantity\\\");\\n\\n        minted[_req.uid] = true;\\n\\n        return signer;\\n    }\\n\\n    /// @dev Returns the address of the signer of the mint request.\\n    function recoverAddress(MintRequest calldata _req, bytes calldata _signature) internal view returns (address) {\\n        return _hashTypedDataV4(keccak256(_encodeRequest(_req))).recover(_signature);\\n    }\\n\\n    /// @dev Resolves 'stack too deep' error in `recoverAddress`.\\n    function _encodeRequest(MintRequest calldata _req) internal pure returns (bytes memory) {\\n        return\\n            abi.encode(\\n                TYPEHASH,\\n                _req.to,\\n                _req.primarySaleRecipient,\\n                _req.quantity,\\n                _req.price,\\n                _req.currency,\\n                _req.validityStartTimestamp,\\n                _req.validityEndTimestamp,\\n                _req.uid\\n            );\\n    }\\n\\n    /// @dev Sets contract URI for the storefront-level metadata of the contract.\\n    function setContractURI(string calldata _uri) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        contractURI = _uri;\\n    }\\n\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable, Multicall)\\n        returns (address sender)\\n    {\\n        return ERC2771ContextUpgradeable._msgSender();\\n    }\\n\\n    function _msgData()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (bytes calldata)\\n    {\\n        return ERC2771ContextUpgradeable._msgData();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../interfaces/IERC5805Upgradeable.sol\\\";\\nimport \\\"../../../utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../../utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\\n *\\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\\n *\\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\\n *\\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\\n *\\n * _Available since v4.2._\\n */\\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable, IERC5805Upgradeable {\\n    function __ERC20Votes_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\\n    }\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint224 votes;\\n    }\\n\\n    bytes32 private constant _DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    mapping(address => address) private _delegates;\\n    mapping(address => Checkpoint[]) private _checkpoints;\\n    Checkpoint[] private _totalSupplyCheckpoints;\\n\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() public view virtual override returns (uint48) {\\n        return SafeCastUpgradeable.toUint48(block.number);\\n    }\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() public view virtual override returns (string memory) {\\n        // Check that the clock was not modified\\n        require(clock() == block.number, \\\"ERC20Votes: broken clock mode\\\");\\n        return \\\"mode=blocknumber&from=default\\\";\\n    }\\n\\n    /**\\n     * @dev Get the `pos`-th checkpoint for `account`.\\n     */\\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\\n        return _checkpoints[account][pos];\\n    }\\n\\n    /**\\n     * @dev Get number of checkpoints for `account`.\\n     */\\n    function numCheckpoints(address account) public view virtual returns (uint32) {\\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\\n    }\\n\\n    /**\\n     * @dev Get the address `account` is currently delegating to.\\n     */\\n    function delegates(address account) public view virtual override returns (address) {\\n        return _delegates[account];\\n    }\\n\\n    /**\\n     * @dev Gets the current votes balance for `account`\\n     */\\n    function getVotes(address account) public view virtual override returns (uint256) {\\n        uint256 pos = _checkpoints[account].length;\\n        unchecked {\\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_checkpoints[account], timepoint);\\n    }\\n\\n    /**\\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\\n     * It is NOT the sum of all the delegated votes!\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\\n    }\\n\\n    /**\\n     * @dev Lookup a value in a list of (sorted) checkpoints.\\n     */\\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\\n        //\\n        // Initially we check if the block is recent to narrow the search range.\\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\\n        // the same.\\n        uint256 length = ckpts.length;\\n\\n        uint256 low = 0;\\n        uint256 high = length;\\n\\n        if (length > 5) {\\n            uint256 mid = length - MathUpgradeable.sqrt(length);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        unchecked {\\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegate votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) public virtual override {\\n        _delegate(_msgSender(), delegatee);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= expiry, \\\"ERC20Votes: signature expired\\\");\\n        address signer = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == _useNonce(signer), \\\"ERC20Votes: invalid nonce\\\");\\n        _delegate(signer, delegatee);\\n    }\\n\\n    /**\\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\\n     */\\n    function _maxSupply() internal view virtual returns (uint224) {\\n        return type(uint224).max;\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been increased.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual override {\\n        super._mint(account, amount);\\n        require(totalSupply() <= _maxSupply(), \\\"ERC20Votes: total supply risks overflowing votes\\\");\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been decreased.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual override {\\n        super._burn(account, amount);\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\\n    }\\n\\n    /**\\n     * @dev Move voting power when tokens are transferred.\\n     *\\n     * Emits a {IVotes-DelegateVotesChanged} event.\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._afterTokenTransfer(from, to, amount);\\n\\n        _moveVotingPower(delegates(from), delegates(to), amount);\\n    }\\n\\n    /**\\n     * @dev Change delegation for `delegator` to `delegatee`.\\n     *\\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\\n     */\\n    function _delegate(address delegator, address delegatee) internal virtual {\\n        address currentDelegate = delegates(delegator);\\n        uint256 delegatorBalance = balanceOf(delegator);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\\n        if (src != dst && amount > 0) {\\n            if (src != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\\n            }\\n\\n            if (dst != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        Checkpoint[] storage ckpts,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\\n        uint256 pos = ckpts.length;\\n\\n        unchecked {\\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\\n\\n            oldWeight = oldCkpt.votes;\\n            newWeight = op(oldWeight, delta);\\n\\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);\\n            } else {\\n                ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(clock()), votes: SafeCastUpgradeable.toUint224(newWeight)}));\\n            }\\n        }\\n    }\\n\\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, ckpts.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../interfaces/IERC5805Upgradeable.sol\\\";\\nimport \\\"../../../utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../../utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\\n *\\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\\n *\\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\\n *\\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\\n *\\n * _Available since v4.2._\\n */\\nabstract contract ERC20VotesUpgradeable is Initializable, ERC20PermitUpgradeable, IERC5805Upgradeable {\\n    function __ERC20Votes_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\\n    }\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint224 votes;\\n    }\\n\\n    bytes32 private constant _DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    mapping(address => address) private _delegates;\\n    mapping(address => Checkpoint[]) private _checkpoints;\\n    Checkpoint[] private _totalSupplyCheckpoints;\\n\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() public view virtual override returns (uint48) {\\n        return SafeCastUpgradeable.toUint48(block.number);\\n    }\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() public view virtual override returns (string memory) {\\n        // Check that the clock was not modified\\n        require(clock() == block.number, \\\"ERC20Votes: broken clock mode\\\");\\n        return \\\"mode=blocknumber&from=default\\\";\\n    }\\n\\n    /**\\n     * @dev Get the `pos`-th checkpoint for `account`.\\n     */\\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\\n        return _checkpoints[account][pos];\\n    }\\n\\n    /**\\n     * @dev Get number of checkpoints for `account`.\\n     */\\n    function numCheckpoints(address account) public view virtual returns (uint32) {\\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\\n    }\\n\\n    /**\\n     * @dev Get the address `account` is currently delegating to.\\n     */\\n    function delegates(address account) public view virtual override returns (address) {\\n        return _delegates[account];\\n    }\\n\\n    /**\\n     * @dev Gets the current votes balance for `account`\\n     */\\n    function getVotes(address account) public view virtual override returns (uint256) {\\n        uint256 pos = _checkpoints[account].length;\\n        unchecked {\\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_checkpoints[account], timepoint);\\n    }\\n\\n    /**\\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\\n     * It is NOT the sum of all the delegated votes!\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\\n    }\\n\\n    /**\\n     * @dev Lookup a value in a list of (sorted) checkpoints.\\n     */\\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\\n        //\\n        // Initially we check if the block is recent to narrow the search range.\\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\\n        // the same.\\n        uint256 length = ckpts.length;\\n\\n        uint256 low = 0;\\n        uint256 high = length;\\n\\n        if (length > 5) {\\n            uint256 mid = length - MathUpgradeable.sqrt(length);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        unchecked {\\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegate votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) public virtual override {\\n        _delegate(_msgSender(), delegatee);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= expiry, \\\"ERC20Votes: signature expired\\\");\\n        address signer = ECDSAUpgradeable.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == _useNonce(signer), \\\"ERC20Votes: invalid nonce\\\");\\n        _delegate(signer, delegatee);\\n    }\\n\\n    /**\\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\\n     */\\n    function _maxSupply() internal view virtual returns (uint224) {\\n        return type(uint224).max;\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been increased.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual override {\\n        super._mint(account, amount);\\n        require(totalSupply() <= _maxSupply(), \\\"ERC20Votes: total supply risks overflowing votes\\\");\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been decreased.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual override {\\n        super._burn(account, amount);\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\\n    }\\n\\n    /**\\n     * @dev Move voting power when tokens are transferred.\\n     *\\n     * Emits a {IVotes-DelegateVotesChanged} event.\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._afterTokenTransfer(from, to, amount);\\n\\n        _moveVotingPower(delegates(from), delegates(to), amount);\\n    }\\n\\n    /**\\n     * @dev Change delegation for `delegator` to `delegatee`.\\n     *\\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\\n     */\\n    function _delegate(address delegator, address delegatee) internal virtual {\\n        address currentDelegate = delegates(delegator);\\n        uint256 delegatorBalance = balanceOf(delegator);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\\n        if (src != dst && amount > 0) {\\n            if (src != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\\n            }\\n\\n            if (dst != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        Checkpoint[] storage ckpts,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\\n        uint256 pos = ckpts.length;\\n\\n        unchecked {\\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\\n\\n            oldWeight = oldCkpt.votes;\\n            newWeight = op(oldWeight, delta);\\n\\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCastUpgradeable.toUint224(newWeight);\\n            } else {\\n                ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(clock()), votes: SafeCastUpgradeable.toUint224(newWeight)}));\\n            }\\n        }\\n    }\\n\\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, ckpts.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}