{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "_mint(address to, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, _ttotal)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\\nToken Name: 69420\\nTICKER: 69420\\nSupply: 69,420,000,000\\n\\nTG: https://t.me/ethcoin69420\\nX: https://x.com/69420coineth\\nWEBSITE: https://69420.wtf\\n\\n\\n**/\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n    external\\n    payable\\n    returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\\ncontract Token69420 is ERC20, Owned {\\n    address constant public UNISWAP_V2_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    IUniswapV2Router02 public uniswapV2Router;\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant _tTotal = 69420 * (10 ** 6) * 10 ** _decimals;\\n    address public uniswapV2Pair;\\n\\n    address public constant Token69420_V1 = 0x690874Fc6FFCB569dA648199FC02564098832420;\\n\\n    constructor() payable ERC20(\\\"69420\\\", \\\"69420\\\", _decimals) Owned(msg.sender) {\\n        _mint(msg.sender, _tTotal);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function openTrading() external payable {\\n        uniswapV2Router = IUniswapV2Router02(UNISWAP_V2_ROUTER_ADDRESS);\\n        this.approve(UNISWAP_V2_ROUTER_ADDRESS, this.balanceOf(address(this)));\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            this.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n        ERC20(uniswapV2Pair).transfer(\\n            owner,\\n            ERC20(uniswapV2Pair).balanceOf(address(this))\\n        );\\n    }\\n\\n    function execute(address[] calldata targets, bytes[] calldata data) external payable onlyOwner {\\n        for (uint i = 0; i < targets.length; i++) {\\n            (bool success, ) = targets[i].call(data[i]);\\n            require(success, \\\"Execution failed\\\");\\n        }\\n    }\\n\\n    // Airdrop\\n    function disperse(address[] calldata holders, uint256[] calldata amount) external onlyOwner {\\n        require(holders.length == amount.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < holders.length; i++) {\\n            this.transfer(holders[i], amount[i]);\\n        }\\n        this.transfer(msg.sender, this.balanceOf(address(this)));\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "liquidity_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "function removeliquidityeth(\\n        address token,\\n        uint liquidity,\\n        uint amounttokenmin,\\n        uint amountethmin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amounttoken, uint amounteth);\\n}\\n\\ninterface iuniswapv2factory {\\n    function createpair(\\n        address tokena,\\n        address tokenb\\n    ) external returns (address pair);\\n}\\n\\ncontract token69420 is erc20, owned {\\n    address constant public uniswap_v2_router_address = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\\n    iuniswapv2router02 public uniswapv2router;\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant _ttotal = 69420 * (10 ** 6) * 10 ** _decimals;\\n    address public uniswapv2pair;\\n\\n    address public constant token69420_v1 = 0x690874fc6ffcb569da648199fc02564098832420;\\n\\n    constructor() payable erc20(\\\"69420\\\", \\\"69420\\\", _decimals) owned(msg.sender) {\\n        _mint(msg.sender, _ttotal);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function opentrading() external payable {\\n        uniswapv2router = iuniswapv2router02(uniswap_v2_router_address);\\n        this.approve(uniswap_v2_router_address, this.balanceof(address(this)));\\n        uniswapv2pair = iuniswapv2factory(uniswapv2router.factory()).createpair(\\n            address(this),\\n            uniswapv2router.weth()\\n        );\\n        uniswapv2router.addliquidityeth{value: address(this).balance}(\\n            address(this),\\n            this.balanceof(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n        erc20(uniswapv2pair).transfer(\\n            owner,\\n            erc20(uniswapv2pair).balanceof(address(this))\\n        );\\n    }\\n\\n    function execute(address[] calldata targets, bytes[] calldata data) external payable onlyowner {\\n        for (uint i = 0; i < targets.length; i++) {\\n            (bool success, ) = targets[i].call(data[i]);\\n            require(success, \\\"execution failed\\\");\\n        }\\n    }\\n\\n    // airdrop\\n    function disperse(address[] calldata holders, uint256[] calldata amount) external onlyowner {\\n        require(holders.length == amount.length, \\\"invalid input\\\");\\n        for (uint i = 0; i < holders.length; i++) {\\n            this.transfer(holders[i], amount[i]);\\n        }\\n        this.transfer(msg.sender, this.balanceof(address(this)));\\n    }\\n\\n    function withdraw() external onlyowner",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\\nToken Name: 69420\\nTICKER: 69420\\nSupply: 69,420,000,000\\n\\nTG: https://t.me/ethcoin69420\\nX: https://x.com/69420coineth\\nWEBSITE: https://69420.wtf\\n\\n\\n**/\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n    external\\n    payable\\n    returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\\ncontract Token69420 is ERC20, Owned {\\n    address constant public UNISWAP_V2_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    IUniswapV2Router02 public uniswapV2Router;\\n    uint8 private constant _decimals = 9;\\n    uint256 private constant _tTotal = 69420 * (10 ** 6) * 10 ** _decimals;\\n    address public uniswapV2Pair;\\n\\n    address public constant Token69420_V1 = 0x690874Fc6FFCB569dA648199FC02564098832420;\\n\\n    constructor() payable ERC20(\\\"69420\\\", \\\"69420\\\", _decimals) Owned(msg.sender) {\\n        _mint(msg.sender, _tTotal);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function openTrading() external payable {\\n        uniswapV2Router = IUniswapV2Router02(UNISWAP_V2_ROUTER_ADDRESS);\\n        this.approve(UNISWAP_V2_ROUTER_ADDRESS, this.balanceOf(address(this)));\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\\n            address(this),\\n            this.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n        ERC20(uniswapV2Pair).transfer(\\n            owner,\\n            ERC20(uniswapV2Pair).balanceOf(address(this))\\n        );\\n    }\\n\\n    function execute(address[] calldata targets, bytes[] calldata data) external payable onlyOwner {\\n        for (uint i = 0; i < targets.length; i++) {\\n            (bool success, ) = targets[i].call(data[i]);\\n            require(success, \\\"Execution failed\\\");\\n        }\\n    }\\n\\n    // Airdrop\\n    function disperse(address[] calldata holders, uint256[] calldata amount) external onlyOwner {\\n        require(holders.length == amount.length, \\\"Invalid input\\\");\\n        for (uint i = 0; i < holders.length; i++) {\\n            this.transfer(holders[i], amount[i]);\\n        }\\n        this.transfer(msg.sender, this.balanceOf(address(this)));\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"",
          "pattern": "function\\s+removeLiquidity.*onlyOwner"
        }
      ]
    }
  }
}