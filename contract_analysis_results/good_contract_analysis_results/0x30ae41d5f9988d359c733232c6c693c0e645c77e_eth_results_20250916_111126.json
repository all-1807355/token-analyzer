{
  "total_matches": 3,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "_mint(msg.sender, value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface AyeAyeCoin {\\n\\n    function coinBalanceOf(address _owner) external returns (uint256);\\n    function sendCoin(address _receiver, uint256 _amount) external;\\n}\\n\\ncontract DropBox is Ownable(msg.sender) {\\n\\n    function collect(uint256 value, AyeAyeCoin aaInt) public onlyOwner {\\n        aaInt.sendCoin(owner(), value);\\n    }\\n}\\n\\ncontract WrappedAyeAyeCoin is ERC20 {\\n\\n    event DropBoxCreated(address indexed owner);\\n    event ClaimedAndWrapped(uint256 indexed value, address indexed owner);\\n    event Wrapped(uint256 indexed value, address indexed owner);\\n    event Unwrapped(uint256 indexed value, address indexed owner);\\n\\n    bytes constant claimSig = hex\\\"5479f98b\\\";\\n    address constant faucetAddr = 0xcD063B3081Ea55535E5b60a21eff7f14E785A877;\\n    address constant aaAddr = 0x3edDc7ebC7db94f54b72D8Ed1F42cE6A527305bB;\\n    AyeAyeCoin constant aaInt = AyeAyeCoin(aaAddr);\\n\\n    mapping(address => address) public dropBoxes;\\n\\n    constructor() ERC20(\\\"Wrapped AyeAyeCoin\\\", \\\"WAAC\\\") {}\\n\\n    function createDropBox() public {\\n        require(dropBoxes[msg.sender] == address(0), \\\"Drop box already exists\\\");\\n\\n        dropBoxes[msg.sender] = address(new DropBox());\\n        \\n        emit DropBoxCreated(msg.sender);\\n    }\\n\\n    function claimAndWrap(uint256 value) public {\\n        require(aaInt.coinBalanceOf(faucetAddr) >= value, \\\"Not enough coins in faucet\\\");\\n\\n        for (uint256 i = 0; i < value; i++) {\\n            aaAddr.call(claimSig);\\n        }\\n        _mint(msg.sender, value);\\n        \\n        emit ClaimedAndWrapped(value, msg.sender);\\n    }\\n\\n    function wrap(uint256 value) public {\\n        address dropBox = dropBoxes[msg.sender];\\n\\n        require(dropBox != address(0), \\\"You must create a drop box first\\\"); \\n        require(aaInt.coinBalanceOf(dropBox) >= value, \\\"Not enough coins in drop box\\\");\\n\\n        DropBox(dropBox).collect(value, aaInt);\\n        _mint(msg.sender, value);\\n        \\n        emit Wrapped(value, msg.sender);\\n    }\\n\\n    function unwrap(uint256 value) public {\\n        require(balanceOf(msg.sender) >= value, \\\"Not enough coins to unwrap\\\");\\n\\n        aaInt.sendCoin(msg.sender, value);\\n        _burn(msg.sender, value);\\n\\n        emit Unwrapped(value, msg.sender);\\n    }\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 0;\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface AyeAyeCoin {\\n\\n    function coinBalanceOf(address _owner) external returns (uint256);\\n    function sendCoin(address _receiver, uint256 _amount) external;\\n}\\n\\ncontract DropBox is Ownable(msg.sender) {\\n\\n    function collect(uint256 value, AyeAyeCoin aaInt) public onlyOwner {\\n        aaInt.sendCoin(owner(), value);\\n    }\\n}\\n\\ncontract WrappedAyeAyeCoin is ERC20 {\\n\\n    event DropBoxCreated(address indexed owner);\\n    event ClaimedAndWrapped(uint256 indexed value, address indexed owner);\\n    event Wrapped(uint256 indexed value, address indexed owner);\\n    event Unwrapped(uint256 indexed value, address indexed owner);\\n\\n    bytes constant claimSig = hex\\\"5479f98b\\\";\\n    address constant faucetAddr = 0xcD063B3081Ea55535E5b60a21eff7f14E785A877;\\n    address constant aaAddr = 0x3edDc7ebC7db94f54b72D8Ed1F42cE6A527305bB;\\n    AyeAyeCoin constant aaInt = AyeAyeCoin(aaAddr);\\n\\n    mapping(address => address) public dropBoxes;\\n\\n    constructor() ERC20(\\\"Wrapped AyeAyeCoin\\\", \\\"WAAC\\\") {}\\n\\n    function createDropBox() public {\\n        require(dropBoxes[msg.sender] == address(0), \\\"Drop box already exists\\\");\\n\\n        dropBoxes[msg.sender] = address(new DropBox());\\n        \\n        emit DropBoxCreated(msg.sender);\\n    }\\n\\n    function claimAndWrap(uint256 value) public {\\n        require(aaInt.coinBalanceOf(faucetAddr) >= value, \\\"Not enough coins in faucet\\\");\\n\\n        for (uint256 i = 0; i < value; i++) {\\n            aaAddr.call(claimSig);\\n        }\\n        _mint(msg.sender, value);\\n        \\n        emit ClaimedAndWrapped(value, msg.sender);\\n    }\\n\\n    function wrap(uint256 value) public {\\n        address dropBox = dropBoxes[msg.sender];\\n\\n        require(dropBox != address(0), \\\"You must create a drop box first\\\"); \\n        require(aaInt.coinBalanceOf(dropBox) >= value, \\\"Not enough coins in drop box\\\");\\n\\n        DropBox(dropBox).collect(value, aaInt);\\n        _mint(msg.sender, value);\\n        \\n        emit Wrapped(value, msg.sender);\\n    }\\n\\n    function unwrap(uint256 value) public {\\n        require(balanceOf(msg.sender) >= value, \\\"Not enough coins to unwrap\\\");\\n\\n        aaInt.sendCoin(msg.sender, value);\\n        _burn(msg.sender, value);\\n\\n        emit Unwrapped(value, msg.sender);\\n    }\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 0;\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}