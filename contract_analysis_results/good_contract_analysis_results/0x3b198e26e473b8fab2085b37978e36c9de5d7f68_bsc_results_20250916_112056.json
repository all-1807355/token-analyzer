{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "function mint (",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./interfaces/IERC677.sol\\\";\\nimport \\\"./interfaces/IERC677Receiver.sol\\\";\\nimport \\\"./Validators.sol\\\";\\n\\ncontract TimeToken is ERC20, IERC677, Validators {\\n\\n    event Minted(address indexed _from, uint256 indexed _fromChainId, uint256 indexed _lockId, uint256 _amount);\\n    event Burned(address indexed _from, uint256 indexed _toChainId, uint256 indexed _burnId, uint256 _amount);\\n\\n    uint256 public lastBurnId;\\n    mapping(uint256 =>  mapping(uint256 => bool)) public lockIdsUsed;\\n\\n    constructor(\\n        string memory tokenName,\\n        string memory tokenSymbol\\n    ) ERC20(tokenName, tokenSymbol) {}\\n\\n    function mint (uint256 _fromChainId, uint256 _lockId, uint256 _amount, bytes[] memory _signatures) external {\\n        require(!lockIdsUsed[_fromChainId][_lockId], \\\"Lock id already used\\\");\\n        bytes32 messageHash = keccak256(abi.encodePacked(_msgSender(), _fromChainId, block.chainid, _lockId, _amount));\\n        require(checkSignatures(messageHash, _signatures), \\\"Incorrect signature(s)\\\");\\n        lockIdsUsed[_fromChainId][_lockId] = true;\\n        _mint(_msgSender(), _amount);\\n        emit Minted(_msgSender(), _fromChainId, _lockId, _amount);\\n    }\\n\\n    function burn (uint256 _toChainId, uint256 _amount) external {\\n        require(_amount > 0, \\\"The amount of the lock must not be zero\\\");\\n        (bool found,) = indexOfChainId(_toChainId);\\n        require(found, \\\"ChainId not allowed\\\");\\n        _burn(_msgSender(), _amount);\\n        lastBurnId++;\\n        emit Burned(_msgSender(), _toChainId, lastBurnId, _amount);\\n    }\\n\\n    function transferAndCall(address _to, uint _value, bytes memory _data) public override returns (bool success)\\n    {\\n        transfer(_to, _value);\\n        emit Transfer(_msgSender(), _to, _value, _data);\\n        if (isContract(_to)) {\\n            contractFallback(_to, _value, _data);\\n        }\\n        return true;\\n    }\\n\\n    function contractFallback(address _to, uint _value, bytes memory _data) private\\n    {\\n        IERC677Receiver receiver = IERC677Receiver(_to);\\n        receiver.onTokenTransfer(_msgSender(), _value, _data);\\n    }\\n\\n    function isContract(address _addr) private view returns (bool hasCode)\\n    {\\n        uint length;\\n        assembly { length := extcodesize(_addr) }\\n        return length > 0;\\n    }\\n\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(_msgsender()",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./interfaces/IERC677.sol\\\";\\nimport \\\"./interfaces/IERC677Receiver.sol\\\";\\nimport \\\"./Validators.sol\\\";\\n\\ncontract TimeToken is ERC20, IERC677, Validators {\\n\\n    event Minted(address indexed _from, uint256 indexed _fromChainId, uint256 indexed _lockId, uint256 _amount);\\n    event Burned(address indexed _from, uint256 indexed _toChainId, uint256 indexed _burnId, uint256 _amount);\\n\\n    uint256 public lastBurnId;\\n    mapping(uint256 =>  mapping(uint256 => bool)) public lockIdsUsed;\\n\\n    constructor(\\n        string memory tokenName,\\n        string memory tokenSymbol\\n    ) ERC20(tokenName, tokenSymbol) {}\\n\\n    function mint (uint256 _fromChainId, uint256 _lockId, uint256 _amount, bytes[] memory _signatures) external {\\n        require(!lockIdsUsed[_fromChainId][_lockId], \\\"Lock id already used\\\");\\n        bytes32 messageHash = keccak256(abi.encodePacked(_msgSender(), _fromChainId, block.chainid, _lockId, _amount));\\n        require(checkSignatures(messageHash, _signatures), \\\"Incorrect signature(s)\\\");\\n        lockIdsUsed[_fromChainId][_lockId] = true;\\n        _mint(_msgSender(), _amount);\\n        emit Minted(_msgSender(), _fromChainId, _lockId, _amount);\\n    }\\n\\n    function burn (uint256 _toChainId, uint256 _amount) external {\\n        require(_amount > 0, \\\"The amount of the lock must not be zero\\\");\\n        (bool found,) = indexOfChainId(_toChainId);\\n        require(found, \\\"ChainId not allowed\\\");\\n        _burn(_msgSender(), _amount);\\n        lastBurnId++;\\n        emit Burned(_msgSender(), _toChainId, lastBurnId, _amount);\\n    }\\n\\n    function transferAndCall(address _to, uint _value, bytes memory _data) public override returns (bool success)\\n    {\\n        transfer(_to, _value);\\n        emit Transfer(_msgSender(), _to, _value, _data);\\n        if (isContract(_to)) {\\n            contractFallback(_to, _value, _data);\\n        }\\n        return true;\\n    }\\n\\n    function contractFallback(address _to, uint _value, bytes memory _data) private\\n    {\\n        IERC677Receiver receiver = IERC677Receiver(_to);\\n        receiver.onTokenTransfer(_msgSender(), _value, _data);\\n    }\\n\\n    function isContract(address _addr) private view returns (bool hasCode)\\n    {\\n        uint length;\\n        assembly { length := extcodesize(_addr) }\\n        return length > 0;\\n    }\\n\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}