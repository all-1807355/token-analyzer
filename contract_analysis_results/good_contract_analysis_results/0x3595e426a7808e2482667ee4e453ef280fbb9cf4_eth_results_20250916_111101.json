{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n *  ____  _______  _______           _     \\n * |  _ \\\\| ____\\\\ \\\\/ /_   _|__   ___ | |___ \\n * | | | |  _|  \\\\  /  | |/ _ \\\\ / _ \\\\| / __|\\n * | |_| | |___ /  \\\\  | | (_) | (_) | \\\\__ \\\\\\n * |____/|_____/_/\\\\_\\\\ |_|\\\\___/ \\\\___/|_|___/\\n *\\n * This smart contract was created effortlessly using the DEXTools Token Creator.\\n * \\n * ? Website: https://www.dextools.io/\\n * ? Twitter: https://twitter.com/DEXToolsApp\\n * ? Telegram: https://t.me/DEXToolsCommunity\\n * \\n * ? Unleash the power of decentralized finances and tokenization with DEXTools Token Creator. Customize your token seamlessly. Manage your created tokens conveniently from your user panel - start creating your dream token today!\\n */\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { IUniswapV2Router02 } from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport { IUniswapV2Factory } from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\n\\nenum TokenType {\\n    Standard,\\n    Liquidity,\\n    LiquidityFee,\\n    LiquidityBuySellFee,\\n    Burn,\\n    Baby,\\n    StandardAntiBot,\\n    LiquidityAntiBot,\\n    LiquidityFeeAntiBot,\\n    LiquidityBuySellFeeAntiBot,\\n    BurnAntiBot,\\n    BabyAntiBot\\n}\\n\\ncontract LiquidityBuySellFeeToken is IERC20, Initializable, OwnableUpgradeable {\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant VERSION = 1;\\n    uint256 public constant MAX_FEE = 10 ** 4 / 5;\\n\\n    mapping(address => uint256) private _rOwned;\\n    mapping(address => uint256) private _tOwned;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    mapping(address => bool) private _isExcluded;\\n    address[] private _excluded;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private _tTotal;\\n    uint256 private _rTotal;\\n    uint256 private _tFeeTotal;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    // Transfer Fee\\n    uint256 public _taxFee;\\n    uint256 private _previousTaxFee;\\n\\n    uint256 public _liquidityFee;\\n    uint256 private _previousLiquidityFee;\\n\\n    uint256 public _marketingFee;\\n    uint256 private _previousMarketingFee;\\n\\n    // Sell Fee\\n    uint256 private _sellTaxFee;\\n    uint256 private _sellLiquidityFee;\\n    uint256 private _sellMarketingFee;\\n\\n    // Buy Fee\\n    uint256 private _buyTaxFee;\\n    uint256 private _buyLiquidityFee;\\n    uint256 private _buyMarketingFee;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public uniswapV2Pair;\\n    address public _marketingAddress;\\n    address public _marketingToken;\\n\\n    bool private inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled;\\n\\n    uint256 private numTokensSellToAddToLiquidity;\\n\\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\\n    event SwapAndLiquifyAmountUpdated(uint256 amount);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    function initialize(\\n        address owner_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        address[3] memory addrs, // router, marketing wallet, marketing token\\n        uint16[3] memory feeSettings, // tax, liquidity, marketing\\n        uint16[3] memory buyFeeSettings, // buyTax, buyLiquidity, buyMarketing\\n        uint16[3] memory sellFeeSettings // sellTax, sellLiquidity, sellMarketing\\n    ) public initializer {\\n        // Set fees\\n        _taxFee = feeSettings[0];\\n        _previousTaxFee = _taxFee;\\n\\n        _liquidityFee = feeSettings[1];\\n        _previousLiquidityFee = _liquidityFee;\\n\\n        _marketingFee = feeSettings[2];\\n        _previousMarketingFee = _marketingFee;\\n        require(\\n            _taxFee + _liquidityFee + _marketingFee <= MAX_FEE,\\n            \\\"fee is over 20%\\\"\\n        );\\n        require(addrs[1] != address(0), \\\"marketing wallet is zero\\\");\\n        _marketingAddress = addrs[1];\\n        _marketingToken = addrs[2];\\n\\n        // Set buy fees\\n        _buyTaxFee = buyFeeSettings[0];\\n        _buyLiquidityFee = buyFeeSettings[1];\\n        _buyMarketingFee = buyFeeSettings[2];\\n        require(\\n            _buyTaxFee + _buyLiquidityFee + _buyMarketingFee <= MAX_FEE,\\n            \\\"buy fee is over 20%\\\"\\n        );\\n\\n        // Set sell fees\\n        _sellTaxFee = sellFeeSettings[0];\\n        _sellLiquidityFee = sellFeeSettings[1];\\n        _sellMarketingFee = sellFeeSettings[2];\\n        require(\\n            _sellTaxFee + _sellLiquidityFee + _sellMarketingFee <= MAX_FEE,\\n            \\\"sell fee is over 20%\\\"\\n        );\\n\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 9;\\n\\n        _tTotal = totalSupply_;\\n        _rTotal = (MAX - (MAX % _tTotal));\\n\\n        numTokensSellToAddToLiquidity = totalSupply_ / (10 ** 3); // 0.1%\\n        swapAndLiquifyEnabled = true;\\n\\n        // Set the owner to the factory initializer caller\\n        __Ownable_init();\\n        transferOwnership(owner_);\\n\\n        _rOwned[owner()] = _rTotal;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addrs[0]);\\n        // Create a uniswap pair for this new token\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        // set the rest of the contract variables\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        emit Transfer(address(0), owner(), _tTotal);\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()] - amount\\n        );\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] - subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n\\n    function totalFees() public view returns (uint256) {\\n        return _tFeeTotal;\\n    }\\n\\n    function deliver(uint256 tAmount) public {\\n        address sender = _msgSender();\\n        require(\\n            !_isExcluded[sender],\\n            \\\"Excluded addresses cannot call this function\\\"\\n        );\\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rTotal = _rTotal - rAmount;\\n        _tFeeTotal = _tFeeTotal + tAmount;\\n    }\\n\\n    function reflectionFromToken(\\n        uint256 tAmount,\\n        bool deductTransferFee\\n    ) public view returns (uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , , , ) = _getValues(tAmount);\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(\\n        uint256 rAmount\\n    ) public view returns (uint256) {\\n        require(\\n            rAmount <= _rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n/*\\n    function excludeFromReward(address account) public onlyOwner {\\n        require(_excluded.length <= 1000, \\\"Cannot exclude more accounts\\\");\\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        if (_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner {\\n        require(_isExcluded[account], \\\"Account is already included\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _tOwned[account] = 0;\\n                _isExcluded[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n*/\\n\\n    function _transferBothExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n/**\\n    function updateFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _taxFee = taxFeeBps;\\n        _liquidityFee = liquidityFeeBps;\\n        _marketingFee = marketingFeeBps;\\n        require(\\n            _taxFee + _liquidityFee + _marketingFee <= MAX_FEE,\\n            \\\"fee is over 20%\\\"\\n        );\\n    }\\n\\n    function updateBuyFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _buyTaxFee = taxFeeBps;\\n        _buyLiquidityFee = liquidityFeeBps;\\n        _buyMarketingFee = marketingFeeBps;\\n        require(\\n            _buyTaxFee + _buyLiquidityFee + _buyMarketingFee <= MAX_FEE,\\n            \\\"buy fee is over 20%\\\"\\n        );\\n    }\\n\\n    function updateSellFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _sellTaxFee = taxFeeBps;\\n        _sellLiquidityFee = liquidityFeeBps;\\n        _sellMarketingFee = marketingFeeBps;\\n        require(\\n            _sellTaxFee + _sellLiquidityFee + _sellMarketingFee <= MAX_FEE,\\n            \\\"sell fee is over 20%\\\"\\n        );\\n    }\\n*/\\n\\n    function setSwapBackSettings(uint256 _amount) external onlyOwner {\\n        require(\\n            _amount >= (totalSupply() * 5) / (10 ** 4),\\n            \\\"Swapback amount should be at least 0.05% of total supply\\\"\\n        );\\n        require(\\n            _amount < (totalSupply() * 5) / 100,\\n            \\\"Swapback amount should be less than 5% of the total supply\\\"\\n        );\\n        numTokensSellToAddToLiquidity = _amount;\\n        emit SwapAndLiquifyAmountUpdated(_amount);\\n    }\\n\\n    //to recieve ETH from uniswapV2Router when swaping\\n    receive() external payable {}\\n\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _rTotal = _rTotal - rFee;\\n        _tFeeTotal = _tFeeTotal + tFee;\\n    }\\n\\n    function _getValues(\\n        uint256 tAmount\\n    )\\n        private\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\\n    {\\n        (\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getTValues(tAmount);\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\n            tAmount,\\n            tFee,\\n            tLiquidity,\\n            tMarketing,\\n            _getRate()\\n        );\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            rFee,\\n            tTransferAmount,\\n            tFee,\\n            tLiquidity,\\n            tMarketing\\n        );\\n    }\\n\\n    function _getTValues(\\n        uint256 tAmount\\n    ) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = calculateTaxFee(tAmount);\\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\\n        uint256 tMarketing = calculateMarketingFee(tAmount);\\n        uint256 tTransferAmount = ((tAmount - tFee) - tLiquidity) - tMarketing;\\n        return (tTransferAmount, tFee, tLiquidity, tMarketing);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 tLiquidity,\\n        uint256 tMarketing,\\n        uint256 currentRate\\n    ) private pure returns (uint256, uint256, uint256) {\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        uint256 rMarketing = tMarketing * currentRate;\\n        uint256 rTransferAmount = ((rAmount - rFee) - rLiquidity) - rMarketing;\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (\\n                _rOwned[_excluded[i]] > rSupply ||\\n                _tOwned[_excluded[i]] > tSupply\\n            ) return (_rTotal, _tTotal);\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\n        }\\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function _takeLiquidity(uint256 tLiquidity) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;\\n        if (_isExcluded[address(this)])\\n            _tOwned[address(this)] = _tOwned[address(this)] + tLiquidity;\\n    }\\n\\n    function _takeMarketingFee(uint256 tMarketing) private {\\n        address receiver = _marketingAddress;\\n\\n        if (_marketingToken != address(0)) receiver = address(this);\\n\\n        if (tMarketing > 0) {\\n            uint256 currentRate = _getRate();\\n            uint256 rMarketing = tMarketing * currentRate;\\n            _rOwned[receiver] = _rOwned[receiver] + rMarketing;\\n            if (_isExcluded[receiver])\\n                _tOwned[receiver] = _tOwned[receiver] + tMarketing;\\n            emit Transfer(_msgSender(), receiver, tMarketing);\\n        }\\n    }\\n\\n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\\n        return (_amount * _taxFee) / (10 ** 4);\\n    }\\n\\n    function calculateLiquidityFee(\\n        uint256 _amount\\n    ) private view returns (uint256) {\\n        return (_amount * _liquidityFee) / (10 ** 4);\\n    }\\n\\n    function calculateMarketingFee(\\n        uint256 _amount\\n    ) private view returns (uint256) {\\n        if (_marketingAddress == address(0)) return 0;\\n        return (_amount * _marketingFee) / (10 ** 4);\\n    }\\n\\n    function removeAllFee() private {\\n        _previousTaxFee = _taxFee;\\n        _previousLiquidityFee = _liquidityFee;\\n        _previousMarketingFee = _marketingFee;\\n\\n        _taxFee = 0;\\n        _liquidityFee = 0;\\n        _marketingFee = 0;\\n    }\\n\\n    function restoreAllFee() private {\\n        _taxFee = _previousTaxFee;\\n        _liquidityFee = _previousLiquidityFee;\\n        _marketingFee = _previousMarketingFee;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"approve from the zero address\\\");\\n        require(spender != address(0), \\\"approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"transfer from the zero address\\\");\\n        require(to != address(0), \\\"transfer to the zero address\\\");\\n        require(amount > 0, \\\"transfer amount is zero\\\");\\n\\n        // is the token balance of this contract address over the min number of\\n        // tokens that we need to initiate a swap + liquidity lock?\\n        // also, don't get caught in a circular liquidity event.\\n        // also, don't swap & liquify if sender is uniswap pair.\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool overMinTokenBalance = contractTokenBalance >=\\n            numTokensSellToAddToLiquidity;\\n\\n        if (\\n            overMinTokenBalance &&\\n            !inSwapAndLiquify &&\\n            from != uniswapV2Pair &&\\n            from != address(uniswapV2Router) &&\\n            swapAndLiquifyEnabled\\n        ) {\\n            inSwapAndLiquify = true;\\n\\n            uint256 _totalFees = _liquidityFee +\\n                _sellLiquidityFee +\\n                _buyLiquidityFee +\\n                _marketingFee +\\n                _sellMarketingFee +\\n                _buyMarketingFee;\\n\\n            contractTokenBalance = numTokensSellToAddToLiquidity;\\n\\n            if (\\n                _marketingFee > 0 ||\\n                _sellMarketingFee > 0 ||\\n                _buyMarketingFee > 0\\n            ) {\\n                uint256 marketingTokens = (contractTokenBalance *\\n                    (_marketingFee + _sellMarketingFee + _buyMarketingFee)) /\\n                    _totalFees;\\n                sendMarketingFee(_marketingToken, marketingTokens);\\n            }\\n\\n            if (\\n                _liquidityFee > 0 ||\\n                _sellLiquidityFee > 0 ||\\n                _buyLiquidityFee > 0\\n            ) {\\n                uint256 swapTokens = (contractTokenBalance *\\n                    (_liquidityFee + _sellLiquidityFee + _buyLiquidityFee)) /\\n                    _totalFees;\\n                swapAndLiquify(swapTokens);\\n            }\\n\\n            inSwapAndLiquify = false;\\n        }\\n\\n        //indicates if fee should be deducted from transfer\\n        bool takeFee = !inSwapAndLiquify;\\n\\n        //don't take fee on liquidity removals\\n        if (from == uniswapV2Pair && to == address(uniswapV2Router))\\n            takeFee = false;\\n\\n        //if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (owner() == from || owner() == to || _marketingAddress == from || _marketingAddress == to || address(this) == from || address(this) == to) {\\n            takeFee = false;\\n        }\\n\\n        //indicates if buy or sell fee is applied from transfer\\n        bool isBuySellFee = false;\\n\\n        if (takeFee) {\\n            _previousTaxFee = _taxFee;\\n            _previousLiquidityFee = _liquidityFee;\\n            _previousMarketingFee = _marketingFee;\\n            // on sell\\n            if (uniswapV2Pair == to) {\\n                _taxFee = _sellTaxFee;\\n                _liquidityFee = _sellLiquidityFee;\\n                _marketingFee = _sellMarketingFee;\\n                isBuySellFee = true;\\n            }\\n            // on buy\\n            else if (uniswapV2Pair == from) {\\n                _taxFee = _buyTaxFee;\\n                _liquidityFee = _buyLiquidityFee;\\n                _marketingFee = _buyMarketingFee;\\n                isBuySellFee = true;\\n            }\\n        }\\n\\n        //transfer amount, it will take tax, burn, liquidity fee\\n        _tokenTransfer(from, to, amount, takeFee);\\n\\n        // if buy or sell fee is setted restore to normal fees\\n        if (isBuySellFee) restoreAllFee();\\n    }\\n\\n    function swapAndLiquify(uint256 contractTokenBalance) private {\\n        // split the contract balance into halves\\n        uint256 half = contractTokenBalance / 2;\\n        uint256 otherHalf = contractTokenBalance - half;\\n\\n        // capture the contract's current ETH balance.\\n        // this is so that we can capture exactly the amount of ETH that the\\n        // swap creates, and not make the liquidity event include any ETH that\\n        // has been manually sent to the contract\\n        uint256 initialBalance = address(this).balance;\\n\\n        // swap tokens for ETH\\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\\n\\n        // how much ETH did we just swap into?\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        // add liquidity to uniswap\\n        addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapTokensForTokens(\\n        address tokenAddress,\\n        uint256 tokenAmount\\n    ) private {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        path[2] = tokenAddress;\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function sendMarketingFee(\\n        address tokenAddress,\\n        uint256 tokenAmount\\n    ) private {\\n        // Send native token\\n        if (tokenAddress == uniswapV2Router.WETH()) {\\n            uint256 initialBalance = address(this).balance;\\n\\n            swapTokensForEth(tokenAmount);\\n\\n            tokenAmount = address(this).balance - initialBalance;\\n\\n            payable(_marketingAddress).transfer(tokenAmount);\\n            // Send custom token\\n        } else if (tokenAddress != address(0)) {\\n            uint256 initialTokenBalance = IERC20(tokenAddress).balanceOf(\\n                address(this)\\n            );\\n\\n            swapTokensForTokens(tokenAddress, tokenAmount);\\n\\n            tokenAmount =\\n                (IERC20(tokenAddress).balanceOf(address(this))) -\\n                initialTokenBalance;\\n\\n            IERC20(tokenAddress).safeTransfer(_marketingAddress, tokenAmount);\\n            // Send this token\\n        } else {\\n            _transfer(address(this), _marketingAddress, tokenAmount);\\n        }\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // add the liquidity\\n        uniswapV2Router.addLiquidityETH{ value: ethAmount }(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(0xdead),\\n            block.timestamp\\n        );\\n    }\\n\\n    //this method is responsible for taking all fee, if takeFee is true\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        if (!takeFee) removeAllFee();\\n\\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferFromExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferToExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferStandard(sender, recipient, amount);\\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferBothExcluded(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n\\n        if (!takeFee) restoreAllFee();\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferToExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferFromExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "balance_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "_getcurrentsupply();\\n        return rsupply / tsupply;\\n    }\\n\\n    function _getcurrentsupply() private view returns (uint256, uint256) {\\n        uint256 rsupply = _rtotal;\\n        uint256 tsupply = _ttotal;\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (\\n                _rowned[_excluded[i]] > rsupply ||\\n                _towned[_excluded[i]] > tsupply\\n            ) return (_rtotal, _ttotal);\\n            rsupply = rsupply - _rowned[_excluded[i]];\\n            tsupply = tsupply - _towned[_excluded[i]];\\n        }\\n        if (rsupply < _rtotal / _ttotal) return (_rtotal",
          "function_context": "\"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n *  ____  _______  _______           _     \\n * |  _ \\\\| ____\\\\ \\\\/ /_   _|__   ___ | |___ \\n * | | | |  _|  \\\\  /  | |/ _ \\\\ / _ \\\\| / __|\\n * | |_| | |___ /  \\\\  | | (_) | (_) | \\\\__ \\\\\\n * |____/|_____/_/\\\\_\\\\ |_|\\\\___/ \\\\___/|_|___/\\n *\\n * This smart contract was created effortlessly using the DEXTools Token Creator.\\n * \\n * ? Website: https://www.dextools.io/\\n * ? Twitter: https://twitter.com/DEXToolsApp\\n * ? Telegram: https://t.me/DEXToolsCommunity\\n * \\n * ? Unleash the power of decentralized finances and tokenization with DEXTools Token Creator. Customize your token seamlessly. Manage your created tokens conveniently from your user panel - start creating your dream token today!\\n */\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { IUniswapV2Router02 } from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport { IUniswapV2Factory } from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\n\\nenum TokenType {\\n    Standard,\\n    Liquidity,\\n    LiquidityFee,\\n    LiquidityBuySellFee,\\n    Burn,\\n    Baby,\\n    StandardAntiBot,\\n    LiquidityAntiBot,\\n    LiquidityFeeAntiBot,\\n    LiquidityBuySellFeeAntiBot,\\n    BurnAntiBot,\\n    BabyAntiBot\\n}\\n\\ncontract LiquidityBuySellFeeToken is IERC20, Initializable, OwnableUpgradeable {\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant VERSION = 1;\\n    uint256 public constant MAX_FEE = 10 ** 4 / 5;\\n\\n    mapping(address => uint256) private _rOwned;\\n    mapping(address => uint256) private _tOwned;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    mapping(address => bool) private _isExcluded;\\n    address[] private _excluded;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private _tTotal;\\n    uint256 private _rTotal;\\n    uint256 private _tFeeTotal;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    // Transfer Fee\\n    uint256 public _taxFee;\\n    uint256 private _previousTaxFee;\\n\\n    uint256 public _liquidityFee;\\n    uint256 private _previousLiquidityFee;\\n\\n    uint256 public _marketingFee;\\n    uint256 private _previousMarketingFee;\\n\\n    // Sell Fee\\n    uint256 private _sellTaxFee;\\n    uint256 private _sellLiquidityFee;\\n    uint256 private _sellMarketingFee;\\n\\n    // Buy Fee\\n    uint256 private _buyTaxFee;\\n    uint256 private _buyLiquidityFee;\\n    uint256 private _buyMarketingFee;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public uniswapV2Pair;\\n    address public _marketingAddress;\\n    address public _marketingToken;\\n\\n    bool private inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled;\\n\\n    uint256 private numTokensSellToAddToLiquidity;\\n\\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\\n    event SwapAndLiquifyAmountUpdated(uint256 amount);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    function initialize(\\n        address owner_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_,\\n        address[3] memory addrs, // router, marketing wallet, marketing token\\n        uint16[3] memory feeSettings, // tax, liquidity, marketing\\n        uint16[3] memory buyFeeSettings, // buyTax, buyLiquidity, buyMarketing\\n        uint16[3] memory sellFeeSettings // sellTax, sellLiquidity, sellMarketing\\n    ) public initializer {\\n        // Set fees\\n        _taxFee = feeSettings[0];\\n        _previousTaxFee = _taxFee;\\n\\n        _liquidityFee = feeSettings[1];\\n        _previousLiquidityFee = _liquidityFee;\\n\\n        _marketingFee = feeSettings[2];\\n        _previousMarketingFee = _marketingFee;\\n        require(\\n            _taxFee + _liquidityFee + _marketingFee <= MAX_FEE,\\n            \\\"fee is over 20%\\\"\\n        );\\n        require(addrs[1] != address(0), \\\"marketing wallet is zero\\\");\\n        _marketingAddress = addrs[1];\\n        _marketingToken = addrs[2];\\n\\n        // Set buy fees\\n        _buyTaxFee = buyFeeSettings[0];\\n        _buyLiquidityFee = buyFeeSettings[1];\\n        _buyMarketingFee = buyFeeSettings[2];\\n        require(\\n            _buyTaxFee + _buyLiquidityFee + _buyMarketingFee <= MAX_FEE,\\n            \\\"buy fee is over 20%\\\"\\n        );\\n\\n        // Set sell fees\\n        _sellTaxFee = sellFeeSettings[0];\\n        _sellLiquidityFee = sellFeeSettings[1];\\n        _sellMarketingFee = sellFeeSettings[2];\\n        require(\\n            _sellTaxFee + _sellLiquidityFee + _sellMarketingFee <= MAX_FEE,\\n            \\\"sell fee is over 20%\\\"\\n        );\\n\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 9;\\n\\n        _tTotal = totalSupply_;\\n        _rTotal = (MAX - (MAX % _tTotal));\\n\\n        numTokensSellToAddToLiquidity = totalSupply_ / (10 ** 3); // 0.1%\\n        swapAndLiquifyEnabled = true;\\n\\n        // Set the owner to the factory initializer caller\\n        __Ownable_init();\\n        transferOwnership(owner_);\\n\\n        _rOwned[owner()] = _rTotal;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addrs[0]);\\n        // Create a uniswap pair for this new token\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        // set the rest of the contract variables\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        emit Transfer(address(0), owner(), _tTotal);\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()] - amount\\n        );\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) public virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] - subtractedValue\\n        );\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n\\n    function totalFees() public view returns (uint256) {\\n        return _tFeeTotal;\\n    }\\n\\n    function deliver(uint256 tAmount) public {\\n        address sender = _msgSender();\\n        require(\\n            !_isExcluded[sender],\\n            \\\"Excluded addresses cannot call this function\\\"\\n        );\\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rTotal = _rTotal - rAmount;\\n        _tFeeTotal = _tFeeTotal + tAmount;\\n    }\\n\\n    function reflectionFromToken(\\n        uint256 tAmount,\\n        bool deductTransferFee\\n    ) public view returns (uint256) {\\n        require(tAmount <= _tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , , , ) = _getValues(tAmount);\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(\\n        uint256 rAmount\\n    ) public view returns (uint256) {\\n        require(\\n            rAmount <= _rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n/*\\n    function excludeFromReward(address account) public onlyOwner {\\n        require(_excluded.length <= 1000, \\\"Cannot exclude more accounts\\\");\\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\n        if (_rOwned[account] > 0) {\\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\\n        }\\n        _isExcluded[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner {\\n        require(_isExcluded[account], \\\"Account is already included\\\");\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _tOwned[account] = 0;\\n                _isExcluded[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n*/\\n\\n    function _transferBothExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n/**\\n    function updateFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _taxFee = taxFeeBps;\\n        _liquidityFee = liquidityFeeBps;\\n        _marketingFee = marketingFeeBps;\\n        require(\\n            _taxFee + _liquidityFee + _marketingFee <= MAX_FEE,\\n            \\\"fee is over 20%\\\"\\n        );\\n    }\\n\\n    function updateBuyFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _buyTaxFee = taxFeeBps;\\n        _buyLiquidityFee = liquidityFeeBps;\\n        _buyMarketingFee = marketingFeeBps;\\n        require(\\n            _buyTaxFee + _buyLiquidityFee + _buyMarketingFee <= MAX_FEE,\\n            \\\"buy fee is over 20%\\\"\\n        );\\n    }\\n\\n    function updateSellFees(\\n        uint256 taxFeeBps,\\n        uint256 liquidityFeeBps,\\n        uint256 marketingFeeBps\\n    ) external onlyOwner {\\n        _sellTaxFee = taxFeeBps;\\n        _sellLiquidityFee = liquidityFeeBps;\\n        _sellMarketingFee = marketingFeeBps;\\n        require(\\n            _sellTaxFee + _sellLiquidityFee + _sellMarketingFee <= MAX_FEE,\\n            \\\"sell fee is over 20%\\\"\\n        );\\n    }\\n*/\\n\\n    function setSwapBackSettings(uint256 _amount) external onlyOwner {\\n        require(\\n            _amount >= (totalSupply() * 5) / (10 ** 4),\\n            \\\"Swapback amount should be at least 0.05% of total supply\\\"\\n        );\\n        require(\\n            _amount < (totalSupply() * 5) / 100,\\n            \\\"Swapback amount should be less than 5% of the total supply\\\"\\n        );\\n        numTokensSellToAddToLiquidity = _amount;\\n        emit SwapAndLiquifyAmountUpdated(_amount);\\n    }\\n\\n    //to recieve ETH from uniswapV2Router when swaping\\n    receive() external payable {}\\n\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _rTotal = _rTotal - rFee;\\n        _tFeeTotal = _tFeeTotal + tFee;\\n    }\\n\\n    function _getValues(\\n        uint256 tAmount\\n    )\\n        private\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\\n    {\\n        (\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getTValues(tAmount);\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\n            tAmount,\\n            tFee,\\n            tLiquidity,\\n            tMarketing,\\n            _getRate()\\n        );\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            rFee,\\n            tTransferAmount,\\n            tFee,\\n            tLiquidity,\\n            tMarketing\\n        );\\n    }\\n\\n    function _getTValues(\\n        uint256 tAmount\\n    ) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = calculateTaxFee(tAmount);\\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\\n        uint256 tMarketing = calculateMarketingFee(tAmount);\\n        uint256 tTransferAmount = ((tAmount - tFee) - tLiquidity) - tMarketing;\\n        return (tTransferAmount, tFee, tLiquidity, tMarketing);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 tLiquidity,\\n        uint256 tMarketing,\\n        uint256 currentRate\\n    ) private pure returns (uint256, uint256, uint256) {\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        uint256 rMarketing = tMarketing * currentRate;\\n        uint256 rTransferAmount = ((rAmount - rFee) - rLiquidity) - rMarketing;\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\n            if (\\n                _rOwned[_excluded[i]] > rSupply ||\\n                _tOwned[_excluded[i]] > tSupply\\n            ) return (_rTotal, _tTotal);\\n            rSupply = rSupply - _rOwned[_excluded[i]];\\n            tSupply = tSupply - _tOwned[_excluded[i]];\\n        }\\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function _takeLiquidity(uint256 tLiquidity) private {\\n        uint256 currentRate = _getRate();\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;\\n        if (_isExcluded[address(this)])\\n            _tOwned[address(this)] = _tOwned[address(this)] + tLiquidity;\\n    }\\n\\n    function _takeMarketingFee(uint256 tMarketing) private {\\n        address receiver = _marketingAddress;\\n\\n        if (_marketingToken != address(0)) receiver = address(this);\\n\\n        if (tMarketing > 0) {\\n            uint256 currentRate = _getRate();\\n            uint256 rMarketing = tMarketing * currentRate;\\n            _rOwned[receiver] = _rOwned[receiver] + rMarketing;\\n            if (_isExcluded[receiver])\\n                _tOwned[receiver] = _tOwned[receiver] + tMarketing;\\n            emit Transfer(_msgSender(), receiver, tMarketing);\\n        }\\n    }\\n\\n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\\n        return (_amount * _taxFee) / (10 ** 4);\\n    }\\n\\n    function calculateLiquidityFee(\\n        uint256 _amount\\n    ) private view returns (uint256) {\\n        return (_amount * _liquidityFee) / (10 ** 4);\\n    }\\n\\n    function calculateMarketingFee(\\n        uint256 _amount\\n    ) private view returns (uint256) {\\n        if (_marketingAddress == address(0)) return 0;\\n        return (_amount * _marketingFee) / (10 ** 4);\\n    }\\n\\n    function removeAllFee() private {\\n        _previousTaxFee = _taxFee;\\n        _previousLiquidityFee = _liquidityFee;\\n        _previousMarketingFee = _marketingFee;\\n\\n        _taxFee = 0;\\n        _liquidityFee = 0;\\n        _marketingFee = 0;\\n    }\\n\\n    function restoreAllFee() private {\\n        _taxFee = _previousTaxFee;\\n        _liquidityFee = _previousLiquidityFee;\\n        _marketingFee = _previousMarketingFee;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"approve from the zero address\\\");\\n        require(spender != address(0), \\\"approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"transfer from the zero address\\\");\\n        require(to != address(0), \\\"transfer to the zero address\\\");\\n        require(amount > 0, \\\"transfer amount is zero\\\");\\n\\n        // is the token balance of this contract address over the min number of\\n        // tokens that we need to initiate a swap + liquidity lock?\\n        // also, don't get caught in a circular liquidity event.\\n        // also, don't swap & liquify if sender is uniswap pair.\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool overMinTokenBalance = contractTokenBalance >=\\n            numTokensSellToAddToLiquidity;\\n\\n        if (\\n            overMinTokenBalance &&\\n            !inSwapAndLiquify &&\\n            from != uniswapV2Pair &&\\n            from != address(uniswapV2Router) &&\\n            swapAndLiquifyEnabled\\n        ) {\\n            inSwapAndLiquify = true;\\n\\n            uint256 _totalFees = _liquidityFee +\\n                _sellLiquidityFee +\\n                _buyLiquidityFee +\\n                _marketingFee +\\n                _sellMarketingFee +\\n                _buyMarketingFee;\\n\\n            contractTokenBalance = numTokensSellToAddToLiquidity;\\n\\n            if (\\n                _marketingFee > 0 ||\\n                _sellMarketingFee > 0 ||\\n                _buyMarketingFee > 0\\n            ) {\\n                uint256 marketingTokens = (contractTokenBalance *\\n                    (_marketingFee + _sellMarketingFee + _buyMarketingFee)) /\\n                    _totalFees;\\n                sendMarketingFee(_marketingToken, marketingTokens);\\n            }\\n\\n            if (\\n                _liquidityFee > 0 ||\\n                _sellLiquidityFee > 0 ||\\n                _buyLiquidityFee > 0\\n            ) {\\n                uint256 swapTokens = (contractTokenBalance *\\n                    (_liquidityFee + _sellLiquidityFee + _buyLiquidityFee)) /\\n                    _totalFees;\\n                swapAndLiquify(swapTokens);\\n            }\\n\\n            inSwapAndLiquify = false;\\n        }\\n\\n        //indicates if fee should be deducted from transfer\\n        bool takeFee = !inSwapAndLiquify;\\n\\n        //don't take fee on liquidity removals\\n        if (from == uniswapV2Pair && to == address(uniswapV2Router))\\n            takeFee = false;\\n\\n        //if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (owner() == from || owner() == to || _marketingAddress == from || _marketingAddress == to || address(this) == from || address(this) == to) {\\n            takeFee = false;\\n        }\\n\\n        //indicates if buy or sell fee is applied from transfer\\n        bool isBuySellFee = false;\\n\\n        if (takeFee) {\\n            _previousTaxFee = _taxFee;\\n            _previousLiquidityFee = _liquidityFee;\\n            _previousMarketingFee = _marketingFee;\\n            // on sell\\n            if (uniswapV2Pair == to) {\\n                _taxFee = _sellTaxFee;\\n                _liquidityFee = _sellLiquidityFee;\\n                _marketingFee = _sellMarketingFee;\\n                isBuySellFee = true;\\n            }\\n            // on buy\\n            else if (uniswapV2Pair == from) {\\n                _taxFee = _buyTaxFee;\\n                _liquidityFee = _buyLiquidityFee;\\n                _marketingFee = _buyMarketingFee;\\n                isBuySellFee = true;\\n            }\\n        }\\n\\n        //transfer amount, it will take tax, burn, liquidity fee\\n        _tokenTransfer(from, to, amount, takeFee);\\n\\n        // if buy or sell fee is setted restore to normal fees\\n        if (isBuySellFee) restoreAllFee();\\n    }\\n\\n    function swapAndLiquify(uint256 contractTokenBalance) private {\\n        // split the contract balance into halves\\n        uint256 half = contractTokenBalance / 2;\\n        uint256 otherHalf = contractTokenBalance - half;\\n\\n        // capture the contract's current ETH balance.\\n        // this is so that we can capture exactly the amount of ETH that the\\n        // swap creates, and not make the liquidity event include any ETH that\\n        // has been manually sent to the contract\\n        uint256 initialBalance = address(this).balance;\\n\\n        // swap tokens for ETH\\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\\n\\n        // how much ETH did we just swap into?\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        // add liquidity to uniswap\\n        addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function swapTokensForTokens(\\n        address tokenAddress,\\n        uint256 tokenAmount\\n    ) private {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        path[2] = tokenAddress;\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function sendMarketingFee(\\n        address tokenAddress,\\n        uint256 tokenAmount\\n    ) private {\\n        // Send native token\\n        if (tokenAddress == uniswapV2Router.WETH()) {\\n            uint256 initialBalance = address(this).balance;\\n\\n            swapTokensForEth(tokenAmount);\\n\\n            tokenAmount = address(this).balance - initialBalance;\\n\\n            payable(_marketingAddress).transfer(tokenAmount);\\n            // Send custom token\\n        } else if (tokenAddress != address(0)) {\\n            uint256 initialTokenBalance = IERC20(tokenAddress).balanceOf(\\n                address(this)\\n            );\\n\\n            swapTokensForTokens(tokenAddress, tokenAmount);\\n\\n            tokenAmount =\\n                (IERC20(tokenAddress).balanceOf(address(this))) -\\n                initialTokenBalance;\\n\\n            IERC20(tokenAddress).safeTransfer(_marketingAddress, tokenAmount);\\n            // Send this token\\n        } else {\\n            _transfer(address(this), _marketingAddress, tokenAmount);\\n        }\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // add the liquidity\\n        uniswapV2Router.addLiquidityETH{ value: ethAmount }(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            address(0xdead),\\n            block.timestamp\\n        );\\n    }\\n\\n    //this method is responsible for taking all fee, if takeFee is true\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        if (!takeFee) removeAllFee();\\n\\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferFromExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferToExcluded(sender, recipient, amount);\\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\\n            _transferStandard(sender, recipient, amount);\\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\\n            _transferBothExcluded(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n\\n        if (!takeFee) restoreAllFee();\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferToExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferFromExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tMarketing\\n        ) = _getValues(tAmount);\\n        _tOwned[sender] = _tOwned[sender] - tAmount;\\n        _rOwned[sender] = _rOwned[sender] - rAmount;\\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(tLiquidity);\\n        _takeMarketingFee(tMarketing);\\n        _reflectFee(rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n}\\n\"",
          "pattern": "_getCurrentSupply.*_rTotal"
        }
      ]
    }
  }
}