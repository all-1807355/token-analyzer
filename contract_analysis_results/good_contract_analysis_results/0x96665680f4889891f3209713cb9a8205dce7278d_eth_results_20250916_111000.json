{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2024-09-20\\r\\n */\\r\\n\\r\\n/**\\r\\n\\r\\n    \u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\\r\\n    \u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\r\\n    \u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u255a\u2588\u2588\u2588\u2554\u255d\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\r\\n    \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2554\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\r\\n    \u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\\r\\n    \u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\\r\\n\\r\\n    ?? ??-??????? ???????? ????? ???????? ??????? ???? ???? ?? ?? ??????? ??? ????? ????? \\r\\n    ???????? ????, ????? ?????? ??? ???????????????, ??? ???????? ???????? ??????? ??? \\r\\n    ?????? ??? ?????-???? ????? ?????????.\\r\\n\\r\\n    Home Page\\r\\n\\r\\n    https://nyxcipher.ai/\\r\\n\\r\\n    Web App\\r\\n\\r\\n    https://app.nyxcipher.ai/\\r\\n\\r\\n    Join our Telegram!\\r\\n\\r\\n    https://t.me/nyxcipherportal\\r\\n\\r\\n    Twitter\\r\\n\\r\\n    https://x.com/nyxcipherai\\r\\n\\r\\n\\r\\n*/\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IFactoryV2 {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address lpPair,\\r\\n        uint\\r\\n    );\\r\\n    function getPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external view returns (address lpPair);\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address lpPair);\\r\\n}\\r\\n\\r\\ninterface IV2Pair {\\r\\n    function factory() external view returns (address);\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\ninterface IRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(\\r\\n        uint amountOut,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IRouter02 is IRouter01 {\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface Initializer {\\r\\n    function setLaunch(\\r\\n        address _initialLpPair,\\r\\n        uint32 _liqAddBlock,\\r\\n        uint64 _liqAddStamp,\\r\\n        uint8 dec\\r\\n    ) external;\\r\\n    function getConfig() external returns (address, address);\\r\\n    function getInits(uint256 amount) external returns (uint256, uint256);\\r\\n    function setLpPair(address pair, bool enabled) external;\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NyxCipher is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    mapping(address => uint256) private _tOwned;\\r\\n    mapping(address => bool) lpPairs;\\r\\n    uint256 private timeSinceLastPair = 0;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    mapping(address => bool) private _liquidityHolders;\\r\\n    mapping(address => bool) private _isExcludedFromProtection;\\r\\n    mapping(address => bool) private _isExcludedFromFees;\\r\\n    uint256 private constant startingSupply = 100_000_000;\\r\\n    string private constant _name = \\\"NYX CIPHER\\\";\\r\\n    string private constant _symbol = \\\"$NXCP\\\";\\r\\n    uint8 private constant _decimals = 8;\\r\\n    uint256 private constant _tTotal = startingSupply * 10 ** _decimals;\\r\\n\\r\\n    // Add these as state variables\\r\\n    uint256 public constant initialTaxRate = 2500; // 25%\\r\\n    uint256 public constant finalTaxRate = 500;    // 5%\\r\\n    uint256 public constant taxReductionPerMinute = 500; // 5% reduction per minute\\r\\n    uint256 public constant maxReductionMinutes = 4;     // Tax reduces for 4 minutes (25% -> 5%)\\r\\n\\r\\n\\r\\n    struct Fees {\\r\\n        uint16 buyFee;\\r\\n        uint16 sellFee;\\r\\n        uint16 transferFee;\\r\\n    }\\r\\n\\r\\n    struct Ratios {\\r\\n        uint16 marketing;\\r\\n        uint16 development;\\r\\n        uint16 buyBackBurnLP;\\r\\n        uint16 totalSwap;\\r\\n    }\\r\\n    // Define the Lock struct to store the amount and release time of locked tokens\\r\\n    struct Lock {\\r\\n        uint256 totalAmount;  // Total tokens to be vested/locked\\r\\n        uint256 releaseTime;  // Time when initial lock period ends\\r\\n        uint256 vestingStart; // When vesting starts (after lock period)\\r\\n        uint256 vestingDuration;  // Total duration for linear vesting\\r\\n        uint256 claimed;  // Tokens that have been claimed already\\r\\n    }\\r\\n    // Set the vesting parameters\\r\\n    uint256 public constant TEAM_LOCK_PERIOD = 90 days;  // 3 months lock period\\r\\n    uint256 public constant TEAM_VESTING_DURATION = 720 days;  // 24 months for vesting\\r\\n\\r\\n\\r\\n    Fees public _taxRates = Fees({buyFee: 500, sellFee: 500, transferFee: 0});\\r\\n\\r\\n    Ratios public _ratios =\\r\\n        Ratios({\\r\\n            marketing: 2,\\r\\n            development: 2,\\r\\n            buyBackBurnLP: 1,\\r\\n            totalSwap: 5\\r\\n        });\\r\\n\\r\\n    uint256 public constant maxBuyTaxes = 1000;\\r\\n    uint256 public constant maxSellTaxes = 1000;\\r\\n    uint256 public constant maxTransferTaxes = 1000;\\r\\n    uint256 constant masterTaxDivisor = 10000;\\r\\n    // Mapping to keep track of locked tokens and their release times for each address\\r\\n    mapping(address => Lock) public lockedTokens;\\r\\n\\r\\n    bool public taxesAreLocked;\\r\\n    IRouter02 public dexRouter;\\r\\n    address public lpPair;\\r\\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    struct TaxWallets {\\r\\n        address payable marketing;\\r\\n        address payable development;\\r\\n        address payable buyBackBurnLP;\\r\\n    }\\r\\n\\r\\n    TaxWallets public _taxWallets =\\r\\n        TaxWallets({\\r\\n            marketing: payable(0x0000000000000000000000000000000000000000),\\r\\n            development: payable(0x0000000000000000000000000000000000000000),\\r\\n            buyBackBurnLP: payable(0x0000000000000000000000000000000000000000)\\r\\n        });\\r\\n\\r\\n    bool inSwap;\\r\\n    bool public contractSwapEnabled = false;\\r\\n    uint256 public swapThreshold = _tTotal / 10000;\\r\\n    uint256 public swapAmount =  _tTotal / 10000;\\r\\n    bool public piContractSwapsEnabled = false;\\r\\n    uint256 public piSwapPercent = 10;\\r\\n    bool public tradingEnabled = false;\\r\\n    bool public _hasLiqBeenAdded = false;\\r\\n    Initializer initializer;\\r\\n    uint256 public launchStamp;\\r\\n\\r\\n    uint256 public maxTransferAmount; // Maximum transfer amount (1% of total supply)\\r\\n    uint256 public maxWalletAmount;   // Maximum wallet amount (1% of total supply)\\r\\n\\r\\n\\r\\n    event ContractSwapEnabledUpdated(bool enabled);\\r\\n    event AutoLiquify(uint256 amountCurrency, uint256 amountTokens);\\r\\n\\r\\n    modifier inSwapFlag() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address payable marketingWallet,\\r\\n        address payable developmentWallet,\\r\\n        address payable buyBackBurnLPWallet,\\r\\n        address payable teamFoundationWallet\\r\\n    ) payable {\\r\\n        // Set the owner.\\r\\n        _owner = msg.sender;\\r\\n\\r\\n        _tOwned[_owner] = _tTotal;\\r\\n        emit Transfer(address(0), _owner, _tTotal);\\r\\n\\r\\n        // Exclude certain addresses from fees\\r\\n        _isExcludedFromFees[_owner] = true;\\r\\n        _isExcludedFromFees[address(this)] = true;\\r\\n        _isExcludedFromFees[DEAD] = true;\\r\\n        _liquidityHolders[_owner] = true;\\r\\n\\r\\n        _isExcludedFromFees[0x407993575c91ce7643a4d4cCACc9A98c36eE1BBE] = true; // PinkLock\\r\\n        _isExcludedFromFees[0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214] = true; // Unicrypt (ETH)\\r\\n        _isExcludedFromFees[0xDba68f07d1b7Ca219f78ae8582C213d975c25cAf] = true; // Unicrypt (ETH)\\r\\n\\r\\n        // Set the tax wallets\\r\\n        _taxWallets = TaxWallets({\\r\\n            marketing: marketingWallet,\\r\\n            development: developmentWallet,\\r\\n            buyBackBurnLP: buyBackBurnLPWallet\\r\\n        });\\r\\n\\r\\n        // Distribute initial supply to designated wallets\\r\\n        uint256 marketingTokens = (_tTotal * 10) / 100;\\r\\n        uint256 developmentTokens = (_tTotal * 5) / 100;\\r\\n        uint256 teamFoundationTokens = (_tTotal * 15) / 100;\\r\\n\\r\\n        _tOwned[marketingWallet] = marketingTokens;\\r\\n        _tOwned[developmentWallet] = developmentTokens;\\r\\n        _tOwned[teamFoundationWallet] = teamFoundationTokens;\\r\\n\\r\\n        // Set up the teamFoundationWallet's lock and vesting\\r\\n        lockedTokens[teamFoundationWallet] = Lock({\\r\\n            totalAmount: (_tTotal * 15) / 100,  // 15% of total supply\\r\\n            releaseTime: block.timestamp + TEAM_LOCK_PERIOD,  // Lock for 3 months\\r\\n            vestingStart: block.timestamp + TEAM_LOCK_PERIOD,  // Vesting starts after 3 months\\r\\n            vestingDuration: TEAM_VESTING_DURATION,  // Linear vesting over 24 months\\r\\n            claimed: 0  // No tokens claimed initially\\r\\n        });\\r\\n        \\r\\n        // Initialize max transfer and holding limits as 1% of total supply\\r\\n        maxTransferAmount = _tTotal / 100; // 1% of total supply\\r\\n        maxWalletAmount = _tTotal / 100;   // 1% of total supply\\r\\n\\r\\n        // Adjust owner's balance\\r\\n        _tOwned[_owner] = _tTotal - (marketingTokens + developmentTokens + teamFoundationTokens);\\r\\n        emit Transfer(_owner, marketingWallet, marketingTokens);\\r\\n        emit Transfer(_owner, developmentWallet, developmentTokens);\\r\\n        emit Transfer(_owner, teamFoundationWallet, teamFoundationTokens);\\r\\n    }\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    // Ownable removed as a lib and added here to allow for custom transfers and renouncements.\\r\\n    // This allows for removal of ownership privileges from the owner once renounced or transferred.\\r\\n\\r\\n    address private _owner;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Caller =/= owner.\\\");\\r\\n        _;\\r\\n    }\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    function transferOwner(address newOwner) external onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Call renounceOwnership to transfer owner to the zero address.\\\"\\r\\n        );\\r\\n        require(\\r\\n            newOwner != DEAD,\\r\\n            \\\"Call renounceOwnership to transfer owner to the zero address.\\\"\\r\\n        );\\r\\n        setExcludedFromFees(_owner, false);\\r\\n        setExcludedFromFees(newOwner, true);\\r\\n\\r\\n        if (balanceOf(_owner) > 0) {\\r\\n            finalizeTransfer(\\r\\n                _owner,\\r\\n                newOwner,\\r\\n                balanceOf(_owner),\\r\\n                false,\\r\\n                false,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external onlyOwner {\\r\\n        require(\\r\\n            tradingEnabled,\\r\\n            \\\"Cannot renounce until trading has been enabled.\\\"\\r\\n        );\\r\\n        setExcludedFromFees(_owner, false);\\r\\n        address oldOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        emit OwnershipTransferred(oldOwner, address(0));\\r\\n    }\\r\\n\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n\\r\\n    receive() external payable {}\\r\\n    function totalSupply() external pure override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    function allowance(\\r\\n        address holder,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _tOwned[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address sender,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(sender != address(0), \\\"ERC20: Zero Address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: Zero Address\\\");\\r\\n\\r\\n        _allowances[sender][spender] = amount;\\r\\n        emit Approval(sender, spender, amount);\\r\\n    }\\r\\n\\r\\n    function approveContractContingency() external onlyOwner returns (bool) {\\r\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\r\\n            _allowances[sender][msg.sender] -= _allowances[sender][msg.sender].sub(amount);\\r\\n        }\\r\\n\\r\\n        return _transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function setNewRouter(address newRouter) external onlyOwner {\\r\\n        require(!_hasLiqBeenAdded, \\\"Cannot change after liquidity.\\\");\\r\\n        IRouter02 _newRouter = IRouter02(newRouter);\\r\\n        address get_pair = IFactoryV2(_newRouter.factory()).getPair(\\r\\n            address(this),\\r\\n            _newRouter.WETH()\\r\\n        );\\r\\n        lpPairs[lpPair] = false;\\r\\n        if (get_pair == address(0)) {\\r\\n            lpPair = IFactoryV2(_newRouter.factory()).createPair(\\r\\n                address(this),\\r\\n                _newRouter.WETH()\\r\\n            );\\r\\n        } else {\\r\\n            lpPair = get_pair;\\r\\n        }\\r\\n        dexRouter = _newRouter;\\r\\n        lpPairs[lpPair] = true;\\r\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function setLpPair(address pair, bool enabled) external onlyOwner {\\r\\n        if (!enabled) {\\r\\n            lpPairs[pair] = false;\\r\\n            initializer.setLpPair(pair, false);\\r\\n        } else {\\r\\n            if (timeSinceLastPair != 0) {\\r\\n                require(\\r\\n                    block.timestamp - timeSinceLastPair > 3 days,\\r\\n                    \\\"3 Day cooldown.\\\"\\r\\n                );\\r\\n            }\\r\\n            require(!lpPairs[pair], \\\"Pair already added to list.\\\");\\r\\n            lpPairs[pair] = true;\\r\\n            timeSinceLastPair = block.timestamp;\\r\\n            initializer.setLpPair(pair, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setInitializer(address init) public onlyOwner {\\r\\n        require(!tradingEnabled);\\r\\n        require(init != address(this), \\\"Can't be self.\\\");\\r\\n        initializer = Initializer(init);\\r\\n        try initializer.getConfig() returns (\\r\\n            address router,\\r\\n            address constructorLP\\r\\n        ) {\\r\\n            dexRouter = IRouter02(router);\\r\\n            lpPair = constructorLP;\\r\\n            lpPairs[lpPair] = true;\\r\\n            _approve(_owner, address(dexRouter), type(uint256).max);\\r\\n            _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n        } catch {\\r\\n            revert();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isExcludedFromFees(address account) external view returns (bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n\\r\\n    function setExcludedFromFees(\\r\\n        address account,\\r\\n        bool enabled\\r\\n    ) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = enabled;\\r\\n    }\\r\\n\\r\\n    function isExcludedFromProtection(\\r\\n        address account\\r\\n    ) external view returns (bool) {\\r\\n        return _isExcludedFromProtection[account];\\r\\n    }\\r\\n\\r\\n    function setExcludedFromProtection(\\r\\n        address account,\\r\\n        bool enabled\\r\\n    ) external onlyOwner {\\r\\n        _isExcludedFromProtection[account] = enabled;\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return (_tTotal - (balanceOf(DEAD) + balanceOf(address(0))));\\r\\n    }\\r\\n\\r\\n    function lockTaxes() external onlyOwner {\\r\\n        // This will lock taxes at their current value forever, do not call this unless you're sure.\\r\\n        taxesAreLocked = true;\\r\\n    }\\r\\n\\r\\n    function setTaxes(\\r\\n        uint16 buyFee,\\r\\n        uint16 sellFee,\\r\\n        uint16 transferFee\\r\\n    ) external onlyOwner {\\r\\n        require(!taxesAreLocked, \\\"Taxes are locked.\\\");\\r\\n        require(\\r\\n            buyFee <= maxBuyTaxes &&\\r\\n                sellFee <= maxSellTaxes &&\\r\\n                transferFee <= maxTransferTaxes,\\r\\n            \\\"Cannot exceed maximums.\\\"\\r\\n        );\\r\\n        _taxRates.buyFee = buyFee;\\r\\n        _taxRates.sellFee = sellFee;\\r\\n        _taxRates.transferFee = transferFee;\\r\\n    }\\r\\n\\r\\n    function setRatios(\\r\\n        uint16 marketing,\\r\\n        uint16 development,\\r\\n        uint16 buyBackBurnLP\\r\\n    ) external onlyOwner {\\r\\n        _ratios.marketing = marketing;\\r\\n        _ratios.development = development;\\r\\n        _ratios.buyBackBurnLP = buyBackBurnLP;\\r\\n        _ratios.totalSwap = marketing + development + buyBackBurnLP;\\r\\n        uint256 total = _taxRates.buyFee + _taxRates.sellFee;\\r\\n        require(\\r\\n            _ratios.totalSwap <= total,\\r\\n            \\\"Cannot exceed sum of buy and sell fees.\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setWallets(\\r\\n        address payable marketing,\\r\\n        address payable development,\\r\\n        address payable buyBackBurnLP\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            marketing != address(0) &&\\r\\n                development != address(0) &&\\r\\n                buyBackBurnLP != address(0),\\r\\n            \\\"Cannot be zero address.\\\"\\r\\n        );\\r\\n        _taxWallets.marketing = payable(marketing);\\r\\n        _taxWallets.development = payable(development);\\r\\n        _taxWallets.buyBackBurnLP = payable(buyBackBurnLP);\\r\\n    }\\r\\n\\r\\n    function getTokenAmountAtPriceImpact(\\r\\n        uint256 priceImpactInHundreds\\r\\n    ) external view returns (uint256) {\\r\\n        return ((balanceOf(lpPair) * priceImpactInHundreds) / masterTaxDivisor);\\r\\n    }\\r\\n\\r\\n    function setSwapSettings(\\r\\n        uint256 thresholdPercent,\\r\\n        uint256 thresholdDivisor,\\r\\n        uint256 amountPercent,\\r\\n        uint256 amountDivisor\\r\\n    ) external onlyOwner {\\r\\n        swapThreshold = (_tTotal * thresholdPercent) / thresholdDivisor;\\r\\n        swapAmount = (_tTotal * amountPercent) / amountDivisor;\\r\\n        require(\\r\\n            swapThreshold <= swapAmount,\\r\\n            \\\"Threshold cannot be above amount.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapAmount <= (balanceOf(lpPair) * 150) / masterTaxDivisor,\\r\\n            \\\"Cannot be above 1.5% of current PI.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapAmount >= _tTotal / 1_000_000,\\r\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapThreshold >= _tTotal / 1_000_000,\\r\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setPriceImpactSwapAmount(\\r\\n        uint256 priceImpactSwapPercent\\r\\n    ) external onlyOwner {\\r\\n        require(priceImpactSwapPercent <= 150, \\\"Cannot set above 1.5%.\\\");\\r\\n        piSwapPercent = priceImpactSwapPercent;\\r\\n    }\\r\\n\\r\\n    function setContractSwapEnabled(\\r\\n        bool swapEnabled,\\r\\n        bool priceImpactSwapEnabled\\r\\n    ) external onlyOwner {\\r\\n        contractSwapEnabled = swapEnabled;\\r\\n        piContractSwapsEnabled = priceImpactSwapEnabled;\\r\\n        emit ContractSwapEnabledUpdated(swapEnabled);\\r\\n    }\\r\\n\\r\\n    function _hasLimits(address from, address to) internal view returns (bool) {\\r\\n        return\\r\\n            from != _owner &&\\r\\n            to != _owner &&\\r\\n            tx.origin != _owner &&\\r\\n            !_liquidityHolders[to] &&\\r\\n            !_liquidityHolders[from] &&\\r\\n            to != DEAD &&\\r\\n            to != address(0) &&\\r\\n            from != address(this) &&\\r\\n            from != address(initializer) &&\\r\\n            to != address(initializer);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n        // Check if the wallet is excluded from max transfer and max wallet restrictions\\r\\n        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\r\\n            // Enforce the maximum transfer amount (only if not excluded)\\r\\n            require(amount <= maxTransferAmount, \\\"Transfer amount exceeds the 1% limit\\\");\\r\\n\\r\\n            // Check if the recipient's balance would exceed the max wallet limit (only if not excluded)\\r\\n            uint256 recipientBalanceAfterTransfer = _tOwned[to] + amount;\\r\\n            require(recipientBalanceAfterTransfer <= maxWalletAmount, \\\"Recipient exceeds maximum wallet balance limit\\\");\\r\\n        }\\r\\n        \\r\\n        bool buy = false;\\r\\n        bool sell = false;\\r\\n        bool other = false;\\r\\n        if (lpPairs[from]) {\\r\\n            buy = true;\\r\\n        } else if (lpPairs[to]) {\\r\\n            sell = true;\\r\\n        } else {\\r\\n            other = true;\\r\\n        }\\r\\n\\r\\n        // Restrict the buyBackBurnLP wallet transfers to only the DEX pair and DEAD addresses\\r\\n        if (from == _taxWallets.buyBackBurnLP) {\\r\\n            require(to == lpPair || to == DEAD, \\\"buyBackBurnLP can only send to DEX pair or burn address\\\");\\r\\n        }\\r\\n        \\r\\n        if (_hasLimits(from, to)) {\\r\\n            if (!tradingEnabled) {\\r\\n                if (!other) {\\r\\n                    revert(\\\"Trading not yet enabled!\\\");\\r\\n                } else if (\\r\\n                    !_isExcludedFromProtection[from] &&\\r\\n                    !_isExcludedFromProtection[to]\\r\\n                ) {\\r\\n                    revert(\\\"Tokens cannot be moved until trading is live.\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (sell) {\\r\\n            if (!inSwap) {\\r\\n                if (contractSwapEnabled) {\\r\\n                    uint256 contractTokenBalance = balanceOf(address(this));\\r\\n                    if (contractTokenBalance >= swapThreshold) {\\r\\n                        uint256 swapAmt = swapAmount;\\r\\n                        if (piContractSwapsEnabled) {\\r\\n                            swapAmt =\\r\\n                                (balanceOf(lpPair) * piSwapPercent) /\\r\\n                                masterTaxDivisor;\\r\\n                        }\\r\\n                        if (contractTokenBalance >= swapAmt) {\\r\\n                            contractTokenBalance = swapAmt;\\r\\n                        }\\r\\n                        contractSwap(contractTokenBalance);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return finalizeTransfer(from, to, amount, buy, sell, other);\\r\\n    }\\r\\n\\r\\n    function contractSwap(uint256 contractTokenBalance) internal inSwapFlag {\\r\\n        Ratios memory ratios = _ratios;\\r\\n        if (ratios.totalSwap == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            _allowances[address(this)][address(dexRouter)] != type(uint256).max\\r\\n        ) {\\r\\n            _allowances[address(this)][address(dexRouter)] = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = dexRouter.WETH();\\r\\n\\r\\n        try\\r\\n            dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                contractTokenBalance,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )\\r\\n        {} catch {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 amtBalance = address(this).balance;\\r\\n        bool success;\\r\\n        uint256 developmentBalance = (amtBalance * ratios.development) /\\r\\n            ratios.totalSwap;\\r\\n        uint256 externalBuybackBalance = (amtBalance * ratios.buyBackBurnLP) /\\r\\n            ratios.totalSwap;\\r\\n        uint256 marketingBalance = amtBalance -\\r\\n            (developmentBalance + externalBuybackBalance);\\r\\n        if (ratios.marketing > 0) {\\r\\n            (success, ) = _taxWallets.marketing.call{\\r\\n                value: marketingBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n        if (ratios.development > 0) {\\r\\n            (success, ) = _taxWallets.development.call{\\r\\n                value: developmentBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n        if (ratios.buyBackBurnLP > 0) {\\r\\n            (success, ) = _taxWallets.buyBackBurnLP.call{\\r\\n                value: externalBuybackBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkLiquidityAdd(address from, address to) internal {\\r\\n        require(!_hasLiqBeenAdded, \\\"Liquidity already added and marked.\\\");\\r\\n        if (!_hasLimits(from, to) && to == lpPair) {\\r\\n            _liquidityHolders[from] = true;\\r\\n            _isExcludedFromFees[from] = true;\\r\\n            _hasLiqBeenAdded = true;\\r\\n            if (address(initializer) == address(0)) {\\r\\n                initializer = Initializer(address(this));\\r\\n            }\\r\\n            contractSwapEnabled = true;\\r\\n            emit ContractSwapEnabledUpdated(true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enableTrading() public onlyOwner {\\r\\n        require(!tradingEnabled, \\\"Trading already enabled!\\\");\\r\\n        require(_hasLiqBeenAdded, \\\"Liquidity must be added.\\\");\\r\\n        if (address(initializer) == address(0)) {\\r\\n            initializer = Initializer(address(this));\\r\\n        }\\r\\n        try\\r\\n            initializer.setLaunch(\\r\\n                lpPair,\\r\\n                uint32(block.number),\\r\\n                uint64(block.timestamp),\\r\\n                _decimals\\r\\n            )\\r\\n        {} catch {}\\r\\n        try initializer.getInits(balanceOf(lpPair)) returns (\\r\\n            uint256 initThreshold,\\r\\n            uint256 initSwapAmount\\r\\n        ) {\\r\\n            swapThreshold = initThreshold;\\r\\n            swapAmount = initSwapAmount;\\r\\n        } catch {}\\r\\n        tradingEnabled = true;\\r\\n        launchStamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function sweepContingency() external onlyOwner {\\r\\n        require(!_hasLiqBeenAdded, \\\"Cannot call after liquidity.\\\");\\r\\n        payable(_owner).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function sweepExternalTokens(address token) external onlyOwner {\\r\\n        if (_hasLiqBeenAdded) {\\r\\n            require(token != address(this), \\\"Cannot sweep native tokens.\\\");\\r\\n        }\\r\\n        IERC20 TOKEN = IERC20(token);\\r\\n        TOKEN.transfer(_owner, TOKEN.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function multiSendTokens(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory amounts\\r\\n    ) external onlyOwner {\\r\\n        require(accounts.length == amounts.length, \\\"Lengths do not match.\\\");\\r\\n        for (uint16 i = 0; i < accounts.length; i++) {\\r\\n            require(\\r\\n                balanceOf(msg.sender) >= amounts[i] * 10 ** _decimals,\\r\\n                \\\"Not enough tokens.\\\"\\r\\n            );\\r\\n            finalizeTransfer(\\r\\n                msg.sender,\\r\\n                accounts[i],\\r\\n                amounts[i] * 10 ** _decimals,\\r\\n                false,\\r\\n                false,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Calculate the vested amount that can be claimed\\r\\n    function vestedAndClaimable(address account) public view returns (uint256) {\\r\\n        Lock memory lock = lockedTokens[account];\\r\\n        \\r\\n        if (block.timestamp < lock.releaseTime) {\\r\\n            return 0;  // Still in lock period\\r\\n        }\\r\\n        \\r\\n        uint256 elapsedTime = block.timestamp - lock.vestingStart;\\r\\n        \\r\\n        if (elapsedTime >= lock.vestingDuration) {\\r\\n            // All tokens are fully vested after the vesting duration\\r\\n            return lock.totalAmount - lock.claimed;\\r\\n        }\\r\\n        \\r\\n        // Calculate linear vesting amount\\r\\n        uint256 vested = (lock.totalAmount * elapsedTime) / lock.vestingDuration;\\r\\n        \\r\\n        // Return the claimable amount (vested minus already claimed)\\r\\n        return vested - lock.claimed;\\r\\n    }\\r\\n\\r\\n    function finalizeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bool buy,\\r\\n        bool sell,\\r\\n        bool other\\r\\n    ) internal returns (bool) {\\r\\n\\r\\n        uint256 availableBalance = _tOwned[from];\\r\\n        // If the sender has locked tokens, calculate the vested amount\\r\\n        if (lockedTokens[from].totalAmount > 0) {\\r\\n            uint256 claimable = vestedAndClaimable(from);\\r\\n            availableBalance = availableBalance.sub(lockedTokens[from].totalAmount - claimable);\\r\\n            \\r\\n            require(amount <= availableBalance, \\\"Amount exceeds unlocked tokens\\\");\\r\\n            \\r\\n            // Update the claimed amount in the lock\\r\\n            lockedTokens[from].claimed = lockedTokens[from].claimed.add(amount);\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        _tOwned[from] -= amount;\\r\\n        uint256 amountReceived = (takeFee)\\r\\n            ? takeTaxes(from, amount, buy, sell)\\r\\n            : amount;\\r\\n        \\r\\n        _tOwned[to] += amountReceived;\\r\\n        emit Transfer(from, to, amountReceived);\\r\\n\\r\\n        if (!_hasLiqBeenAdded) {\\r\\n            _checkLiquidityAdd(from, to);\\r\\n            if (\\r\\n                !_hasLiqBeenAdded &&\\r\\n                _hasLimits(from, to) &&\\r\\n                !_isExcludedFromProtection[from] &&\\r\\n                !_isExcludedFromProtection[to] &&\\r\\n                !other\\r\\n            ) {\\r\\n                revert(\\\"Pre-liquidity transfer protection.\\\");\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeTaxes(\\r\\n        address from,\\r\\n        uint256 amount,\\r\\n        bool buy,\\r\\n        bool sell\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 currentFee = getDynamicTaxRate(buy, sell);\\r\\n\\r\\n        if (currentFee == 0) {\\r\\n            return amount;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = (amount * currentFee) / masterTaxDivisor;\\r\\n        if (feeAmount > 0) {\\r\\n            _tOwned[address(this)] += feeAmount;\\r\\n            emit Transfer(from, address(this), feeAmount);\\r\\n        }\\r\\n\\r\\n        return amount - feeAmount;\\r\\n    }\\r\\n\\r\\n    function getDynamicTaxRate(bool buy, bool sell) public view returns (uint256) {\\r\\n        uint256 baseRate;\\r\\n\\r\\n        if (buy) {\\r\\n            baseRate = _taxRates.buyFee;\\r\\n        } else if (sell) {\\r\\n            baseRate = _taxRates.sellFee;\\r\\n        } else {\\r\\n            baseRate = _taxRates.transferFee;\\r\\n        }\\r\\n\\r\\n        if (block.timestamp >= launchStamp) {\\r\\n            uint256 minutesSinceLaunch = (block.timestamp - launchStamp) / 60;\\r\\n            \\r\\n            if (minutesSinceLaunch >= maxReductionMinutes) {\\r\\n                // After 4 minutes, tax is reduced to the final rate of 5%\\r\\n                return finalTaxRate;  // 5%\\r\\n            } else {\\r\\n                // Each minute, reduce tax by 5% starting from 25%\\r\\n                uint256 reducedRate = initialTaxRate - (minutesSinceLaunch * taxReductionPerMinute); \\r\\n                return reducedRate;  // Return the dynamic rate\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return baseRate; // Return the base rate before the launch\\r\\n    }\\r\\n\\r\\n    function setMaxTransferAmount(uint256 _maxTransferAmount) external onlyOwner {\\r\\n        require(_maxTransferAmount > 0, \\\"Max transfer amount must be greater than zero\\\");\\r\\n        maxTransferAmount = _maxTransferAmount;\\r\\n    }\\r\\n\\r\\n    function setMaxWalletAmount(uint256 _maxWalletAmount) external onlyOwner {\\r\\n        require(_maxWalletAmount > 0, \\\"Max wallet amount must be greater than zero\\\");\\r\\n        maxWalletAmount = _maxWalletAmount;\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "stealth_fee_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "mapping(address => bool) private _isexcludedfromfee",
          "function_context": "\"content\": \"/**\\r\\n *Submitted for verification at Etherscan.io on 2024-09-20\\r\\n */\\r\\n\\r\\n/**\\r\\n\\r\\n    \u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\\r\\n    \u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\r\\n    \u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u255a\u2588\u2588\u2588\u2554\u255d\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\\r\\n    \u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2554\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\r\\n    \u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\\r\\n    \u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\\r\\n\\r\\n    ?? ??-??????? ???????? ????? ???????? ??????? ???? ???? ?? ?? ??????? ??? ????? ????? \\r\\n    ???????? ????, ????? ?????? ??? ???????????????, ??? ???????? ???????? ??????? ??? \\r\\n    ?????? ??? ?????-???? ????? ?????????.\\r\\n\\r\\n    Home Page\\r\\n\\r\\n    https://nyxcipher.ai/\\r\\n\\r\\n    Web App\\r\\n\\r\\n    https://app.nyxcipher.ai/\\r\\n\\r\\n    Join our Telegram!\\r\\n\\r\\n    https://t.me/nyxcipherportal\\r\\n\\r\\n    Twitter\\r\\n\\r\\n    https://x.com/nyxcipherai\\r\\n\\r\\n\\r\\n*/\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IFactoryV2 {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address lpPair,\\r\\n        uint\\r\\n    );\\r\\n    function getPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external view returns (address lpPair);\\r\\n    function createPair(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) external returns (address lpPair);\\r\\n}\\r\\n\\r\\ninterface IV2Pair {\\r\\n    function factory() external view returns (address);\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\ninterface IRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function swapExactETHForTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint[] memory amounts);\\r\\n    function getAmountsOut(\\r\\n        uint amountIn,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(\\r\\n        uint amountOut,\\r\\n        address[] calldata path\\r\\n    ) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IRouter02 is IRouter01 {\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface Initializer {\\r\\n    function setLaunch(\\r\\n        address _initialLpPair,\\r\\n        uint32 _liqAddBlock,\\r\\n        uint64 _liqAddStamp,\\r\\n        uint8 dec\\r\\n    ) external;\\r\\n    function getConfig() external returns (address, address);\\r\\n    function getInits(uint256 amount) external returns (uint256, uint256);\\r\\n    function setLpPair(address pair, bool enabled) external;\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract NyxCipher is IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    mapping(address => uint256) private _tOwned;\\r\\n    mapping(address => bool) lpPairs;\\r\\n    uint256 private timeSinceLastPair = 0;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    mapping(address => bool) private _liquidityHolders;\\r\\n    mapping(address => bool) private _isExcludedFromProtection;\\r\\n    mapping(address => bool) private _isExcludedFromFees;\\r\\n    uint256 private constant startingSupply = 100_000_000;\\r\\n    string private constant _name = \\\"NYX CIPHER\\\";\\r\\n    string private constant _symbol = \\\"$NXCP\\\";\\r\\n    uint8 private constant _decimals = 8;\\r\\n    uint256 private constant _tTotal = startingSupply * 10 ** _decimals;\\r\\n\\r\\n    // Add these as state variables\\r\\n    uint256 public constant initialTaxRate = 2500; // 25%\\r\\n    uint256 public constant finalTaxRate = 500;    // 5%\\r\\n    uint256 public constant taxReductionPerMinute = 500; // 5% reduction per minute\\r\\n    uint256 public constant maxReductionMinutes = 4;     // Tax reduces for 4 minutes (25% -> 5%)\\r\\n\\r\\n\\r\\n    struct Fees {\\r\\n        uint16 buyFee;\\r\\n        uint16 sellFee;\\r\\n        uint16 transferFee;\\r\\n    }\\r\\n\\r\\n    struct Ratios {\\r\\n        uint16 marketing;\\r\\n        uint16 development;\\r\\n        uint16 buyBackBurnLP;\\r\\n        uint16 totalSwap;\\r\\n    }\\r\\n    // Define the Lock struct to store the amount and release time of locked tokens\\r\\n    struct Lock {\\r\\n        uint256 totalAmount;  // Total tokens to be vested/locked\\r\\n        uint256 releaseTime;  // Time when initial lock period ends\\r\\n        uint256 vestingStart; // When vesting starts (after lock period)\\r\\n        uint256 vestingDuration;  // Total duration for linear vesting\\r\\n        uint256 claimed;  // Tokens that have been claimed already\\r\\n    }\\r\\n    // Set the vesting parameters\\r\\n    uint256 public constant TEAM_LOCK_PERIOD = 90 days;  // 3 months lock period\\r\\n    uint256 public constant TEAM_VESTING_DURATION = 720 days;  // 24 months for vesting\\r\\n\\r\\n\\r\\n    Fees public _taxRates = Fees({buyFee: 500, sellFee: 500, transferFee: 0});\\r\\n\\r\\n    Ratios public _ratios =\\r\\n        Ratios({\\r\\n            marketing: 2,\\r\\n            development: 2,\\r\\n            buyBackBurnLP: 1,\\r\\n            totalSwap: 5\\r\\n        });\\r\\n\\r\\n    uint256 public constant maxBuyTaxes = 1000;\\r\\n    uint256 public constant maxSellTaxes = 1000;\\r\\n    uint256 public constant maxTransferTaxes = 1000;\\r\\n    uint256 constant masterTaxDivisor = 10000;\\r\\n    // Mapping to keep track of locked tokens and their release times for each address\\r\\n    mapping(address => Lock) public lockedTokens;\\r\\n\\r\\n    bool public taxesAreLocked;\\r\\n    IRouter02 public dexRouter;\\r\\n    address public lpPair;\\r\\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    struct TaxWallets {\\r\\n        address payable marketing;\\r\\n        address payable development;\\r\\n        address payable buyBackBurnLP;\\r\\n    }\\r\\n\\r\\n    TaxWallets public _taxWallets =\\r\\n        TaxWallets({\\r\\n            marketing: payable(0x0000000000000000000000000000000000000000),\\r\\n            development: payable(0x0000000000000000000000000000000000000000),\\r\\n            buyBackBurnLP: payable(0x0000000000000000000000000000000000000000)\\r\\n        });\\r\\n\\r\\n    bool inSwap;\\r\\n    bool public contractSwapEnabled = false;\\r\\n    uint256 public swapThreshold = _tTotal / 10000;\\r\\n    uint256 public swapAmount =  _tTotal / 10000;\\r\\n    bool public piContractSwapsEnabled = false;\\r\\n    uint256 public piSwapPercent = 10;\\r\\n    bool public tradingEnabled = false;\\r\\n    bool public _hasLiqBeenAdded = false;\\r\\n    Initializer initializer;\\r\\n    uint256 public launchStamp;\\r\\n\\r\\n    uint256 public maxTransferAmount; // Maximum transfer amount (1% of total supply)\\r\\n    uint256 public maxWalletAmount;   // Maximum wallet amount (1% of total supply)\\r\\n\\r\\n\\r\\n    event ContractSwapEnabledUpdated(bool enabled);\\r\\n    event AutoLiquify(uint256 amountCurrency, uint256 amountTokens);\\r\\n\\r\\n    modifier inSwapFlag() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address payable marketingWallet,\\r\\n        address payable developmentWallet,\\r\\n        address payable buyBackBurnLPWallet,\\r\\n        address payable teamFoundationWallet\\r\\n    ) payable {\\r\\n        // Set the owner.\\r\\n        _owner = msg.sender;\\r\\n\\r\\n        _tOwned[_owner] = _tTotal;\\r\\n        emit Transfer(address(0), _owner, _tTotal);\\r\\n\\r\\n        // Exclude certain addresses from fees\\r\\n        _isExcludedFromFees[_owner] = true;\\r\\n        _isExcludedFromFees[address(this)] = true;\\r\\n        _isExcludedFromFees[DEAD] = true;\\r\\n        _liquidityHolders[_owner] = true;\\r\\n\\r\\n        _isExcludedFromFees[0x407993575c91ce7643a4d4cCACc9A98c36eE1BBE] = true; // PinkLock\\r\\n        _isExcludedFromFees[0x663A5C229c09b049E36dCc11a9B0d4a8Eb9db214] = true; // Unicrypt (ETH)\\r\\n        _isExcludedFromFees[0xDba68f07d1b7Ca219f78ae8582C213d975c25cAf] = true; // Unicrypt (ETH)\\r\\n\\r\\n        // Set the tax wallets\\r\\n        _taxWallets = TaxWallets({\\r\\n            marketing: marketingWallet,\\r\\n            development: developmentWallet,\\r\\n            buyBackBurnLP: buyBackBurnLPWallet\\r\\n        });\\r\\n\\r\\n        // Distribute initial supply to designated wallets\\r\\n        uint256 marketingTokens = (_tTotal * 10) / 100;\\r\\n        uint256 developmentTokens = (_tTotal * 5) / 100;\\r\\n        uint256 teamFoundationTokens = (_tTotal * 15) / 100;\\r\\n\\r\\n        _tOwned[marketingWallet] = marketingTokens;\\r\\n        _tOwned[developmentWallet] = developmentTokens;\\r\\n        _tOwned[teamFoundationWallet] = teamFoundationTokens;\\r\\n\\r\\n        // Set up the teamFoundationWallet's lock and vesting\\r\\n        lockedTokens[teamFoundationWallet] = Lock({\\r\\n            totalAmount: (_tTotal * 15) / 100,  // 15% of total supply\\r\\n            releaseTime: block.timestamp + TEAM_LOCK_PERIOD,  // Lock for 3 months\\r\\n            vestingStart: block.timestamp + TEAM_LOCK_PERIOD,  // Vesting starts after 3 months\\r\\n            vestingDuration: TEAM_VESTING_DURATION,  // Linear vesting over 24 months\\r\\n            claimed: 0  // No tokens claimed initially\\r\\n        });\\r\\n        \\r\\n        // Initialize max transfer and holding limits as 1% of total supply\\r\\n        maxTransferAmount = _tTotal / 100; // 1% of total supply\\r\\n        maxWalletAmount = _tTotal / 100;   // 1% of total supply\\r\\n\\r\\n        // Adjust owner's balance\\r\\n        _tOwned[_owner] = _tTotal - (marketingTokens + developmentTokens + teamFoundationTokens);\\r\\n        emit Transfer(_owner, marketingWallet, marketingTokens);\\r\\n        emit Transfer(_owner, developmentWallet, developmentTokens);\\r\\n        emit Transfer(_owner, teamFoundationWallet, teamFoundationTokens);\\r\\n    }\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    // Ownable removed as a lib and added here to allow for custom transfers and renouncements.\\r\\n    // This allows for removal of ownership privileges from the owner once renounced or transferred.\\r\\n\\r\\n    address private _owner;\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Caller =/= owner.\\\");\\r\\n        _;\\r\\n    }\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    function transferOwner(address newOwner) external onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Call renounceOwnership to transfer owner to the zero address.\\\"\\r\\n        );\\r\\n        require(\\r\\n            newOwner != DEAD,\\r\\n            \\\"Call renounceOwnership to transfer owner to the zero address.\\\"\\r\\n        );\\r\\n        setExcludedFromFees(_owner, false);\\r\\n        setExcludedFromFees(newOwner, true);\\r\\n\\r\\n        if (balanceOf(_owner) > 0) {\\r\\n            finalizeTransfer(\\r\\n                _owner,\\r\\n                newOwner,\\r\\n                balanceOf(_owner),\\r\\n                false,\\r\\n                false,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external onlyOwner {\\r\\n        require(\\r\\n            tradingEnabled,\\r\\n            \\\"Cannot renounce until trading has been enabled.\\\"\\r\\n        );\\r\\n        setExcludedFromFees(_owner, false);\\r\\n        address oldOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        emit OwnershipTransferred(oldOwner, address(0));\\r\\n    }\\r\\n\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n    //===============================================================================================================\\r\\n\\r\\n    receive() external payable {}\\r\\n    function totalSupply() external pure override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    function allowance(\\r\\n        address holder,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _tOwned[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address sender,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        require(sender != address(0), \\\"ERC20: Zero Address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: Zero Address\\\");\\r\\n\\r\\n        _allowances[sender][spender] = amount;\\r\\n        emit Approval(sender, spender, amount);\\r\\n    }\\r\\n\\r\\n    function approveContractContingency() external onlyOwner returns (bool) {\\r\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\r\\n            _allowances[sender][msg.sender] -= _allowances[sender][msg.sender].sub(amount);\\r\\n        }\\r\\n\\r\\n        return _transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function setNewRouter(address newRouter) external onlyOwner {\\r\\n        require(!_hasLiqBeenAdded, \\\"Cannot change after liquidity.\\\");\\r\\n        IRouter02 _newRouter = IRouter02(newRouter);\\r\\n        address get_pair = IFactoryV2(_newRouter.factory()).getPair(\\r\\n            address(this),\\r\\n            _newRouter.WETH()\\r\\n        );\\r\\n        lpPairs[lpPair] = false;\\r\\n        if (get_pair == address(0)) {\\r\\n            lpPair = IFactoryV2(_newRouter.factory()).createPair(\\r\\n                address(this),\\r\\n                _newRouter.WETH()\\r\\n            );\\r\\n        } else {\\r\\n            lpPair = get_pair;\\r\\n        }\\r\\n        dexRouter = _newRouter;\\r\\n        lpPairs[lpPair] = true;\\r\\n        _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function setLpPair(address pair, bool enabled) external onlyOwner {\\r\\n        if (!enabled) {\\r\\n            lpPairs[pair] = false;\\r\\n            initializer.setLpPair(pair, false);\\r\\n        } else {\\r\\n            if (timeSinceLastPair != 0) {\\r\\n                require(\\r\\n                    block.timestamp - timeSinceLastPair > 3 days,\\r\\n                    \\\"3 Day cooldown.\\\"\\r\\n                );\\r\\n            }\\r\\n            require(!lpPairs[pair], \\\"Pair already added to list.\\\");\\r\\n            lpPairs[pair] = true;\\r\\n            timeSinceLastPair = block.timestamp;\\r\\n            initializer.setLpPair(pair, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setInitializer(address init) public onlyOwner {\\r\\n        require(!tradingEnabled);\\r\\n        require(init != address(this), \\\"Can't be self.\\\");\\r\\n        initializer = Initializer(init);\\r\\n        try initializer.getConfig() returns (\\r\\n            address router,\\r\\n            address constructorLP\\r\\n        ) {\\r\\n            dexRouter = IRouter02(router);\\r\\n            lpPair = constructorLP;\\r\\n            lpPairs[lpPair] = true;\\r\\n            _approve(_owner, address(dexRouter), type(uint256).max);\\r\\n            _approve(address(this), address(dexRouter), type(uint256).max);\\r\\n        } catch {\\r\\n            revert();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isExcludedFromFees(address account) external view returns (bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n\\r\\n    function setExcludedFromFees(\\r\\n        address account,\\r\\n        bool enabled\\r\\n    ) public onlyOwner {\\r\\n        _isExcludedFromFees[account] = enabled;\\r\\n    }\\r\\n\\r\\n    function isExcludedFromProtection(\\r\\n        address account\\r\\n    ) external view returns (bool) {\\r\\n        return _isExcludedFromProtection[account];\\r\\n    }\\r\\n\\r\\n    function setExcludedFromProtection(\\r\\n        address account,\\r\\n        bool enabled\\r\\n    ) external onlyOwner {\\r\\n        _isExcludedFromProtection[account] = enabled;\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return (_tTotal - (balanceOf(DEAD) + balanceOf(address(0))));\\r\\n    }\\r\\n\\r\\n    function lockTaxes() external onlyOwner {\\r\\n        // This will lock taxes at their current value forever, do not call this unless you're sure.\\r\\n        taxesAreLocked = true;\\r\\n    }\\r\\n\\r\\n    function setTaxes(\\r\\n        uint16 buyFee,\\r\\n        uint16 sellFee,\\r\\n        uint16 transferFee\\r\\n    ) external onlyOwner {\\r\\n        require(!taxesAreLocked, \\\"Taxes are locked.\\\");\\r\\n        require(\\r\\n            buyFee <= maxBuyTaxes &&\\r\\n                sellFee <= maxSellTaxes &&\\r\\n                transferFee <= maxTransferTaxes,\\r\\n            \\\"Cannot exceed maximums.\\\"\\r\\n        );\\r\\n        _taxRates.buyFee = buyFee;\\r\\n        _taxRates.sellFee = sellFee;\\r\\n        _taxRates.transferFee = transferFee;\\r\\n    }\\r\\n\\r\\n    function setRatios(\\r\\n        uint16 marketing,\\r\\n        uint16 development,\\r\\n        uint16 buyBackBurnLP\\r\\n    ) external onlyOwner {\\r\\n        _ratios.marketing = marketing;\\r\\n        _ratios.development = development;\\r\\n        _ratios.buyBackBurnLP = buyBackBurnLP;\\r\\n        _ratios.totalSwap = marketing + development + buyBackBurnLP;\\r\\n        uint256 total = _taxRates.buyFee + _taxRates.sellFee;\\r\\n        require(\\r\\n            _ratios.totalSwap <= total,\\r\\n            \\\"Cannot exceed sum of buy and sell fees.\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setWallets(\\r\\n        address payable marketing,\\r\\n        address payable development,\\r\\n        address payable buyBackBurnLP\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            marketing != address(0) &&\\r\\n                development != address(0) &&\\r\\n                buyBackBurnLP != address(0),\\r\\n            \\\"Cannot be zero address.\\\"\\r\\n        );\\r\\n        _taxWallets.marketing = payable(marketing);\\r\\n        _taxWallets.development = payable(development);\\r\\n        _taxWallets.buyBackBurnLP = payable(buyBackBurnLP);\\r\\n    }\\r\\n\\r\\n    function getTokenAmountAtPriceImpact(\\r\\n        uint256 priceImpactInHundreds\\r\\n    ) external view returns (uint256) {\\r\\n        return ((balanceOf(lpPair) * priceImpactInHundreds) / masterTaxDivisor);\\r\\n    }\\r\\n\\r\\n    function setSwapSettings(\\r\\n        uint256 thresholdPercent,\\r\\n        uint256 thresholdDivisor,\\r\\n        uint256 amountPercent,\\r\\n        uint256 amountDivisor\\r\\n    ) external onlyOwner {\\r\\n        swapThreshold = (_tTotal * thresholdPercent) / thresholdDivisor;\\r\\n        swapAmount = (_tTotal * amountPercent) / amountDivisor;\\r\\n        require(\\r\\n            swapThreshold <= swapAmount,\\r\\n            \\\"Threshold cannot be above amount.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapAmount <= (balanceOf(lpPair) * 150) / masterTaxDivisor,\\r\\n            \\\"Cannot be above 1.5% of current PI.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapAmount >= _tTotal / 1_000_000,\\r\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\r\\n        );\\r\\n        require(\\r\\n            swapThreshold >= _tTotal / 1_000_000,\\r\\n            \\\"Cannot be lower than 0.00001% of total supply.\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setPriceImpactSwapAmount(\\r\\n        uint256 priceImpactSwapPercent\\r\\n    ) external onlyOwner {\\r\\n        require(priceImpactSwapPercent <= 150, \\\"Cannot set above 1.5%.\\\");\\r\\n        piSwapPercent = priceImpactSwapPercent;\\r\\n    }\\r\\n\\r\\n    function setContractSwapEnabled(\\r\\n        bool swapEnabled,\\r\\n        bool priceImpactSwapEnabled\\r\\n    ) external onlyOwner {\\r\\n        contractSwapEnabled = swapEnabled;\\r\\n        piContractSwapsEnabled = priceImpactSwapEnabled;\\r\\n        emit ContractSwapEnabledUpdated(swapEnabled);\\r\\n    }\\r\\n\\r\\n    function _hasLimits(address from, address to) internal view returns (bool) {\\r\\n        return\\r\\n            from != _owner &&\\r\\n            to != _owner &&\\r\\n            tx.origin != _owner &&\\r\\n            !_liquidityHolders[to] &&\\r\\n            !_liquidityHolders[from] &&\\r\\n            to != DEAD &&\\r\\n            to != address(0) &&\\r\\n            from != address(this) &&\\r\\n            from != address(initializer) &&\\r\\n            to != address(initializer);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n        // Check if the wallet is excluded from max transfer and max wallet restrictions\\r\\n        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\\r\\n            // Enforce the maximum transfer amount (only if not excluded)\\r\\n            require(amount <= maxTransferAmount, \\\"Transfer amount exceeds the 1% limit\\\");\\r\\n\\r\\n            // Check if the recipient's balance would exceed the max wallet limit (only if not excluded)\\r\\n            uint256 recipientBalanceAfterTransfer = _tOwned[to] + amount;\\r\\n            require(recipientBalanceAfterTransfer <= maxWalletAmount, \\\"Recipient exceeds maximum wallet balance limit\\\");\\r\\n        }\\r\\n        \\r\\n        bool buy = false;\\r\\n        bool sell = false;\\r\\n        bool other = false;\\r\\n        if (lpPairs[from]) {\\r\\n            buy = true;\\r\\n        } else if (lpPairs[to]) {\\r\\n            sell = true;\\r\\n        } else {\\r\\n            other = true;\\r\\n        }\\r\\n\\r\\n        // Restrict the buyBackBurnLP wallet transfers to only the DEX pair and DEAD addresses\\r\\n        if (from == _taxWallets.buyBackBurnLP) {\\r\\n            require(to == lpPair || to == DEAD, \\\"buyBackBurnLP can only send to DEX pair or burn address\\\");\\r\\n        }\\r\\n        \\r\\n        if (_hasLimits(from, to)) {\\r\\n            if (!tradingEnabled) {\\r\\n                if (!other) {\\r\\n                    revert(\\\"Trading not yet enabled!\\\");\\r\\n                } else if (\\r\\n                    !_isExcludedFromProtection[from] &&\\r\\n                    !_isExcludedFromProtection[to]\\r\\n                ) {\\r\\n                    revert(\\\"Tokens cannot be moved until trading is live.\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (sell) {\\r\\n            if (!inSwap) {\\r\\n                if (contractSwapEnabled) {\\r\\n                    uint256 contractTokenBalance = balanceOf(address(this));\\r\\n                    if (contractTokenBalance >= swapThreshold) {\\r\\n                        uint256 swapAmt = swapAmount;\\r\\n                        if (piContractSwapsEnabled) {\\r\\n                            swapAmt =\\r\\n                                (balanceOf(lpPair) * piSwapPercent) /\\r\\n                                masterTaxDivisor;\\r\\n                        }\\r\\n                        if (contractTokenBalance >= swapAmt) {\\r\\n                            contractTokenBalance = swapAmt;\\r\\n                        }\\r\\n                        contractSwap(contractTokenBalance);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return finalizeTransfer(from, to, amount, buy, sell, other);\\r\\n    }\\r\\n\\r\\n    function contractSwap(uint256 contractTokenBalance) internal inSwapFlag {\\r\\n        Ratios memory ratios = _ratios;\\r\\n        if (ratios.totalSwap == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            _allowances[address(this)][address(dexRouter)] != type(uint256).max\\r\\n        ) {\\r\\n            _allowances[address(this)][address(dexRouter)] = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = dexRouter.WETH();\\r\\n\\r\\n        try\\r\\n            dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                contractTokenBalance,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            )\\r\\n        {} catch {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 amtBalance = address(this).balance;\\r\\n        bool success;\\r\\n        uint256 developmentBalance = (amtBalance * ratios.development) /\\r\\n            ratios.totalSwap;\\r\\n        uint256 externalBuybackBalance = (amtBalance * ratios.buyBackBurnLP) /\\r\\n            ratios.totalSwap;\\r\\n        uint256 marketingBalance = amtBalance -\\r\\n            (developmentBalance + externalBuybackBalance);\\r\\n        if (ratios.marketing > 0) {\\r\\n            (success, ) = _taxWallets.marketing.call{\\r\\n                value: marketingBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n        if (ratios.development > 0) {\\r\\n            (success, ) = _taxWallets.development.call{\\r\\n                value: developmentBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n        if (ratios.buyBackBurnLP > 0) {\\r\\n            (success, ) = _taxWallets.buyBackBurnLP.call{\\r\\n                value: externalBuybackBalance,\\r\\n                gas: 55000\\r\\n            }(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkLiquidityAdd(address from, address to) internal {\\r\\n        require(!_hasLiqBeenAdded, \\\"Liquidity already added and marked.\\\");\\r\\n        if (!_hasLimits(from, to) && to == lpPair) {\\r\\n            _liquidityHolders[from] = true;\\r\\n            _isExcludedFromFees[from] = true;\\r\\n            _hasLiqBeenAdded = true;\\r\\n            if (address(initializer) == address(0)) {\\r\\n                initializer = Initializer(address(this));\\r\\n            }\\r\\n            contractSwapEnabled = true;\\r\\n            emit ContractSwapEnabledUpdated(true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enableTrading() public onlyOwner {\\r\\n        require(!tradingEnabled, \\\"Trading already enabled!\\\");\\r\\n        require(_hasLiqBeenAdded, \\\"Liquidity must be added.\\\");\\r\\n        if (address(initializer) == address(0)) {\\r\\n            initializer = Initializer(address(this));\\r\\n        }\\r\\n        try\\r\\n            initializer.setLaunch(\\r\\n                lpPair,\\r\\n                uint32(block.number),\\r\\n                uint64(block.timestamp),\\r\\n                _decimals\\r\\n            )\\r\\n        {} catch {}\\r\\n        try initializer.getInits(balanceOf(lpPair)) returns (\\r\\n            uint256 initThreshold,\\r\\n            uint256 initSwapAmount\\r\\n        ) {\\r\\n            swapThreshold = initThreshold;\\r\\n            swapAmount = initSwapAmount;\\r\\n        } catch {}\\r\\n        tradingEnabled = true;\\r\\n        launchStamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function sweepContingency() external onlyOwner {\\r\\n        require(!_hasLiqBeenAdded, \\\"Cannot call after liquidity.\\\");\\r\\n        payable(_owner).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function sweepExternalTokens(address token) external onlyOwner {\\r\\n        if (_hasLiqBeenAdded) {\\r\\n            require(token != address(this), \\\"Cannot sweep native tokens.\\\");\\r\\n        }\\r\\n        IERC20 TOKEN = IERC20(token);\\r\\n        TOKEN.transfer(_owner, TOKEN.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function multiSendTokens(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory amounts\\r\\n    ) external onlyOwner {\\r\\n        require(accounts.length == amounts.length, \\\"Lengths do not match.\\\");\\r\\n        for (uint16 i = 0; i < accounts.length; i++) {\\r\\n            require(\\r\\n                balanceOf(msg.sender) >= amounts[i] * 10 ** _decimals,\\r\\n                \\\"Not enough tokens.\\\"\\r\\n            );\\r\\n            finalizeTransfer(\\r\\n                msg.sender,\\r\\n                accounts[i],\\r\\n                amounts[i] * 10 ** _decimals,\\r\\n                false,\\r\\n                false,\\r\\n                true\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Calculate the vested amount that can be claimed\\r\\n    function vestedAndClaimable(address account) public view returns (uint256) {\\r\\n        Lock memory lock = lockedTokens[account];\\r\\n        \\r\\n        if (block.timestamp < lock.releaseTime) {\\r\\n            return 0;  // Still in lock period\\r\\n        }\\r\\n        \\r\\n        uint256 elapsedTime = block.timestamp - lock.vestingStart;\\r\\n        \\r\\n        if (elapsedTime >= lock.vestingDuration) {\\r\\n            // All tokens are fully vested after the vesting duration\\r\\n            return lock.totalAmount - lock.claimed;\\r\\n        }\\r\\n        \\r\\n        // Calculate linear vesting amount\\r\\n        uint256 vested = (lock.totalAmount * elapsedTime) / lock.vestingDuration;\\r\\n        \\r\\n        // Return the claimable amount (vested minus already claimed)\\r\\n        return vested - lock.claimed;\\r\\n    }\\r\\n\\r\\n    function finalizeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        bool buy,\\r\\n        bool sell,\\r\\n        bool other\\r\\n    ) internal returns (bool) {\\r\\n\\r\\n        uint256 availableBalance = _tOwned[from];\\r\\n        // If the sender has locked tokens, calculate the vested amount\\r\\n        if (lockedTokens[from].totalAmount > 0) {\\r\\n            uint256 claimable = vestedAndClaimable(from);\\r\\n            availableBalance = availableBalance.sub(lockedTokens[from].totalAmount - claimable);\\r\\n            \\r\\n            require(amount <= availableBalance, \\\"Amount exceeds unlocked tokens\\\");\\r\\n            \\r\\n            // Update the claimed amount in the lock\\r\\n            lockedTokens[from].claimed = lockedTokens[from].claimed.add(amount);\\r\\n        }\\r\\n\\r\\n        bool takeFee = true;\\r\\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        _tOwned[from] -= amount;\\r\\n        uint256 amountReceived = (takeFee)\\r\\n            ? takeTaxes(from, amount, buy, sell)\\r\\n            : amount;\\r\\n        \\r\\n        _tOwned[to] += amountReceived;\\r\\n        emit Transfer(from, to, amountReceived);\\r\\n\\r\\n        if (!_hasLiqBeenAdded) {\\r\\n            _checkLiquidityAdd(from, to);\\r\\n            if (\\r\\n                !_hasLiqBeenAdded &&\\r\\n                _hasLimits(from, to) &&\\r\\n                !_isExcludedFromProtection[from] &&\\r\\n                !_isExcludedFromProtection[to] &&\\r\\n                !other\\r\\n            ) {\\r\\n                revert(\\\"Pre-liquidity transfer protection.\\\");\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeTaxes(\\r\\n        address from,\\r\\n        uint256 amount,\\r\\n        bool buy,\\r\\n        bool sell\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 currentFee = getDynamicTaxRate(buy, sell);\\r\\n\\r\\n        if (currentFee == 0) {\\r\\n            return amount;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = (amount * currentFee) / masterTaxDivisor;\\r\\n        if (feeAmount > 0) {\\r\\n            _tOwned[address(this)] += feeAmount;\\r\\n            emit Transfer(from, address(this), feeAmount);\\r\\n        }\\r\\n\\r\\n        return amount - feeAmount;\\r\\n    }\\r\\n\\r\\n    function getDynamicTaxRate(bool buy, bool sell) public view returns (uint256) {\\r\\n        uint256 baseRate;\\r\\n\\r\\n        if (buy) {\\r\\n            baseRate = _taxRates.buyFee;\\r\\n        } else if (sell) {\\r\\n            baseRate = _taxRates.sellFee;\\r\\n        } else {\\r\\n            baseRate = _taxRates.transferFee;\\r\\n        }\\r\\n\\r\\n        if (block.timestamp >= launchStamp) {\\r\\n            uint256 minutesSinceLaunch = (block.timestamp - launchStamp) / 60;\\r\\n            \\r\\n            if (minutesSinceLaunch >= maxReductionMinutes) {\\r\\n                // After 4 minutes, tax is reduced to the final rate of 5%\\r\\n                return finalTaxRate;  // 5%\\r\\n            } else {\\r\\n                // Each minute, reduce tax by 5% starting from 25%\\r\\n                uint256 reducedRate = initialTaxRate - (minutesSinceLaunch * taxReductionPerMinute); \\r\\n                return reducedRate;  // Return the dynamic rate\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return baseRate; // Return the base rate before the launch\\r\\n    }\\r\\n\\r\\n    function setMaxTransferAmount(uint256 _maxTransferAmount) external onlyOwner {\\r\\n        require(_maxTransferAmount > 0, \\\"Max transfer amount must be greater than zero\\\");\\r\\n        maxTransferAmount = _maxTransferAmount;\\r\\n    }\\r\\n\\r\\n    function setMaxWalletAmount(uint256 _maxWalletAmount) external onlyOwner {\\r\\n        require(_maxWalletAmount > 0, \\\"Max wallet amount must be greater than zero\\\");\\r\\n        maxWalletAmount = _maxWalletAmount;\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"",
          "pattern": "mapping\\s*\\(\\s*address\\s*=>\\s*bool\\s*\\)\\s*private\\s*_isExcludedFromFee"
        }
      ]
    }
  }
}