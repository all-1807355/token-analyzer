{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressBytes } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressBytes.sol';\\n\\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\\n\\nimport { InterchainTokenStandard } from './InterchainTokenStandard.sol';\\nimport { ERC20 } from './ERC20.sol';\\nimport { ERC20Permit } from './ERC20Permit.sol';\\nimport { Minter } from '../utils/Minter.sol';\\n\\n/**\\n * @title InterchainToken\\n * @notice This contract implements an interchain token which extends InterchainToken functionality.\\n * @dev This contract also inherits Minter and Implementation logic.\\n */\\ncontract InterchainToken is InterchainTokenStandard, ERC20, ERC20Permit, Minter, IInterchainToken {\\n    using AddressBytes for bytes;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    bytes32 internal tokenId;\\n    address internal immutable interchainTokenService_;\\n\\n    // bytes32(uint256(keccak256('interchain-token-initialized')) - 1);\\n    bytes32 internal constant INITIALIZED_SLOT = 0xc778385ecb3e8cecb82223fa1f343ec6865b2d64c65b0c15c7e8aef225d9e214;\\n\\n    /**\\n     * @notice Constructs the InterchainToken contract.\\n     * @dev Makes the implementation act as if it has been setup already to disallow calls to init() (even though that would not achieve anything really).\\n     */\\n    constructor(address interchainTokenServiceAddress) {\\n        _initialize();\\n\\n        if (interchainTokenServiceAddress == address(0)) revert InterchainTokenServiceAddressZero();\\n\\n        interchainTokenService_ = interchainTokenServiceAddress;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract has been setup.\\n     * @return initialized True if the contract has been setup, false otherwise.\\n     */\\n    function _isInitialized() internal view returns (bool initialized) {\\n        assembly {\\n            initialized := sload(INITIALIZED_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets initialized to true, to allow only a single init.\\n     */\\n    function _initialize() internal {\\n        assembly {\\n            sstore(INITIALIZED_SLOT, true)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the interchain token service\\n     * @return address The interchain token service contract\\n     */\\n    function interchainTokenService() public view override(InterchainTokenStandard, IInterchainToken) returns (address) {\\n        return interchainTokenService_;\\n    }\\n\\n    /**\\n     * @notice Returns the tokenId for this token.\\n     * @return bytes32 The token manager contract.\\n     */\\n    function interchainTokenId() public view override(InterchainTokenStandard, IInterchainToken) returns (bytes32) {\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Setup function to initialize contract parameters.\\n     * @param tokenId_ The tokenId of the token.\\n     * @param minter The address of the token minter.\\n     * @param tokenName The name of the token.\\n     * @param tokenSymbol The symbopl of the token.\\n     * @param tokenDecimals The decimals of the token.\\n     */\\n    function init(bytes32 tokenId_, address minter, string calldata tokenName, string calldata tokenSymbol, uint8 tokenDecimals) external {\\n        if (_isInitialized()) revert AlreadyInitialized();\\n\\n        _initialize();\\n\\n        if (tokenId_ == bytes32(0)) revert TokenIdZero();\\n        if (bytes(tokenName).length == 0) revert TokenNameEmpty();\\n        if (bytes(tokenSymbol).length == 0) revert TokenSymbolEmpty();\\n\\n        name = tokenName;\\n        symbol = tokenSymbol;\\n        decimals = tokenDecimals;\\n        tokenId = tokenId_;\\n\\n        /**\\n         * @dev Set the token service as a minter to allow it to mint and burn tokens.\\n         * Also add the provided address as a minter. If `address(0)` was provided,\\n         * add it as a minter to allow anyone to easily check that no custom minter was set.\\n         */\\n        _addMinter(interchainTokenService_);\\n        _addMinter(minter);\\n\\n        _setNameHash(tokenName);\\n    }\\n\\n    /**\\n     * @notice Function to mint new tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     */\\n    function mint(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @notice Function to burn tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will have its tokens burnt.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @notice A method to be overwritten that will decrease the allowance of the `spender` from `sender` by `amount`.\\n     * @dev Needs to be overwritten. This provides flexibility for the choice of ERC20 implementation used. Must revert if allowance is not sufficient.\\n     */\\n    function _spendAllowance(address sender, address spender, uint256 amount) internal override {\\n        uint256 _allowance = allowance[sender][spender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, spender, _allowance - amount);\\n        }\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    mapping(address => uint256) public override balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    uint256 public override totalSupply;\\n    uint256 internal constant UINT256_MAX = type(uint256).max;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\\n        uint256 _allowance = allowance[sender][msg.sender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, msg.sender, _allowance - amount);\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        if (sender == address(0) || recipient == address(0)) revert InvalidAccount();\\n\\n        balanceOf[sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        totalSupply += amount;\\n        balanceOf[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        balanceOf[account] -= amount;\\n        totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (owner == address(0) || spender == address(0)) revert InvalidAccount();\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressBytes } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressBytes.sol';\\n\\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\\n\\nimport { InterchainTokenStandard } from './InterchainTokenStandard.sol';\\nimport { ERC20 } from './ERC20.sol';\\nimport { ERC20Permit } from './ERC20Permit.sol';\\nimport { Minter } from '../utils/Minter.sol';\\n\\n/**\\n * @title InterchainToken\\n * @notice This contract implements an interchain token which extends InterchainToken functionality.\\n * @dev This contract also inherits Minter and Implementation logic.\\n */\\ncontract InterchainToken is InterchainTokenStandard, ERC20, ERC20Permit, Minter, IInterchainToken {\\n    using AddressBytes for bytes;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    bytes32 internal tokenId;\\n    address internal immutable interchainTokenService_;\\n\\n    // bytes32(uint256(keccak256('interchain-token-initialized')) - 1);\\n    bytes32 internal constant INITIALIZED_SLOT = 0xc778385ecb3e8cecb82223fa1f343ec6865b2d64c65b0c15c7e8aef225d9e214;\\n\\n    /**\\n     * @notice Constructs the InterchainToken contract.\\n     * @dev Makes the implementation act as if it has been setup already to disallow calls to init() (even though that would not achieve anything really).\\n     */\\n    constructor(address interchainTokenServiceAddress) {\\n        _initialize();\\n\\n        if (interchainTokenServiceAddress == address(0)) revert InterchainTokenServiceAddressZero();\\n\\n        interchainTokenService_ = interchainTokenServiceAddress;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract has been setup.\\n     * @return initialized True if the contract has been setup, false otherwise.\\n     */\\n    function _isInitialized() internal view returns (bool initialized) {\\n        assembly {\\n            initialized := sload(INITIALIZED_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets initialized to true, to allow only a single init.\\n     */\\n    function _initialize() internal {\\n        assembly {\\n            sstore(INITIALIZED_SLOT, true)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the interchain token service\\n     * @return address The interchain token service contract\\n     */\\n    function interchainTokenService() public view override(InterchainTokenStandard, IInterchainToken) returns (address) {\\n        return interchainTokenService_;\\n    }\\n\\n    /**\\n     * @notice Returns the tokenId for this token.\\n     * @return bytes32 The token manager contract.\\n     */\\n    function interchainTokenId() public view override(InterchainTokenStandard, IInterchainToken) returns (bytes32) {\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Setup function to initialize contract parameters.\\n     * @param tokenId_ The tokenId of the token.\\n     * @param minter The address of the token minter.\\n     * @param tokenName The name of the token.\\n     * @param tokenSymbol The symbopl of the token.\\n     * @param tokenDecimals The decimals of the token.\\n     */\\n    function init(bytes32 tokenId_, address minter, string calldata tokenName, string calldata tokenSymbol, uint8 tokenDecimals) external {\\n        if (_isInitialized()) revert AlreadyInitialized();\\n\\n        _initialize();\\n\\n        if (tokenId_ == bytes32(0)) revert TokenIdZero();\\n        if (bytes(tokenName).length == 0) revert TokenNameEmpty();\\n        if (bytes(tokenSymbol).length == 0) revert TokenSymbolEmpty();\\n\\n        name = tokenName;\\n        symbol = tokenSymbol;\\n        decimals = tokenDecimals;\\n        tokenId = tokenId_;\\n\\n        /**\\n         * @dev Set the token service as a minter to allow it to mint and burn tokens.\\n         * Also add the provided address as a minter. If `address(0)` was provided,\\n         * add it as a minter to allow anyone to easily check that no custom minter was set.\\n         */\\n        _addMinter(interchainTokenService_);\\n        _addMinter(minter);\\n\\n        _setNameHash(tokenName);\\n    }\\n\\n    /**\\n     * @notice Function to mint new tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     */\\n    function mint(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @notice Function to burn tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will have its tokens burnt.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @notice A method to be overwritten that will decrease the allowance of the `spender` from `sender` by `amount`.\\n     * @dev Needs to be overwritten. This provides flexibility for the choice of ERC20 implementation used. Must revert if allowance is not sufficient.\\n     */\\n    function _spendAllowance(address sender, address spender, uint256 amount) internal override {\\n        uint256 _allowance = allowance[sender][spender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, spender, _allowance - amount);\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    mapping(address => uint256) public override balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    uint256 public override totalSupply;\\n    uint256 internal constant UINT256_MAX = type(uint256).max;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\\n        uint256 _allowance = allowance[sender][msg.sender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, msg.sender, _allowance - amount);\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        if (sender == address(0) || recipient == address(0)) revert InvalidAccount();\\n\\n        balanceOf[sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        totalSupply += amount;\\n        balanceOf[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        balanceOf[account] -= amount;\\n        totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (owner == address(0) || spender == address(0)) revert InvalidAccount();\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}