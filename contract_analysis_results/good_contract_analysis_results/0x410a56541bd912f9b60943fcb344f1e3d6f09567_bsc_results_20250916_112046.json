{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "_mint(to, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"./IBTCMT.sol\\\";\\n\\ncontract BTCMT is ERC20Burnable, AccessControl, IBTCMT {\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    uint256 private constant _ROUND_LEN = 604800;\\n    uint256 private constant _NUMBER_OF_ROUNDS = 500;\\n\\n    mapping (address => mapping (address => uint256)) public lockedAllowances;\\n    mapping (address => uint256) public index;\\n    mapping (address => TimeAndAmount[]) public allMints;\\n\\n    uint256 private _lockedTotalSupply;\\n    mapping (address => uint256) private _lockedAmounts;\\n    mapping (address => bool) private _farms;\\n\\n    struct TimeAndAmount {\\n        uint256 time;\\n        uint256 total;\\n        uint256 alreadyUnlocked;\\n        uint256 transferredAsLocked;\\n    }\\n \\n    constructor() ERC20(\\\"Minto Bitcoin Hashrate Token\\\", \\\"BTCMT\\\") {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(MINTER_ROLE, _msgSender());\\n    }\\n\\n    function balanceOfSum (address account) external override view returns (uint256) {\\n        return super.balanceOf(account) + _lockedAmounts[account];\\n    }\\n\\n    function balanceOfLocked (address account) external view returns (uint256) {\\n        return _lockedAmounts[account] - _vision(account);\\n    }\\n\\n    function allMintsLength (address account) external view returns (uint256) {\\n        return allMints[account].length;\\n    }\\n\\n    function addFarm (address farm) onlyRole(DEFAULT_ADMIN_ROLE) external {\\n        require(farm != address(0), \\\"Cannot set zero address as farm\\\");\\n        _farms[farm] = true;\\n        emit FarmStatusChanged(farm, true);\\n    }\\n\\n    function removeFarm (address farm) onlyRole(DEFAULT_ADMIN_ROLE) external {\\n        _farms[farm] = false;\\n        emit FarmStatusChanged(farm, false);\\n    }\\n\\n    function mintLocked (address to, uint256 amount, uint256 timeInWeeks) onlyRole(MINTER_ROLE) external {\\n        require(to != address(0), \\\"Cannot mint to zero address\\\");\\n        require(timeInWeeks <= _NUMBER_OF_ROUNDS, \\\"Cannot set this time to unlock\\\");\\n        if (timeInWeeks == 0) {\\n            _mint(to, amount);\\n        }\\n        else {\\n            _lockedTotalSupply += amount;\\n            _lockedAmounts[to] += amount;\\n            uint256 totalToMint = (amount * _NUMBER_OF_ROUNDS) / timeInWeeks;\\n            allMints[to].push (TimeAndAmount(block.timestamp, totalToMint, 0, totalToMint - amount));\\n            emit TransferLocked(address(0), to, amount);\\n        }\\n    }\\n\\n    function burnLocked (uint256 amount) external {\\n        _burnLocked(_msgSender(), amount);\\n    }\\n\\n    function burnFromLocked (address from, uint256 amount) external {\\n        require(lockedAllowances[from][_msgSender()] >= amount, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, _msgSender(), lockedAllowances[from][_msgSender()] - amount);\\n        _burnLocked(from, amount);\\n    }\\n\\n    function approveLocked (address to, uint256 amount) external {\\n        _approveLocked(_msgSender(), to, amount);\\n    }\\n\\n    function increaseLockedAllowance (address to, uint256 amount) external {\\n        _approveLocked(_msgSender(), to, lockedAllowances[_msgSender()][to] + amount);\\n    }\\n\\n    function decreaseLockedAllowance (address to, uint256 amount) external {\\n        require(lockedAllowances[_msgSender()][to] >= amount, \\\"Allowance would be below zero\\\");\\n        _approveLocked(_msgSender(), to, lockedAllowances[_msgSender()][to] - amount);\\n    }\\n\\n    function transferLocked (address to, uint256 amount) external {\\n        require(!(_farms[to]), \\\"Cannot transfer to farm\\\");\\n        _transferLocked(_msgSender(), to, amount);\\n    }\\n\\n    function transferFromLocked (address from, address to, uint256 amount) external {\\n        require(!(_farms[to]), \\\"Cannot transfer to farm\\\");\\n        require(lockedAllowances[from][_msgSender()] >= amount, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, _msgSender(), lockedAllowances[from][_msgSender()] - amount);\\n        _transferLocked(from, to, amount);\\n    }\\n\\n    function transferFarm (address to, uint256 amountLocked, uint256 amountUnlocked, uint256[] calldata farmIndexes) external override returns (uint256[] memory) {\\n        address from = _msgSender();\\n        require(_farms[from], \\\"Sender is not a farm\\\");\\n        _transfer(from, to, amountUnlocked);\\n        uint256[] memory newIndexes = _transferLockedForFarm(from, to, amountLocked, farmIndexes);\\n        if (_lockedAmounts[to] > 0) {\\n            unlock(to, 0);\\n        }\\n        return newIndexes;\\n    }\\n\\n    function transferFromFarm (address from, uint256 amountLocked, uint256 amountUnlocked) external override returns (uint256[] memory) {\\n        address to = _msgSender();\\n        require(_farms[to], \\\"Sender is not a farm\\\");\\n        require(lockedAllowances[from][to] >= amountLocked, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, to, lockedAllowances[from][to] - amountLocked);\\n        uint256 len = allMints[to].length;\\n        _transferLocked(from, to, amountLocked);\\n        uint256[] memory m = new uint256[](allMints[to].length - len);\\n        for (uint256 i = len; i < allMints[to].length; i++) {\\n            m[i - len] = i;\\n        }\\n        transferFrom(from, to, amountUnlocked);\\n        return (m);\\n    }\\n\\n    function totalSupply() public view override(ERC20,IERC20) returns (uint256) {\\n        return super.totalSupply() + _lockedTotalSupply;\\n    }\\n\\n    function balanceOf (address account) public view override(ERC20,IERC20) returns (uint256) {\\n        return super.balanceOf(account) + _vision(account);\\n    }\\n\\n    function unlock (address who, uint256 numberOfBlocks) public {\\n        require(!(_farms[who]), \\\"Cannot unlock farm\\\");\\n        require(_lockedAmounts[who] > 0, \\\"No tokens locked\\\");\\n        uint256 l = allMints[who].length;\\n        uint256 i = index[who];\\n        require(i + numberOfBlocks <= l, \\\"Cannot unlock this many blocks, exceeds length\\\");\\n        uint256 toUnlockTotal = 0;\\n        if (numberOfBlocks == 0 ) {\\n            numberOfBlocks = l;\\n        }\\n        else {\\n            numberOfBlocks += i;\\n        }\\n        for (i; i < numberOfBlocks; i++) {\\n            uint256 _total = allMints[who][i].total;\\n            uint256 _alreadyUnlocked = allMints[who][i].alreadyUnlocked;\\n            uint256 _transferredAsLocked = allMints[who][i].transferredAsLocked;\\n            if ( (_alreadyUnlocked + _transferredAsLocked >= _total) && index[who] == i) {\\n                index[who] = i+1;\\n                delete allMints[who][i];\\n            }\\n            else {\\n                uint256 rounds = ((block.timestamp - allMints[who][i].time) / _ROUND_LEN);\\n                if(rounds > 0) {\\n                    uint256 toUnlock = _total * rounds / _NUMBER_OF_ROUNDS;\\n                    if (_alreadyUnlocked < toUnlock) {\\n                        toUnlock = toUnlock - _alreadyUnlocked;\\n                    }\\n                    else {\\n                        toUnlock = 0;\\n                    }\\n                    if (toUnlock > 0) {\\n                        uint256 allowed = _total - (_transferredAsLocked + _alreadyUnlocked);\\n                        if (allowed > 0) {\\n                            if (toUnlock > allowed){\\n                                toUnlock = allowed;\\n                            }\\n                            allMints[who][i].alreadyUnlocked = _alreadyUnlocked + toUnlock;\\n                            toUnlockTotal += toUnlock;\\n                            if ( (allMints[who][i].alreadyUnlocked + _transferredAsLocked >= _total) && index[who] == i){\\n                                index[who] = i+1;\\n                                delete allMints[who][i];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        _lockedAmounts[who] -= toUnlockTotal;\\n        _lockedTotalSupply -= toUnlockTotal;\\n        emit TransferLocked(who, address(0), toUnlockTotal);\\n        _mint(who, toUnlockTotal);\\n    }\\n\\n    function _beforeTokenTransfer (address from, address to, uint256 amount) internal override {\\n        super._beforeTokenTransfer(from, to, amount);\\n        if (from != address(0) && !(_farms[from]) && !(_farms[to]) && super.balanceOf(from) < amount && _lockedAmounts[from] > 0) {\\n            unlock(from, 0);\\n        }\\n    }\\n\\n    function _vision (address who) private view returns (uint256) {\\n        uint256 toUnlockTotal = 0;\\n        for (uint256 i = index[who]; i < allMints[who].length; i++) {\\n            uint256 _total = allMints[who][i].total;\\n            uint256 _alreadyUnlocked = allMints[who][i].alreadyUnlocked;\\n            uint256 _transferredAsLocked = allMints[who][i].transferredAsLocked;\\n            uint256 rounds = ((block.timestamp - allMints[who][i].time) / _ROUND_LEN);\\n            if(rounds > 0) {\\n                uint256 toUnlock = _total * rounds / _NUMBER_OF_ROUNDS;\\n                if (_alreadyUnlocked < toUnlock) {\\n                    toUnlock = toUnlock - _alreadyUnlocked;\\n                }\\n                else {\\n                    toUnlock = 0;\\n                }\\n                if (toUnlock > 0) {\\n                    uint256 allowed = _total - (_transferredAsLocked + _alreadyUnlocked);\\n                    if (allowed > 0) {\\n                        if (toUnlock > allowed){\\n                            toUnlock = allowed;\\n                        }\\n                        toUnlockTotal += toUnlock;\\n                    }\\n                }\\n            }\\n        }\\n        return toUnlockTotal;\\n    }\\n\\n    function _burnLocked (address from, uint256 amount) private {\\n        require(from != address(0), \\\"Cannot burn from zero address\\\");\\n        unlock(from, 0);\\n        require(_lockedAmounts[from] >= amount, \\\"Not enough locked token to burn\\\");\\n        _burnLoop(from, address(0), amount);\\n    }\\n\\n    function _approveLocked (address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"Cannot approve from zero address\\\");\\n        require(to != address(0), \\\"Cannot approve to zero address\\\");\\n        lockedAllowances[from][to] = amount;\\n        emit ApprovalLocked(from, to, amount);\\n    }\\n\\n    function _transferLocked (address from, address to, uint256 amount) private {\\n        uint256[] memory indexes = new uint256[](0);\\n        _transferLockedForFarm(from, to, amount, indexes);\\n    }\\n\\n    function _transferLockedForFarm (address from, address to, uint256 amount, uint256[] memory indexes) private returns (uint256[] memory newIndexes) {\\n        require(from != address(0), \\\"Cannot transfer from zero address\\\");\\n        require(to != address(0), \\\"Cannot transfer to zero address\\\");\\n        if (!(_farms[from]) && _lockedAmounts[from] > 0){\\n            unlock(from, 0);\\n        }\\n        require(_lockedAmounts[from] >= amount, \\\"Not enough locked token to transfer\\\");\\n        if (_farms[from]) {\\n            newIndexes = _burnLoopForFarm(from, to, amount, indexes);\\n            return newIndexes;\\n        }\\n        else {\\n            _burnLoop(from, to, amount);\\n        }\\n    }\\n\\n    function _burnLoop (address from, address to, uint256 amount) private {\\n        uint256[] memory indexes = new uint256[](0);\\n        _burnLoopForFarm(from, to, amount, indexes);\\n    }\\n\\n    function _burnLoopForFarm (address from, address to, uint256 amount, uint256[] memory indexes) private returns (uint256[] memory newIndexes){\\n        _lockedAmounts[from] -= amount;\\n        if (to == address(0)) {\\n            _lockedTotalSupply -= amount;\\n        }\\n        else {\\n            _lockedAmounts[to] += amount;\\n        }\\n        emit TransferLocked(from, to, amount);\\n        bool farmWithdrawal = false;\\n        uint256 i;\\n        if (_farms[from]) {\\n            farmWithdrawal = true;\\n        }\\n        if (farmWithdrawal) {\\n            i = indexes.length;\\n        }\\n        else {\\n            i = allMints[from].length;\\n        }\\n        for (i; i > 0; i--) {\\n            if (amount > 0) {\\n                uint256 _time;\\n                uint256 _total;\\n                uint256 _alreadyUnlocked;\\n                uint256 _transferredAsLocked;\\n                uint256 avaliable;\\n                if (farmWithdrawal) {\\n                    _time = allMints[from][indexes[i-1]].time;\\n                    _total = allMints[from][indexes[i-1]].total;\\n                    _alreadyUnlocked = allMints[from][indexes[i-1]].alreadyUnlocked;\\n                    _transferredAsLocked = allMints[from][indexes[i-1]].transferredAsLocked;\\n                    avaliable = _total - (_alreadyUnlocked + _transferredAsLocked);\\n                }\\n                else {\\n                    _time = allMints[from][i-1].time;\\n                    _total = allMints[from][i-1].total;\\n                    _alreadyUnlocked = allMints[from][i-1].alreadyUnlocked;\\n                    _transferredAsLocked = allMints[from][i-1].transferredAsLocked;\\n                    avaliable = _total - (_alreadyUnlocked + _transferredAsLocked);\\n                }\\n                if (avaliable > 0) {\\n                    uint256 toTransfer;\\n                    if (avaliable > amount) {\\n                        toTransfer = amount;\\n                    }\\n                    else {\\n                        toTransfer = avaliable;\\n                    }\\n                    amount -= toTransfer;\\n                    if (to != address(0)) {\\n                        allMints[to].push (TimeAndAmount (_time, _total, _alreadyUnlocked + (avaliable - toTransfer), _transferredAsLocked));\\n                    }\\n                    if (farmWithdrawal) {\\n                        allMints[from][indexes[i-1]].transferredAsLocked = _transferredAsLocked + toTransfer;\\n                    }\\n                    else {\\n                        allMints[from][i-1].transferredAsLocked = _transferredAsLocked + toTransfer;\\n                    }\\n                }\\n            }\\n        }\\n        if (farmWithdrawal) {\\n            uint256 l = indexes.length;\\n            newIndexes = new uint256[](l);\\n            if (l > 0) {\\n                uint256 indexu = 0;\\n                for (i=0; i < l; i++) {\\n                    if ((allMints[from][indexes[i]].alreadyUnlocked + allMints[from][indexes[i]].transferredAsLocked) >= allMints[from][indexes[i]].total) {\\n                        delete allMints[from][indexes[i]];\\n                    }\\n                    else {\\n                        newIndexes[indexu]=indexes[i];\\n                        indexu++;\\n                    }\\n                }\\n                uint256 toReduce = l - indexu;\\n                assembly { mstore(newIndexes, sub(mload(newIndexes), toReduce)) }\\n            }\\n            return newIndexes;\\n        }\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(who, tounlocktotal)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"./IBTCMT.sol\\\";\\n\\ncontract BTCMT is ERC20Burnable, AccessControl, IBTCMT {\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n    uint256 private constant _ROUND_LEN = 604800;\\n    uint256 private constant _NUMBER_OF_ROUNDS = 500;\\n\\n    mapping (address => mapping (address => uint256)) public lockedAllowances;\\n    mapping (address => uint256) public index;\\n    mapping (address => TimeAndAmount[]) public allMints;\\n\\n    uint256 private _lockedTotalSupply;\\n    mapping (address => uint256) private _lockedAmounts;\\n    mapping (address => bool) private _farms;\\n\\n    struct TimeAndAmount {\\n        uint256 time;\\n        uint256 total;\\n        uint256 alreadyUnlocked;\\n        uint256 transferredAsLocked;\\n    }\\n \\n    constructor() ERC20(\\\"Minto Bitcoin Hashrate Token\\\", \\\"BTCMT\\\") {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(MINTER_ROLE, _msgSender());\\n    }\\n\\n    function balanceOfSum (address account) external override view returns (uint256) {\\n        return super.balanceOf(account) + _lockedAmounts[account];\\n    }\\n\\n    function balanceOfLocked (address account) external view returns (uint256) {\\n        return _lockedAmounts[account] - _vision(account);\\n    }\\n\\n    function allMintsLength (address account) external view returns (uint256) {\\n        return allMints[account].length;\\n    }\\n\\n    function addFarm (address farm) onlyRole(DEFAULT_ADMIN_ROLE) external {\\n        require(farm != address(0), \\\"Cannot set zero address as farm\\\");\\n        _farms[farm] = true;\\n        emit FarmStatusChanged(farm, true);\\n    }\\n\\n    function removeFarm (address farm) onlyRole(DEFAULT_ADMIN_ROLE) external {\\n        _farms[farm] = false;\\n        emit FarmStatusChanged(farm, false);\\n    }\\n\\n    function mintLocked (address to, uint256 amount, uint256 timeInWeeks) onlyRole(MINTER_ROLE) external {\\n        require(to != address(0), \\\"Cannot mint to zero address\\\");\\n        require(timeInWeeks <= _NUMBER_OF_ROUNDS, \\\"Cannot set this time to unlock\\\");\\n        if (timeInWeeks == 0) {\\n            _mint(to, amount);\\n        }\\n        else {\\n            _lockedTotalSupply += amount;\\n            _lockedAmounts[to] += amount;\\n            uint256 totalToMint = (amount * _NUMBER_OF_ROUNDS) / timeInWeeks;\\n            allMints[to].push (TimeAndAmount(block.timestamp, totalToMint, 0, totalToMint - amount));\\n            emit TransferLocked(address(0), to, amount);\\n        }\\n    }\\n\\n    function burnLocked (uint256 amount) external {\\n        _burnLocked(_msgSender(), amount);\\n    }\\n\\n    function burnFromLocked (address from, uint256 amount) external {\\n        require(lockedAllowances[from][_msgSender()] >= amount, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, _msgSender(), lockedAllowances[from][_msgSender()] - amount);\\n        _burnLocked(from, amount);\\n    }\\n\\n    function approveLocked (address to, uint256 amount) external {\\n        _approveLocked(_msgSender(), to, amount);\\n    }\\n\\n    function increaseLockedAllowance (address to, uint256 amount) external {\\n        _approveLocked(_msgSender(), to, lockedAllowances[_msgSender()][to] + amount);\\n    }\\n\\n    function decreaseLockedAllowance (address to, uint256 amount) external {\\n        require(lockedAllowances[_msgSender()][to] >= amount, \\\"Allowance would be below zero\\\");\\n        _approveLocked(_msgSender(), to, lockedAllowances[_msgSender()][to] - amount);\\n    }\\n\\n    function transferLocked (address to, uint256 amount) external {\\n        require(!(_farms[to]), \\\"Cannot transfer to farm\\\");\\n        _transferLocked(_msgSender(), to, amount);\\n    }\\n\\n    function transferFromLocked (address from, address to, uint256 amount) external {\\n        require(!(_farms[to]), \\\"Cannot transfer to farm\\\");\\n        require(lockedAllowances[from][_msgSender()] >= amount, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, _msgSender(), lockedAllowances[from][_msgSender()] - amount);\\n        _transferLocked(from, to, amount);\\n    }\\n\\n    function transferFarm (address to, uint256 amountLocked, uint256 amountUnlocked, uint256[] calldata farmIndexes) external override returns (uint256[] memory) {\\n        address from = _msgSender();\\n        require(_farms[from], \\\"Sender is not a farm\\\");\\n        _transfer(from, to, amountUnlocked);\\n        uint256[] memory newIndexes = _transferLockedForFarm(from, to, amountLocked, farmIndexes);\\n        if (_lockedAmounts[to] > 0) {\\n            unlock(to, 0);\\n        }\\n        return newIndexes;\\n    }\\n\\n    function transferFromFarm (address from, uint256 amountLocked, uint256 amountUnlocked) external override returns (uint256[] memory) {\\n        address to = _msgSender();\\n        require(_farms[to], \\\"Sender is not a farm\\\");\\n        require(lockedAllowances[from][to] >= amountLocked, \\\"Not enough locked token allowance\\\");\\n        _approveLocked(from, to, lockedAllowances[from][to] - amountLocked);\\n        uint256 len = allMints[to].length;\\n        _transferLocked(from, to, amountLocked);\\n        uint256[] memory m = new uint256[](allMints[to].length - len);\\n        for (uint256 i = len; i < allMints[to].length; i++) {\\n            m[i - len] = i;\\n        }\\n        transferFrom(from, to, amountUnlocked);\\n        return (m);\\n    }\\n\\n    function totalSupply() public view override(ERC20,IERC20) returns (uint256) {\\n        return super.totalSupply() + _lockedTotalSupply;\\n    }\\n\\n    function balanceOf (address account) public view override(ERC20,IERC20) returns (uint256) {\\n        return super.balanceOf(account) + _vision(account);\\n    }\\n\\n    function unlock (address who, uint256 numberOfBlocks) public {\\n        require(!(_farms[who]), \\\"Cannot unlock farm\\\");\\n        require(_lockedAmounts[who] > 0, \\\"No tokens locked\\\");\\n        uint256 l = allMints[who].length;\\n        uint256 i = index[who];\\n        require(i + numberOfBlocks <= l, \\\"Cannot unlock this many blocks, exceeds length\\\");\\n        uint256 toUnlockTotal = 0;\\n        if (numberOfBlocks == 0 ) {\\n            numberOfBlocks = l;\\n        }\\n        else {\\n            numberOfBlocks += i;\\n        }\\n        for (i; i < numberOfBlocks; i++) {\\n            uint256 _total = allMints[who][i].total;\\n            uint256 _alreadyUnlocked = allMints[who][i].alreadyUnlocked;\\n            uint256 _transferredAsLocked = allMints[who][i].transferredAsLocked;\\n            if ( (_alreadyUnlocked + _transferredAsLocked >= _total) && index[who] == i) {\\n                index[who] = i+1;\\n                delete allMints[who][i];\\n            }\\n            else {\\n                uint256 rounds = ((block.timestamp - allMints[who][i].time) / _ROUND_LEN);\\n                if(rounds > 0) {\\n                    uint256 toUnlock = _total * rounds / _NUMBER_OF_ROUNDS;\\n                    if (_alreadyUnlocked < toUnlock) {\\n                        toUnlock = toUnlock - _alreadyUnlocked;\\n                    }\\n                    else {\\n                        toUnlock = 0;\\n                    }\\n                    if (toUnlock > 0) {\\n                        uint256 allowed = _total - (_transferredAsLocked + _alreadyUnlocked);\\n                        if (allowed > 0) {\\n                            if (toUnlock > allowed){\\n                                toUnlock = allowed;\\n                            }\\n                            allMints[who][i].alreadyUnlocked = _alreadyUnlocked + toUnlock;\\n                            toUnlockTotal += toUnlock;\\n                            if ( (allMints[who][i].alreadyUnlocked + _transferredAsLocked >= _total) && index[who] == i){\\n                                index[who] = i+1;\\n                                delete allMints[who][i];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        _lockedAmounts[who] -= toUnlockTotal;\\n        _lockedTotalSupply -= toUnlockTotal;\\n        emit TransferLocked(who, address(0), toUnlockTotal);\\n        _mint(who, toUnlockTotal);\\n    }\\n\\n    function _beforeTokenTransfer (address from, address to, uint256 amount) internal override {\\n        super._beforeTokenTransfer(from, to, amount);\\n        if (from != address(0) && !(_farms[from]) && !(_farms[to]) && super.balanceOf(from) < amount && _lockedAmounts[from] > 0) {\\n            unlock(from, 0);\\n        }\\n    }\\n\\n    function _vision (address who) private view returns (uint256) {\\n        uint256 toUnlockTotal = 0;\\n        for (uint256 i = index[who]; i < allMints[who].length; i++) {\\n            uint256 _total = allMints[who][i].total;\\n            uint256 _alreadyUnlocked = allMints[who][i].alreadyUnlocked;\\n            uint256 _transferredAsLocked = allMints[who][i].transferredAsLocked;\\n            uint256 rounds = ((block.timestamp - allMints[who][i].time) / _ROUND_LEN);\\n            if(rounds > 0) {\\n                uint256 toUnlock = _total * rounds / _NUMBER_OF_ROUNDS;\\n                if (_alreadyUnlocked < toUnlock) {\\n                    toUnlock = toUnlock - _alreadyUnlocked;\\n                }\\n                else {\\n                    toUnlock = 0;\\n                }\\n                if (toUnlock > 0) {\\n                    uint256 allowed = _total - (_transferredAsLocked + _alreadyUnlocked);\\n                    if (allowed > 0) {\\n                        if (toUnlock > allowed){\\n                            toUnlock = allowed;\\n                        }\\n                        toUnlockTotal += toUnlock;\\n                    }\\n                }\\n            }\\n        }\\n        return toUnlockTotal;\\n    }\\n\\n    function _burnLocked (address from, uint256 amount) private {\\n        require(from != address(0), \\\"Cannot burn from zero address\\\");\\n        unlock(from, 0);\\n        require(_lockedAmounts[from] >= amount, \\\"Not enough locked token to burn\\\");\\n        _burnLoop(from, address(0), amount);\\n    }\\n\\n    function _approveLocked (address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"Cannot approve from zero address\\\");\\n        require(to != address(0), \\\"Cannot approve to zero address\\\");\\n        lockedAllowances[from][to] = amount;\\n        emit ApprovalLocked(from, to, amount);\\n    }\\n\\n    function _transferLocked (address from, address to, uint256 amount) private {\\n        uint256[] memory indexes = new uint256[](0);\\n        _transferLockedForFarm(from, to, amount, indexes);\\n    }\\n\\n    function _transferLockedForFarm (address from, address to, uint256 amount, uint256[] memory indexes) private returns (uint256[] memory newIndexes) {\\n        require(from != address(0), \\\"Cannot transfer from zero address\\\");\\n        require(to != address(0), \\\"Cannot transfer to zero address\\\");\\n        if (!(_farms[from]) && _lockedAmounts[from] > 0){\\n            unlock(from, 0);\\n        }\\n        require(_lockedAmounts[from] >= amount, \\\"Not enough locked token to transfer\\\");\\n        if (_farms[from]) {\\n            newIndexes = _burnLoopForFarm(from, to, amount, indexes);\\n            return newIndexes;\\n        }\\n        else {\\n            _burnLoop(from, to, amount);\\n        }\\n    }\\n\\n    function _burnLoop (address from, address to, uint256 amount) private {\\n        uint256[] memory indexes = new uint256[](0);\\n        _burnLoopForFarm(from, to, amount, indexes);\\n    }\\n\\n    function _burnLoopForFarm (address from, address to, uint256 amount, uint256[] memory indexes) private returns (uint256[] memory newIndexes){\\n        _lockedAmounts[from] -= amount;\\n        if (to == address(0)) {\\n            _lockedTotalSupply -= amount;\\n        }\\n        else {\\n            _lockedAmounts[to] += amount;\\n        }\\n        emit TransferLocked(from, to, amount);\\n        bool farmWithdrawal = false;\\n        uint256 i;\\n        if (_farms[from]) {\\n            farmWithdrawal = true;\\n        }\\n        if (farmWithdrawal) {\\n            i = indexes.length;\\n        }\\n        else {\\n            i = allMints[from].length;\\n        }\\n        for (i; i > 0; i--) {\\n            if (amount > 0) {\\n                uint256 _time;\\n                uint256 _total;\\n                uint256 _alreadyUnlocked;\\n                uint256 _transferredAsLocked;\\n                uint256 avaliable;\\n                if (farmWithdrawal) {\\n                    _time = allMints[from][indexes[i-1]].time;\\n                    _total = allMints[from][indexes[i-1]].total;\\n                    _alreadyUnlocked = allMints[from][indexes[i-1]].alreadyUnlocked;\\n                    _transferredAsLocked = allMints[from][indexes[i-1]].transferredAsLocked;\\n                    avaliable = _total - (_alreadyUnlocked + _transferredAsLocked);\\n                }\\n                else {\\n                    _time = allMints[from][i-1].time;\\n                    _total = allMints[from][i-1].total;\\n                    _alreadyUnlocked = allMints[from][i-1].alreadyUnlocked;\\n                    _transferredAsLocked = allMints[from][i-1].transferredAsLocked;\\n                    avaliable = _total - (_alreadyUnlocked + _transferredAsLocked);\\n                }\\n                if (avaliable > 0) {\\n                    uint256 toTransfer;\\n                    if (avaliable > amount) {\\n                        toTransfer = amount;\\n                    }\\n                    else {\\n                        toTransfer = avaliable;\\n                    }\\n                    amount -= toTransfer;\\n                    if (to != address(0)) {\\n                        allMints[to].push (TimeAndAmount (_time, _total, _alreadyUnlocked + (avaliable - toTransfer), _transferredAsLocked));\\n                    }\\n                    if (farmWithdrawal) {\\n                        allMints[from][indexes[i-1]].transferredAsLocked = _transferredAsLocked + toTransfer;\\n                    }\\n                    else {\\n                        allMints[from][i-1].transferredAsLocked = _transferredAsLocked + toTransfer;\\n                    }\\n                }\\n            }\\n        }\\n        if (farmWithdrawal) {\\n            uint256 l = indexes.length;\\n            newIndexes = new uint256[](l);\\n            if (l > 0) {\\n                uint256 indexu = 0;\\n                for (i=0; i < l; i++) {\\n                    if ((allMints[from][indexes[i]].alreadyUnlocked + allMints[from][indexes[i]].transferredAsLocked) >= allMints[from][indexes[i]].total) {\\n                        delete allMints[from][indexes[i]];\\n                    }\\n                    else {\\n                        newIndexes[indexu]=indexes[i];\\n                        indexu++;\\n                    }\\n                }\\n                uint256 toReduce = l - indexu;\\n                assembly { mstore(newIndexes, sub(mload(newIndexes), toReduce)) }\\n            }\\n            return newIndexes;\\n        }\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}