{
  "total_matches": 6,
  "patterns_found": {
    "minting_mechanics": {
      "count": 6,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// join.sol -- Basic token adapters\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface GemLike {\\r\\n    function decimals() external view returns (uint);\\r\\n    function transfer(address,uint) external returns (bool);\\r\\n    function transferFrom(address,address,uint) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface DSTokenLike {\\r\\n    function mint(address,uint) external;\\r\\n    function burn(address,uint) external;\\r\\n}\\r\\n\\r\\ninterface VatLike {\\r\\n    function slip(bytes32,address,int) external;\\r\\n    function move(address,address,uint) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n    Here we provide *adapters* to connect the Vat to arbitrary external\\r\\n    token implementations, creating a bounded context for the Vat. The\\r\\n    adapters here are provided as working examples:\\r\\n\\r\\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\\r\\n                   semantics.\\r\\n\\r\\n      - `ETHJoin`: For native Ether.\\r\\n\\r\\n      - `USBJoin`: For connecting internal USB balances to an external\\r\\n                   `DSToken` implementation.\\r\\n\\r\\n    In practice, adapter implementations will be varied and specific to\\r\\n    individual collateral types, accounting for different transfer\\r\\n    semantics and token standards.\\r\\n\\r\\n    Adapters need to implement two basic methods:\\r\\n\\r\\n      - `join`: enter collateral into the system\\r\\n      - `exit`: remove collateral from the system\\r\\n\\r\\n*/\\r\\n\\r\\ncontract GemJoin {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth {\\r\\n        wards[usr] = 1;\\r\\n        emit Rely(usr);\\r\\n    }\\r\\n    function deny(address usr) external auth {\\r\\n        wards[usr] = 0;\\r\\n        emit Deny(usr);\\r\\n    }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"GemJoin/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    VatLike public vat;   // CDP Engine\\r\\n    bytes32 public ilk;   // Collateral Type\\r\\n    GemLike public gem;\\r\\n    uint    public dec;\\r\\n    uint    public live;  // Active Flag\\r\\n\\r\\n    // Events\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n    event Join(address indexed usr, uint256 wad);\\r\\n    event Exit(address indexed usr, uint256 wad);\\r\\n    event Cage();\\r\\n\\r\\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        ilk = ilk_;\\r\\n        gem = GemLike(gem_);\\r\\n        dec = gem.decimals();\\r\\n        emit Rely(msg.sender);\\r\\n    }\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        emit Cage();\\r\\n    }\\r\\n    function join(address usr, uint wad) external {\\r\\n        require(live == 1, \\\"GemJoin/not-live\\\");\\r\\n        require(int(wad) >= 0, \\\"GemJoin/overflow\\\");\\r\\n        vat.slip(ilk, usr, int(wad));\\r\\n        require(gem.transferFrom(msg.sender, address(this), wad), \\\"GemJoin/failed-transfer\\\");\\r\\n        emit Join(usr, wad);\\r\\n    }\\r\\n    function exit(address usr, uint wad) external {\\r\\n        require(wad <= 2 ** 255, \\\"GemJoin/overflow\\\");\\r\\n        vat.slip(ilk, msg.sender, -int(wad));\\r\\n        require(gem.transfer(usr, wad), \\\"GemJoin/failed-transfer\\\");\\r\\n        emit Exit(usr, wad);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract USBJoin {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth {\\r\\n        wards[usr] = 1;\\r\\n        emit Rely(usr);\\r\\n    }\\r\\n    function deny(address usr) external auth {\\r\\n        wards[usr] = 0;\\r\\n        emit Deny(usr);\\r\\n    }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"USBJoin/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    VatLike public vat;      // CDP Engine\\r\\n    DSTokenLike public USB;  // Stablecoin Token\\r\\n    uint    public live;     // Active Flag\\r\\n\\r\\n    // Events\\r\\n    event Rely(address indexed usr);\\r\\n    event Deny(address indexed usr);\\r\\n    event Join(address indexed usr, uint256 wad);\\r\\n    event Exit(address indexed usr, uint256 wad);\\r\\n    event Cage();\\r\\n\\r\\n    constructor(address vat_, address USB_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        live = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        USB = DSTokenLike(USB_);\\r\\n    }\\r\\n    function cage() external auth {\\r\\n        live = 0;\\r\\n        emit Cage();\\r\\n    }\\r\\n    uint constant ONE = 10 ** 27;\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function join(address usr, uint wad) external {\\r\\n        vat.move(address(this), usr, mul(ONE, wad));\\r\\n        USB.burn(msg.sender, wad);\\r\\n        emit Join(usr, wad);\\r\\n    }\\r\\n    function exit(address usr, uint wad) external {\\r\\n        require(live == 1, \\\"USBJoin/not-live\\\");\\r\\n        vat.move(msg.sender, address(this), mul(ONE, wad));\\r\\n        USB.mint(usr, wad);\\r\\n        emit Exit(usr, wad);\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// flop.sol -- Debt auction\\r\\n\\r\\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\\r\\n//\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ninterface VatLike {\\r\\n    function move(address,address,uint) external;\\r\\n    function suck(address,address,uint) external;\\r\\n}\\r\\ninterface GemLike {\\r\\n    function mint(address,uint) external;\\r\\n}\\r\\ninterface VowLike {\\r\\n    function Ash() external returns (uint);\\r\\n    function kiss(uint) external;\\r\\n}\\r\\n\\r\\n/*\\r\\n   This thing creates gems on demand in return for USB.\\r\\n\\r\\n - `lot` gems in return for bid\\r\\n - `bid` USB paid\\r\\n - `gal` receives USB income\\r\\n - `ttl` single bid lifetime\\r\\n - `beg` minimum bid increase\\r\\n - `end` max auction duration\\r\\n*/\\r\\n\\r\\ncontract Flopper {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address usr) external auth { wards[usr] = 1; }\\r\\n    function deny(address usr) external auth { wards[usr] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"Flopper/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- Data ---\\r\\n    struct Bid {\\r\\n        uint256 bid;  // USB paid                [rad]\\r\\n        uint256 lot;  // gems in return for bid  [wad]\\r\\n        address guy;  // high bidder\\r\\n        uint48  tic;  // bid expiry time         [unix epoch time]\\r\\n        uint48  end;  // auction expiry time     [unix epoch time]\\r\\n    }\\r\\n\\r\\n    mapping (uint => Bid) public bids;\\r\\n\\r\\n    VatLike  public   vat;  // CDP Engine\\r\\n    GemLike  public   gem;\\r\\n\\r\\n    uint256  constant ONE = 1.00E18;\\r\\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\\r\\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\\r\\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime         [seconds]\\r\\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\\r\\n    uint256  public kicks = 0;\\r\\n    uint256  public live;             // Active Flag\\r\\n    address  public vow;              // not used until shutdown\\r\\n\\r\\n    // --- Events ---\\r\\n    event Kick(\\r\\n      uint256 id,\\r\\n      uint256 lot,\\r\\n      uint256 bid,\\r\\n      address indexed gal\\r\\n    );\\r\\n\\r\\n    // --- Init ---\\r\\n    constructor(address vat_, address gem_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        vat = VatLike(vat_);\\r\\n        gem = GemLike(gem_);\\r\\n        live = 1;\\r\\n    }\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\r\\n        require(y == 0 || (z = x * y) / y == x);\\r\\n    }\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        if (x > y) { z = y; } else { z = x; }\\r\\n    }\\r\\n\\r\\n    // --- Admin ---\\r\\n    function file(bytes32 what, uint data) external auth {\\r\\n        if (what == \\\"beg\\\") beg = data;\\r\\n        else if (what == \\\"pad\\\") pad = data;\\r\\n        else if (what == \\\"ttl\\\") ttl = uint48(data);\\r\\n        else if (what == \\\"tau\\\") tau = uint48(data);\\r\\n        else revert(\\\"Flopper/file-unrecognized-param\\\");\\r\\n    }\\r\\n\\r\\n    // --- Auction ---\\r\\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(kicks < type(uint256).max, \\\"Flopper/overflow\\\");\\r\\n        id = ++kicks;\\r\\n\\r\\n        bids[id].bid = bid;\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].guy = gal;\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n\\r\\n        emit Kick(id, lot, bid, gal);\\r\\n    }\\r\\n    function tick(uint id) external {\\r\\n        require(bids[id].end < block.timestamp, \\\"Flopper/not-finished\\\");\\r\\n        require(bids[id].tic == 0, \\\"Flopper/bid-already-placed\\\");\\r\\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\\r\\n        bids[id].end = add(uint48(block.timestamp), tau);\\r\\n    }\\r\\n    function dent(uint id, uint lot, uint bid) external {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flopper/guy-not-set\\\");\\r\\n        require(bids[id].tic > block.timestamp || bids[id].tic == 0, \\\"Flopper/already-finished-tic\\\");\\r\\n        require(bids[id].end > block.timestamp, \\\"Flopper/already-finished-end\\\");\\r\\n\\r\\n        require(bid == bids[id].bid, \\\"Flopper/not-matching-bid\\\");\\r\\n        require(lot <  bids[id].lot, \\\"Flopper/lot-not-lower\\\");\\r\\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \\\"Flopper/insufficient-decrease\\\");\\r\\n\\r\\n        if (msg.sender != bids[id].guy) {\\r\\n            vat.move(msg.sender, bids[id].guy, bid);\\r\\n\\r\\n            // on first dent, clear as much Ash as possible\\r\\n            if (bids[id].tic == 0) {\\r\\n                uint Ash = VowLike(bids[id].guy).Ash();\\r\\n                VowLike(bids[id].guy).kiss(min(bid, Ash));\\r\\n            }\\r\\n\\r\\n            bids[id].guy = msg.sender;\\r\\n        }\\r\\n\\r\\n        bids[id].lot = lot;\\r\\n        bids[id].tic = add(uint48(block.timestamp), ttl);\\r\\n    }\\r\\n    function deal(uint id) external {\\r\\n        require(live == 1, \\\"Flopper/not-live\\\");\\r\\n        require(bids[id].tic != 0 && (bids[id].tic < block.timestamp || bids[id].end < block.timestamp), \\\"Flopper/not-finished\\\");\\r\\n        gem.mint(bids[id].guy, bids[id].lot);\\r\\n        delete bids[id];\\r\\n    }\\r\\n\\r\\n    // --- Shutdown ---\\r\\n    function cage() external auth {\\r\\n       live = 0;\\r\\n       vow = msg.sender;\\r\\n    }\\r\\n    function yank(uint id) external {\\r\\n        require(live == 0, \\\"Flopper/still-live\\\");\\r\\n        require(bids[id].guy != address(0), \\\"Flopper/guy-not-set\\\");\\r\\n        vat.suck(vow, bids[id].guy, bids[id].bid);\\r\\n        delete bids[id];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ncontract USB {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address guy) external auth { wards[guy] = 1; }\\r\\n    function deny(address guy) external auth { wards[guy] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"USB/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- ERC20 Data ---\\r\\n    string  public constant name     = \\\"USB Stablecoin\\\";\\r\\n    string  public constant symbol   = \\\"USB\\\";\\r\\n    string  public constant version  = \\\"1\\\";\\r\\n    uint8   public constant decimals = 18;\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping (address => uint)                      public balanceOf;\\r\\n    mapping (address => mapping (address => uint)) public allowance;\\r\\n    mapping (address => uint)                      public nonces;\\r\\n\\r\\n    event Approval(address indexed src, address indexed guy, uint wad);\\r\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n\\r\\n    // --- EIP712 niceties ---\\r\\n    bytes32 public DOMAIN_SEPARATOR;\\r\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\r\\n\\r\\n    constructor(uint256 chainId_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\r\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n            keccak256(bytes(name)),\\r\\n            keccak256(bytes(version)),\\r\\n            chainId_,\\r\\n            address(this)\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    // --- Token ---\\r\\n    function transfer(address dst, uint wad) external returns (bool) {\\r\\n        return transferFrom(msg.sender, dst, wad);\\r\\n    }\\r\\n    function transferFrom(address src, address dst, uint wad)\\r\\n        public returns (bool)\\r\\n    {\\r\\n        require(balanceOf[src] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[src][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[src] = sub(balanceOf[src], wad);\\r\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\r\\n        emit Transfer(src, dst, wad);\\r\\n        return true;\\r\\n    }\\r\\n    function mint(address usr, uint wad) external auth {\\r\\n        balanceOf[usr] = add(balanceOf[usr], wad);\\r\\n        totalSupply    = add(totalSupply, wad);\\r\\n        emit Transfer(address(0), usr, wad);\\r\\n    }\\r\\n    function burn(address usr, uint wad) external {\\r\\n        require(balanceOf[usr] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (usr != msg.sender && allowance[usr][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[usr][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[usr] = sub(balanceOf[usr], wad);\\r\\n        totalSupply    = sub(totalSupply, wad);\\r\\n        emit Transfer(usr, address(0), wad);\\r\\n    }\\r\\n    function approve(address usr, uint wad) external returns (bool) {\\r\\n        allowance[msg.sender][usr] = wad;\\r\\n        emit Approval(msg.sender, usr, wad);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // --- Alias ---\\r\\n    function push(address usr, uint wad) external {\\r\\n        transferFrom(msg.sender, usr, wad);\\r\\n    }\\r\\n    function pull(address usr, uint wad) external {\\r\\n        transferFrom(usr, msg.sender, wad);\\r\\n    }\\r\\n    function move(address src, address dst, uint wad) external {\\r\\n        transferFrom(src, dst, wad);\\r\\n    }\\r\\n\\r\\n    // --- Approve by signature ---\\r\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\\r\\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\\r\\n    {\\r\\n        bytes32 digest =\\r\\n            keccak256(abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR,\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH,\\r\\n                                     holder,\\r\\n                                     spender,\\r\\n                                     nonce,\\r\\n                                     expiry,\\r\\n                                     allowed))\\r\\n        ));\\r\\n\\r\\n        require(holder != address(0), \\\"USB/invalid-address-0\\\");\\r\\n        require(holder == ecrecover(digest, v, r, s), \\\"USB/invalid-permit\\\");\\r\\n        require(expiry == 0 || block.timestamp <= expiry, \\\"USB/permit-expired\\\");\\r\\n        require(nonce == nonces[holder]++, \\\"USB/invalid-nonce\\\");\\r\\n        uint wad = allowed ? type(uint256).max : 0;\\r\\n        allowance[holder][spender] = wad;\\r\\n        emit Approval(holder, spender, wad);\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"/// token.sol -- ERC20 implementation with minting and burning\\n\\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.23;\\n\\ninterface DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) external view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(address(0))) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\\ncontract DSToken is DSMath, DSAuth {\\n    bool                                              public  stopped;\\n    uint256                                           public  totalSupply;\\n    mapping (address => uint256)                      public  balanceOf;\\n    mapping (address => mapping (address => uint256)) public  allowance;\\n    string                                            public  symbol;\\n    uint8                                             public  decimals = 18; // standard token precision. override to customize\\n    string                                            public  name = \\\"\\\";     // Optional token name\\n\\n\\n    constructor(string memory symbol_) public {\\n        symbol = symbol_;\\n    }\\n\\n    event Approval(address indexed src, address indexed guy, uint wad);\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\n    event Mint(address indexed guy, uint wad);\\n    event Burn(address indexed guy, uint wad);\\n    event Stop();\\n    event Start();\\n\\n    modifier stoppable {\\n        require(!stopped, \\\"ds-stop-is-stopped\\\");\\n        _;\\n    }\\n\\n    function approve(address guy) external returns (bool) {\\n        return approve(guy, type(uint256).max);\\n    }\\n\\n    function approve(address guy, uint wad) public stoppable returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n\\n        emit Approval(msg.sender, guy, wad);\\n\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint wad) external returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        stoppable\\n        returns (bool)\\n    {\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\n            require(allowance[src][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[src] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[src] = sub(balanceOf[src], wad);\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function push(address dst, uint wad) external {\\n        transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function pull(address src, uint wad) external {\\n        transferFrom(src, msg.sender, wad);\\n    }\\n\\n    function move(address src, address dst, uint wad) external {\\n        transferFrom(src, dst, wad);\\n    }\\n\\n\\n    function mint(uint wad) external {\\n        mint(msg.sender, wad);\\n    }\\n\\n    function burn(uint wad) external {\\n        burn(msg.sender, wad);\\n    }\\n\\n    function mint(address guy, uint wad) public auth stoppable {\\n        balanceOf[guy] = add(balanceOf[guy], wad);\\n        totalSupply = add(totalSupply, wad);\\n        emit Mint(guy, wad);\\n    }\\n\\n    function burn(address guy, uint wad) public auth stoppable {\\n        if (guy != msg.sender && allowance[guy][msg.sender] != type(uint256).max) {\\n            require(allowance[guy][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[guy] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[guy] = sub(balanceOf[guy], wad);\\n        totalSupply = sub(totalSupply, wad);\\n        emit Burn(guy, wad);\\n    }\\n\\n    function stop() public auth {\\n        stopped = true;\\n        emit Stop();\\n    }\\n\\n    function start() public auth {\\n        stopped = false;\\n        emit Start();\\n    }\\n\\n\\n    function setName(string memory name_) public auth {\\n        name = name_;\\n    }\\n}\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"/// token.sol -- ERC20 implementation with minting and burning\\n\\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.23;\\n\\ninterface DSAuthority {\\n    function canCall(\\n        address src, address dst, bytes4 sig\\n    ) external view returns (bool);\\n}\\n\\ncontract DSAuthEvents {\\n    event LogSetAuthority (address indexed authority);\\n    event LogSetOwner     (address indexed owner);\\n}\\n\\ncontract DSAuth is DSAuthEvents {\\n    DSAuthority  public  authority;\\n    address      public  owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n        emit LogSetOwner(msg.sender);\\n    }\\n\\n    function setOwner(address owner_)\\n        public\\n        auth\\n    {\\n        owner = owner_;\\n        emit LogSetOwner(owner);\\n    }\\n\\n    function setAuthority(DSAuthority authority_)\\n        public\\n        auth\\n    {\\n        authority = authority_;\\n        emit LogSetAuthority(address(authority));\\n    }\\n\\n    modifier auth {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"ds-auth-unauthorized\\\");\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        } else if (src == owner) {\\n            return true;\\n        } else if (authority == DSAuthority(address(0))) {\\n            return false;\\n        } else {\\n            return authority.canCall(src, address(this), sig);\\n        }\\n    }\\n}\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\\ncontract DSToken is DSMath, DSAuth {\\n    bool                                              public  stopped;\\n    uint256                                           public  totalSupply;\\n    mapping (address => uint256)                      public  balanceOf;\\n    mapping (address => mapping (address => uint256)) public  allowance;\\n    string                                            public  symbol;\\n    uint8                                             public  decimals = 18; // standard token precision. override to customize\\n    string                                            public  name = \\\"\\\";     // Optional token name\\n\\n\\n    constructor(string memory symbol_) public {\\n        symbol = symbol_;\\n    }\\n\\n    event Approval(address indexed src, address indexed guy, uint wad);\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\n    event Mint(address indexed guy, uint wad);\\n    event Burn(address indexed guy, uint wad);\\n    event Stop();\\n    event Start();\\n\\n    modifier stoppable {\\n        require(!stopped, \\\"ds-stop-is-stopped\\\");\\n        _;\\n    }\\n\\n    function approve(address guy) external returns (bool) {\\n        return approve(guy, type(uint256).max);\\n    }\\n\\n    function approve(address guy, uint wad) public stoppable returns (bool) {\\n        allowance[msg.sender][guy] = wad;\\n\\n        emit Approval(msg.sender, guy, wad);\\n\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint wad) external returns (bool) {\\n        return transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad)\\n        public\\n        stoppable\\n        returns (bool)\\n    {\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\n            require(allowance[src][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[src] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[src] = sub(balanceOf[src], wad);\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function push(address dst, uint wad) external {\\n        transferFrom(msg.sender, dst, wad);\\n    }\\n\\n    function pull(address src, uint wad) external {\\n        transferFrom(src, msg.sender, wad);\\n    }\\n\\n    function move(address src, address dst, uint wad) external {\\n        transferFrom(src, dst, wad);\\n    }\\n\\n\\n    function mint(uint wad) external {\\n        mint(msg.sender, wad);\\n    }\\n\\n    function burn(uint wad) external {\\n        burn(msg.sender, wad);\\n    }\\n\\n    function mint(address guy, uint wad) public auth stoppable {\\n        balanceOf[guy] = add(balanceOf[guy], wad);\\n        totalSupply = add(totalSupply, wad);\\n        emit Mint(guy, wad);\\n    }\\n\\n    function burn(address guy, uint wad) public auth stoppable {\\n        if (guy != msg.sender && allowance[guy][msg.sender] != type(uint256).max) {\\n            require(allowance[guy][msg.sender] >= wad, \\\"ds-token-insufficient-approval\\\");\\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\\n        }\\n\\n        require(balanceOf[guy] >= wad, \\\"ds-token-insufficient-balance\\\");\\n        balanceOf[guy] = sub(balanceOf[guy], wad);\\n        totalSupply = sub(totalSupply, wad);\\n        emit Burn(guy, wad);\\n    }\\n\\n    function stop() public auth {\\n        stopped = true;\\n        emit Stop();\\n    }\\n\\n    function start() public auth {\\n        stopped = false;\\n        emit Start();\\n    }\\n\\n\\n    function setName(string memory name_) public auth {\\n        name = name_;\\n    }\\n}\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// FIXME: This contract was altered compared to the production version.\\r\\n// It doesn't use LibNote anymore.\\r\\n// New deployments of this contract will need to include custom events (TO DO).\\r\\n\\r\\ncontract USB {\\r\\n    // --- Auth ---\\r\\n    mapping (address => uint) public wards;\\r\\n    function rely(address guy) external auth { wards[guy] = 1; }\\r\\n    function deny(address guy) external auth { wards[guy] = 0; }\\r\\n    modifier auth {\\r\\n        require(wards[msg.sender] == 1, \\\"USB/not-authorized\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // --- ERC20 Data ---\\r\\n    string  public constant name     = \\\"USB Stablecoin\\\";\\r\\n    string  public constant symbol   = \\\"USB\\\";\\r\\n    string  public constant version  = \\\"1\\\";\\r\\n    uint8   public constant decimals = 18;\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping (address => uint)                      public balanceOf;\\r\\n    mapping (address => mapping (address => uint)) public allowance;\\r\\n    mapping (address => uint)                      public nonces;\\r\\n\\r\\n    event Approval(address indexed src, address indexed guy, uint wad);\\r\\n    event Transfer(address indexed src, address indexed dst, uint wad);\\r\\n\\r\\n    // --- Math ---\\r\\n    function add(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x + y) >= x);\\r\\n    }\\r\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\r\\n        require((z = x - y) <= x);\\r\\n    }\\r\\n\\r\\n    // --- EIP712 niceties ---\\r\\n    bytes32 public DOMAIN_SEPARATOR;\\r\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\r\\n\\r\\n    constructor(uint256 chainId_) public {\\r\\n        wards[msg.sender] = 1;\\r\\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\\r\\n            keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n            keccak256(bytes(name)),\\r\\n            keccak256(bytes(version)),\\r\\n            chainId_,\\r\\n            address(this)\\r\\n        ));\\r\\n    }\\r\\n\\r\\n    // --- Token ---\\r\\n    function transfer(address dst, uint wad) external returns (bool) {\\r\\n        return transferFrom(msg.sender, dst, wad);\\r\\n    }\\r\\n    function transferFrom(address src, address dst, uint wad)\\r\\n        public returns (bool)\\r\\n    {\\r\\n        require(balanceOf[src] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[src][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[src] = sub(balanceOf[src], wad);\\r\\n        balanceOf[dst] = add(balanceOf[dst], wad);\\r\\n        emit Transfer(src, dst, wad);\\r\\n        return true;\\r\\n    }\\r\\n    function mint(address usr, uint wad) external auth {\\r\\n        balanceOf[usr] = add(balanceOf[usr], wad);\\r\\n        totalSupply    = add(totalSupply, wad);\\r\\n        emit Transfer(address(0), usr, wad);\\r\\n    }\\r\\n    function burn(address usr, uint wad) external {\\r\\n        require(balanceOf[usr] >= wad, \\\"USB/insufficient-balance\\\");\\r\\n        if (usr != msg.sender && allowance[usr][msg.sender] != type(uint256).max) {\\r\\n            require(allowance[usr][msg.sender] >= wad, \\\"USB/insufficient-allowance\\\");\\r\\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\\r\\n        }\\r\\n        balanceOf[usr] = sub(balanceOf[usr], wad);\\r\\n        totalSupply    = sub(totalSupply, wad);\\r\\n        emit Transfer(usr, address(0), wad);\\r\\n    }\\r\\n    function approve(address usr, uint wad) external returns (bool) {\\r\\n        allowance[msg.sender][usr] = wad;\\r\\n        emit Approval(msg.sender, usr, wad);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // --- Alias ---\\r\\n    function push(address usr, uint wad) external {\\r\\n        transferFrom(msg.sender, usr, wad);\\r\\n    }\\r\\n    function pull(address usr, uint wad) external {\\r\\n        transferFrom(usr, msg.sender, wad);\\r\\n    }\\r\\n    function move(address src, address dst, uint wad) external {\\r\\n        transferFrom(src, dst, wad);\\r\\n    }\\r\\n\\r\\n    // --- Approve by signature ---\\r\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\\r\\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\\r\\n    {\\r\\n        bytes32 digest =\\r\\n            keccak256(abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR,\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH,\\r\\n                                     holder,\\r\\n                                     spender,\\r\\n                                     nonce,\\r\\n                                     expiry,\\r\\n                                     allowed))\\r\\n        ));\\r\\n\\r\\n        require(holder != address(0), \\\"USB/invalid-address-0\\\");\\r\\n        require(holder == ecrecover(digest, v, r, s), \\\"USB/invalid-permit\\\");\\r\\n        require(expiry == 0 || block.timestamp <= expiry, \\\"USB/permit-expired\\\");\\r\\n        require(nonce == nonces[holder]++, \\\"USB/invalid-nonce\\\");\\r\\n        uint wad = allowed ? type(uint256).max : 0;\\r\\n        allowance[holder][spender] = wad;\\r\\n        emit Approval(holder, spender, wad);\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}