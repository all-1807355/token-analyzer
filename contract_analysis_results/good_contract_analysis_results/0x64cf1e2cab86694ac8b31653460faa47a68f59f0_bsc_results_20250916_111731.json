{
  "total_matches": 3,
  "patterns_found": {
    "minting_mechanics": {
      "count": 3,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title GamesCoin ERC20 Token\\n/// @dev This contract extends ERC20 token with burnable functionality and a minting feature.\\n/// The minting is capped monthly and can accumulate if not minted every month.\\ncontract GamesCoin is ERC20, ERC20Burnable, Ownable {\\n    uint8 public constant DECIMALS = 5;\\n\\n    uint256 public constant MAX_SUPPLY = 3_000_000_000 * (10 ** DECIMALS);\\n    uint256 public constant MONTHLY_MINT_CAP = 50_000_000 * (10 ** DECIMALS);\\n    uint256 public constant MINT_ALLOWANCE_INCREASE_PERIOD = 30 days;\\n\\n    uint256 public immutable MINT_START = 1700089200;\\n\\n    uint256 internal totalMinted;\\n\\n    /// @notice Emitted when tokens are minted.\\n    /// @param to The address of the recipient that received the minted tokens.\\n    /// @param amount The amount of tokens that were minted.\\n    event TokensMinted(address indexed to, uint256 amount);\\n\\n    /// @notice Emitted when the maximum supply is reached.\\n    error MaxSupplyReached();\\n\\n    /// @notice Emitted when there is a mint attempte and no tokens are available for minting.\\n    error NoTokensAvailableForMinting();\\n\\n    /// @notice Emitted when the owner attempts to renounce ownership.\\n    error OwnershipCannotBeRenounced();\\n\\n    /// @notice Constructor to create GamesCoin\\n    /// @dev Sets the initial owner of the contract and initializes the contract with the ERC20 token details.\\n    /// @param initialOwner The address that will be granted the ownership of the contract.\\n    constructor(address initialOwner) ERC20(\\\"GamesCoin\\\", \\\"GC\\\") Ownable(initialOwner) {}\\n\\n\\n    /// @notice Mints tokens to the owner's address\\n    /// @dev This function can only be called by the owner.\\n    /// It mints up to the mintableAmount, which is calculated based on the time since the last mint.\\n    /// Minting is restricted by the MAX_SUPPLY.\\n    /// Emits the TokensMinted event upon successful minting.\\n    function mint() public onlyOwner {\\n        if (totalMinted >= MAX_SUPPLY) {\\n            revert MaxSupplyReached();\\n        }\\n\\n        uint256 mintableAmount = calculateMintableAmount(); // Update the amount available for minting\\n\\n        if (mintableAmount <= 0) {\\n            revert NoTokensAvailableForMinting();\\n        }\\n\\n        totalMinted += mintableAmount;\\n        _mint(owner(), mintableAmount);\\n\\n        emit TokensMinted(owner(), mintableAmount);\\n    }\\n\\n    /// @dev Internal function to update the mintable amount based on the time elapsed since MINT_START.\\n    /// It calculates the total number of months passed and adjusts the mintableAmount accordingly.\\n    /// The calculation ensures the minting does not exceed the monthly cap and the overall MAX_SUPPLY.\\n    function calculateMintableAmount() internal view returns (uint256) {\\n        // Calculate the number of months since mint started\\n        uint256 monthsPassed = (block.timestamp - MINT_START) / MINT_ALLOWANCE_INCREASE_PERIOD + 1;\\n\\n        // Calculate how many tokens can be minted based on months passed\\n        uint256 mintProjection = monthsPassed * MONTHLY_MINT_CAP;\\n\\n        // Calculate the new total that should have been minted by this month\\n        uint256 newTotalMinted = mintProjection < MAX_SUPPLY ? mintProjection : MAX_SUPPLY;\\n\\n        // Subtract what was already minted to get the amount available for minting this month\\n        return newTotalMinted - totalMinted;\\n    }\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    /// @dev Overridden to return a fixed value of decimals.\\n    function decimals() public pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // @dev Overridden to prevent renouncing ownership.\\n    function renounceOwnership() public override onlyOwner {\\n        revert OwnershipCannotBeRenounced();\\n    }\\n\\n    /// @notice Returns the current owner of the contract.\\n    /// @dev Returns the bep20 token owner which is necessary for binding with bep2 token.\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(owner()",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title GamesCoin ERC20 Token\\n/// @dev This contract extends ERC20 token with burnable functionality and a minting feature.\\n/// The minting is capped monthly and can accumulate if not minted every month.\\ncontract GamesCoin is ERC20, ERC20Burnable, Ownable {\\n    uint8 public constant DECIMALS = 5;\\n\\n    uint256 public constant MAX_SUPPLY = 3_000_000_000 * (10 ** DECIMALS);\\n    uint256 public constant MONTHLY_MINT_CAP = 50_000_000 * (10 ** DECIMALS);\\n    uint256 public constant MINT_ALLOWANCE_INCREASE_PERIOD = 30 days;\\n\\n    uint256 public immutable MINT_START = 1700089200;\\n\\n    uint256 internal totalMinted;\\n\\n    /// @notice Emitted when tokens are minted.\\n    /// @param to The address of the recipient that received the minted tokens.\\n    /// @param amount The amount of tokens that were minted.\\n    event TokensMinted(address indexed to, uint256 amount);\\n\\n    /// @notice Emitted when the maximum supply is reached.\\n    error MaxSupplyReached();\\n\\n    /// @notice Emitted when there is a mint attempte and no tokens are available for minting.\\n    error NoTokensAvailableForMinting();\\n\\n    /// @notice Emitted when the owner attempts to renounce ownership.\\n    error OwnershipCannotBeRenounced();\\n\\n    /// @notice Constructor to create GamesCoin\\n    /// @dev Sets the initial owner of the contract and initializes the contract with the ERC20 token details.\\n    /// @param initialOwner The address that will be granted the ownership of the contract.\\n    constructor(address initialOwner) ERC20(\\\"GamesCoin\\\", \\\"GC\\\") Ownable(initialOwner) {}\\n\\n\\n    /// @notice Mints tokens to the owner's address\\n    /// @dev This function can only be called by the owner.\\n    /// It mints up to the mintableAmount, which is calculated based on the time since the last mint.\\n    /// Minting is restricted by the MAX_SUPPLY.\\n    /// Emits the TokensMinted event upon successful minting.\\n    function mint() public onlyOwner {\\n        if (totalMinted >= MAX_SUPPLY) {\\n            revert MaxSupplyReached();\\n        }\\n\\n        uint256 mintableAmount = calculateMintableAmount(); // Update the amount available for minting\\n\\n        if (mintableAmount <= 0) {\\n            revert NoTokensAvailableForMinting();\\n        }\\n\\n        totalMinted += mintableAmount;\\n        _mint(owner(), mintableAmount);\\n\\n        emit TokensMinted(owner(), mintableAmount);\\n    }\\n\\n    /// @dev Internal function to update the mintable amount based on the time elapsed since MINT_START.\\n    /// It calculates the total number of months passed and adjusts the mintableAmount accordingly.\\n    /// The calculation ensures the minting does not exceed the monthly cap and the overall MAX_SUPPLY.\\n    function calculateMintableAmount() internal view returns (uint256) {\\n        // Calculate the number of months since mint started\\n        uint256 monthsPassed = (block.timestamp - MINT_START) / MINT_ALLOWANCE_INCREASE_PERIOD + 1;\\n\\n        // Calculate how many tokens can be minted based on months passed\\n        uint256 mintProjection = monthsPassed * MONTHLY_MINT_CAP;\\n\\n        // Calculate the new total that should have been minted by this month\\n        uint256 newTotalMinted = mintProjection < MAX_SUPPLY ? mintProjection : MAX_SUPPLY;\\n\\n        // Subtract what was already minted to get the amount available for minting this month\\n        return newTotalMinted - totalMinted;\\n    }\\n\\n    /// @notice Returns the number of decimals used to get its user representation.\\n    /// @dev Overridden to return a fixed value of decimals.\\n    function decimals() public pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // @dev Overridden to prevent renouncing ownership.\\n    function renounceOwnership() public override onlyOwner {\\n        revert OwnershipCannotBeRenounced();\\n    }\\n\\n    /// @notice Returns the current owner of the contract.\\n    /// @dev Returns the bep20 token owner which is necessary for binding with bep2 token.\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}