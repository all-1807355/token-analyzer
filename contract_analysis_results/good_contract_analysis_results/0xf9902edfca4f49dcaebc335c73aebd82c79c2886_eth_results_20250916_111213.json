{
  "total_matches": 3,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "_mint(_msgsender()",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {Ownable} from \\\"./utils/Ownable.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport {IERC20Errors} from \\\"./interfaces/IERC20Errors.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\n\\n/*\\n==  ADO Protocol is an ecosystem designed to improve on-chain efficiency\\n==  and connect Web2 businesses with blockchain technology.\\n  https://www.adoprotocol.com\\n  https://x.com/adoprotocol\\n  https://t.me/AdoProtocolEnglish\\n  https://medium.com/@AdoProtocol\\n*/\\ncontract ADOToken is Ownable, IERC20, IERC20Metadata, IERC20Errors {\\n    string private _name = \\\"ADO Protocol\\\";\\n    string private _symbol = \\\"ADO\\\";\\n    uint8 _decimals = 18;\\n    mapping(address account => uint256) private _balances;\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n    IUniswapV2Router02 public immutable _uniswapRouter;\\n    address public immutable deployer;\\n    mapping(address => bool) private _isLP;\\n    bool private _swapping = false;\\n    uint256 private _totalSupply;\\n    uint256 private _tokensToLiqudate;\\n    uint256 private _fee = 5;\\n    address private _stableToken;\\n    address private _wETHlp;\\n    address private _stablelp;\\n\\n    event TokenFeeUpdate(uint256 oldFee, uint256 newFee);\\n    event TokenBalanceToLiqudate(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    modifier lockTheSwap() {\\n        _swapping = true;\\n        _;\\n        _swapping = false;\\n    }\\n\\n    modifier onlyDeployer() {\\n        require(_msgSender() == deployer, \\\"Token: Only the token deployer can call this function\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        deployer = _msgSender();\\n        _mint(_msgSender(), 1000000000 * (10 ** _decimals));\\n        _tokensToLiqudate = _totalSupply / 10000;\\n        _uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _approve(address(this), address(_uniswapRouter), type(uint256).max);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function fee() external view returns(uint256) {\\n\\t\\treturn _fee;\\n\\t}\\n\\n    function wETHlp() public view returns (address) {\\n        return _wETHlp;\\n    }\\n\\n    function stablelp() public view returns (address) {\\n        return _stablelp;\\n    }\\n\\n    function stableToken() public view returns (address) {\\n        return _stableToken;\\n    }\\n\\n    function isLP(address account) public view returns (bool) {\\n        return _isLP[account];\\n    }\\n\\n    function tokensToLiqudate() external view returns(uint256) {\\n\\t\\treturn _tokensToLiqudate;\\n\\t}\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function updateStableToken(address stableERC20Token) external onlyDeployer returns (bool) {\\n        require(stableERC20Token.code.length > 0, \\\"Token: stableToken, not a valid contract\\\");\\n        IUniswapV2Factory factory = IUniswapV2Factory(_uniswapRouter.factory());\\n        if (_wETHlp == address(0)) {\\n            _wETHlp = factory.getPair(address(this), _uniswapRouter.WETH());\\n            _isLP[_wETHlp] = true;\\n        }\\n        _stablelp = factory.getPair(address(this), stableERC20Token);\\n        if (_stablelp != address(0)) {\\n            _stableToken = stableERC20Token;\\n            _isLP[_stablelp] = true;\\n        }\\n        return _isLP[_stablelp];\\n    }\\n\\n    function updateFee(uint256 newFee) external onlyDeployer returns (bool) {\\n        require(newFee != _fee, \\\"Token: The Fee is already set to the requested value\\\");\\n        require(newFee <= 10, \\\"Token: The fee can only be between 0 and 10%\\\");\\n        emit TokenFeeUpdate(_fee, newFee);\\n        _fee = newFee;\\n        return true;\\n    }\\n\\n    function updateTokensToLiqudate(uint256 newValue) external onlyDeployer returns (bool) {\\n        require(newValue >= 10 ** 18 && newValue <= 1000000 * 10 ** 18, \\\"Token: Tokens too liqudate must be between 1 and 1.000.000 ADO\\\");\\n        emit TokenBalanceToLiqudate(newValue, _tokensToLiqudate);\\n        _tokensToLiqudate = newValue;\\n        return true;\\n    }\\n\\n    function _swapTokens() private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        if (_balances[_wETHlp] > _balances[_stablelp]) {\\n            path[1] = _uniswapRouter.WETH();\\n            _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        } else {\\n            path[1] = _stableToken;\\n            _uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        bool takeFee = false;\\n        uint256 _value = value;\\n        if (_isLP[from] || _isLP[to]) {\\n            takeFee = tx.origin != deployer;\\n        }\\n        if (!_swapping && _fee > 0 && takeFee) {\\n            if (_isLP[to]) {\\n                if (_balances[address(this)] >= _tokensToLiqudate) {\\n                    _swapTokens();\\n                }\\n            }\\n            uint256 txFee = (_value * _fee) / 100;\\n            _value -= txFee;\\n            _update(from, address(this), txFee);\\n        }\\n        _update(from, to, _value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance < type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {Ownable} from \\\"./utils/Ownable.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport {IERC20Errors} from \\\"./interfaces/IERC20Errors.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\n\\n/*\\n==  ADO Protocol is an ecosystem designed to improve on-chain efficiency\\n==  and connect Web2 businesses with blockchain technology.\\n  https://www.adoprotocol.com\\n  https://x.com/adoprotocol\\n  https://t.me/AdoProtocolEnglish\\n  https://medium.com/@AdoProtocol\\n*/\\ncontract ADOToken is Ownable, IERC20, IERC20Metadata, IERC20Errors {\\n    string private _name = \\\"ADO Protocol\\\";\\n    string private _symbol = \\\"ADO\\\";\\n    uint8 _decimals = 18;\\n    mapping(address account => uint256) private _balances;\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n    IUniswapV2Router02 public immutable _uniswapRouter;\\n    address public immutable deployer;\\n    mapping(address => bool) private _isLP;\\n    bool private _swapping = false;\\n    uint256 private _totalSupply;\\n    uint256 private _tokensToLiqudate;\\n    uint256 private _fee = 5;\\n    address private _stableToken;\\n    address private _wETHlp;\\n    address private _stablelp;\\n\\n    event TokenFeeUpdate(uint256 oldFee, uint256 newFee);\\n    event TokenBalanceToLiqudate(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    modifier lockTheSwap() {\\n        _swapping = true;\\n        _;\\n        _swapping = false;\\n    }\\n\\n    modifier onlyDeployer() {\\n        require(_msgSender() == deployer, \\\"Token: Only the token deployer can call this function\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        deployer = _msgSender();\\n        _mint(_msgSender(), 1000000000 * (10 ** _decimals));\\n        _tokensToLiqudate = _totalSupply / 10000;\\n        _uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _approve(address(this), address(_uniswapRouter), type(uint256).max);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function fee() external view returns(uint256) {\\n\\t\\treturn _fee;\\n\\t}\\n\\n    function wETHlp() public view returns (address) {\\n        return _wETHlp;\\n    }\\n\\n    function stablelp() public view returns (address) {\\n        return _stablelp;\\n    }\\n\\n    function stableToken() public view returns (address) {\\n        return _stableToken;\\n    }\\n\\n    function isLP(address account) public view returns (bool) {\\n        return _isLP[account];\\n    }\\n\\n    function tokensToLiqudate() external view returns(uint256) {\\n\\t\\treturn _tokensToLiqudate;\\n\\t}\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function updateStableToken(address stableERC20Token) external onlyDeployer returns (bool) {\\n        require(stableERC20Token.code.length > 0, \\\"Token: stableToken, not a valid contract\\\");\\n        IUniswapV2Factory factory = IUniswapV2Factory(_uniswapRouter.factory());\\n        if (_wETHlp == address(0)) {\\n            _wETHlp = factory.getPair(address(this), _uniswapRouter.WETH());\\n            _isLP[_wETHlp] = true;\\n        }\\n        _stablelp = factory.getPair(address(this), stableERC20Token);\\n        if (_stablelp != address(0)) {\\n            _stableToken = stableERC20Token;\\n            _isLP[_stablelp] = true;\\n        }\\n        return _isLP[_stablelp];\\n    }\\n\\n    function updateFee(uint256 newFee) external onlyDeployer returns (bool) {\\n        require(newFee != _fee, \\\"Token: The Fee is already set to the requested value\\\");\\n        require(newFee <= 10, \\\"Token: The fee can only be between 0 and 10%\\\");\\n        emit TokenFeeUpdate(_fee, newFee);\\n        _fee = newFee;\\n        return true;\\n    }\\n\\n    function updateTokensToLiqudate(uint256 newValue) external onlyDeployer returns (bool) {\\n        require(newValue >= 10 ** 18 && newValue <= 1000000 * 10 ** 18, \\\"Token: Tokens too liqudate must be between 1 and 1.000.000 ADO\\\");\\n        emit TokenBalanceToLiqudate(newValue, _tokensToLiqudate);\\n        _tokensToLiqudate = newValue;\\n        return true;\\n    }\\n\\n    function _swapTokens() private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        if (_balances[_wETHlp] > _balances[_stablelp]) {\\n            path[1] = _uniswapRouter.WETH();\\n            _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        } else {\\n            path[1] = _stableToken;\\n            _uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        bool takeFee = false;\\n        uint256 _value = value;\\n        if (_isLP[from] || _isLP[to]) {\\n            takeFee = tx.origin != deployer;\\n        }\\n        if (!_swapping && _fee > 0 && takeFee) {\\n            if (_isLP[to]) {\\n                if (_balances[address(this)] >= _tokensToLiqudate) {\\n                    _swapTokens();\\n                }\\n            }\\n            uint256 txFee = (_value * _fee) / 100;\\n            _value -= txFee;\\n            _update(from, address(this), txFee);\\n        }\\n        _update(from, to, _value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance < type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    },
    "router_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "modifier locktheswap",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.24;\\n\\nimport {Ownable} from \\\"./utils/Ownable.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./interfaces/IERC20Metadata.sol\\\";\\nimport {IERC20Errors} from \\\"./interfaces/IERC20Errors.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./interfaces/IUniswapV2Factory.sol\\\";\\n\\n/*\\n==  ADO Protocol is an ecosystem designed to improve on-chain efficiency\\n==  and connect Web2 businesses with blockchain technology.\\n  https://www.adoprotocol.com\\n  https://x.com/adoprotocol\\n  https://t.me/AdoProtocolEnglish\\n  https://medium.com/@AdoProtocol\\n*/\\ncontract ADOToken is Ownable, IERC20, IERC20Metadata, IERC20Errors {\\n    string private _name = \\\"ADO Protocol\\\";\\n    string private _symbol = \\\"ADO\\\";\\n    uint8 _decimals = 18;\\n    mapping(address account => uint256) private _balances;\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n    IUniswapV2Router02 public immutable _uniswapRouter;\\n    address public immutable deployer;\\n    mapping(address => bool) private _isLP;\\n    bool private _swapping = false;\\n    uint256 private _totalSupply;\\n    uint256 private _tokensToLiqudate;\\n    uint256 private _fee = 5;\\n    address private _stableToken;\\n    address private _wETHlp;\\n    address private _stablelp;\\n\\n    event TokenFeeUpdate(uint256 oldFee, uint256 newFee);\\n    event TokenBalanceToLiqudate(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n    modifier lockTheSwap() {\\n        _swapping = true;\\n        _;\\n        _swapping = false;\\n    }\\n\\n    modifier onlyDeployer() {\\n        require(_msgSender() == deployer, \\\"Token: Only the token deployer can call this function\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        deployer = _msgSender();\\n        _mint(_msgSender(), 1000000000 * (10 ** _decimals));\\n        _tokensToLiqudate = _totalSupply / 10000;\\n        _uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _approve(address(this), address(_uniswapRouter), type(uint256).max);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function fee() external view returns(uint256) {\\n\\t\\treturn _fee;\\n\\t}\\n\\n    function wETHlp() public view returns (address) {\\n        return _wETHlp;\\n    }\\n\\n    function stablelp() public view returns (address) {\\n        return _stablelp;\\n    }\\n\\n    function stableToken() public view returns (address) {\\n        return _stableToken;\\n    }\\n\\n    function isLP(address account) public view returns (bool) {\\n        return _isLP[account];\\n    }\\n\\n    function tokensToLiqudate() external view returns(uint256) {\\n\\t\\treturn _tokensToLiqudate;\\n\\t}\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function updateStableToken(address stableERC20Token) external onlyDeployer returns (bool) {\\n        require(stableERC20Token.code.length > 0, \\\"Token: stableToken, not a valid contract\\\");\\n        IUniswapV2Factory factory = IUniswapV2Factory(_uniswapRouter.factory());\\n        if (_wETHlp == address(0)) {\\n            _wETHlp = factory.getPair(address(this), _uniswapRouter.WETH());\\n            _isLP[_wETHlp] = true;\\n        }\\n        _stablelp = factory.getPair(address(this), stableERC20Token);\\n        if (_stablelp != address(0)) {\\n            _stableToken = stableERC20Token;\\n            _isLP[_stablelp] = true;\\n        }\\n        return _isLP[_stablelp];\\n    }\\n\\n    function updateFee(uint256 newFee) external onlyDeployer returns (bool) {\\n        require(newFee != _fee, \\\"Token: The Fee is already set to the requested value\\\");\\n        require(newFee <= 10, \\\"Token: The fee can only be between 0 and 10%\\\");\\n        emit TokenFeeUpdate(_fee, newFee);\\n        _fee = newFee;\\n        return true;\\n    }\\n\\n    function updateTokensToLiqudate(uint256 newValue) external onlyDeployer returns (bool) {\\n        require(newValue >= 10 ** 18 && newValue <= 1000000 * 10 ** 18, \\\"Token: Tokens too liqudate must be between 1 and 1.000.000 ADO\\\");\\n        emit TokenBalanceToLiqudate(newValue, _tokensToLiqudate);\\n        _tokensToLiqudate = newValue;\\n        return true;\\n    }\\n\\n    function _swapTokens() private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        if (_balances[_wETHlp] > _balances[_stablelp]) {\\n            path[1] = _uniswapRouter.WETH();\\n            _uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        } else {\\n            path[1] = _stableToken;\\n            _uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n                _tokensToLiqudate,\\n                0,\\n                path,\\n                deployer,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        bool takeFee = false;\\n        uint256 _value = value;\\n        if (_isLP[from] || _isLP[to]) {\\n            takeFee = tx.origin != deployer;\\n        }\\n        if (!_swapping && _fee > 0 && takeFee) {\\n            if (_isLP[to]) {\\n                if (_balances[address(this)] >= _tokensToLiqudate) {\\n                    _swapTokens();\\n                }\\n            }\\n            uint256 txFee = (_value * _fee) / 100;\\n            _value -= txFee;\\n            _update(from, address(this), txFee);\\n        }\\n        _update(from, to, _value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance < type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(\\n                    spender,\\n                    currentAllowance,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "modifier\\s+lockTheSwap"
        }
      ]
    }
  }
}