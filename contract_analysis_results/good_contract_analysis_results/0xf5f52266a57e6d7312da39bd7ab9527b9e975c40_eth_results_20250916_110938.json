{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC-20\\n * applications.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * Both values are immutable: they can only be set once during construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     *\\n     * ```solidity\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance < type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, maxsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\\n         .o@8 88bu.         \\n     .o@8888% %*8888eu.     \\n .o@8888%\\\"       ^%*8888eu  \\n8888R\\\"      AVM       \\\"%8888 \\n\\\"*8888bu.          .o8888R% \\n   ^\\\"*8888bu.  .o8888R%\\\"    \\n       ^%*888 8888%\\\"        \\n           ^% %\\\"    \\n\\nhttps://avm.codes                           \\n*/\\n\\npragma solidity ^0.8.28;\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\n\\ncontract Token is ERC20, Ownable {\\n    uint256 public immutable MAX_SUPPLY;\\n    address public immutable pair;\\n    address public treasury;\\n\\n    IUniswapV2Router02 private constant _router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n    address private immutable _weth;\\n    address private immutable _deployer;\\n\\n    uint256 public startBlock;\\n    uint256 public startBlockTime;\\n    uint256 private raiseAmount;\\n\\n    mapping(address account => bool) public isExcludedFromFees;\\n    mapping(address account => bool) public isExcludedFromMaxWallet;\\n    mapping(address origin => mapping(uint256 blockNumber => uint256 txCount))\\n        public maxBuyTxsPerBlockPerOrigin;\\n    uint256 private _maxBuyTxsPerBlockPerOrigin = 10;\\n    mapping(uint256 blockNumber => uint256 txCount) public maxBuyTxsPerBlock;\\n    uint256 private _maxBuyTxsPerBlock = 100;\\n\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 maxSupply,\\n        address _treasury\\n    ) ERC20(name, symbol) Ownable(msg.sender) {\\n        MAX_SUPPLY = maxSupply;\\n        _weth = _router.WETH();\\n\\n        pair = IUniswapV2Factory(_router.factory()).createPair(\\n            address(this),\\n            _weth\\n        );\\n\\n        isExcludedFromFees[msg.sender] = true;\\n        isExcludedFromFees[address(this)] = true;\\n        isExcludedFromFees[pair] = true;\\n        isExcludedFromFees[treasury] = true;\\n        isExcludedFromMaxWallet[msg.sender] = true;\\n        isExcludedFromMaxWallet[address(this)] = true;\\n        isExcludedFromMaxWallet[pair] = true;\\n        isExcludedFromMaxWallet[treasury] = true;\\n\\n        _mint(msg.sender, maxSupply);\\n        _approve(msg.sender, address(_router), type(uint256).max);\\n\\n        treasury = _treasury;\\n        _deployer = msg.sender;\\n        _approve(address(this), address(_router), type(uint256).max);\\n    }\\n\\n    function setTreasury(address newTreasury) external {\\n        require(newTreasury != address(0), \\\"treasury-is-0\\\");\\n        require(\\n            msg.sender == _deployer || msg.sender == owner(),\\n            \\\"only-deployer\\\"\\n        );\\n        treasury = newTreasury;\\n    }\\n\\n    function enableTrading() external onlyOwner {\\n        require(startBlock == 0, \\\"trading-already-enabled\\\");\\n        startBlock = block.number;\\n        startBlockTime = block.timestamp;\\n    }\\n\\n    function setExcludedFromFees(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        isExcludedFromFees[account] = excluded;\\n    }\\n\\n    function setExcludedFromMaxWallet(\\n        address account,\\n        bool excluded\\n    ) external onlyOwner {\\n        isExcludedFromMaxWallet[account] = excluded;\\n    }\\n\\n    function feesAndMaxWallet()\\n        external\\n        view\\n        returns (uint256 _feeBps, uint256 _maxWallet)\\n    {\\n        return _feesAndMaxWallet();\\n    }\\n\\n    function _feesAndMaxWallet()\\n        internal\\n        view\\n        returns (uint256 _feeBps, uint256 _maxWallet)\\n    {\\n        if (startBlockTime == 0) {\\n            return (0, 0);\\n        }\\n        uint256 _diffSeconds = block.timestamp - startBlockTime;\\n\\n        if (_diffSeconds < 3600) {\\n            // 1 min\\n            if (_diffSeconds < 60) {\\n                _feeBps = 4000; // 40%\\n                _maxWallet = MAX_SUPPLY / 1000; // 0.1%\\n                return (_feeBps, _maxWallet);\\n            }\\n            // 2-5 min\\n            if (_diffSeconds < 300) {\\n                _feeBps = 3000; // 30%\\n                _maxWallet = MAX_SUPPLY / 666; // 0.15%\\n                return (_feeBps, _maxWallet);\\n            }\\n            // 6-8 min\\n            if (_diffSeconds < 480) {\\n                _feeBps = 2000; // 20%\\n                _maxWallet = MAX_SUPPLY / 500; // 0.2%\\n                return (_feeBps, _maxWallet);\\n            }\\n\\n            if (_diffSeconds < 900) {\\n                // 9-15 min\\n                _feeBps = 1000; // 10%\\n                _maxWallet = MAX_SUPPLY / 333; // 0.3%\\n                return (_feeBps, _maxWallet);\\n            }\\n\\n            _feeBps = 400; // 4%\\n            _maxWallet = MAX_SUPPLY / 200; // 0.5%\\n            return (_feeBps, _maxWallet);\\n        }\\n\\n        if (raiseAmount < 500 ether) {\\n            _feeBps = 400; // 4%;\\n        } else if (raiseAmount < 700 ether) {\\n            _feeBps = 300; // 3%;\\n        } else if (raiseAmount < 900 ether) {\\n            _feeBps = 200; // 2%;\\n        } else {\\n            _feeBps = 0; // 0%;\\n        }\\n        _maxWallet = MAX_SUPPLY; // no limit\\n        return (_feeBps, _maxWallet);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal override {\\n        (uint256 _feeBps, uint256 _maxWallet) = _feesAndMaxWallet();\\n\\n        bool isBuy = from == pair;\\n        if (isBuy || to == pair) {\\n            require(\\n                startBlock > 0 || isExcludedFromFees[to],\\n                \\\"trading-not-enabled\\\"\\n            );\\n\\n            if (_feeBps != 0) {\\n                if (isBuy && !isExcludedFromFees[to]) {\\n                    if (\\n                        startBlockTime > 0 &&\\n                        block.timestamp - startBlockTime < 180\\n                    ) {\\n                        require(\\n                            maxBuyTxsPerBlockPerOrigin[tx.origin][\\n                                block.number\\n                            ] < _maxBuyTxsPerBlockPerOrigin,\\n                            \\\"max-buy-txs-per-block-per-origin-exceeded\\\"\\n                        );\\n                        maxBuyTxsPerBlockPerOrigin[tx.origin][block.number]++;\\n\\n                        require(\\n                            maxBuyTxsPerBlock[block.number] <\\n                                _maxBuyTxsPerBlock,\\n                            \\\"max-buy-txs-per-block-exceeded\\\"\\n                        );\\n                        maxBuyTxsPerBlock[block.number]++;\\n                    }\\n\\n                    uint256 fee = (value * _feeBps) / 10000;\\n                    value -= fee;\\n                    super._update(from, address(this), fee);\\n                }\\n\\n                if (!isBuy && !isExcludedFromFees[from]) {\\n                    uint256 fee = (value * _feeBps) / 10000;\\n                    value -= fee;\\n                    super._update(from, address(this), fee);\\n                    _swapTokensForEth();\\n                }\\n            } else {\\n                // sell any remaining tokens after cap is reached\\n                if (!isBuy && !isExcludedFromFees[from]) {\\n                    _swapTokensForEth();\\n                }\\n            }\\n        }\\n\\n        require(\\n            isExcludedFromMaxWallet[to] || value + balanceOf(to) <= _maxWallet,\\n            \\\"max-wallet-size-exceeded\\\"\\n        );\\n        super._update(from, to, value);\\n    }\\n\\n    function _swapTokensForEth() internal {\\n        uint256 startDiff = block.timestamp - startBlockTime;\\n        if (startDiff < 300) {\\n            return;\\n        }\\n\\n        uint256 _tokenAmount = balanceOf(address(this));\\n\\n        if (_tokenAmount == 0) {\\n            return;\\n        }\\n\\n        address[] memory _path = new address[](2);\\n        _path[0] = _weth;\\n        _path[1] = address(this);\\n\\n        // sell max 1 eth worth of tokens\\n        uint256 _maxTokenAmount = _router.getAmountsOut(1 ether, _path)[1];\\n\\n        if (_tokenAmount > _maxTokenAmount) {\\n            _tokenAmount = _maxTokenAmount;\\n        }\\n\\n        _path[0] = address(this);\\n        _path[1] = _weth;\\n\\n        uint256 _treasuryBalanceBefore = address(treasury).balance;\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            _tokenAmount,\\n            0,\\n            _path,\\n            treasury,\\n            block.timestamp\\n        );\\n        uint256 _treasuryBalanceAfter = address(treasury).balance;\\n        raiseAmount += _treasuryBalanceAfter - _treasuryBalanceBefore;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}