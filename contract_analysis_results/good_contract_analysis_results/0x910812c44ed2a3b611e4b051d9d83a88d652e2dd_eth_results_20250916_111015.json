{
  "total_matches": 4,
  "patterns_found": {
    "minting_mechanics": {
      "count": 4,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n/*                                                                                                                                                                                                                            \\r\\n                                                    ..            ..                                                      \\r\\n                                                    :.     :;:::;;:;::..                            .                     \\r\\n                                                   .:.    .;xxxxXXXXx+;:..              .                                 \\r\\n                                                   . .   :;X$&&$&&$$$X+;::...         ...                                 \\r\\n                                                  .  ..:+xX$x:.....:+XXx++;::...........:.                                \\r\\n                                                .+++++xX$X+.           .+XX++;;:::::...:;;:..........        .            \\r\\n                                    .         . .+$&&&&x:.                .;Xx++;;;;::;;+++;;:::..:::......     .         \\r\\n                              . . .  .     .      :::;:...                   :xXXx++;+++xXx;+;..... .        .            \\r\\n            . ..  . .  ... .. . ..  ...              ...                   ....:X$XXxxxXXXXxx+x++;;;::............ .      \\r\\n        .. ......... .. .......... .... .  .                              ...:...:X$$X$Xx+;;;;:...... ... ...... . ..     \\r\\n        .........:......... .       ....... .                              .:;:.....$$X;.   ..;;;;;;;;;;;;:::..:......    \\r\\n     .....::::;;:;+.;:.:...         ...::::.. . ...  .            .       ...:::.. ...;      .+xx++;+;+;+;;;;;;:;:::...   \\r\\n    ..:..:+;;++;x++Xxxxxx++x;::...    ::;;;:;......... .          ....    ...:;;::..  ...    .;++xx++++xx+x++x++++;:..    \\r\\n  ..::.;;+;++xx+XXX$XXXX$$$&&&$$$$$Xx::;++++;:;.............      .:;;;;::...:xx;:....  .;::::xXXXXXXXX$$$$$$$$XXxx;+:.   \\r\\n . :::;;+x+xXXXXXX$$$$$$$$$$$$&$$$$$&&$$$X+++;:......... ......    .+xxXxx::..;XX+;.......+x+$$$$$$Xx;:                   \\r\\n  ..:;;;xXXX$$$&&$$XxxXxxxx+++;;+++++x$&&$Xx+;;;.....:.........    .:+xxxx;;:..+$Xx+::....;X$$.                           \\r\\n                                    ;&$+;;X&$x+;;:..:::::;....:..   .+xxx++::...;$&Xx+;:..+;                              \\r\\n                                    x$x.   +&&$XXx;;:;::;+;..:;;++;:;+x$x++;;....;$&$XXXXXX.                              \\r\\n                                     +$;;:;X$+   .xXxxxx+++;..;xX$$X+;x$$x;+;;::.:;$&$$$$$;                               \\r\\n                                        x$$$$X;...;$$+.  ;Xx+..;xXXxx++x$$Xx++;;:::+$$$$x.                                \\r\\n                                           ;X$X$XX$Xx+;:;;x$$XXx$$Xxx+++x$$XXx+++;::.                                     \\r\\n                                            ;XX&&&&xxXX$$$&$+:;X$&$Xxx+++x$&$Xx+;:::                                      \\r\\n                                               ;&$Xxxx$$$&X++:.:XX$$XXxx+xx$&XXX++:                                       \\r\\n                                                :X$$$$$&$x;xXX$$$$X$$XXXX++x.                                             \\r\\n                                                    :+x$x++;+x$&$XXxX$XXx+;                                               \\r\\n                                                       ;XX$$$$$$X++;.                                                     \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                          ........    ......      ..........  .......        .:;:.:.  ..........                          \\r\\n                          :;&X;;+X$;  ;+$X;;.     ;x$+;;;+Xx  :$$;;+X$+.   +$+:.;X&+  ;x$x;;;;XX                          \\r\\n                            &+    +$   .Xx         ;X. .; ;+   XX    .xx. X$.     +:   :$: .: +x                          \\r\\n                            &x   :Xx   .Xx         ;$XxX&      XX     ;$::$x           :$XxX$                             \\r\\n                            &$xxx+.    .Xx     x.  ;X. .x  .   XX     ;$..$x   ;XX$$:  :$: .+  .                          \\r\\n                            &+         .Xx    .&:  ;X.    +x   XX    :X+  x&;     Xx   :$:    +X                          \\r\\n                          +x&$x+:     xx$$xxxxx&:.+X$XxxxxXx  ;$$xxxXX:    ;XX+;;x$+  +X$Xxxxx$X                          \\r\\n*/\\r\\n\\r\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport {ERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/// @title PLEDGE Token\\r\\n/// @dev ERC20 token with pledge mechanics where if a user pledges to limit their monthly transfers, they can transfer up to 1% of their balance each month without breaking the pledge.\\r\\n/// @notice This is a token contract where holders can pledge to limit their monthly transfers.\\r\\n/// @author MonkMatto\\r\\n/// @custom:security-contact monkmatto@protonmail.com\\r\\n/// @custom:disclaimer Not audited. Use at your own risk.\\r\\n/// @custom:version v0.5.4\\r\\ncontract PLEDGE is ERC20, ERC20Permit, Ownable {\\r\\n\\r\\n    /// @notice Constructor to create PLEDGE token with admin rights and permit functionality.\\r\\n    constructor()\\r\\n        ERC20(\\\"PLEDGE\\\", \\\"PLEDGE\\\")\\r\\n        ERC20Permit(\\\"PLEDGE\\\")\\r\\n        Ownable(msg.sender)\\r\\n    {}\\r\\n\\r\\n    bool public protectionsEnabled; // Whether protections are enabled or disabled\\r\\n    address public feeReceiver; // The address that receives fees during the protection period\\r\\n    address public uniswapRouterAddress = 0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD; // The address of the Uniswap Router for penalty exemptions, set to the Universal Router by default\\r\\n    uint256 public nonAirdropTokensMinted; // The number of non-airdrop tokens minted\\r\\n    uint256 public protectionStartTime; // The timestamp for calculating penalties\\r\\n    uint256 public maxTokenSupply = 1_000_000_000 * (10 ** decimals()); // 1 billion tokens with 18 decimals\\r\\n    uint256 public pledgeAirdropAmount = maxTokenSupply / 1_000; // 0.1% of maxTokenSupply\\r\\n    uint256 public defaultPledgeOnePercent = pledgeAirdropAmount / 100; // 0.001% of maxTokenSupply\\r\\n    uint256 private limitDivisor = 10; // The divisor for the pledge limit\\r\\n    uint256 public constant PROTECTION_PERIOD = 125 minutes; // Period of time during which protections are enabled\\r\\n\\r\\n    /// @dev Stores pledge data for each address\\r\\n    /// @param status The status of the pledge: 0 for no pledge, 1 for active pledge, 2 for failed pledge, and 3 for completed pledge\\r\\n    /// @param onePercent One percent of the pledged balance. For initial airdrops, this is kept at value 0 for optimization but is handled in other functions\\r\\n    /// @param monthlyWindowStart The timestamp when the current monthly window started\\r\\n    /// @param amountTransferredThisWindow Amount of tokens transferred in current window\\r\\n    struct PledgeData {\\r\\n        uint8 status;\\r\\n        uint256 onePercent;\\r\\n        uint256 monthlyWindowStart;\\r\\n        uint256 amountTransferredThisWindow;\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping of addresses to their pledge data\\r\\n    mapping(address => PledgeData) public pledger;\\r\\n\\r\\n    /// @dev Emitted when protections are toggled\\r\\n    /// @param enabled Whether protections are enabled or disabled\\r\\n    /// @param feeRecipient The address that receives penalties\\r\\n    /// @param timestamp The timestamp of the event\\r\\n    event ProtectionsToggled(bool enabled, address feeRecipient, uint256 timestamp);\\r\\n\\r\\n    /// @dev Emitted when a penalty is charged\\r\\n    /// @param user The address that was charged the penalty\\r\\n    /// @param attemptedAmount The amount that was attempted to be transferred\\r\\n    /// @param adjustedAmount The amount that was actually transferred after the penalty\\r\\n    /// @param penalty The amount of the penalty sent to the feeReceiver\\r\\n    event PenaltyCharged(address user, uint256 attemptedAmount, uint256 adjustedAmount, uint256 penalty);\\r\\n\\r\\n    /// @dev Emitted when a new pledge is created\\r\\n    /// @param pledgerAddress The address that created the pledge\\r\\n    /// @param pledgerBalance The balance pledged\\r\\n    event CreatedPledge(address indexed pledgerAddress, uint256 pledgerBalance);\\r\\n\\r\\n    /// @dev Emitted when a pledge is broken due to excessive transfers\\r\\n    /// @param pledgerAddress The address that broke their pledge\\r\\n    /// @param transferredAmount The amount transferred that broke the pledge\\r\\n    /// @param allowedTransferAmount The maximum amount that was allowed to transfer\\r\\n    event BrokenPledge(address indexed pledgerAddress, uint256 transferredAmount, uint256 allowedTransferAmount);\\r\\n\\r\\n    /// @dev Emitted when a pledge is completed\\r\\n    /// @param pledgerAddress The address that completed their pledge\\r\\n    event CompletedPledge(address indexed pledgerAddress);\\r\\n\\r\\n    /// @notice Returns the time in seconds remaining in the current window for a given address.\\r\\n    /// @dev Conveniently calculates time until the current window expires for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The time until the current window expires in seconds\\r\\n    function getTimeRemainingInWindow(address _address) public view returns (uint256) {\\r\\n        if (_isWindowExpired(_address)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return 30 days - (block.timestamp - pledger[_address].monthlyWindowStart);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount that can be transferred by a given address at the current time without breaking the pledge. If there is no pledge active, it returns 0.\\r\\n    /// @dev If the pledge is active, it checks if the current window has expired. If it has, it returns the full one percent, otherwise it returns the remaining amount that can be transferred in the current window.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The amount that can be transferred by the address at the current time without breaking the pledge.\\r\\n    function getTransferableAmount(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n          uint256 transferable;\\r\\n          uint256 onePercent = pledger[_address].onePercent;\\r\\n          // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n          if (onePercent == 0) {\\r\\n              onePercent = defaultPledgeOnePercent;\\r\\n          }\\r\\n          if (_isWindowExpired(_address)) {\\r\\n              transferable = onePercent;\\r\\n          } else {\\r\\n              transferable = onePercent - pledger[_address].amountTransferredThisWindow;\\r\\n          }\\r\\n          return transferable > balanceOf(_address) ? balanceOf(_address) : transferable;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledged balance of a given address.\\r\\n    /// @dev If the pledge is active, it returns a very close approximation of the initially pledged balance, otherwise it returns 0.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return pledgedBalance The pledged balance of the address.\\r\\n    function getPledgedBalance(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n            uint256 onePercent = pledger[_address].onePercent;\\r\\n            // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n            if (onePercent == 0) {\\r\\n                onePercent = defaultPledgeOnePercent;\\r\\n            }\\r\\n            uint256 pledgedBalance = onePercent * 100;\\r\\n            return pledgedBalance;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledge data of a given address.\\r\\n    /// @dev Returns the pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window (0 means the window has expired) for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window for the address.\\r\\n    function getPledgerData(address _address) external view returns (uint8, uint256, uint256, uint256, uint256, uint256) {\\r\\n        return (\\r\\n            pledger[_address].status,\\r\\n            balanceOf(_address),\\r\\n            getPledgedBalance(_address),\\r\\n            pledger[_address].amountTransferredThisWindow,\\r\\n            getTransferableAmount(_address),\\r\\n            getTimeRemainingInWindow(_address)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to begin a temporary launch protection.\\r\\n    /// @dev Allows the owner to enable protections for a set period of time and set the feeReceiver address.\\r\\n    /// @param _feeReceiver The address that will receive penalties.\\r\\n    function beginLaunchProtection(address _feeReceiver) external onlyOwner {\\r\\n        feeReceiver = _feeReceiver;\\r\\n        protectionsEnabled = true;\\r\\n        protectionStartTime = block.timestamp;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to disable launch protection.\\r\\n    /// @dev After the protection window has ended, penalties are automatically bypassed, but the owner can disable protections to save gas on future transfers.\\r\\n    function disableLaunchProtection() external onlyOwner {\\r\\n        protectionsEnabled = false;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the Uniswap Router address.\\r\\n    /// @dev Allows the owner to set the Uniswap Router address to prevent penalties on token distributions from the router.\\r\\n    /// @dev It is set as state on deployment to the universal router address, but it can be updated on contract if needed.\\r\\n    /// @param _uniswapRouterAddress The address of the Uniswap Router being used for token distributions during the protection period.\\r\\n    function setUniswapRouterAddress(address _uniswapRouterAddress) external onlyOwner {\\r\\n        uniswapRouterAddress = _uniswapRouterAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the amount that can be transferred without penalty during the protection period.\\r\\n    /// @dev Sets the divisor for the defaultPledgerOnePercent value, which is used to calculate the base limit for transfers during the protection period.\\r\\n    /// @param _limitDivisor The amount to divide defaultPledgerOnePercent by.\\r\\n    function setLimitDivisor(uint256 _limitDivisor) external onlyOwner {\\r\\n        require(_limitDivisor > 0, \\\"INVALID_DIVISOR\\\");\\r\\n        limitDivisor = _limitDivisor;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to airdrop tokens to pledgers.\\r\\n    /// @dev Allows the owner to airdrop 1 million tokens or 0.1% of maxTokenSupply number of tokens to pledgers who have not yet pledged.\\r\\n    /// @dev 90% of maxTokenSupply is reserved for airdrops, and 10% is reserved for non-airdrop tokens.\\r\\n    /// @dev To save a lot of gas during airdrops, the 'onePercent' value in the pledge struct is not set and remains 0. Airdrop recipients will be the only accounts that have an active status and onePercent value of 0, so elsewhere in the contract we check for this and set it to defaultPledgeOnePercent.\\r\\n    /// @param _addresses The addresses to airdrop tokens to.\\r\\n    function airdropToPledgers(address[] calldata _addresses) external onlyOwner {\\r\\n        uint256 len = _addresses.length;\\r\\n        require(totalSupply() - nonAirdropTokensMinted + len * pledgeAirdropAmount <= maxTokenSupply * 90 / 100, \\\"90% MAX SUPPLY AIRDROP CAP REACHED\\\");\\r\\n        for (uint256 i = 0; i < len; ) {          \\r\\n            require(pledger[_addresses[i]].status == 0 && _addresses[i] != address(0), \\\"INVALID PLEDGER\\\");\\r\\n            _mint(_addresses[i], pledgeAirdropAmount);\\r\\n            pledger[_addresses[i]].status = 1;\\r\\n            unchecked {\\r\\n                i += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to mint tokens to a given address.\\r\\n    /// @dev Allows the owner to mint up to 10% of maxTokenSupply amount of tokens to a given address.\\r\\n    /// @dev 10% is reserved for non-airdrop tokens, and 90% of maxTokenSupply is reserved for airdrops.\\r\\n    /// @param _to The address to mint tokens to.\\r\\n    /// @param _amount The amount of tokens to mint.\\r\\n    function mint(address _to, uint256 _amount) external virtual onlyOwner {\\r\\n        require(nonAirdropTokensMinted + _amount <= maxTokenSupply / 10, \\\"10% MAX SUPPLY NON-AIRDROP CAP REACHED\\\");\\r\\n        require(_amount > 0 && _amount + totalSupply() <= maxTokenSupply, \\\"WRONG AMOUNT\\\");\\r\\n        require(_to != address(0), \\\"INVALID ADDRESS\\\");\\r\\n        _mint(_to, _amount);\\r\\n        nonAirdropTokensMinted += _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows an EOA to register a pledge on contract.\\r\\n    /// @dev Allows EOA to record a pledge on contract if they own >= 100 base token units.\\r\\n    /// @dev Accounts that have previously failed a pledge cannot pledge again.\\r\\n    /// @dev Accounts that have an active pledge cannot reduce their pledge.\\r\\n    /// @dev monthlyWindowStart is not set during pledging, but is updated during transfers.\\r\\n    function pledge() external {\\r\\n        address from = msg.sender;\\r\\n        uint256 balance = balanceOf(from);\\r\\n        require(pledger[from].status != 2, \\\"HAS FAILED PLEDGE\\\");\\r\\n        require(balance >= 100, \\\"MUST OWN >= 100 BASE UNITS\\\");\\r\\n        uint256 pledgedBalance = getPledgedBalance(from);\\r\\n        require(balance >= pledgedBalance, \\\"CANNOT REDUCE PLEDGE\\\");\\r\\n        pledger[from].onePercent = balance / 100;\\r\\n        pledger[from].status = 1;\\r\\n        emit CreatedPledge(from, balance);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows EOA to complete a pledge.\\r\\n    /// @dev Allows EOA to complete a pledge if they have no balance and have not failed a pledge.\\r\\n    function completePledge() external {\\r\\n        address from = msg.sender;\\r\\n        require(pledger[from].status == 1, \\\"NO ACTIVE PLEDGE\\\");\\r\\n        require(balanceOf(from) == 0, \\\"MUST HAVE 0 BALANCE\\\");\\r\\n        pledger[from].status = 3;\\r\\n        emit CompletedPledge(from);\\r\\n    }\\r\\n\\r\\n    /// @dev Overrides the internal _update function to add penalty logic and pledge status updates as required.\\r\\n    /// @dev calls _updatePledgeStatus to update the pledge status for the sender.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param to The address tokens are being transferred to.\\r\\n    /// @param value The quantity of tokens being transferred.\\r\\n    function _update(address from, address to, uint256 value) internal virtual override {\\r\\n        if (\\r\\n            protectionsEnabled &&\\r\\n            block.timestamp <= protectionStartTime + PROTECTION_PERIOD &&\\r\\n            value > defaultPledgeOnePercent / limitDivisor &&\\r\\n            from != uniswapRouterAddress &&\\r\\n            from != owner() &&\\r\\n            from != address(0)\\r\\n        ) {\\r\\n            require(balanceOf(from) >= value, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n            (uint256 adjustedAmount, uint256 penalty) = _calculatePenalty(value);\\r\\n            if (penalty > 0) {\\r\\n                super._update(from, feeReceiver, penalty);\\r\\n                emit PenaltyCharged(tx.origin, value, adjustedAmount, penalty);\\r\\n            }\\r\\n            if (adjustedAmount > 0) {\\r\\n                super._update(from, to, adjustedAmount);\\r\\n            }\\r\\n        } else {\\r\\n            super._update(from, to, value);\\r\\n        }\\r\\n        if (pledger[from].status == 1) {\\r\\n            _updatePledgeStatus(from, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function that calculates the penalty for a given amount of tokens based on the time since launch and the amount over the limit.\\r\\n    /// @dev These penalties are combined to create a penalty percentage that is applied to the excess amount.\\r\\n    /// @param attemptedAmount The amount of tokens that were attempted to be transferred.\\r\\n    /// @return adjustedAmount The amount of tokens that can be transferred after the penalty.\\r\\n    /// @return penalty The amount of the penalty that will be charged.\\r\\n    function _calculatePenalty(uint256 attemptedAmount) internal view returns (uint256 adjustedAmount, uint256 penalty) {     \\r\\n        uint256 timeSinceLaunch = block.timestamp - protectionStartTime;\\r\\n        uint256 baseLimit = defaultPledgeOnePercent / limitDivisor;\\r\\n        \\r\\n        // Only apply penalty to amount over baseLimit\\r\\n        uint256 excessAmount = attemptedAmount - baseLimit;\\r\\n        \\r\\n        // Time factor: 100 at start, linearly decreases to 0\\r\\n        uint256 timePenalty = ((PROTECTION_PERIOD - timeSinceLaunch) * 100) / PROTECTION_PERIOD;\\r\\n        \\r\\n        // Amount factor: 0 when at baseLimit, approaches 100 as amount increases\\r\\n        uint256 amountPenalty = (excessAmount * 100) / (baseLimit + excessAmount);\\r\\n        \\r\\n        // Combined penalty percentage (0-100)\\r\\n        uint256 penaltyPercent = (timePenalty * amountPenalty) / 100;\\r\\n        \\r\\n        // Apply penalty to excess amount\\r\\n        uint256 penaltyAmount = (excessAmount * penaltyPercent) / 100;\\r\\n        \\r\\n        return (attemptedAmount - penaltyAmount, penaltyAmount);\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to update the pledge status for a given address.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param amount The quantity of tokens being transferred.\\r\\n    function _updatePledgeStatus(address from, uint256 amount) internal {\\r\\n        if (_isWindowExpired(from)) {\\r\\n            pledger[from].monthlyWindowStart = block.timestamp;\\r\\n            pledger[from].amountTransferredThisWindow = amount;\\r\\n        } else {\\r\\n            pledger[from].amountTransferredThisWindow += amount;\\r\\n        }\\r\\n        uint256 onePercent = pledger[from].onePercent;\\r\\n        // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n        if (onePercent == 0) {\\r\\n            onePercent = defaultPledgeOnePercent;\\r\\n        }\\r\\n        if (pledger[from].amountTransferredThisWindow > onePercent) {\\r\\n            pledger[from].status = 2;\\r\\n            emit BrokenPledge(from, pledger[from].amountTransferredThisWindow, onePercent);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check if the pledge window has expired for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return true if the pledge window has expired for the address.\\r\\n    function _isWindowExpired(address _address) internal view returns (bool) {\\r\\n        return (block.timestamp - pledger[_address].monthlyWindowStart) >= 30 days;\\r\\n    }\\r\\n}\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(_addresses[i], pledgeairdropamount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n/*                                                                                                                                                                                                                            \\r\\n                                                    ..            ..                                                      \\r\\n                                                    :.     :;:::;;:;::..                            .                     \\r\\n                                                   .:.    .;xxxxXXXXx+;:..              .                                 \\r\\n                                                   . .   :;X$&&$&&$$$X+;::...         ...                                 \\r\\n                                                  .  ..:+xX$x:.....:+XXx++;::...........:.                                \\r\\n                                                .+++++xX$X+.           .+XX++;;:::::...:;;:..........        .            \\r\\n                                    .         . .+$&&&&x:.                .;Xx++;;;;::;;+++;;:::..:::......     .         \\r\\n                              . . .  .     .      :::;:...                   :xXXx++;+++xXx;+;..... .        .            \\r\\n            . ..  . .  ... .. . ..  ...              ...                   ....:X$XXxxxXXXXxx+x++;;;::............ .      \\r\\n        .. ......... .. .......... .... .  .                              ...:...:X$$X$Xx+;;;;:...... ... ...... . ..     \\r\\n        .........:......... .       ....... .                              .:;:.....$$X;.   ..;;;;;;;;;;;;:::..:......    \\r\\n     .....::::;;:;+.;:.:...         ...::::.. . ...  .            .       ...:::.. ...;      .+xx++;+;+;+;;;;;;:;:::...   \\r\\n    ..:..:+;;++;x++Xxxxxx++x;::...    ::;;;:;......... .          ....    ...:;;::..  ...    .;++xx++++xx+x++x++++;:..    \\r\\n  ..::.;;+;++xx+XXX$XXXX$$$&&&$$$$$Xx::;++++;:;.............      .:;;;;::...:xx;:....  .;::::xXXXXXXXX$$$$$$$$XXxx;+:.   \\r\\n . :::;;+x+xXXXXXX$$$$$$$$$$$$&$$$$$&&$$$X+++;:......... ......    .+xxXxx::..;XX+;.......+x+$$$$$$Xx;:                   \\r\\n  ..:;;;xXXX$$$&&$$XxxXxxxx+++;;+++++x$&&$Xx+;;;.....:.........    .:+xxxx;;:..+$Xx+::....;X$$.                           \\r\\n                                    ;&$+;;X&$x+;;:..:::::;....:..   .+xxx++::...;$&Xx+;:..+;                              \\r\\n                                    x$x.   +&&$XXx;;:;::;+;..:;;++;:;+x$x++;;....;$&$XXXXXX.                              \\r\\n                                     +$;;:;X$+   .xXxxxx+++;..;xX$$X+;x$$x;+;;::.:;$&$$$$$;                               \\r\\n                                        x$$$$X;...;$$+.  ;Xx+..;xXXxx++x$$Xx++;;:::+$$$$x.                                \\r\\n                                           ;X$X$XX$Xx+;:;;x$$XXx$$Xxx+++x$$XXx+++;::.                                     \\r\\n                                            ;XX&&&&xxXX$$$&$+:;X$&$Xxx+++x$&$Xx+;:::                                      \\r\\n                                               ;&$Xxxx$$$&X++:.:XX$$XXxx+xx$&XXX++:                                       \\r\\n                                                :X$$$$$&$x;xXX$$$$X$$XXXX++x.                                             \\r\\n                                                    :+x$x++;+x$&$XXxX$XXx+;                                               \\r\\n                                                       ;XX$$$$$$X++;.                                                     \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                          ........    ......      ..........  .......        .:;:.:.  ..........                          \\r\\n                          :;&X;;+X$;  ;+$X;;.     ;x$+;;;+Xx  :$$;;+X$+.   +$+:.;X&+  ;x$x;;;;XX                          \\r\\n                            &+    +$   .Xx         ;X. .; ;+   XX    .xx. X$.     +:   :$: .: +x                          \\r\\n                            &x   :Xx   .Xx         ;$XxX&      XX     ;$::$x           :$XxX$                             \\r\\n                            &$xxx+.    .Xx     x.  ;X. .x  .   XX     ;$..$x   ;XX$$:  :$: .+  .                          \\r\\n                            &+         .Xx    .&:  ;X.    +x   XX    :X+  x&;     Xx   :$:    +X                          \\r\\n                          +x&$x+:     xx$$xxxxx&:.+X$XxxxxXx  ;$$xxxXX:    ;XX+;;x$+  +X$Xxxxx$X                          \\r\\n*/\\r\\n\\r\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport {ERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/// @title PLEDGE Token\\r\\n/// @dev ERC20 token with pledge mechanics where if a user pledges to limit their monthly transfers, they can transfer up to 1% of their balance each month without breaking the pledge.\\r\\n/// @notice This is a token contract where holders can pledge to limit their monthly transfers.\\r\\n/// @author MonkMatto\\r\\n/// @custom:security-contact monkmatto@protonmail.com\\r\\n/// @custom:disclaimer Not audited. Use at your own risk.\\r\\n/// @custom:version v0.5.4\\r\\ncontract PLEDGE is ERC20, ERC20Permit, Ownable {\\r\\n\\r\\n    /// @notice Constructor to create PLEDGE token with admin rights and permit functionality.\\r\\n    constructor()\\r\\n        ERC20(\\\"PLEDGE\\\", \\\"PLEDGE\\\")\\r\\n        ERC20Permit(\\\"PLEDGE\\\")\\r\\n        Ownable(msg.sender)\\r\\n    {}\\r\\n\\r\\n    bool public protectionsEnabled; // Whether protections are enabled or disabled\\r\\n    address public feeReceiver; // The address that receives fees during the protection period\\r\\n    address public uniswapRouterAddress = 0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD; // The address of the Uniswap Router for penalty exemptions, set to the Universal Router by default\\r\\n    uint256 public nonAirdropTokensMinted; // The number of non-airdrop tokens minted\\r\\n    uint256 public protectionStartTime; // The timestamp for calculating penalties\\r\\n    uint256 public maxTokenSupply = 1_000_000_000 * (10 ** decimals()); // 1 billion tokens with 18 decimals\\r\\n    uint256 public pledgeAirdropAmount = maxTokenSupply / 1_000; // 0.1% of maxTokenSupply\\r\\n    uint256 public defaultPledgeOnePercent = pledgeAirdropAmount / 100; // 0.001% of maxTokenSupply\\r\\n    uint256 private limitDivisor = 10; // The divisor for the pledge limit\\r\\n    uint256 public constant PROTECTION_PERIOD = 125 minutes; // Period of time during which protections are enabled\\r\\n\\r\\n    /// @dev Stores pledge data for each address\\r\\n    /// @param status The status of the pledge: 0 for no pledge, 1 for active pledge, 2 for failed pledge, and 3 for completed pledge\\r\\n    /// @param onePercent One percent of the pledged balance. For initial airdrops, this is kept at value 0 for optimization but is handled in other functions\\r\\n    /// @param monthlyWindowStart The timestamp when the current monthly window started\\r\\n    /// @param amountTransferredThisWindow Amount of tokens transferred in current window\\r\\n    struct PledgeData {\\r\\n        uint8 status;\\r\\n        uint256 onePercent;\\r\\n        uint256 monthlyWindowStart;\\r\\n        uint256 amountTransferredThisWindow;\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping of addresses to their pledge data\\r\\n    mapping(address => PledgeData) public pledger;\\r\\n\\r\\n    /// @dev Emitted when protections are toggled\\r\\n    /// @param enabled Whether protections are enabled or disabled\\r\\n    /// @param feeRecipient The address that receives penalties\\r\\n    /// @param timestamp The timestamp of the event\\r\\n    event ProtectionsToggled(bool enabled, address feeRecipient, uint256 timestamp);\\r\\n\\r\\n    /// @dev Emitted when a penalty is charged\\r\\n    /// @param user The address that was charged the penalty\\r\\n    /// @param attemptedAmount The amount that was attempted to be transferred\\r\\n    /// @param adjustedAmount The amount that was actually transferred after the penalty\\r\\n    /// @param penalty The amount of the penalty sent to the feeReceiver\\r\\n    event PenaltyCharged(address user, uint256 attemptedAmount, uint256 adjustedAmount, uint256 penalty);\\r\\n\\r\\n    /// @dev Emitted when a new pledge is created\\r\\n    /// @param pledgerAddress The address that created the pledge\\r\\n    /// @param pledgerBalance The balance pledged\\r\\n    event CreatedPledge(address indexed pledgerAddress, uint256 pledgerBalance);\\r\\n\\r\\n    /// @dev Emitted when a pledge is broken due to excessive transfers\\r\\n    /// @param pledgerAddress The address that broke their pledge\\r\\n    /// @param transferredAmount The amount transferred that broke the pledge\\r\\n    /// @param allowedTransferAmount The maximum amount that was allowed to transfer\\r\\n    event BrokenPledge(address indexed pledgerAddress, uint256 transferredAmount, uint256 allowedTransferAmount);\\r\\n\\r\\n    /// @dev Emitted when a pledge is completed\\r\\n    /// @param pledgerAddress The address that completed their pledge\\r\\n    event CompletedPledge(address indexed pledgerAddress);\\r\\n\\r\\n    /// @notice Returns the time in seconds remaining in the current window for a given address.\\r\\n    /// @dev Conveniently calculates time until the current window expires for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The time until the current window expires in seconds\\r\\n    function getTimeRemainingInWindow(address _address) public view returns (uint256) {\\r\\n        if (_isWindowExpired(_address)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return 30 days - (block.timestamp - pledger[_address].monthlyWindowStart);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount that can be transferred by a given address at the current time without breaking the pledge. If there is no pledge active, it returns 0.\\r\\n    /// @dev If the pledge is active, it checks if the current window has expired. If it has, it returns the full one percent, otherwise it returns the remaining amount that can be transferred in the current window.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The amount that can be transferred by the address at the current time without breaking the pledge.\\r\\n    function getTransferableAmount(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n          uint256 transferable;\\r\\n          uint256 onePercent = pledger[_address].onePercent;\\r\\n          // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n          if (onePercent == 0) {\\r\\n              onePercent = defaultPledgeOnePercent;\\r\\n          }\\r\\n          if (_isWindowExpired(_address)) {\\r\\n              transferable = onePercent;\\r\\n          } else {\\r\\n              transferable = onePercent - pledger[_address].amountTransferredThisWindow;\\r\\n          }\\r\\n          return transferable > balanceOf(_address) ? balanceOf(_address) : transferable;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledged balance of a given address.\\r\\n    /// @dev If the pledge is active, it returns a very close approximation of the initially pledged balance, otherwise it returns 0.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return pledgedBalance The pledged balance of the address.\\r\\n    function getPledgedBalance(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n            uint256 onePercent = pledger[_address].onePercent;\\r\\n            // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n            if (onePercent == 0) {\\r\\n                onePercent = defaultPledgeOnePercent;\\r\\n            }\\r\\n            uint256 pledgedBalance = onePercent * 100;\\r\\n            return pledgedBalance;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledge data of a given address.\\r\\n    /// @dev Returns the pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window (0 means the window has expired) for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window for the address.\\r\\n    function getPledgerData(address _address) external view returns (uint8, uint256, uint256, uint256, uint256, uint256) {\\r\\n        return (\\r\\n            pledger[_address].status,\\r\\n            balanceOf(_address),\\r\\n            getPledgedBalance(_address),\\r\\n            pledger[_address].amountTransferredThisWindow,\\r\\n            getTransferableAmount(_address),\\r\\n            getTimeRemainingInWindow(_address)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to begin a temporary launch protection.\\r\\n    /// @dev Allows the owner to enable protections for a set period of time and set the feeReceiver address.\\r\\n    /// @param _feeReceiver The address that will receive penalties.\\r\\n    function beginLaunchProtection(address _feeReceiver) external onlyOwner {\\r\\n        feeReceiver = _feeReceiver;\\r\\n        protectionsEnabled = true;\\r\\n        protectionStartTime = block.timestamp;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to disable launch protection.\\r\\n    /// @dev After the protection window has ended, penalties are automatically bypassed, but the owner can disable protections to save gas on future transfers.\\r\\n    function disableLaunchProtection() external onlyOwner {\\r\\n        protectionsEnabled = false;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the Uniswap Router address.\\r\\n    /// @dev Allows the owner to set the Uniswap Router address to prevent penalties on token distributions from the router.\\r\\n    /// @dev It is set as state on deployment to the universal router address, but it can be updated on contract if needed.\\r\\n    /// @param _uniswapRouterAddress The address of the Uniswap Router being used for token distributions during the protection period.\\r\\n    function setUniswapRouterAddress(address _uniswapRouterAddress) external onlyOwner {\\r\\n        uniswapRouterAddress = _uniswapRouterAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the amount that can be transferred without penalty during the protection period.\\r\\n    /// @dev Sets the divisor for the defaultPledgerOnePercent value, which is used to calculate the base limit for transfers during the protection period.\\r\\n    /// @param _limitDivisor The amount to divide defaultPledgerOnePercent by.\\r\\n    function setLimitDivisor(uint256 _limitDivisor) external onlyOwner {\\r\\n        require(_limitDivisor > 0, \\\"INVALID_DIVISOR\\\");\\r\\n        limitDivisor = _limitDivisor;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to airdrop tokens to pledgers.\\r\\n    /// @dev Allows the owner to airdrop 1 million tokens or 0.1% of maxTokenSupply number of tokens to pledgers who have not yet pledged.\\r\\n    /// @dev 90% of maxTokenSupply is reserved for airdrops, and 10% is reserved for non-airdrop tokens.\\r\\n    /// @dev To save a lot of gas during airdrops, the 'onePercent' value in the pledge struct is not set and remains 0. Airdrop recipients will be the only accounts that have an active status and onePercent value of 0, so elsewhere in the contract we check for this and set it to defaultPledgeOnePercent.\\r\\n    /// @param _addresses The addresses to airdrop tokens to.\\r\\n    function airdropToPledgers(address[] calldata _addresses) external onlyOwner {\\r\\n        uint256 len = _addresses.length;\\r\\n        require(totalSupply() - nonAirdropTokensMinted + len * pledgeAirdropAmount <= maxTokenSupply * 90 / 100, \\\"90% MAX SUPPLY AIRDROP CAP REACHED\\\");\\r\\n        for (uint256 i = 0; i < len; ) {          \\r\\n            require(pledger[_addresses[i]].status == 0 && _addresses[i] != address(0), \\\"INVALID PLEDGER\\\");\\r\\n            _mint(_addresses[i], pledgeAirdropAmount);\\r\\n            pledger[_addresses[i]].status = 1;\\r\\n            unchecked {\\r\\n                i += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to mint tokens to a given address.\\r\\n    /// @dev Allows the owner to mint up to 10% of maxTokenSupply amount of tokens to a given address.\\r\\n    /// @dev 10% is reserved for non-airdrop tokens, and 90% of maxTokenSupply is reserved for airdrops.\\r\\n    /// @param _to The address to mint tokens to.\\r\\n    /// @param _amount The amount of tokens to mint.\\r\\n    function mint(address _to, uint256 _amount) external virtual onlyOwner {\\r\\n        require(nonAirdropTokensMinted + _amount <= maxTokenSupply / 10, \\\"10% MAX SUPPLY NON-AIRDROP CAP REACHED\\\");\\r\\n        require(_amount > 0 && _amount + totalSupply() <= maxTokenSupply, \\\"WRONG AMOUNT\\\");\\r\\n        require(_to != address(0), \\\"INVALID ADDRESS\\\");\\r\\n        _mint(_to, _amount);\\r\\n        nonAirdropTokensMinted += _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows an EOA to register a pledge on contract.\\r\\n    /// @dev Allows EOA to record a pledge on contract if they own >= 100 base token units.\\r\\n    /// @dev Accounts that have previously failed a pledge cannot pledge again.\\r\\n    /// @dev Accounts that have an active pledge cannot reduce their pledge.\\r\\n    /// @dev monthlyWindowStart is not set during pledging, but is updated during transfers.\\r\\n    function pledge() external {\\r\\n        address from = msg.sender;\\r\\n        uint256 balance = balanceOf(from);\\r\\n        require(pledger[from].status != 2, \\\"HAS FAILED PLEDGE\\\");\\r\\n        require(balance >= 100, \\\"MUST OWN >= 100 BASE UNITS\\\");\\r\\n        uint256 pledgedBalance = getPledgedBalance(from);\\r\\n        require(balance >= pledgedBalance, \\\"CANNOT REDUCE PLEDGE\\\");\\r\\n        pledger[from].onePercent = balance / 100;\\r\\n        pledger[from].status = 1;\\r\\n        emit CreatedPledge(from, balance);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows EOA to complete a pledge.\\r\\n    /// @dev Allows EOA to complete a pledge if they have no balance and have not failed a pledge.\\r\\n    function completePledge() external {\\r\\n        address from = msg.sender;\\r\\n        require(pledger[from].status == 1, \\\"NO ACTIVE PLEDGE\\\");\\r\\n        require(balanceOf(from) == 0, \\\"MUST HAVE 0 BALANCE\\\");\\r\\n        pledger[from].status = 3;\\r\\n        emit CompletedPledge(from);\\r\\n    }\\r\\n\\r\\n    /// @dev Overrides the internal _update function to add penalty logic and pledge status updates as required.\\r\\n    /// @dev calls _updatePledgeStatus to update the pledge status for the sender.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param to The address tokens are being transferred to.\\r\\n    /// @param value The quantity of tokens being transferred.\\r\\n    function _update(address from, address to, uint256 value) internal virtual override {\\r\\n        if (\\r\\n            protectionsEnabled &&\\r\\n            block.timestamp <= protectionStartTime + PROTECTION_PERIOD &&\\r\\n            value > defaultPledgeOnePercent / limitDivisor &&\\r\\n            from != uniswapRouterAddress &&\\r\\n            from != owner() &&\\r\\n            from != address(0)\\r\\n        ) {\\r\\n            require(balanceOf(from) >= value, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n            (uint256 adjustedAmount, uint256 penalty) = _calculatePenalty(value);\\r\\n            if (penalty > 0) {\\r\\n                super._update(from, feeReceiver, penalty);\\r\\n                emit PenaltyCharged(tx.origin, value, adjustedAmount, penalty);\\r\\n            }\\r\\n            if (adjustedAmount > 0) {\\r\\n                super._update(from, to, adjustedAmount);\\r\\n            }\\r\\n        } else {\\r\\n            super._update(from, to, value);\\r\\n        }\\r\\n        if (pledger[from].status == 1) {\\r\\n            _updatePledgeStatus(from, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function that calculates the penalty for a given amount of tokens based on the time since launch and the amount over the limit.\\r\\n    /// @dev These penalties are combined to create a penalty percentage that is applied to the excess amount.\\r\\n    /// @param attemptedAmount The amount of tokens that were attempted to be transferred.\\r\\n    /// @return adjustedAmount The amount of tokens that can be transferred after the penalty.\\r\\n    /// @return penalty The amount of the penalty that will be charged.\\r\\n    function _calculatePenalty(uint256 attemptedAmount) internal view returns (uint256 adjustedAmount, uint256 penalty) {     \\r\\n        uint256 timeSinceLaunch = block.timestamp - protectionStartTime;\\r\\n        uint256 baseLimit = defaultPledgeOnePercent / limitDivisor;\\r\\n        \\r\\n        // Only apply penalty to amount over baseLimit\\r\\n        uint256 excessAmount = attemptedAmount - baseLimit;\\r\\n        \\r\\n        // Time factor: 100 at start, linearly decreases to 0\\r\\n        uint256 timePenalty = ((PROTECTION_PERIOD - timeSinceLaunch) * 100) / PROTECTION_PERIOD;\\r\\n        \\r\\n        // Amount factor: 0 when at baseLimit, approaches 100 as amount increases\\r\\n        uint256 amountPenalty = (excessAmount * 100) / (baseLimit + excessAmount);\\r\\n        \\r\\n        // Combined penalty percentage (0-100)\\r\\n        uint256 penaltyPercent = (timePenalty * amountPenalty) / 100;\\r\\n        \\r\\n        // Apply penalty to excess amount\\r\\n        uint256 penaltyAmount = (excessAmount * penaltyPercent) / 100;\\r\\n        \\r\\n        return (attemptedAmount - penaltyAmount, penaltyAmount);\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to update the pledge status for a given address.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param amount The quantity of tokens being transferred.\\r\\n    function _updatePledgeStatus(address from, uint256 amount) internal {\\r\\n        if (_isWindowExpired(from)) {\\r\\n            pledger[from].monthlyWindowStart = block.timestamp;\\r\\n            pledger[from].amountTransferredThisWindow = amount;\\r\\n        } else {\\r\\n            pledger[from].amountTransferredThisWindow += amount;\\r\\n        }\\r\\n        uint256 onePercent = pledger[from].onePercent;\\r\\n        // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n        if (onePercent == 0) {\\r\\n            onePercent = defaultPledgeOnePercent;\\r\\n        }\\r\\n        if (pledger[from].amountTransferredThisWindow > onePercent) {\\r\\n            pledger[from].status = 2;\\r\\n            emit BrokenPledge(from, pledger[from].amountTransferredThisWindow, onePercent);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check if the pledge window has expired for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return true if the pledge window has expired for the address.\\r\\n    function _isWindowExpired(address _address) internal view returns (bool) {\\r\\n        return (block.timestamp - pledger[_address].monthlyWindowStart) >= 30 days;\\r\\n    }\\r\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n/*                                                                                                                                                                                                                            \\r\\n                                                    ..            ..                                                      \\r\\n                                                    :.     :;:::;;:;::..                            .                     \\r\\n                                                   .:.    .;xxxxXXXXx+;:..              .                                 \\r\\n                                                   . .   :;X$&&$&&$$$X+;::...         ...                                 \\r\\n                                                  .  ..:+xX$x:.....:+XXx++;::...........:.                                \\r\\n                                                .+++++xX$X+.           .+XX++;;:::::...:;;:..........        .            \\r\\n                                    .         . .+$&&&&x:.                .;Xx++;;;;::;;+++;;:::..:::......     .         \\r\\n                              . . .  .     .      :::;:...                   :xXXx++;+++xXx;+;..... .        .            \\r\\n            . ..  . .  ... .. . ..  ...              ...                   ....:X$XXxxxXXXXxx+x++;;;::............ .      \\r\\n        .. ......... .. .......... .... .  .                              ...:...:X$$X$Xx+;;;;:...... ... ...... . ..     \\r\\n        .........:......... .       ....... .                              .:;:.....$$X;.   ..;;;;;;;;;;;;:::..:......    \\r\\n     .....::::;;:;+.;:.:...         ...::::.. . ...  .            .       ...:::.. ...;      .+xx++;+;+;+;;;;;;:;:::...   \\r\\n    ..:..:+;;++;x++Xxxxxx++x;::...    ::;;;:;......... .          ....    ...:;;::..  ...    .;++xx++++xx+x++x++++;:..    \\r\\n  ..::.;;+;++xx+XXX$XXXX$$$&&&$$$$$Xx::;++++;:;.............      .:;;;;::...:xx;:....  .;::::xXXXXXXXX$$$$$$$$XXxx;+:.   \\r\\n . :::;;+x+xXXXXXX$$$$$$$$$$$$&$$$$$&&$$$X+++;:......... ......    .+xxXxx::..;XX+;.......+x+$$$$$$Xx;:                   \\r\\n  ..:;;;xXXX$$$&&$$XxxXxxxx+++;;+++++x$&&$Xx+;;;.....:.........    .:+xxxx;;:..+$Xx+::....;X$$.                           \\r\\n                                    ;&$+;;X&$x+;;:..:::::;....:..   .+xxx++::...;$&Xx+;:..+;                              \\r\\n                                    x$x.   +&&$XXx;;:;::;+;..:;;++;:;+x$x++;;....;$&$XXXXXX.                              \\r\\n                                     +$;;:;X$+   .xXxxxx+++;..;xX$$X+;x$$x;+;;::.:;$&$$$$$;                               \\r\\n                                        x$$$$X;...;$$+.  ;Xx+..;xXXxx++x$$Xx++;;:::+$$$$x.                                \\r\\n                                           ;X$X$XX$Xx+;:;;x$$XXx$$Xxx+++x$$XXx+++;::.                                     \\r\\n                                            ;XX&&&&xxXX$$$&$+:;X$&$Xxx+++x$&$Xx+;:::                                      \\r\\n                                               ;&$Xxxx$$$&X++:.:XX$$XXxx+xx$&XXX++:                                       \\r\\n                                                :X$$$$$&$x;xXX$$$$X$$XXXX++x.                                             \\r\\n                                                    :+x$x++;+x$&$XXxX$XXx+;                                               \\r\\n                                                       ;XX$$$$$$X++;.                                                     \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                                                                                                                          \\r\\n                          ........    ......      ..........  .......        .:;:.:.  ..........                          \\r\\n                          :;&X;;+X$;  ;+$X;;.     ;x$+;;;+Xx  :$$;;+X$+.   +$+:.;X&+  ;x$x;;;;XX                          \\r\\n                            &+    +$   .Xx         ;X. .; ;+   XX    .xx. X$.     +:   :$: .: +x                          \\r\\n                            &x   :Xx   .Xx         ;$XxX&      XX     ;$::$x           :$XxX$                             \\r\\n                            &$xxx+.    .Xx     x.  ;X. .x  .   XX     ;$..$x   ;XX$$:  :$: .+  .                          \\r\\n                            &+         .Xx    .&:  ;X.    +x   XX    :X+  x&;     Xx   :$:    +X                          \\r\\n                          +x&$x+:     xx$$xxxxx&:.+X$XxxxxXx  ;$$xxxXX:    ;XX+;;x$+  +X$Xxxxx$X                          \\r\\n*/\\r\\n\\r\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport {ERC20Permit} from \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\r\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/// @title PLEDGE Token\\r\\n/// @dev ERC20 token with pledge mechanics where if a user pledges to limit their monthly transfers, they can transfer up to 1% of their balance each month without breaking the pledge.\\r\\n/// @notice This is a token contract where holders can pledge to limit their monthly transfers.\\r\\n/// @author MonkMatto\\r\\n/// @custom:security-contact monkmatto@protonmail.com\\r\\n/// @custom:disclaimer Not audited. Use at your own risk.\\r\\n/// @custom:version v0.5.4\\r\\ncontract PLEDGE is ERC20, ERC20Permit, Ownable {\\r\\n\\r\\n    /// @notice Constructor to create PLEDGE token with admin rights and permit functionality.\\r\\n    constructor()\\r\\n        ERC20(\\\"PLEDGE\\\", \\\"PLEDGE\\\")\\r\\n        ERC20Permit(\\\"PLEDGE\\\")\\r\\n        Ownable(msg.sender)\\r\\n    {}\\r\\n\\r\\n    bool public protectionsEnabled; // Whether protections are enabled or disabled\\r\\n    address public feeReceiver; // The address that receives fees during the protection period\\r\\n    address public uniswapRouterAddress = 0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD; // The address of the Uniswap Router for penalty exemptions, set to the Universal Router by default\\r\\n    uint256 public nonAirdropTokensMinted; // The number of non-airdrop tokens minted\\r\\n    uint256 public protectionStartTime; // The timestamp for calculating penalties\\r\\n    uint256 public maxTokenSupply = 1_000_000_000 * (10 ** decimals()); // 1 billion tokens with 18 decimals\\r\\n    uint256 public pledgeAirdropAmount = maxTokenSupply / 1_000; // 0.1% of maxTokenSupply\\r\\n    uint256 public defaultPledgeOnePercent = pledgeAirdropAmount / 100; // 0.001% of maxTokenSupply\\r\\n    uint256 private limitDivisor = 10; // The divisor for the pledge limit\\r\\n    uint256 public constant PROTECTION_PERIOD = 125 minutes; // Period of time during which protections are enabled\\r\\n\\r\\n    /// @dev Stores pledge data for each address\\r\\n    /// @param status The status of the pledge: 0 for no pledge, 1 for active pledge, 2 for failed pledge, and 3 for completed pledge\\r\\n    /// @param onePercent One percent of the pledged balance. For initial airdrops, this is kept at value 0 for optimization but is handled in other functions\\r\\n    /// @param monthlyWindowStart The timestamp when the current monthly window started\\r\\n    /// @param amountTransferredThisWindow Amount of tokens transferred in current window\\r\\n    struct PledgeData {\\r\\n        uint8 status;\\r\\n        uint256 onePercent;\\r\\n        uint256 monthlyWindowStart;\\r\\n        uint256 amountTransferredThisWindow;\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping of addresses to their pledge data\\r\\n    mapping(address => PledgeData) public pledger;\\r\\n\\r\\n    /// @dev Emitted when protections are toggled\\r\\n    /// @param enabled Whether protections are enabled or disabled\\r\\n    /// @param feeRecipient The address that receives penalties\\r\\n    /// @param timestamp The timestamp of the event\\r\\n    event ProtectionsToggled(bool enabled, address feeRecipient, uint256 timestamp);\\r\\n\\r\\n    /// @dev Emitted when a penalty is charged\\r\\n    /// @param user The address that was charged the penalty\\r\\n    /// @param attemptedAmount The amount that was attempted to be transferred\\r\\n    /// @param adjustedAmount The amount that was actually transferred after the penalty\\r\\n    /// @param penalty The amount of the penalty sent to the feeReceiver\\r\\n    event PenaltyCharged(address user, uint256 attemptedAmount, uint256 adjustedAmount, uint256 penalty);\\r\\n\\r\\n    /// @dev Emitted when a new pledge is created\\r\\n    /// @param pledgerAddress The address that created the pledge\\r\\n    /// @param pledgerBalance The balance pledged\\r\\n    event CreatedPledge(address indexed pledgerAddress, uint256 pledgerBalance);\\r\\n\\r\\n    /// @dev Emitted when a pledge is broken due to excessive transfers\\r\\n    /// @param pledgerAddress The address that broke their pledge\\r\\n    /// @param transferredAmount The amount transferred that broke the pledge\\r\\n    /// @param allowedTransferAmount The maximum amount that was allowed to transfer\\r\\n    event BrokenPledge(address indexed pledgerAddress, uint256 transferredAmount, uint256 allowedTransferAmount);\\r\\n\\r\\n    /// @dev Emitted when a pledge is completed\\r\\n    /// @param pledgerAddress The address that completed their pledge\\r\\n    event CompletedPledge(address indexed pledgerAddress);\\r\\n\\r\\n    /// @notice Returns the time in seconds remaining in the current window for a given address.\\r\\n    /// @dev Conveniently calculates time until the current window expires for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The time until the current window expires in seconds\\r\\n    function getTimeRemainingInWindow(address _address) public view returns (uint256) {\\r\\n        if (_isWindowExpired(_address)) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return 30 days - (block.timestamp - pledger[_address].monthlyWindowStart);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount that can be transferred by a given address at the current time without breaking the pledge. If there is no pledge active, it returns 0.\\r\\n    /// @dev If the pledge is active, it checks if the current window has expired. If it has, it returns the full one percent, otherwise it returns the remaining amount that can be transferred in the current window.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The amount that can be transferred by the address at the current time without breaking the pledge.\\r\\n    function getTransferableAmount(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n          uint256 transferable;\\r\\n          uint256 onePercent = pledger[_address].onePercent;\\r\\n          // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n          if (onePercent == 0) {\\r\\n              onePercent = defaultPledgeOnePercent;\\r\\n          }\\r\\n          if (_isWindowExpired(_address)) {\\r\\n              transferable = onePercent;\\r\\n          } else {\\r\\n              transferable = onePercent - pledger[_address].amountTransferredThisWindow;\\r\\n          }\\r\\n          return transferable > balanceOf(_address) ? balanceOf(_address) : transferable;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledged balance of a given address.\\r\\n    /// @dev If the pledge is active, it returns a very close approximation of the initially pledged balance, otherwise it returns 0.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return pledgedBalance The pledged balance of the address.\\r\\n    function getPledgedBalance(address _address) public view returns (uint256) {\\r\\n        if (pledger[_address].status == 1) {\\r\\n            uint256 onePercent = pledger[_address].onePercent;\\r\\n            // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n            if (onePercent == 0) {\\r\\n                onePercent = defaultPledgeOnePercent;\\r\\n            }\\r\\n            uint256 pledgedBalance = onePercent * 100;\\r\\n            return pledgedBalance;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the pledge data of a given address.\\r\\n    /// @dev Returns the pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window (0 means the window has expired) for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return The pledger status, balance, pledged balance, amount transferred this window, transferable amount, and time remaining in the current window for the address.\\r\\n    function getPledgerData(address _address) external view returns (uint8, uint256, uint256, uint256, uint256, uint256) {\\r\\n        return (\\r\\n            pledger[_address].status,\\r\\n            balanceOf(_address),\\r\\n            getPledgedBalance(_address),\\r\\n            pledger[_address].amountTransferredThisWindow,\\r\\n            getTransferableAmount(_address),\\r\\n            getTimeRemainingInWindow(_address)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to begin a temporary launch protection.\\r\\n    /// @dev Allows the owner to enable protections for a set period of time and set the feeReceiver address.\\r\\n    /// @param _feeReceiver The address that will receive penalties.\\r\\n    function beginLaunchProtection(address _feeReceiver) external onlyOwner {\\r\\n        feeReceiver = _feeReceiver;\\r\\n        protectionsEnabled = true;\\r\\n        protectionStartTime = block.timestamp;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to disable launch protection.\\r\\n    /// @dev After the protection window has ended, penalties are automatically bypassed, but the owner can disable protections to save gas on future transfers.\\r\\n    function disableLaunchProtection() external onlyOwner {\\r\\n        protectionsEnabled = false;\\r\\n        emit ProtectionsToggled(protectionsEnabled, feeReceiver, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the Uniswap Router address.\\r\\n    /// @dev Allows the owner to set the Uniswap Router address to prevent penalties on token distributions from the router.\\r\\n    /// @dev It is set as state on deployment to the universal router address, but it can be updated on contract if needed.\\r\\n    /// @param _uniswapRouterAddress The address of the Uniswap Router being used for token distributions during the protection period.\\r\\n    function setUniswapRouterAddress(address _uniswapRouterAddress) external onlyOwner {\\r\\n        uniswapRouterAddress = _uniswapRouterAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to set the amount that can be transferred without penalty during the protection period.\\r\\n    /// @dev Sets the divisor for the defaultPledgerOnePercent value, which is used to calculate the base limit for transfers during the protection period.\\r\\n    /// @param _limitDivisor The amount to divide defaultPledgerOnePercent by.\\r\\n    function setLimitDivisor(uint256 _limitDivisor) external onlyOwner {\\r\\n        require(_limitDivisor > 0, \\\"INVALID_DIVISOR\\\");\\r\\n        limitDivisor = _limitDivisor;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to airdrop tokens to pledgers.\\r\\n    /// @dev Allows the owner to airdrop 1 million tokens or 0.1% of maxTokenSupply number of tokens to pledgers who have not yet pledged.\\r\\n    /// @dev 90% of maxTokenSupply is reserved for airdrops, and 10% is reserved for non-airdrop tokens.\\r\\n    /// @dev To save a lot of gas during airdrops, the 'onePercent' value in the pledge struct is not set and remains 0. Airdrop recipients will be the only accounts that have an active status and onePercent value of 0, so elsewhere in the contract we check for this and set it to defaultPledgeOnePercent.\\r\\n    /// @param _addresses The addresses to airdrop tokens to.\\r\\n    function airdropToPledgers(address[] calldata _addresses) external onlyOwner {\\r\\n        uint256 len = _addresses.length;\\r\\n        require(totalSupply() - nonAirdropTokensMinted + len * pledgeAirdropAmount <= maxTokenSupply * 90 / 100, \\\"90% MAX SUPPLY AIRDROP CAP REACHED\\\");\\r\\n        for (uint256 i = 0; i < len; ) {          \\r\\n            require(pledger[_addresses[i]].status == 0 && _addresses[i] != address(0), \\\"INVALID PLEDGER\\\");\\r\\n            _mint(_addresses[i], pledgeAirdropAmount);\\r\\n            pledger[_addresses[i]].status = 1;\\r\\n            unchecked {\\r\\n                i += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Allows the owner to mint tokens to a given address.\\r\\n    /// @dev Allows the owner to mint up to 10% of maxTokenSupply amount of tokens to a given address.\\r\\n    /// @dev 10% is reserved for non-airdrop tokens, and 90% of maxTokenSupply is reserved for airdrops.\\r\\n    /// @param _to The address to mint tokens to.\\r\\n    /// @param _amount The amount of tokens to mint.\\r\\n    function mint(address _to, uint256 _amount) external virtual onlyOwner {\\r\\n        require(nonAirdropTokensMinted + _amount <= maxTokenSupply / 10, \\\"10% MAX SUPPLY NON-AIRDROP CAP REACHED\\\");\\r\\n        require(_amount > 0 && _amount + totalSupply() <= maxTokenSupply, \\\"WRONG AMOUNT\\\");\\r\\n        require(_to != address(0), \\\"INVALID ADDRESS\\\");\\r\\n        _mint(_to, _amount);\\r\\n        nonAirdropTokensMinted += _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows an EOA to register a pledge on contract.\\r\\n    /// @dev Allows EOA to record a pledge on contract if they own >= 100 base token units.\\r\\n    /// @dev Accounts that have previously failed a pledge cannot pledge again.\\r\\n    /// @dev Accounts that have an active pledge cannot reduce their pledge.\\r\\n    /// @dev monthlyWindowStart is not set during pledging, but is updated during transfers.\\r\\n    function pledge() external {\\r\\n        address from = msg.sender;\\r\\n        uint256 balance = balanceOf(from);\\r\\n        require(pledger[from].status != 2, \\\"HAS FAILED PLEDGE\\\");\\r\\n        require(balance >= 100, \\\"MUST OWN >= 100 BASE UNITS\\\");\\r\\n        uint256 pledgedBalance = getPledgedBalance(from);\\r\\n        require(balance >= pledgedBalance, \\\"CANNOT REDUCE PLEDGE\\\");\\r\\n        pledger[from].onePercent = balance / 100;\\r\\n        pledger[from].status = 1;\\r\\n        emit CreatedPledge(from, balance);\\r\\n    }\\r\\n\\r\\n    /// @notice Allows EOA to complete a pledge.\\r\\n    /// @dev Allows EOA to complete a pledge if they have no balance and have not failed a pledge.\\r\\n    function completePledge() external {\\r\\n        address from = msg.sender;\\r\\n        require(pledger[from].status == 1, \\\"NO ACTIVE PLEDGE\\\");\\r\\n        require(balanceOf(from) == 0, \\\"MUST HAVE 0 BALANCE\\\");\\r\\n        pledger[from].status = 3;\\r\\n        emit CompletedPledge(from);\\r\\n    }\\r\\n\\r\\n    /// @dev Overrides the internal _update function to add penalty logic and pledge status updates as required.\\r\\n    /// @dev calls _updatePledgeStatus to update the pledge status for the sender.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param to The address tokens are being transferred to.\\r\\n    /// @param value The quantity of tokens being transferred.\\r\\n    function _update(address from, address to, uint256 value) internal virtual override {\\r\\n        if (\\r\\n            protectionsEnabled &&\\r\\n            block.timestamp <= protectionStartTime + PROTECTION_PERIOD &&\\r\\n            value > defaultPledgeOnePercent / limitDivisor &&\\r\\n            from != uniswapRouterAddress &&\\r\\n            from != owner() &&\\r\\n            from != address(0)\\r\\n        ) {\\r\\n            require(balanceOf(from) >= value, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n            (uint256 adjustedAmount, uint256 penalty) = _calculatePenalty(value);\\r\\n            if (penalty > 0) {\\r\\n                super._update(from, feeReceiver, penalty);\\r\\n                emit PenaltyCharged(tx.origin, value, adjustedAmount, penalty);\\r\\n            }\\r\\n            if (adjustedAmount > 0) {\\r\\n                super._update(from, to, adjustedAmount);\\r\\n            }\\r\\n        } else {\\r\\n            super._update(from, to, value);\\r\\n        }\\r\\n        if (pledger[from].status == 1) {\\r\\n            _updatePledgeStatus(from, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function that calculates the penalty for a given amount of tokens based on the time since launch and the amount over the limit.\\r\\n    /// @dev These penalties are combined to create a penalty percentage that is applied to the excess amount.\\r\\n    /// @param attemptedAmount The amount of tokens that were attempted to be transferred.\\r\\n    /// @return adjustedAmount The amount of tokens that can be transferred after the penalty.\\r\\n    /// @return penalty The amount of the penalty that will be charged.\\r\\n    function _calculatePenalty(uint256 attemptedAmount) internal view returns (uint256 adjustedAmount, uint256 penalty) {     \\r\\n        uint256 timeSinceLaunch = block.timestamp - protectionStartTime;\\r\\n        uint256 baseLimit = defaultPledgeOnePercent / limitDivisor;\\r\\n        \\r\\n        // Only apply penalty to amount over baseLimit\\r\\n        uint256 excessAmount = attemptedAmount - baseLimit;\\r\\n        \\r\\n        // Time factor: 100 at start, linearly decreases to 0\\r\\n        uint256 timePenalty = ((PROTECTION_PERIOD - timeSinceLaunch) * 100) / PROTECTION_PERIOD;\\r\\n        \\r\\n        // Amount factor: 0 when at baseLimit, approaches 100 as amount increases\\r\\n        uint256 amountPenalty = (excessAmount * 100) / (baseLimit + excessAmount);\\r\\n        \\r\\n        // Combined penalty percentage (0-100)\\r\\n        uint256 penaltyPercent = (timePenalty * amountPenalty) / 100;\\r\\n        \\r\\n        // Apply penalty to excess amount\\r\\n        uint256 penaltyAmount = (excessAmount * penaltyPercent) / 100;\\r\\n        \\r\\n        return (attemptedAmount - penaltyAmount, penaltyAmount);\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to update the pledge status for a given address.\\r\\n    /// @param from The address tokens are being transferred from.\\r\\n    /// @param amount The quantity of tokens being transferred.\\r\\n    function _updatePledgeStatus(address from, uint256 amount) internal {\\r\\n        if (_isWindowExpired(from)) {\\r\\n            pledger[from].monthlyWindowStart = block.timestamp;\\r\\n            pledger[from].amountTransferredThisWindow = amount;\\r\\n        } else {\\r\\n            pledger[from].amountTransferredThisWindow += amount;\\r\\n        }\\r\\n        uint256 onePercent = pledger[from].onePercent;\\r\\n        // Because airdrop accounts have default onePercent value of 0, we need to set it to defaultPledgeOnePercent\\r\\n        if (onePercent == 0) {\\r\\n            onePercent = defaultPledgeOnePercent;\\r\\n        }\\r\\n        if (pledger[from].amountTransferredThisWindow > onePercent) {\\r\\n            pledger[from].status = 2;\\r\\n            emit BrokenPledge(from, pledger[from].amountTransferredThisWindow, onePercent);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function to check if the pledge window has expired for a given address.\\r\\n    /// @param _address The address to check.\\r\\n    /// @return true if the pledge window has expired for the address.\\r\\n    function _isWindowExpired(address _address) internal view returns (bool) {\\r\\n        return (block.timestamp - pledger[_address].monthlyWindowStart) >= 30 days;\\r\\n    }\\r\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC-20\\n * applications.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     *\\n     * ```solidity\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}