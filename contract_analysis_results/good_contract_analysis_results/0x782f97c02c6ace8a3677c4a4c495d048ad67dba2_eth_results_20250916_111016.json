{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 2,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 value)",
          "function_context": "\"content\": \"/**\\n    X:          https://x.com/SocialLensAi\\n    Telegram:   https://t.me/SocialLensAi\\n    Website:    https://sociallens.ai/\\n    Docs:       https://sociallens.gitbook.io/\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.28;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ncontract SocialLensAi is Ownable, ERC20 {\\n    IUniswapV2Router public immutable uniswapV2Router;\\n\\n    address public constant ZERO_ADDRESS = address(0);\\n    address public constant DEAD_ADDRESS = address(0xdEaD);\\n\\n    address public immutable uniswapV2Pair;\\n    address public marketingWallet;\\n    address public developmentWallet;\\n    address public revenueWallet;\\n\\n    bool public isLimitsEnabled;\\n    bool public isCooldownEnabled;\\n    bool public isTaxEnabled;\\n    bool private inSwapBack;\\n    bool public isLaunched;\\n\\n    uint256 private lastSwapBackExecutionBlock;\\n\\n    uint256 public constant MAX_FEE = 30;\\n\\n    uint256 public maxBuy;\\n    uint256 public maxSell;\\n    uint256 public maxWallet;\\n\\n    uint256 public swapTokensAtAmount;\\n    uint256 public buyFee;\\n    uint256 public sellFee;\\n    uint256 public transferFee;\\n\\n    mapping(address => bool) public isBot;\\n    mapping(address => bool) public isExcludedFromFees;\\n    mapping(address => bool) public isExcludedFromLimits;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n    mapping(address => uint256) private _holderLastTransferTimestamp;\\n\\n    event Launch();\\n    event SetMarketingWallet(address newWallet, address oldWallet);\\n    event SetDevelopmentWallet(address newWallet, address oldWallet);\\n    event SetRevenueWallet(address newWallet, address oldWallet);\\n    event SetLimitsEnabled(bool status);\\n    event SetCooldownEnabled(bool status);\\n    event SetTaxesEnabled(bool status);\\n    event SetMaxBuy(uint256 amount);\\n    event SetMaxSell(uint256 amount);\\n    event SetMaxWallet(uint256 amount);\\n    event SetSwapTokensAtAmount(uint256 newValue, uint256 oldValue);\\n    event SetBuyFees(uint256 newValue, uint256 oldValue);\\n    event SetSellFees(uint256 newValue, uint256 oldValue);\\n    event SetTransferFees(uint256 newValue, uint256 oldValue);\\n    event ExcludeFromFees(address account, bool isExcluded);\\n    event ExcludeFromLimits(address account, bool isExcluded);\\n    event SetBots(address account, bool isExcluded);\\n    event SetAutomatedMarketMakerPair(address pair, bool value);\\n    event WithdrawStuckTokens(address token, uint256 amount);\\n\\n    error AlreadyLaunched();\\n    error InvalidSender();\\n    error AddressZero();\\n    error AmountTooLow();\\n    error AmountTooHigh();\\n    error FeeTooHigh();\\n    error AMMAlreadySet();\\n    error NoNativeTokens();\\n    error NoTokens();\\n    error FailedToWithdrawNativeTokens();\\n    error BotDetected();\\n    error TransferDelay();\\n    error MaxBuyAmountExceed();\\n    error MaxSellAmountExceed();\\n    error MaxWalletAmountExceed();\\n    error NotLaunched();\\n\\n    modifier lockSwapBack() {\\n        inSwapBack = true;\\n        _;\\n        inSwapBack = false;\\n    }\\n\\n    constructor() Ownable(msg.sender) ERC20(\\\"Social Lens AI\\\", \\\"LENS\\\") {\\n        address sender = msg.sender;\\n        _mint(sender, 100_000_000 ether);\\n        uint256 totalSupply = totalSupply();\\n\\n        marketingWallet   = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n        developmentWallet = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n        revenueWallet     = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n\\n        address uniswapFeeCollector = 0x000000fee13a103A10D593b9AE06b3e05F2E7E1c;\\n\\n        maxBuy = (totalSupply * 12) / 1000;\\n        maxSell = (totalSupply * 12) / 1000;\\n        maxWallet = (totalSupply * 12) / 1000;\\n        swapTokensAtAmount = (totalSupply * 5) / 10000;\\n\\n        isLimitsEnabled = true;\\n        isCooldownEnabled = true;\\n        isTaxEnabled = true;\\n\\n        buyFee = 20;\\n        sellFee = 30;\\n        transferFee = 60;\\n\\n        uniswapV2Router = IUniswapV2Router(\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n        );\\n\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _setAutomatedMarketMakerPair(uniswapV2Pair, true);\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        _excludeFromFees(address(this), true);\\n        _excludeFromFees(DEAD_ADDRESS, true);\\n        _excludeFromFees(sender, true);\\n        _excludeFromFees(marketingWallet, true);\\n        _excludeFromFees(developmentWallet, true);\\n        _excludeFromFees(revenueWallet, true);\\n        _excludeFromFees(uniswapFeeCollector, true);\\n        _excludeFromLimits(address(this), true);\\n        _excludeFromLimits(DEAD_ADDRESS, true);\\n        _excludeFromLimits(sender, true);\\n        _excludeFromLimits(marketingWallet, true);\\n        _excludeFromLimits(developmentWallet, true);\\n        _excludeFromLimits(revenueWallet, true);\\n        _excludeFromLimits(uniswapFeeCollector, true);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function launch() external onlyOwner {\\n        require(!isLaunched, AlreadyLaunched());\\n        isLaunched = true;\\n        emit Launch();\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external {\\n        require(msg.sender == marketingWallet, InvalidSender());\\n        require(_marketingWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = marketingWallet;\\n        marketingWallet = _marketingWallet;\\n        emit SetMarketingWallet(marketingWallet, oldWallet);\\n    }\\n\\n    function setDevelopmentWallet(address _developmentWallet) external {\\n        require(msg.sender == developmentWallet, InvalidSender());\\n        require(_developmentWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = developmentWallet;\\n        developmentWallet = _developmentWallet;\\n        emit SetDevelopmentWallet(developmentWallet, oldWallet);\\n    }\\n\\n    function setRevenueWallet(address _revenueWallet) external {\\n        require(msg.sender == revenueWallet, InvalidSender());\\n        require(_revenueWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = revenueWallet;\\n        revenueWallet = _revenueWallet;\\n        emit SetRevenueWallet(revenueWallet, oldWallet);\\n    }\\n\\n    function setLimitsEnabled(bool value) external onlyOwner {\\n        isLimitsEnabled = value;\\n        emit SetLimitsEnabled(value);\\n    }\\n\\n    function setCooldownEnabled(bool value) external onlyOwner {\\n        isCooldownEnabled = value;\\n        emit SetCooldownEnabled(value);\\n    }\\n\\n    function setTaxesEnabled(bool value) external onlyOwner {\\n        isTaxEnabled = value;\\n        emit SetTaxesEnabled(value);\\n    }\\n\\n    function setMaxBuy(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 2) / 1000), AmountTooLow());\\n        maxBuy = amount;\\n        emit SetMaxBuy(maxBuy);\\n    }\\n\\n    function setMaxSell(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 2) / 1000), AmountTooLow());\\n        maxSell = amount;\\n        emit SetMaxSell(maxSell);\\n    }\\n\\n    function setMaxWallet(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 3) / 1000), AmountTooLow());\\n        maxWallet = amount;\\n        emit SetMaxWallet(maxWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        uint256 _totalSupply = totalSupply();\\n        require(amount >= (_totalSupply * 1) / 1000000, AmountTooLow());\\n        require(amount <= (_totalSupply * 5) / 1000, AmountTooHigh());\\n        uint256 oldValue = swapTokensAtAmount;\\n        swapTokensAtAmount = amount;\\n        emit SetSwapTokensAtAmount(amount, oldValue);\\n    }\\n\\n    function setBuyFees(uint256 _buyFee) external onlyOwner {\\n        require(_buyFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = buyFee;\\n        buyFee = _buyFee;\\n        emit SetBuyFees(_buyFee, oldValue);\\n    }\\n\\n    function setSellFees(uint256 _sellFee) external onlyOwner {\\n        require(_sellFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = sellFee;\\n        sellFee = _sellFee;\\n        emit SetSellFees(_sellFee, oldValue);\\n    }\\n\\n    function setTransferFees(uint256 _transferFee) external onlyOwner {\\n        require(_transferFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = transferFee;\\n        transferFee = _transferFee;\\n        emit SetTransferFees(_transferFee, oldValue);\\n    }\\n\\n    function excludeFromFees(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _excludeFromFees(accounts[i], value);\\n        }\\n    }\\n\\n    function excludeFromLimits(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _excludeFromLimits(accounts[i], value);\\n        }\\n    }\\n\\n    function setBots(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            if (\\n                (!automatedMarketMakerPairs[accounts[i]]) &&\\n                (accounts[i] != address(uniswapV2Router)) &&\\n                (accounts[i] != address(this)) &&\\n                (accounts[i] != ZERO_ADDRESS) &&\\n                (!isExcludedFromFees[accounts[i]] &&\\n                    !isExcludedFromLimits[accounts[i]])\\n            ) _setBots(accounts[i], value);\\n        }\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value)\\n        external\\n        onlyOwner\\n    {\\n        require(!automatedMarketMakerPairs[pair], AMMAlreadySet());\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function withdrawStuckTokens(address _token) external {\\n        require(msg.sender == developmentWallet, InvalidSender());\\n        address sender = msg.sender;\\n        uint256 amount;\\n        if (_token == ZERO_ADDRESS) {\\n            bool success;\\n            amount = address(this).balance;\\n            require(amount > 0, NoNativeTokens());\\n            (success, ) = address(sender).call{value: amount}(\\\"\\\");\\n            require(success, FailedToWithdrawNativeTokens());\\n        } else {\\n            amount = IERC20(_token).balanceOf(address(this));\\n            require(amount > 0, NoTokens());\\n            IERC20(_token).transfer(msg.sender, amount);\\n        }\\n        emit WithdrawStuckTokens(_token, amount);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        address oldOwner = owner();\\n        if (oldOwner != ZERO_ADDRESS) {\\n            _excludeFromFees(oldOwner, false);\\n            _excludeFromLimits(oldOwner, false);\\n        }\\n        _excludeFromFees(newOwner, true);\\n        _excludeFromLimits(newOwner, true);\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        address sender = msg.sender;\\n        address origin = tx.origin;\\n        uint256 blockNumber = block.number;\\n\\n        require(!isBot[from], BotDetected());\\n        require(sender == from || !isBot[sender], BotDetected());\\n        require(\\n            origin == from || origin == sender || !isBot[origin],\\n            BotDetected()\\n        );\\n\\n        require(\\n            isLaunched ||\\n                isExcludedFromLimits[from] ||\\n                isExcludedFromLimits[to],\\n            NotLaunched()\\n        );\\n\\n        bool limits = isLimitsEnabled &&\\n            !inSwapBack &&\\n            !(isExcludedFromLimits[from] || isExcludedFromLimits[to]);\\n        if (limits) {\\n            if (\\n                from != owner() &&\\n                to != owner() &&\\n                to != ZERO_ADDRESS &&\\n                to != DEAD_ADDRESS\\n            ) {\\n                if (isCooldownEnabled) {\\n                    if (to != address(uniswapV2Router) && to != uniswapV2Pair) {\\n                        require(\\n                            _holderLastTransferTimestamp[origin] <\\n                                blockNumber - 3 &&\\n                                _holderLastTransferTimestamp[to] <\\n                                blockNumber - 3,\\n                            TransferDelay()\\n                        );\\n                        _holderLastTransferTimestamp[origin] = blockNumber;\\n                        _holderLastTransferTimestamp[to] = blockNumber;\\n                    }\\n                }\\n\\n                if (\\n                    automatedMarketMakerPairs[from] && !isExcludedFromLimits[to]\\n                ) {\\n                    require(amount <= maxBuy, MaxBuyAmountExceed());\\n                    require(\\n                        amount + balanceOf(to) <= maxWallet,\\n                        MaxWalletAmountExceed()\\n                    );\\n                } else if (\\n                    automatedMarketMakerPairs[to] && !isExcludedFromLimits[from]\\n                ) {\\n                    require(amount <= maxSell, MaxSellAmountExceed());\\n                } else if (!isExcludedFromLimits[to]) {\\n                    require(\\n                        amount + balanceOf(to) <= maxWallet,\\n                        MaxWalletAmountExceed()\\n                    );\\n                }\\n            }\\n        }\\n\\n        bool takeFee = isTaxEnabled &&\\n            !inSwapBack &&\\n            !(isExcludedFromFees[from] || isExcludedFromFees[to]);\\n\\n        if (takeFee) {\\n            uint256 fees = 0;\\n            if (automatedMarketMakerPairs[to] && sellFee > 0) {\\n                fees = (amount * sellFee) / 100;\\n            } else if (automatedMarketMakerPairs[from] && buyFee > 0) {\\n                fees = (amount * buyFee) / 100;\\n            } else if (\\n                !automatedMarketMakerPairs[to] &&\\n                !automatedMarketMakerPairs[from] &&\\n                transferFee > 0\\n            ) {\\n                fees = (amount * transferFee) / 100;\\n            }\\n\\n            if (fees > 0) {\\n                amount -= fees;\\n                super._update(from, address(this), fees);\\n            }\\n        }\\n\\n        uint256 balance = balanceOf(address(this));\\n        bool shouldSwap = balance >= swapTokensAtAmount;\\n        if (takeFee && !automatedMarketMakerPairs[from] && shouldSwap) {\\n            if (blockNumber > lastSwapBackExecutionBlock) {\\n                _swapBack(balance);\\n                lastSwapBackExecutionBlock = blockNumber;\\n            }\\n        }\\n\\n        super._update(from, to, amount);\\n    }\\n\\n    function _swapBack(uint256 balance) internal virtual lockSwapBack {\\n        bool success;\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uint256 maxSwapAmount = swapTokensAtAmount * 20;\\n\\n        if (balance > maxSwapAmount) {\\n            balance = maxSwapAmount;\\n        }\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            balance,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 ethBalance = address(this).balance;\\n\\n        uint256 ethForMarketing = ( ethBalance * 1 ) / 5;\\n        uint256 ethForRevenue = ( ethBalance * 1 ) / 5;\\n        uint256 ethForDevelopment = ethBalance - ethForMarketing - ethForRevenue;\\n\\n        (success, ) = address(marketingWallet).call{value: ethForMarketing}(\\n            \\\"\\\"\\n        );\\n\\n        (success, ) = address(developmentWallet).call{value: ethForDevelopment}(\\n            \\\"\\\"\\n        );\\n\\n        (success, ) = address(revenueWallet).call{value: ethForRevenue}(\\n            \\\"\\\"\\n        );\\n    }\\n\\n    function _excludeFromFees(address account, bool value) internal virtual {\\n        isExcludedFromFees[account] = value;\\n        emit ExcludeFromFees(account, value);\\n    }\\n\\n    function _excludeFromLimits(address account, bool value) internal virtual {\\n        isExcludedFromLimits[account] = value;\\n        emit ExcludeFromLimits(account, value);\\n    }\\n\\n    function _setBots(address account, bool value) internal virtual {\\n        isBot[account] = value;\\n        emit SetBots(account, value);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value)\\n        internal\\n        virtual\\n    {\\n        automatedMarketMakerPairs[pair] = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(sender, 100_000_000 ether)",
          "function_context": "\"content\": \"/**\\n    X:          https://x.com/SocialLensAi\\n    Telegram:   https://t.me/SocialLensAi\\n    Website:    https://sociallens.ai/\\n    Docs:       https://sociallens.gitbook.io/\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.28;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface IERC20Errors {\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    error ERC20InvalidSender(address sender);\\n\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    error ERC20InvalidApprover(address approver);\\n\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ncontract SocialLensAi is Ownable, ERC20 {\\n    IUniswapV2Router public immutable uniswapV2Router;\\n\\n    address public constant ZERO_ADDRESS = address(0);\\n    address public constant DEAD_ADDRESS = address(0xdEaD);\\n\\n    address public immutable uniswapV2Pair;\\n    address public marketingWallet;\\n    address public developmentWallet;\\n    address public revenueWallet;\\n\\n    bool public isLimitsEnabled;\\n    bool public isCooldownEnabled;\\n    bool public isTaxEnabled;\\n    bool private inSwapBack;\\n    bool public isLaunched;\\n\\n    uint256 private lastSwapBackExecutionBlock;\\n\\n    uint256 public constant MAX_FEE = 30;\\n\\n    uint256 public maxBuy;\\n    uint256 public maxSell;\\n    uint256 public maxWallet;\\n\\n    uint256 public swapTokensAtAmount;\\n    uint256 public buyFee;\\n    uint256 public sellFee;\\n    uint256 public transferFee;\\n\\n    mapping(address => bool) public isBot;\\n    mapping(address => bool) public isExcludedFromFees;\\n    mapping(address => bool) public isExcludedFromLimits;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n    mapping(address => uint256) private _holderLastTransferTimestamp;\\n\\n    event Launch();\\n    event SetMarketingWallet(address newWallet, address oldWallet);\\n    event SetDevelopmentWallet(address newWallet, address oldWallet);\\n    event SetRevenueWallet(address newWallet, address oldWallet);\\n    event SetLimitsEnabled(bool status);\\n    event SetCooldownEnabled(bool status);\\n    event SetTaxesEnabled(bool status);\\n    event SetMaxBuy(uint256 amount);\\n    event SetMaxSell(uint256 amount);\\n    event SetMaxWallet(uint256 amount);\\n    event SetSwapTokensAtAmount(uint256 newValue, uint256 oldValue);\\n    event SetBuyFees(uint256 newValue, uint256 oldValue);\\n    event SetSellFees(uint256 newValue, uint256 oldValue);\\n    event SetTransferFees(uint256 newValue, uint256 oldValue);\\n    event ExcludeFromFees(address account, bool isExcluded);\\n    event ExcludeFromLimits(address account, bool isExcluded);\\n    event SetBots(address account, bool isExcluded);\\n    event SetAutomatedMarketMakerPair(address pair, bool value);\\n    event WithdrawStuckTokens(address token, uint256 amount);\\n\\n    error AlreadyLaunched();\\n    error InvalidSender();\\n    error AddressZero();\\n    error AmountTooLow();\\n    error AmountTooHigh();\\n    error FeeTooHigh();\\n    error AMMAlreadySet();\\n    error NoNativeTokens();\\n    error NoTokens();\\n    error FailedToWithdrawNativeTokens();\\n    error BotDetected();\\n    error TransferDelay();\\n    error MaxBuyAmountExceed();\\n    error MaxSellAmountExceed();\\n    error MaxWalletAmountExceed();\\n    error NotLaunched();\\n\\n    modifier lockSwapBack() {\\n        inSwapBack = true;\\n        _;\\n        inSwapBack = false;\\n    }\\n\\n    constructor() Ownable(msg.sender) ERC20(\\\"Social Lens AI\\\", \\\"LENS\\\") {\\n        address sender = msg.sender;\\n        _mint(sender, 100_000_000 ether);\\n        uint256 totalSupply = totalSupply();\\n\\n        marketingWallet   = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n        developmentWallet = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n        revenueWallet     = 0xbd8c1d156405996374c179B7b0b97c718C07B90B;\\n\\n        address uniswapFeeCollector = 0x000000fee13a103A10D593b9AE06b3e05F2E7E1c;\\n\\n        maxBuy = (totalSupply * 12) / 1000;\\n        maxSell = (totalSupply * 12) / 1000;\\n        maxWallet = (totalSupply * 12) / 1000;\\n        swapTokensAtAmount = (totalSupply * 5) / 10000;\\n\\n        isLimitsEnabled = true;\\n        isCooldownEnabled = true;\\n        isTaxEnabled = true;\\n\\n        buyFee = 20;\\n        sellFee = 30;\\n        transferFee = 60;\\n\\n        uniswapV2Router = IUniswapV2Router(\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\n        );\\n\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n            address(this),\\n            uniswapV2Router.WETH()\\n        );\\n\\n        _setAutomatedMarketMakerPair(uniswapV2Pair, true);\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n        _excludeFromFees(address(this), true);\\n        _excludeFromFees(DEAD_ADDRESS, true);\\n        _excludeFromFees(sender, true);\\n        _excludeFromFees(marketingWallet, true);\\n        _excludeFromFees(developmentWallet, true);\\n        _excludeFromFees(revenueWallet, true);\\n        _excludeFromFees(uniswapFeeCollector, true);\\n        _excludeFromLimits(address(this), true);\\n        _excludeFromLimits(DEAD_ADDRESS, true);\\n        _excludeFromLimits(sender, true);\\n        _excludeFromLimits(marketingWallet, true);\\n        _excludeFromLimits(developmentWallet, true);\\n        _excludeFromLimits(revenueWallet, true);\\n        _excludeFromLimits(uniswapFeeCollector, true);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function launch() external onlyOwner {\\n        require(!isLaunched, AlreadyLaunched());\\n        isLaunched = true;\\n        emit Launch();\\n    }\\n\\n    function setMarketingWallet(address _marketingWallet) external {\\n        require(msg.sender == marketingWallet, InvalidSender());\\n        require(_marketingWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = marketingWallet;\\n        marketingWallet = _marketingWallet;\\n        emit SetMarketingWallet(marketingWallet, oldWallet);\\n    }\\n\\n    function setDevelopmentWallet(address _developmentWallet) external {\\n        require(msg.sender == developmentWallet, InvalidSender());\\n        require(_developmentWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = developmentWallet;\\n        developmentWallet = _developmentWallet;\\n        emit SetDevelopmentWallet(developmentWallet, oldWallet);\\n    }\\n\\n    function setRevenueWallet(address _revenueWallet) external {\\n        require(msg.sender == revenueWallet, InvalidSender());\\n        require(_revenueWallet != ZERO_ADDRESS, AddressZero());\\n        address oldWallet = revenueWallet;\\n        revenueWallet = _revenueWallet;\\n        emit SetRevenueWallet(revenueWallet, oldWallet);\\n    }\\n\\n    function setLimitsEnabled(bool value) external onlyOwner {\\n        isLimitsEnabled = value;\\n        emit SetLimitsEnabled(value);\\n    }\\n\\n    function setCooldownEnabled(bool value) external onlyOwner {\\n        isCooldownEnabled = value;\\n        emit SetCooldownEnabled(value);\\n    }\\n\\n    function setTaxesEnabled(bool value) external onlyOwner {\\n        isTaxEnabled = value;\\n        emit SetTaxesEnabled(value);\\n    }\\n\\n    function setMaxBuy(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 2) / 1000), AmountTooLow());\\n        maxBuy = amount;\\n        emit SetMaxBuy(maxBuy);\\n    }\\n\\n    function setMaxSell(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 2) / 1000), AmountTooLow());\\n        maxSell = amount;\\n        emit SetMaxSell(maxSell);\\n    }\\n\\n    function setMaxWallet(uint256 amount) external onlyOwner {\\n        require(amount >= ((totalSupply() * 3) / 1000), AmountTooLow());\\n        maxWallet = amount;\\n        emit SetMaxWallet(maxWallet);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 amount) external onlyOwner {\\n        uint256 _totalSupply = totalSupply();\\n        require(amount >= (_totalSupply * 1) / 1000000, AmountTooLow());\\n        require(amount <= (_totalSupply * 5) / 1000, AmountTooHigh());\\n        uint256 oldValue = swapTokensAtAmount;\\n        swapTokensAtAmount = amount;\\n        emit SetSwapTokensAtAmount(amount, oldValue);\\n    }\\n\\n    function setBuyFees(uint256 _buyFee) external onlyOwner {\\n        require(_buyFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = buyFee;\\n        buyFee = _buyFee;\\n        emit SetBuyFees(_buyFee, oldValue);\\n    }\\n\\n    function setSellFees(uint256 _sellFee) external onlyOwner {\\n        require(_sellFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = sellFee;\\n        sellFee = _sellFee;\\n        emit SetSellFees(_sellFee, oldValue);\\n    }\\n\\n    function setTransferFees(uint256 _transferFee) external onlyOwner {\\n        require(_transferFee <= MAX_FEE, FeeTooHigh());\\n        uint256 oldValue = transferFee;\\n        transferFee = _transferFee;\\n        emit SetTransferFees(_transferFee, oldValue);\\n    }\\n\\n    function excludeFromFees(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _excludeFromFees(accounts[i], value);\\n        }\\n    }\\n\\n    function excludeFromLimits(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _excludeFromLimits(accounts[i], value);\\n        }\\n    }\\n\\n    function setBots(address[] calldata accounts, bool value)\\n        external\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            if (\\n                (!automatedMarketMakerPairs[accounts[i]]) &&\\n                (accounts[i] != address(uniswapV2Router)) &&\\n                (accounts[i] != address(this)) &&\\n                (accounts[i] != ZERO_ADDRESS) &&\\n                (!isExcludedFromFees[accounts[i]] &&\\n                    !isExcludedFromLimits[accounts[i]])\\n            ) _setBots(accounts[i], value);\\n        }\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value)\\n        external\\n        onlyOwner\\n    {\\n        require(!automatedMarketMakerPairs[pair], AMMAlreadySet());\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function withdrawStuckTokens(address _token) external {\\n        require(msg.sender == developmentWallet, InvalidSender());\\n        address sender = msg.sender;\\n        uint256 amount;\\n        if (_token == ZERO_ADDRESS) {\\n            bool success;\\n            amount = address(this).balance;\\n            require(amount > 0, NoNativeTokens());\\n            (success, ) = address(sender).call{value: amount}(\\\"\\\");\\n            require(success, FailedToWithdrawNativeTokens());\\n        } else {\\n            amount = IERC20(_token).balanceOf(address(this));\\n            require(amount > 0, NoTokens());\\n            IERC20(_token).transfer(msg.sender, amount);\\n        }\\n        emit WithdrawStuckTokens(_token, amount);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        address oldOwner = owner();\\n        if (oldOwner != ZERO_ADDRESS) {\\n            _excludeFromFees(oldOwner, false);\\n            _excludeFromLimits(oldOwner, false);\\n        }\\n        _excludeFromFees(newOwner, true);\\n        _excludeFromLimits(newOwner, true);\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    function _update(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        address sender = msg.sender;\\n        address origin = tx.origin;\\n        uint256 blockNumber = block.number;\\n\\n        require(!isBot[from], BotDetected());\\n        require(sender == from || !isBot[sender], BotDetected());\\n        require(\\n            origin == from || origin == sender || !isBot[origin],\\n            BotDetected()\\n        );\\n\\n        require(\\n            isLaunched ||\\n                isExcludedFromLimits[from] ||\\n                isExcludedFromLimits[to],\\n            NotLaunched()\\n        );\\n\\n        bool limits = isLimitsEnabled &&\\n            !inSwapBack &&\\n            !(isExcludedFromLimits[from] || isExcludedFromLimits[to]);\\n        if (limits) {\\n            if (\\n                from != owner() &&\\n                to != owner() &&\\n                to != ZERO_ADDRESS &&\\n                to != DEAD_ADDRESS\\n            ) {\\n                if (isCooldownEnabled) {\\n                    if (to != address(uniswapV2Router) && to != uniswapV2Pair) {\\n                        require(\\n                            _holderLastTransferTimestamp[origin] <\\n                                blockNumber - 3 &&\\n                                _holderLastTransferTimestamp[to] <\\n                                blockNumber - 3,\\n                            TransferDelay()\\n                        );\\n                        _holderLastTransferTimestamp[origin] = blockNumber;\\n                        _holderLastTransferTimestamp[to] = blockNumber;\\n                    }\\n                }\\n\\n                if (\\n                    automatedMarketMakerPairs[from] && !isExcludedFromLimits[to]\\n                ) {\\n                    require(amount <= maxBuy, MaxBuyAmountExceed());\\n                    require(\\n                        amount + balanceOf(to) <= maxWallet,\\n                        MaxWalletAmountExceed()\\n                    );\\n                } else if (\\n                    automatedMarketMakerPairs[to] && !isExcludedFromLimits[from]\\n                ) {\\n                    require(amount <= maxSell, MaxSellAmountExceed());\\n                } else if (!isExcludedFromLimits[to]) {\\n                    require(\\n                        amount + balanceOf(to) <= maxWallet,\\n                        MaxWalletAmountExceed()\\n                    );\\n                }\\n            }\\n        }\\n\\n        bool takeFee = isTaxEnabled &&\\n            !inSwapBack &&\\n            !(isExcludedFromFees[from] || isExcludedFromFees[to]);\\n\\n        if (takeFee) {\\n            uint256 fees = 0;\\n            if (automatedMarketMakerPairs[to] && sellFee > 0) {\\n                fees = (amount * sellFee) / 100;\\n            } else if (automatedMarketMakerPairs[from] && buyFee > 0) {\\n                fees = (amount * buyFee) / 100;\\n            } else if (\\n                !automatedMarketMakerPairs[to] &&\\n                !automatedMarketMakerPairs[from] &&\\n                transferFee > 0\\n            ) {\\n                fees = (amount * transferFee) / 100;\\n            }\\n\\n            if (fees > 0) {\\n                amount -= fees;\\n                super._update(from, address(this), fees);\\n            }\\n        }\\n\\n        uint256 balance = balanceOf(address(this));\\n        bool shouldSwap = balance >= swapTokensAtAmount;\\n        if (takeFee && !automatedMarketMakerPairs[from] && shouldSwap) {\\n            if (blockNumber > lastSwapBackExecutionBlock) {\\n                _swapBack(balance);\\n                lastSwapBackExecutionBlock = blockNumber;\\n            }\\n        }\\n\\n        super._update(from, to, amount);\\n    }\\n\\n    function _swapBack(uint256 balance) internal virtual lockSwapBack {\\n        bool success;\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uint256 maxSwapAmount = swapTokensAtAmount * 20;\\n\\n        if (balance > maxSwapAmount) {\\n            balance = maxSwapAmount;\\n        }\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            balance,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 ethBalance = address(this).balance;\\n\\n        uint256 ethForMarketing = ( ethBalance * 1 ) / 5;\\n        uint256 ethForRevenue = ( ethBalance * 1 ) / 5;\\n        uint256 ethForDevelopment = ethBalance - ethForMarketing - ethForRevenue;\\n\\n        (success, ) = address(marketingWallet).call{value: ethForMarketing}(\\n            \\\"\\\"\\n        );\\n\\n        (success, ) = address(developmentWallet).call{value: ethForDevelopment}(\\n            \\\"\\\"\\n        );\\n\\n        (success, ) = address(revenueWallet).call{value: ethForRevenue}(\\n            \\\"\\\"\\n        );\\n    }\\n\\n    function _excludeFromFees(address account, bool value) internal virtual {\\n        isExcludedFromFees[account] = value;\\n        emit ExcludeFromFees(account, value);\\n    }\\n\\n    function _excludeFromLimits(address account, bool value) internal virtual {\\n        isExcludedFromLimits[account] = value;\\n        emit ExcludeFromLimits(account, value);\\n    }\\n\\n    function _setBots(address account, bool value) internal virtual {\\n        isBot[account] = value;\\n        emit SetBots(account, value);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value)\\n        internal\\n        virtual\\n    {\\n        automatedMarketMakerPairs[pair] = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n}\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        }
      ]
    }
  }
}