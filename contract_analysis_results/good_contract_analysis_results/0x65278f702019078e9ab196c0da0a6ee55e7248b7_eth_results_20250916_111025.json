{
  "total_matches": 7,
  "patterns_found": {
    "minting_mechanics": {
      "count": 7,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\n\\r\\nimport {DioneBridge} from \\\"./bridge/DioneBridge.sol\\\";\\r\\n\\r\\n//////////////////////////////////////////////////\\r\\n///                                            ///\\r\\n///            Wrapped Dione token             ///\\r\\n///                                            ///\\r\\n//////////////////////////////////////////////////\\r\\n\\r\\ncontract WDIONEBridged is ERC20, Ownable2Step{\\r\\n    /// ERRORS\\r\\n\\r\\n    error FeeTooBig();\\r\\n    error ZeroAddress();\\r\\n    error OnlyBridge();\\r\\n    error BalanceUnderflow();\\r\\n\\r\\n    /// EVENTS\\r\\n\\r\\n    event FeesSentToBridge(address indexed receiver, uint256 amount);\\r\\n    event FeeUpdated(uint256 newFee);\\r\\n    event FeeReceiverUpdated(address newFeeReceiver);\\r\\n    event PayFeeListUpdated(address account, bool isPayFee);\\r\\n    event FeeThresholdUpdated(uint256 newFeeThreshold);\\r\\n\\r\\n    /// CONSTANTS\\r\\n\\r\\n    /// @notice Divisor for computation (1 bps (basis point) precision: 0.001%).\\r\\n    uint32 constant PCT_DIV = 100_000; \\r\\n    /// @notice Minimum amount of accumulated commission to send commission to Odyssey\\r\\n    uint256 constant MIN_FEE_THRESHOLD = 1 * 10 ** 18;\\r\\n    /// @notice Dione bridge instance\\r\\n    DioneBridge immutable public BRIDGE;\\r\\n    /// @notice Odyssey chain id, used in Wanchain gateway\\r\\n    uint256 immutable public ODYSSEY_ID;\\r\\n    \\r\\n    /// STORAGE\\r\\n\\r\\n    /// @notice List of addresses of token recipients for which commission is charged\\r\\n    mapping(address => bool) public isPayFee;\\r\\n    /// @notice send fees to the Odyssey chain if collected fees are above this threshold\\r\\n    uint256 public feeThreshold;\\r\\n    /// @notice collected fees tracker\\r\\n    uint256 public collectedFees;\\r\\n    /// @notice transfer fee in bps, [0...100000]\\r\\n    uint32 public fee;\\r\\n    /// @notice account that will receive bridged fees in Odyssey\\r\\n    address public feeReceiver;\\r\\n    /// @dev Indicator that an attempt was made to send fees during the transfer\\r\\n    bool private _isTrySendFees;\\r\\n\\r\\n    modifier onlyBridge() {\\r\\n        if(msg.sender != address(BRIDGE)) revert OnlyBridge();\\r\\n        _;\\r\\n    }\\r\\n    /// @notice Set initial parameters for the token\\r\\n    /// @param name Token name\\r\\n    /// @param symbol Token symbol\\r\\n    /// @param _bridge Dione bridge address\\r\\n    /// @param _targetId chain Id of the fee receiver\\r\\n    /// @param _owner token admin\\r\\n    /// @param _fee fee amount in bps [0...100000]\\r\\n    /// @param _feeThreshold send fees to the receiver if collected amount is above the threshold\\r\\n    /// @param _feeReceiver address of the fee receiver in the target chain\\r\\n    /// @param _toAdd array of (accounts)token recipients for which commission is charged\\r\\n    constructor(\\r\\n        string memory name,\\r\\n        string memory symbol,\\r\\n        DioneBridge _bridge,\\r\\n        uint256 _targetId,\\r\\n        address _owner,\\r\\n        uint32 _fee,\\r\\n        uint256 _feeThreshold,\\r\\n        address _feeReceiver,\\r\\n        address[] memory _toAdd\\r\\n    )\\r\\n        ERC20(name, symbol)\\r\\n    {\\r\\n        if (address(_bridge) == address(0)) revert ZeroAddress();\\r\\n        if(fee > PCT_DIV) revert FeeTooBig();\\r\\n        BRIDGE = _bridge;\\r\\n        ODYSSEY_ID = _targetId;\\r\\n        fee = _fee;\\r\\n        feeThreshold = _feeThreshold;\\r\\n        feeReceiver = _feeReceiver;\\r\\n        setPayFeeListBatch(_toAdd, true);\\r\\n\\r\\n        _transferOwnership(_owner);\\r\\n    }\\r\\n\\r\\n    /// @notice Send collected fees to the target chain if threshold condition allows\\r\\n    /// @dev Will not revert in failure\\r\\n    /// @dev This contract MUST have ETH tokens to pay for the tokens bridging into the target chain\\r\\n    function checkAndSendFees() public {\\r\\n        if (!_isTrySendFees) {\\r\\n            if(collectedFees > feeThreshold) {\\r\\n                _isTrySendFees = true;\\r\\n                uint256 _collectedFees = collectedFees;\\r\\n                collectedFees = 0;\\r\\n\\r\\n                uint256 toPay = _estimateGas();\\r\\n                if(address(this).balance < toPay) return;\\r\\n\\r\\n                _approve(address(this), address(BRIDGE), _collectedFees);\\r\\n                bool success = _trySendFees(toPay);\\r\\n                _approve(address(this), address(BRIDGE), 0);\\r\\n                \\r\\n                if(!success) {\\r\\n                    collectedFees = _collectedFees;\\r\\n                    return;\\r\\n                }\\r\\n                emit FeesSentToBridge(feeReceiver, _collectedFees);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    ///------------------ BRIDGE ------------------///\\r\\n\\r\\n    /// @notice Mint tokens to the recipient\\r\\n    /// @param to Minted tokens recipient\\r\\n    /// @param amount Minted tokens amount\\r\\n    function mint(address to, uint256 amount) onlyBridge external {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Burn tokens from the account\\r\\n    /// @param amount Burned tokens amount\\r\\n    function burn(uint256 amount) onlyBridge external {\\r\\n        if(balanceOf(msg.sender) < amount) revert BalanceUnderflow();\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _trySendFees(uint256 toPay) internal returns(bool success) {\\r\\n        (success, ) = address(BRIDGE).call{value: toPay}(abi.encodeWithSelector(\\r\\n            BRIDGE.redeem.selector,\\r\\n            feeReceiver,\\r\\n            ODYSSEY_ID,\\r\\n            IERC20(address(this)),\\r\\n            collectedFees\\r\\n        ));\\r\\n    } \\r\\n\\r\\n    function _estimateGas() internal view returns(uint256 toPay) {\\r\\n        toPay = BRIDGE.estimateFee(\\r\\n            ODYSSEY_ID,\\r\\n            BRIDGE.messageGasLimit()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    ///------------------ ADMIN ------------------///\\r\\n\\r\\n    /// @notice Set fee \\r\\n    /// @param _fee fee amount in bps [0...100000]\\r\\n    function setFee(uint32 _fee) onlyOwner external {\\r\\n        if(_fee > PCT_DIV) revert FeeTooBig();\\r\\n        fee = _fee;\\r\\n\\r\\n        emit FeeUpdated(_fee);\\r\\n    }\\r\\n\\r\\n    /// @notice Set fee receiver\\r\\n    /// @param _feeReceiver address of the fee receiver in the target chain\\r\\n    function setFeeReceiver(address _feeReceiver) onlyOwner external {\\r\\n        if (_feeReceiver == address(0)) revert ZeroAddress();\\r\\n        feeReceiver = _feeReceiver;\\r\\n\\r\\n        emit FeeReceiverUpdated(_feeReceiver);\\r\\n    }\\r\\n\\r\\n    /// @notice Set fee threshold\\r\\n    /// @param _feeThreshold send fees to the receiver if collected amount is above the threshold\\r\\n    function setFeeThreshold(uint256 _feeThreshold) onlyOwner external {\\r\\n        require(_feeThreshold >= MIN_FEE_THRESHOLD, \\\"WDIONEBridged: Fee threshold too low\\\");\\r\\n        feeThreshold = _feeThreshold;\\r\\n\\r\\n        emit FeeThresholdUpdated(_feeThreshold);\\r\\n    }\\r\\n\\r\\n    /// @notice Configure the pay fee list\\r\\n    /// @param account Account to add/remove from the pay fee list\\r\\n    /// @param add Add=true, Remove=false\\r\\n    function setPayFeeList(address account, bool add) onlyOwner public {\\r\\n        if (account == address(0)) revert ZeroAddress();\\r\\n        isPayFee[account] = add;\\r\\n\\r\\n        emit PayFeeListUpdated(account, add);\\r\\n    }\\r\\n\\r\\n    /// @notice Mass configure the pay fee list\\r\\n    /// @param accounts Array of accounts\\r\\n    /// @param add Add=true, Remove=false\\r\\n    function setPayFeeListBatch(address[] memory accounts, bool add) onlyOwner public {\\r\\n        for(uint256 i=0; i<accounts.length; ++i) {\\r\\n            if (accounts[i] == address(0)) revert ZeroAddress();\\r\\n            isPayFee[accounts[i]] = add;\\r\\n\\r\\n            emit PayFeeListUpdated(accounts[i], add);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw native tokens from contract\\r\\n    /// @param amount Amount of native tokens\\r\\n    function withdrawNative(uint256 amount) onlyOwner external {\\r\\n        (bool success, ) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    ///------------------ ERC20 ------------------///\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        uint256 feeAmount = 0;\\r\\n        if(isPayFee[to] && to != address(BRIDGE)) {\\r\\n            feeAmount = amount * fee / PCT_DIV;\\r\\n        }\\r\\n        if (spender != from) {\\r\\n            _spendAllowance(from, spender, amount);\\r\\n        }\\r\\n        if (feeAmount > 0) {\\r\\n            collectedFees += feeAmount;\\r\\n            _transfer(from, address(this), feeAmount);\\r\\n        }\\r\\n        _transfer(from, to, amount - feeAmount);\\r\\n\\r\\n        _isTrySendFees = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        return transferFrom(owner, to, amount);\\r\\n    }\\r\\n\\r\\n    function _afterTokenTransfer(address, address, uint256) internal override {\\r\\n        checkAndSendFees();\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"../wanchain/app/WmbAppUpgradeable.sol\\\";\\r\\n\\r\\ninterface IERC20Mintable is IERC20 {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract DioneBridge is Initializable, WmbAppUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for IERC20Mintable;\\r\\n    using SafeERC20 for ERC20Burnable;\\r\\n\\r\\n    enum Operation {\\r\\n        Invalid,\\r\\n        Withdraw,\\r\\n        Mint,\\r\\n        Deposit,\\r\\n        Redeem\\r\\n    }\\r\\n\\r\\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\r\\n    bytes32 public constant RESCUER_ROLE = keccak256(\\\"RESCUER_ROLE\\\");\\r\\n\\r\\n    uint256 public startBlockNumber;\\r\\n    uint256 public constant bridgeVersion = 1;\\r\\n    address payable public WETH_ADDRESS;\\r\\n    uint256 public messageGasLimit;\\r\\n    uint256 public feeInBp;\\r\\n    uint256 public constant percentConverter = 1e4;\\r\\n\\r\\n    mapping(bytes32 => mapping(address => uint256)) public pendingRoles;\\r\\n    mapping(address => uint256) private _wrappedTokenMaxSupply;\\r\\n    mapping(uint256 => mapping(address => address)) private _supportedTokensForReceive;\\r\\n    mapping(uint256 => mapping(address => Operation)) private _allowedTokenOperations;\\r\\n    mapping(uint256 => address) private _supportedBridges;\\r\\n    mapping(address => bool) private _isTokenSupportedToSend;\\r\\n    mapping(address => uint256) private _accumulatedFees;\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => bool) public isFeeFree;\\r\\n    mapping(address => uint256) public minBridgedAmounts;\\r\\n    mapping(address => mapping(address => uint256)) public emergencyTokenStorage;\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        address _wmbGateway\\r\\n    ) external initializer {\\r\\n        require(_wmbGateway != address(0), \\\"Invalid wmbGateway address\\\");\\r\\n        startBlockNumber = block.number;\\r\\n        __AccessControlDefaultAdminRules_init(0, msg.sender);\\r\\n        _setupRole(RESCUER_ROLE, msg.sender);\\r\\n        _setupRole(GOVERNANCE_ROLE, msg.sender);\\r\\n        _setupWmbGateway(_wmbGateway);\\r\\n\\r\\n        messageGasLimit = 160000;\\r\\n    }\\r\\n\\r\\n    function setWethAddress(address payable _wethAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_wethAddress != address(0), \\\"Invalid WETH address\\\");\\r\\n        WETH_ADDRESS = _wethAddress;\\r\\n\\r\\n        emit WethAddressUpdated(_wethAddress);\\r\\n    }\\r\\n\\r\\n    function setSupportedBridge(uint256 chainId, address _bridgeAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_bridgeAddress != address(0), \\\"Invalid bridge address\\\");\\r\\n        _supportedBridges[chainId] = _bridgeAddress;\\r\\n\\r\\n        emit SupportedBridgeUpdated(chainId, _bridgeAddress);\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(address dioneERC20, uint256 maxSupply) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(dioneERC20 != address(0), \\\"Invalid dione ERC20 address\\\");\\r\\n        _wrappedTokenMaxSupply[dioneERC20] = maxSupply;\\r\\n\\r\\n        emit WrappedTokenMaxSupplyUpdated(dioneERC20, maxSupply);\\r\\n    }\\r\\n\\r\\n    function setMessageGasLimit(uint256 gasLimit) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(gasLimit >= IWmbGateway(wmbGateway).minGasLimit(), \\\"Gas limit too low\\\");\\r\\n        require(gasLimit <= IWmbGateway(wmbGateway).maxGasLimit(), \\\"Gas limit too high\\\");\\r\\n        messageGasLimit = gasLimit;\\r\\n\\r\\n        emit MessageGasLimitUpdated(gasLimit);\\r\\n    }\\r\\n\\r\\n    function setTokenForReceive(\\r\\n        uint256 fromChainId,\\r\\n        address fromToken,\\r\\n        address toToken,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(fromToken != address(0), \\\"Invalid fromToken address\\\");\\r\\n        require(toToken != address(0), \\\"Invalid toToken address\\\");\\r\\n        \\r\\n        _supportedTokensForReceive[fromChainId][fromToken] = toToken;\\r\\n        _allowedTokenOperations[fromChainId][fromToken] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForReceiveUpdated(fromChainId, fromToken, toToken, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setTokenToSend(\\r\\n        address token,\\r\\n        bool isSupported,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n        uint256 chainId = IWmbGateway(wmbGateway).chainId();\\r\\n        \\r\\n        _isTokenSupportedToSend[token] = isSupported;\\r\\n        _allowedTokenOperations[chainId][token] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForSendUpdated(token, isSupported, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 _fee) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_fee <= percentConverter, \\\"Invalid fee\\\");\\r\\n\\r\\n        feeInBp = _fee;\\r\\n\\r\\n        emit FeeUpdated(_fee);\\r\\n    }\\r\\n\\r\\n    function setFeeFreelist(address account, bool add) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(account != address(0), \\\"Invalid account address\\\");\\r\\n\\r\\n        isFeeFree[account] = add;\\r\\n\\r\\n        emit FeeFreeListUpdated(account, add);\\r\\n    }\\r\\n\\r\\n    function setMinBridgedAmounts(address token, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n\\r\\n        minBridgedAmounts[token] = amount;\\r\\n\\r\\n        emit MinBridgetAmountsUpdated(token, amount);\\r\\n    }\\r\\n\\r\\n    event TokenDeposit(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenRedeem(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenWithdraw(address indexed to, IERC20 token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenMint(address indexed to, IERC20Mintable token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenAddedToEmergencyTokenStorage(address indexed account, address indexed token, uint256 amount);\\r\\n\\r\\n    event WethAddressUpdated(address newWethAddress);\\r\\n    event SupportedBridgeUpdated(uint256 chainId, address newBridgeAddress);\\r\\n    event WrappedTokenMaxSupplyUpdated(address token, uint256 newMaxSupply);\\r\\n    event MessageGasLimitUpdated(uint256 newGasLimit);\\r\\n    event SupportedTokenForReceiveUpdated(uint256 fromChainId, address fromToken, address toToken, Operation allowedOp);\\r\\n    event SupportedTokenForSendUpdated(address token, bool isSupported, Operation allowedOp);\\r\\n    event FeeUpdated(uint256 fee);\\r\\n    event FeeFreeListUpdated(address account, bool isFeeFree);\\r\\n    event MinBridgetAmountsUpdated(address token, uint256 amount);\\r\\n\\r\\n    // VIEW FUNCTIONS ***/\\r\\n\\r\\n    function getWrappedTokenMaxSupply(address dioneERC20) public view returns (uint256) {\\r\\n        return _wrappedTokenMaxSupply[dioneERC20] == 0 ? type(uint256).max : _wrappedTokenMaxSupply[dioneERC20];\\r\\n    }\\r\\n\\r\\n    function getSupportedTokensForReceive(uint256 fromChainId, address fromToken) external view returns(address) {\\r\\n        return _supportedTokensForReceive[fromChainId][fromToken];\\r\\n    }\\r\\n\\r\\n    function getSupportedBridges(uint256 chainId) external view returns(address) {\\r\\n        return _supportedBridges[chainId];\\r\\n    }\\r\\n\\r\\n    function getIsTokenSupportedToSend(address token) external view returns(bool) {\\r\\n        return _isTokenSupportedToSend[token];\\r\\n    }\\r\\n\\r\\n    function getAllowedTokenOperations(uint256 chainId, address token) external view returns(Operation) {\\r\\n        return _allowedTokenOperations[chainId][token];\\r\\n    }\\r\\n\\r\\n    // PAUSABLE FUNCTIONS ***/\\r\\n    function pause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes to transfers an ERC20 token cross-chain\\r\\n     * @param to address on other chain to bridge assets to\\r\\n     * @param chainId which chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function deposit(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        address tokenAddress = address(token) == address(0) ? WETH_ADDRESS : address(token);\\r\\n        require(_isTokenSupportedToSend[tokenAddress], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][tokenAddress] == Operation.Deposit, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(amount >= minBridgedAmounts[tokenAddress], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n\\r\\n        uint256 recievedAmount = 0;\\r\\n        uint256 receivedMessageFee = 0;\\r\\n        if (address(token) == address(0)) {\\r\\n            require(msg.value >= (messageFee + amount), \\\"Insufficient amount or message feeInBp\\\");\\r\\n\\r\\n            IWETH9(WETH_ADDRESS).deposit{value: amount}();\\r\\n            recievedAmount = amount;\\r\\n            receivedMessageFee = msg.value - amount;\\r\\n        } else {\\r\\n            require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n            uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n            recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n            receivedMessageFee = msg.value;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n        _balances[tokenAddress] += recievedAmount - feeAmount;\\r\\n        _accumulatedFees[tokenAddress] += feeAmount;\\r\\n        emit TokenDeposit(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n\\r\\n        if (receivedMessageFee - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: receivedMessageFee - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(\\r\\n            to,\\r\\n            tokenAddress,\\r\\n            recievedAmount - feeAmount,\\r\\n            Operation.Mint\\r\\n        );\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes that (typically) a wrapped dioneAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param chainId which underlying chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function redeem(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        ERC20Burnable token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        require(_isTokenSupportedToSend[address(token)], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][address(token)] == Operation.Redeem, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n        require(amount >= minBridgedAmounts[address(token)], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n        uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        uint256 recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n\\r\\n        _accumulatedFees[address(token)] += feeAmount;\\r\\n        emit TokenRedeem(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n        token.burn(recievedAmount - feeAmount);\\r\\n\\r\\n        if (msg.value - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: msg.value - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(to, address(token), recievedAmount - feeAmount, Operation.Withdraw);\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    function withdrawFromEmergencyStorage(address token, uint256 amount) external {\\r\\n        address owner = msg.sender;\\r\\n        require(emergencyTokenStorage[owner][token] >= amount, \\\"Amount exceeds the tokens stored in the storage\\\");\\r\\n        \\r\\n        emergencyTokenStorage[owner][token] -= amount;\\r\\n        if (token == address(0)) {\\r\\n            (bool success, ) = owner.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            IERC20(token).safeTransfer(owner, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Rescues tokens that are sent to the contract by mistake and cannot be retrieved by other means\\r\\n     * USE WITH EXTREME CAUTION - CAN BREAK THE ACCOUNTING OF THE BRIDGE\\r\\n     * @param token ERC20 compatible token to retrieve from the bridge\\r\\n     * @param to address of the receiver\\r\\n     * @param amount amount in token decimals to transfer\\r\\n     **/\\r\\n    function rescueTokens(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(hasRole(RESCUER_ROLE, msg.sender), \\\"Not rescuer\\\");\\r\\n        uint256 contractBalance = address(token) == address(0) ? address(this).balance : token.balanceOf(address(this));\\r\\n        require(contractBalance - (_balances[address(token)] + _accumulatedFees[address(token)]) >= amount, \\\"Cannot withdraw user deposited tokens or accumulated fees\\\");\\r\\n        if(address(token) == address(0)) {\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            token.safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawFees(address token, address to, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to != address(0), \\\"Zero address\\\");\\r\\n        require(_accumulatedFees[token] >= amount, \\\"Amount exeeds accumulated fees\\\");\\r\\n        \\r\\n        _accumulatedFees[token] -= amount;\\r\\n        IERC20(token).safeTransfer(to, amount);\\r\\n    }\\r\\n\\r\\n    function mintToken(address token, address[] calldata to, uint256[] calldata amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to.length == amount.length, \\\"Array length not equal\\\");\\r\\n        \\r\\n        for (uint i = 0; i < to.length; i++) {\\r\\n            require(to[i] != address(0), \\\"Zero address\\\");\\r\\n            require(amount[i] > 0, \\\"Zero amount\\\");\\r\\n            \\r\\n            IERC20Mintable(token).mint(to[i], amount[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ADMIN ROLES\\r\\n\\r\\n    /**\\r\\n     * @notice Grant role after a delay\\r\\n     * @param role role hash\\r\\n     * @param account assignee\\r\\n     * @param validAtTimestamp timestamp at which user can accept the role, 0 will revoke pending role\\r\\n     **/\\r\\n    function grantRole(bytes32 role, address account, uint256 validAtTimestamp) public {\\r\\n        bytes32 roleAdmin = getRoleAdmin(role);\\r\\n        require(hasRole(roleAdmin, msg.sender), \\\"AccessControl: sender must be an admin to grant\\\");\\r\\n        if (!hasRole(role, account)) {\\r\\n            pendingRoles[role][account] = validAtTimestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accept role after a delay\\r\\n     * @param role role hash\\r\\n     **/\\r\\n    function acceptRole(bytes32 role) public {\\r\\n        uint256 timestamp = pendingRoles[role][msg.sender];\\r\\n        require(timestamp <= block.timestamp && timestamp !=0, \\\"Role not assigned\\\");\\r\\n        _setupRole(role, msg.sender);\\r\\n        pendingRoles[role][msg.sender] = 0;\\r\\n    }\\r\\n\\r\\n    function grantRole(bytes32 /*role*/, address /*account*/) public pure override {\\r\\n        revert(\\\"Direct role assignment not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function _wmbReceive(\\r\\n        bytes calldata data,\\r\\n        bytes32 messageId,\\r\\n        uint256 fromChainId,\\r\\n        address /*fromSC*/\\r\\n    ) internal override {\\r\\n\\t\\t(address to, address token, uint256 amount, Operation op) = _decodeMessageData(data);\\r\\n        require(_supportedTokensForReceive[fromChainId][token] != address(0), \\\"Unsupported token\\\");\\r\\n        require(_allowedTokenOperations[fromChainId][token] == op, \\\"Not allowed operation\\\");\\r\\n\\r\\n        if (op == Operation.Withdraw) {\\r\\n            _withdraw(\\r\\n                to,\\r\\n                IERC20(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else if (op == Operation.Mint) {\\r\\n            _mint(\\r\\n                payable(to),\\r\\n                IERC20Mintable(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else {\\r\\n            revert(\\\"Invalid operation\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _encodeMessageData(\\r\\n        address to,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        Operation op\\r\\n    ) internal pure returns(bytes memory) {\\r\\n        return abi.encode(\\r\\n            to,\\r\\n            token,\\r\\n            amount,\\r\\n            op\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _decodeMessageData(\\r\\n        bytes memory data\\r\\n    ) internal pure returns(address to, address token, uint256 amount, Operation op) {\\r\\n        (to, token, amount, op) = abi.decode(data, (address, address, uint256, Operation));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Function to be called by the node group to withdraw the underlying assets from the contract\\r\\n     * @param to address on chain to send underlying assets to\\r\\n     * @param token ERC20 compatible token to withdraw from the bridge\\r\\n     * @param amount Amount in native token decimals to withdraw\\r\\n     **/\\r\\n    function _withdraw(\\r\\n        address to,\\r\\n        IERC20 token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n        _balances[address(token)] -= amount;\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (success) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } else {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            try token.transfer(to, amount) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } catch {\\r\\n                emergencyTokenStorage[to][address(token)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(token), amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Nodes call this function to mint a DioneBridgeERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted.\\r\\n     * @dev This means the DioneBridge.sol contract must have minter access to the token attempting to be minted\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain post-fees\\r\\n     **/\\r\\n    function _mint(\\r\\n        address payable to,\\r\\n        IERC20Mintable token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        emit TokenMint(to, token, amount, 0, messageId);\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n            _balances[address(token)] -= amount;\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            uint256 balance = _balances[address(token)];\\r\\n            if (balance < amount) {\\r\\n                _balances[address(token)] -= balance;\\r\\n                uint256 mintAmount = amount - balance;\\r\\n                require(token.totalSupply() + mintAmount <= getWrappedTokenMaxSupply(address(token)) , \\\"Exceeds max supply\\\");\\r\\n                token.mint(address(this), mintAmount);\\r\\n            } else {\\r\\n                _balances[address(token)] -= amount;\\r\\n            }\\r\\n            IERC20(token).safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sendMessage(\\r\\n        uint256 toChainId,\\r\\n        bytes memory msgData,\\r\\n        uint256 messageFee\\r\\n    ) internal {\\r\\n        require(_supportedBridges[toChainId] != address(0), \\\"Destination bridge address zero\\\");\\r\\n        _dispatchMessage(toChainId, _supportedBridges[toChainId], msgData, messageFee);\\r\\n    }\\r\\n\\r\\n    function _calcBridgeFee(uint256 amount) internal view returns(uint256) {\\r\\n        return isFeeFree[msg.sender] \\r\\n            ? 0\\r\\n            : amount * feeInBp / percentConverter;\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\n\\r\\nimport {DioneBridge} from \\\"./bridge/DioneBridge.sol\\\";\\r\\n\\r\\n//////////////////////////////////////////////////\\r\\n///                                            ///\\r\\n///            Wrapped Dione token             ///\\r\\n///                                            ///\\r\\n//////////////////////////////////////////////////\\r\\n\\r\\ncontract WDIONEBridged is ERC20, Ownable2Step{\\r\\n    /// ERRORS\\r\\n\\r\\n    error FeeTooBig();\\r\\n    error ZeroAddress();\\r\\n    error OnlyBridge();\\r\\n    error BalanceUnderflow();\\r\\n\\r\\n    /// EVENTS\\r\\n\\r\\n    event FeesSentToBridge(address indexed receiver, uint256 amount);\\r\\n    event FeeUpdated(uint256 newFee);\\r\\n    event FeeReceiverUpdated(address newFeeReceiver);\\r\\n    event PayFeeListUpdated(address account, bool isPayFee);\\r\\n    event FeeThresholdUpdated(uint256 newFeeThreshold);\\r\\n\\r\\n    /// CONSTANTS\\r\\n\\r\\n    /// @notice Divisor for computation (1 bps (basis point) precision: 0.001%).\\r\\n    uint32 constant PCT_DIV = 100_000; \\r\\n    /// @notice Minimum amount of accumulated commission to send commission to Odyssey\\r\\n    uint256 constant MIN_FEE_THRESHOLD = 1 * 10 ** 18;\\r\\n    /// @notice Dione bridge instance\\r\\n    DioneBridge immutable public BRIDGE;\\r\\n    /// @notice Odyssey chain id, used in Wanchain gateway\\r\\n    uint256 immutable public ODYSSEY_ID;\\r\\n    \\r\\n    /// STORAGE\\r\\n\\r\\n    /// @notice List of addresses of token recipients for which commission is charged\\r\\n    mapping(address => bool) public isPayFee;\\r\\n    /// @notice send fees to the Odyssey chain if collected fees are above this threshold\\r\\n    uint256 public feeThreshold;\\r\\n    /// @notice collected fees tracker\\r\\n    uint256 public collectedFees;\\r\\n    /// @notice transfer fee in bps, [0...100000]\\r\\n    uint32 public fee;\\r\\n    /// @notice account that will receive bridged fees in Odyssey\\r\\n    address public feeReceiver;\\r\\n    /// @dev Indicator that an attempt was made to send fees during the transfer\\r\\n    bool private _isTrySendFees;\\r\\n\\r\\n    modifier onlyBridge() {\\r\\n        if(msg.sender != address(BRIDGE)) revert OnlyBridge();\\r\\n        _;\\r\\n    }\\r\\n    /// @notice Set initial parameters for the token\\r\\n    /// @param name Token name\\r\\n    /// @param symbol Token symbol\\r\\n    /// @param _bridge Dione bridge address\\r\\n    /// @param _targetId chain Id of the fee receiver\\r\\n    /// @param _owner token admin\\r\\n    /// @param _fee fee amount in bps [0...100000]\\r\\n    /// @param _feeThreshold send fees to the receiver if collected amount is above the threshold\\r\\n    /// @param _feeReceiver address of the fee receiver in the target chain\\r\\n    /// @param _toAdd array of (accounts)token recipients for which commission is charged\\r\\n    constructor(\\r\\n        string memory name,\\r\\n        string memory symbol,\\r\\n        DioneBridge _bridge,\\r\\n        uint256 _targetId,\\r\\n        address _owner,\\r\\n        uint32 _fee,\\r\\n        uint256 _feeThreshold,\\r\\n        address _feeReceiver,\\r\\n        address[] memory _toAdd\\r\\n    )\\r\\n        ERC20(name, symbol)\\r\\n    {\\r\\n        if (address(_bridge) == address(0)) revert ZeroAddress();\\r\\n        if(fee > PCT_DIV) revert FeeTooBig();\\r\\n        BRIDGE = _bridge;\\r\\n        ODYSSEY_ID = _targetId;\\r\\n        fee = _fee;\\r\\n        feeThreshold = _feeThreshold;\\r\\n        feeReceiver = _feeReceiver;\\r\\n        setPayFeeListBatch(_toAdd, true);\\r\\n\\r\\n        _transferOwnership(_owner);\\r\\n    }\\r\\n\\r\\n    /// @notice Send collected fees to the target chain if threshold condition allows\\r\\n    /// @dev Will not revert in failure\\r\\n    /// @dev This contract MUST have ETH tokens to pay for the tokens bridging into the target chain\\r\\n    function checkAndSendFees() public {\\r\\n        if (!_isTrySendFees) {\\r\\n            if(collectedFees > feeThreshold) {\\r\\n                _isTrySendFees = true;\\r\\n                uint256 _collectedFees = collectedFees;\\r\\n                collectedFees = 0;\\r\\n\\r\\n                uint256 toPay = _estimateGas();\\r\\n                if(address(this).balance < toPay) return;\\r\\n\\r\\n                _approve(address(this), address(BRIDGE), _collectedFees);\\r\\n                bool success = _trySendFees(toPay);\\r\\n                _approve(address(this), address(BRIDGE), 0);\\r\\n                \\r\\n                if(!success) {\\r\\n                    collectedFees = _collectedFees;\\r\\n                    return;\\r\\n                }\\r\\n                emit FeesSentToBridge(feeReceiver, _collectedFees);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    ///------------------ BRIDGE ------------------///\\r\\n\\r\\n    /// @notice Mint tokens to the recipient\\r\\n    /// @param to Minted tokens recipient\\r\\n    /// @param amount Minted tokens amount\\r\\n    function mint(address to, uint256 amount) onlyBridge external {\\r\\n        _mint(to, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Burn tokens from the account\\r\\n    /// @param amount Burned tokens amount\\r\\n    function burn(uint256 amount) onlyBridge external {\\r\\n        if(balanceOf(msg.sender) < amount) revert BalanceUnderflow();\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _trySendFees(uint256 toPay) internal returns(bool success) {\\r\\n        (success, ) = address(BRIDGE).call{value: toPay}(abi.encodeWithSelector(\\r\\n            BRIDGE.redeem.selector,\\r\\n            feeReceiver,\\r\\n            ODYSSEY_ID,\\r\\n            IERC20(address(this)),\\r\\n            collectedFees\\r\\n        ));\\r\\n    } \\r\\n\\r\\n    function _estimateGas() internal view returns(uint256 toPay) {\\r\\n        toPay = BRIDGE.estimateFee(\\r\\n            ODYSSEY_ID,\\r\\n            BRIDGE.messageGasLimit()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    ///------------------ ADMIN ------------------///\\r\\n\\r\\n    /// @notice Set fee \\r\\n    /// @param _fee fee amount in bps [0...100000]\\r\\n    function setFee(uint32 _fee) onlyOwner external {\\r\\n        if(_fee > PCT_DIV) revert FeeTooBig();\\r\\n        fee = _fee;\\r\\n\\r\\n        emit FeeUpdated(_fee);\\r\\n    }\\r\\n\\r\\n    /// @notice Set fee receiver\\r\\n    /// @param _feeReceiver address of the fee receiver in the target chain\\r\\n    function setFeeReceiver(address _feeReceiver) onlyOwner external {\\r\\n        if (_feeReceiver == address(0)) revert ZeroAddress();\\r\\n        feeReceiver = _feeReceiver;\\r\\n\\r\\n        emit FeeReceiverUpdated(_feeReceiver);\\r\\n    }\\r\\n\\r\\n    /// @notice Set fee threshold\\r\\n    /// @param _feeThreshold send fees to the receiver if collected amount is above the threshold\\r\\n    function setFeeThreshold(uint256 _feeThreshold) onlyOwner external {\\r\\n        require(_feeThreshold >= MIN_FEE_THRESHOLD, \\\"WDIONEBridged: Fee threshold too low\\\");\\r\\n        feeThreshold = _feeThreshold;\\r\\n\\r\\n        emit FeeThresholdUpdated(_feeThreshold);\\r\\n    }\\r\\n\\r\\n    /// @notice Configure the pay fee list\\r\\n    /// @param account Account to add/remove from the pay fee list\\r\\n    /// @param add Add=true, Remove=false\\r\\n    function setPayFeeList(address account, bool add) onlyOwner public {\\r\\n        if (account == address(0)) revert ZeroAddress();\\r\\n        isPayFee[account] = add;\\r\\n\\r\\n        emit PayFeeListUpdated(account, add);\\r\\n    }\\r\\n\\r\\n    /// @notice Mass configure the pay fee list\\r\\n    /// @param accounts Array of accounts\\r\\n    /// @param add Add=true, Remove=false\\r\\n    function setPayFeeListBatch(address[] memory accounts, bool add) onlyOwner public {\\r\\n        for(uint256 i=0; i<accounts.length; ++i) {\\r\\n            if (accounts[i] == address(0)) revert ZeroAddress();\\r\\n            isPayFee[accounts[i]] = add;\\r\\n\\r\\n            emit PayFeeListUpdated(accounts[i], add);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraw native tokens from contract\\r\\n    /// @param amount Amount of native tokens\\r\\n    function withdrawNative(uint256 amount) onlyOwner external {\\r\\n        (bool success, ) = msg.sender.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    ///------------------ ERC20 ------------------///\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        uint256 feeAmount = 0;\\r\\n        if(isPayFee[to] && to != address(BRIDGE)) {\\r\\n            feeAmount = amount * fee / PCT_DIV;\\r\\n        }\\r\\n        if (spender != from) {\\r\\n            _spendAllowance(from, spender, amount);\\r\\n        }\\r\\n        if (feeAmount > 0) {\\r\\n            collectedFees += feeAmount;\\r\\n            _transfer(from, address(this), feeAmount);\\r\\n        }\\r\\n        _transfer(from, to, amount - feeAmount);\\r\\n\\r\\n        _isTrySendFees = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        return transferFrom(owner, to, amount);\\r\\n    }\\r\\n\\r\\n    function _afterTokenTransfer(address, address, uint256) internal override {\\r\\n        checkAndSendFees();\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(\\r\\n                payable(to)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"../wanchain/app/WmbAppUpgradeable.sol\\\";\\r\\n\\r\\ninterface IERC20Mintable is IERC20 {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract DioneBridge is Initializable, WmbAppUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for IERC20Mintable;\\r\\n    using SafeERC20 for ERC20Burnable;\\r\\n\\r\\n    enum Operation {\\r\\n        Invalid,\\r\\n        Withdraw,\\r\\n        Mint,\\r\\n        Deposit,\\r\\n        Redeem\\r\\n    }\\r\\n\\r\\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\r\\n    bytes32 public constant RESCUER_ROLE = keccak256(\\\"RESCUER_ROLE\\\");\\r\\n\\r\\n    uint256 public startBlockNumber;\\r\\n    uint256 public constant bridgeVersion = 1;\\r\\n    address payable public WETH_ADDRESS;\\r\\n    uint256 public messageGasLimit;\\r\\n    uint256 public feeInBp;\\r\\n    uint256 public constant percentConverter = 1e4;\\r\\n\\r\\n    mapping(bytes32 => mapping(address => uint256)) public pendingRoles;\\r\\n    mapping(address => uint256) private _wrappedTokenMaxSupply;\\r\\n    mapping(uint256 => mapping(address => address)) private _supportedTokensForReceive;\\r\\n    mapping(uint256 => mapping(address => Operation)) private _allowedTokenOperations;\\r\\n    mapping(uint256 => address) private _supportedBridges;\\r\\n    mapping(address => bool) private _isTokenSupportedToSend;\\r\\n    mapping(address => uint256) private _accumulatedFees;\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => bool) public isFeeFree;\\r\\n    mapping(address => uint256) public minBridgedAmounts;\\r\\n    mapping(address => mapping(address => uint256)) public emergencyTokenStorage;\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        address _wmbGateway\\r\\n    ) external initializer {\\r\\n        require(_wmbGateway != address(0), \\\"Invalid wmbGateway address\\\");\\r\\n        startBlockNumber = block.number;\\r\\n        __AccessControlDefaultAdminRules_init(0, msg.sender);\\r\\n        _setupRole(RESCUER_ROLE, msg.sender);\\r\\n        _setupRole(GOVERNANCE_ROLE, msg.sender);\\r\\n        _setupWmbGateway(_wmbGateway);\\r\\n\\r\\n        messageGasLimit = 160000;\\r\\n    }\\r\\n\\r\\n    function setWethAddress(address payable _wethAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_wethAddress != address(0), \\\"Invalid WETH address\\\");\\r\\n        WETH_ADDRESS = _wethAddress;\\r\\n\\r\\n        emit WethAddressUpdated(_wethAddress);\\r\\n    }\\r\\n\\r\\n    function setSupportedBridge(uint256 chainId, address _bridgeAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_bridgeAddress != address(0), \\\"Invalid bridge address\\\");\\r\\n        _supportedBridges[chainId] = _bridgeAddress;\\r\\n\\r\\n        emit SupportedBridgeUpdated(chainId, _bridgeAddress);\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(address dioneERC20, uint256 maxSupply) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(dioneERC20 != address(0), \\\"Invalid dione ERC20 address\\\");\\r\\n        _wrappedTokenMaxSupply[dioneERC20] = maxSupply;\\r\\n\\r\\n        emit WrappedTokenMaxSupplyUpdated(dioneERC20, maxSupply);\\r\\n    }\\r\\n\\r\\n    function setMessageGasLimit(uint256 gasLimit) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(gasLimit >= IWmbGateway(wmbGateway).minGasLimit(), \\\"Gas limit too low\\\");\\r\\n        require(gasLimit <= IWmbGateway(wmbGateway).maxGasLimit(), \\\"Gas limit too high\\\");\\r\\n        messageGasLimit = gasLimit;\\r\\n\\r\\n        emit MessageGasLimitUpdated(gasLimit);\\r\\n    }\\r\\n\\r\\n    function setTokenForReceive(\\r\\n        uint256 fromChainId,\\r\\n        address fromToken,\\r\\n        address toToken,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(fromToken != address(0), \\\"Invalid fromToken address\\\");\\r\\n        require(toToken != address(0), \\\"Invalid toToken address\\\");\\r\\n        \\r\\n        _supportedTokensForReceive[fromChainId][fromToken] = toToken;\\r\\n        _allowedTokenOperations[fromChainId][fromToken] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForReceiveUpdated(fromChainId, fromToken, toToken, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setTokenToSend(\\r\\n        address token,\\r\\n        bool isSupported,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n        uint256 chainId = IWmbGateway(wmbGateway).chainId();\\r\\n        \\r\\n        _isTokenSupportedToSend[token] = isSupported;\\r\\n        _allowedTokenOperations[chainId][token] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForSendUpdated(token, isSupported, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 _fee) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_fee <= percentConverter, \\\"Invalid fee\\\");\\r\\n\\r\\n        feeInBp = _fee;\\r\\n\\r\\n        emit FeeUpdated(_fee);\\r\\n    }\\r\\n\\r\\n    function setFeeFreelist(address account, bool add) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(account != address(0), \\\"Invalid account address\\\");\\r\\n\\r\\n        isFeeFree[account] = add;\\r\\n\\r\\n        emit FeeFreeListUpdated(account, add);\\r\\n    }\\r\\n\\r\\n    function setMinBridgedAmounts(address token, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n\\r\\n        minBridgedAmounts[token] = amount;\\r\\n\\r\\n        emit MinBridgetAmountsUpdated(token, amount);\\r\\n    }\\r\\n\\r\\n    event TokenDeposit(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenRedeem(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenWithdraw(address indexed to, IERC20 token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenMint(address indexed to, IERC20Mintable token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenAddedToEmergencyTokenStorage(address indexed account, address indexed token, uint256 amount);\\r\\n\\r\\n    event WethAddressUpdated(address newWethAddress);\\r\\n    event SupportedBridgeUpdated(uint256 chainId, address newBridgeAddress);\\r\\n    event WrappedTokenMaxSupplyUpdated(address token, uint256 newMaxSupply);\\r\\n    event MessageGasLimitUpdated(uint256 newGasLimit);\\r\\n    event SupportedTokenForReceiveUpdated(uint256 fromChainId, address fromToken, address toToken, Operation allowedOp);\\r\\n    event SupportedTokenForSendUpdated(address token, bool isSupported, Operation allowedOp);\\r\\n    event FeeUpdated(uint256 fee);\\r\\n    event FeeFreeListUpdated(address account, bool isFeeFree);\\r\\n    event MinBridgetAmountsUpdated(address token, uint256 amount);\\r\\n\\r\\n    // VIEW FUNCTIONS ***/\\r\\n\\r\\n    function getWrappedTokenMaxSupply(address dioneERC20) public view returns (uint256) {\\r\\n        return _wrappedTokenMaxSupply[dioneERC20] == 0 ? type(uint256).max : _wrappedTokenMaxSupply[dioneERC20];\\r\\n    }\\r\\n\\r\\n    function getSupportedTokensForReceive(uint256 fromChainId, address fromToken) external view returns(address) {\\r\\n        return _supportedTokensForReceive[fromChainId][fromToken];\\r\\n    }\\r\\n\\r\\n    function getSupportedBridges(uint256 chainId) external view returns(address) {\\r\\n        return _supportedBridges[chainId];\\r\\n    }\\r\\n\\r\\n    function getIsTokenSupportedToSend(address token) external view returns(bool) {\\r\\n        return _isTokenSupportedToSend[token];\\r\\n    }\\r\\n\\r\\n    function getAllowedTokenOperations(uint256 chainId, address token) external view returns(Operation) {\\r\\n        return _allowedTokenOperations[chainId][token];\\r\\n    }\\r\\n\\r\\n    // PAUSABLE FUNCTIONS ***/\\r\\n    function pause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes to transfers an ERC20 token cross-chain\\r\\n     * @param to address on other chain to bridge assets to\\r\\n     * @param chainId which chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function deposit(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        address tokenAddress = address(token) == address(0) ? WETH_ADDRESS : address(token);\\r\\n        require(_isTokenSupportedToSend[tokenAddress], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][tokenAddress] == Operation.Deposit, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(amount >= minBridgedAmounts[tokenAddress], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n\\r\\n        uint256 recievedAmount = 0;\\r\\n        uint256 receivedMessageFee = 0;\\r\\n        if (address(token) == address(0)) {\\r\\n            require(msg.value >= (messageFee + amount), \\\"Insufficient amount or message feeInBp\\\");\\r\\n\\r\\n            IWETH9(WETH_ADDRESS).deposit{value: amount}();\\r\\n            recievedAmount = amount;\\r\\n            receivedMessageFee = msg.value - amount;\\r\\n        } else {\\r\\n            require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n            uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n            recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n            receivedMessageFee = msg.value;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n        _balances[tokenAddress] += recievedAmount - feeAmount;\\r\\n        _accumulatedFees[tokenAddress] += feeAmount;\\r\\n        emit TokenDeposit(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n\\r\\n        if (receivedMessageFee - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: receivedMessageFee - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(\\r\\n            to,\\r\\n            tokenAddress,\\r\\n            recievedAmount - feeAmount,\\r\\n            Operation.Mint\\r\\n        );\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes that (typically) a wrapped dioneAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param chainId which underlying chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function redeem(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        ERC20Burnable token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        require(_isTokenSupportedToSend[address(token)], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][address(token)] == Operation.Redeem, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n        require(amount >= minBridgedAmounts[address(token)], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n        uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        uint256 recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n\\r\\n        _accumulatedFees[address(token)] += feeAmount;\\r\\n        emit TokenRedeem(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n        token.burn(recievedAmount - feeAmount);\\r\\n\\r\\n        if (msg.value - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: msg.value - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(to, address(token), recievedAmount - feeAmount, Operation.Withdraw);\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    function withdrawFromEmergencyStorage(address token, uint256 amount) external {\\r\\n        address owner = msg.sender;\\r\\n        require(emergencyTokenStorage[owner][token] >= amount, \\\"Amount exceeds the tokens stored in the storage\\\");\\r\\n        \\r\\n        emergencyTokenStorage[owner][token] -= amount;\\r\\n        if (token == address(0)) {\\r\\n            (bool success, ) = owner.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            IERC20(token).safeTransfer(owner, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Rescues tokens that are sent to the contract by mistake and cannot be retrieved by other means\\r\\n     * USE WITH EXTREME CAUTION - CAN BREAK THE ACCOUNTING OF THE BRIDGE\\r\\n     * @param token ERC20 compatible token to retrieve from the bridge\\r\\n     * @param to address of the receiver\\r\\n     * @param amount amount in token decimals to transfer\\r\\n     **/\\r\\n    function rescueTokens(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(hasRole(RESCUER_ROLE, msg.sender), \\\"Not rescuer\\\");\\r\\n        uint256 contractBalance = address(token) == address(0) ? address(this).balance : token.balanceOf(address(this));\\r\\n        require(contractBalance - (_balances[address(token)] + _accumulatedFees[address(token)]) >= amount, \\\"Cannot withdraw user deposited tokens or accumulated fees\\\");\\r\\n        if(address(token) == address(0)) {\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            token.safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawFees(address token, address to, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to != address(0), \\\"Zero address\\\");\\r\\n        require(_accumulatedFees[token] >= amount, \\\"Amount exeeds accumulated fees\\\");\\r\\n        \\r\\n        _accumulatedFees[token] -= amount;\\r\\n        IERC20(token).safeTransfer(to, amount);\\r\\n    }\\r\\n\\r\\n    function mintToken(address token, address[] calldata to, uint256[] calldata amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to.length == amount.length, \\\"Array length not equal\\\");\\r\\n        \\r\\n        for (uint i = 0; i < to.length; i++) {\\r\\n            require(to[i] != address(0), \\\"Zero address\\\");\\r\\n            require(amount[i] > 0, \\\"Zero amount\\\");\\r\\n            \\r\\n            IERC20Mintable(token).mint(to[i], amount[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ADMIN ROLES\\r\\n\\r\\n    /**\\r\\n     * @notice Grant role after a delay\\r\\n     * @param role role hash\\r\\n     * @param account assignee\\r\\n     * @param validAtTimestamp timestamp at which user can accept the role, 0 will revoke pending role\\r\\n     **/\\r\\n    function grantRole(bytes32 role, address account, uint256 validAtTimestamp) public {\\r\\n        bytes32 roleAdmin = getRoleAdmin(role);\\r\\n        require(hasRole(roleAdmin, msg.sender), \\\"AccessControl: sender must be an admin to grant\\\");\\r\\n        if (!hasRole(role, account)) {\\r\\n            pendingRoles[role][account] = validAtTimestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accept role after a delay\\r\\n     * @param role role hash\\r\\n     **/\\r\\n    function acceptRole(bytes32 role) public {\\r\\n        uint256 timestamp = pendingRoles[role][msg.sender];\\r\\n        require(timestamp <= block.timestamp && timestamp !=0, \\\"Role not assigned\\\");\\r\\n        _setupRole(role, msg.sender);\\r\\n        pendingRoles[role][msg.sender] = 0;\\r\\n    }\\r\\n\\r\\n    function grantRole(bytes32 /*role*/, address /*account*/) public pure override {\\r\\n        revert(\\\"Direct role assignment not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function _wmbReceive(\\r\\n        bytes calldata data,\\r\\n        bytes32 messageId,\\r\\n        uint256 fromChainId,\\r\\n        address /*fromSC*/\\r\\n    ) internal override {\\r\\n\\t\\t(address to, address token, uint256 amount, Operation op) = _decodeMessageData(data);\\r\\n        require(_supportedTokensForReceive[fromChainId][token] != address(0), \\\"Unsupported token\\\");\\r\\n        require(_allowedTokenOperations[fromChainId][token] == op, \\\"Not allowed operation\\\");\\r\\n\\r\\n        if (op == Operation.Withdraw) {\\r\\n            _withdraw(\\r\\n                to,\\r\\n                IERC20(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else if (op == Operation.Mint) {\\r\\n            _mint(\\r\\n                payable(to),\\r\\n                IERC20Mintable(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else {\\r\\n            revert(\\\"Invalid operation\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _encodeMessageData(\\r\\n        address to,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        Operation op\\r\\n    ) internal pure returns(bytes memory) {\\r\\n        return abi.encode(\\r\\n            to,\\r\\n            token,\\r\\n            amount,\\r\\n            op\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _decodeMessageData(\\r\\n        bytes memory data\\r\\n    ) internal pure returns(address to, address token, uint256 amount, Operation op) {\\r\\n        (to, token, amount, op) = abi.decode(data, (address, address, uint256, Operation));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Function to be called by the node group to withdraw the underlying assets from the contract\\r\\n     * @param to address on chain to send underlying assets to\\r\\n     * @param token ERC20 compatible token to withdraw from the bridge\\r\\n     * @param amount Amount in native token decimals to withdraw\\r\\n     **/\\r\\n    function _withdraw(\\r\\n        address to,\\r\\n        IERC20 token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n        _balances[address(token)] -= amount;\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (success) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } else {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            try token.transfer(to, amount) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } catch {\\r\\n                emergencyTokenStorage[to][address(token)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(token), amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Nodes call this function to mint a DioneBridgeERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted.\\r\\n     * @dev This means the DioneBridge.sol contract must have minter access to the token attempting to be minted\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain post-fees\\r\\n     **/\\r\\n    function _mint(\\r\\n        address payable to,\\r\\n        IERC20Mintable token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        emit TokenMint(to, token, amount, 0, messageId);\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n            _balances[address(token)] -= amount;\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            uint256 balance = _balances[address(token)];\\r\\n            if (balance < amount) {\\r\\n                _balances[address(token)] -= balance;\\r\\n                uint256 mintAmount = amount - balance;\\r\\n                require(token.totalSupply() + mintAmount <= getWrappedTokenMaxSupply(address(token)) , \\\"Exceeds max supply\\\");\\r\\n                token.mint(address(this), mintAmount);\\r\\n            } else {\\r\\n                _balances[address(token)] -= amount;\\r\\n            }\\r\\n            IERC20(token).safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sendMessage(\\r\\n        uint256 toChainId,\\r\\n        bytes memory msgData,\\r\\n        uint256 messageFee\\r\\n    ) internal {\\r\\n        require(_supportedBridges[toChainId] != address(0), \\\"Destination bridge address zero\\\");\\r\\n        _dispatchMessage(toChainId, _supportedBridges[toChainId], msgData, messageFee);\\r\\n    }\\r\\n\\r\\n    function _calcBridgeFee(uint256 amount) internal view returns(uint256) {\\r\\n        return isFeeFree[msg.sender] \\r\\n            ? 0\\r\\n            : amount * feeInBp / percentConverter;\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(\\r\\n        address payable to,\\r\\n        ierc20mintable token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageid\\r\\n    )",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"../wanchain/app/WmbAppUpgradeable.sol\\\";\\r\\n\\r\\ninterface IERC20Mintable is IERC20 {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract DioneBridge is Initializable, WmbAppUpgradeable, ReentrancyGuardUpgradeable, PausableUpgradeable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for IERC20Mintable;\\r\\n    using SafeERC20 for ERC20Burnable;\\r\\n\\r\\n    enum Operation {\\r\\n        Invalid,\\r\\n        Withdraw,\\r\\n        Mint,\\r\\n        Deposit,\\r\\n        Redeem\\r\\n    }\\r\\n\\r\\n    bytes32 public constant GOVERNANCE_ROLE = keccak256(\\\"GOVERNANCE_ROLE\\\");\\r\\n    bytes32 public constant RESCUER_ROLE = keccak256(\\\"RESCUER_ROLE\\\");\\r\\n\\r\\n    uint256 public startBlockNumber;\\r\\n    uint256 public constant bridgeVersion = 1;\\r\\n    address payable public WETH_ADDRESS;\\r\\n    uint256 public messageGasLimit;\\r\\n    uint256 public feeInBp;\\r\\n    uint256 public constant percentConverter = 1e4;\\r\\n\\r\\n    mapping(bytes32 => mapping(address => uint256)) public pendingRoles;\\r\\n    mapping(address => uint256) private _wrappedTokenMaxSupply;\\r\\n    mapping(uint256 => mapping(address => address)) private _supportedTokensForReceive;\\r\\n    mapping(uint256 => mapping(address => Operation)) private _allowedTokenOperations;\\r\\n    mapping(uint256 => address) private _supportedBridges;\\r\\n    mapping(address => bool) private _isTokenSupportedToSend;\\r\\n    mapping(address => uint256) private _accumulatedFees;\\r\\n    mapping(address => uint256) private _balances;\\r\\n    mapping(address => bool) public isFeeFree;\\r\\n    mapping(address => uint256) public minBridgedAmounts;\\r\\n    mapping(address => mapping(address => uint256)) public emergencyTokenStorage;\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    function initialize(\\r\\n        address _wmbGateway\\r\\n    ) external initializer {\\r\\n        require(_wmbGateway != address(0), \\\"Invalid wmbGateway address\\\");\\r\\n        startBlockNumber = block.number;\\r\\n        __AccessControlDefaultAdminRules_init(0, msg.sender);\\r\\n        _setupRole(RESCUER_ROLE, msg.sender);\\r\\n        _setupRole(GOVERNANCE_ROLE, msg.sender);\\r\\n        _setupWmbGateway(_wmbGateway);\\r\\n\\r\\n        messageGasLimit = 160000;\\r\\n    }\\r\\n\\r\\n    function setWethAddress(address payable _wethAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_wethAddress != address(0), \\\"Invalid WETH address\\\");\\r\\n        WETH_ADDRESS = _wethAddress;\\r\\n\\r\\n        emit WethAddressUpdated(_wethAddress);\\r\\n    }\\r\\n\\r\\n    function setSupportedBridge(uint256 chainId, address _bridgeAddress) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_bridgeAddress != address(0), \\\"Invalid bridge address\\\");\\r\\n        _supportedBridges[chainId] = _bridgeAddress;\\r\\n\\r\\n        emit SupportedBridgeUpdated(chainId, _bridgeAddress);\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(address dioneERC20, uint256 maxSupply) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(dioneERC20 != address(0), \\\"Invalid dione ERC20 address\\\");\\r\\n        _wrappedTokenMaxSupply[dioneERC20] = maxSupply;\\r\\n\\r\\n        emit WrappedTokenMaxSupplyUpdated(dioneERC20, maxSupply);\\r\\n    }\\r\\n\\r\\n    function setMessageGasLimit(uint256 gasLimit) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(gasLimit >= IWmbGateway(wmbGateway).minGasLimit(), \\\"Gas limit too low\\\");\\r\\n        require(gasLimit <= IWmbGateway(wmbGateway).maxGasLimit(), \\\"Gas limit too high\\\");\\r\\n        messageGasLimit = gasLimit;\\r\\n\\r\\n        emit MessageGasLimitUpdated(gasLimit);\\r\\n    }\\r\\n\\r\\n    function setTokenForReceive(\\r\\n        uint256 fromChainId,\\r\\n        address fromToken,\\r\\n        address toToken,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(fromToken != address(0), \\\"Invalid fromToken address\\\");\\r\\n        require(toToken != address(0), \\\"Invalid toToken address\\\");\\r\\n        \\r\\n        _supportedTokensForReceive[fromChainId][fromToken] = toToken;\\r\\n        _allowedTokenOperations[fromChainId][fromToken] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForReceiveUpdated(fromChainId, fromToken, toToken, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setTokenToSend(\\r\\n        address token,\\r\\n        bool isSupported,\\r\\n        Operation allowedOp\\r\\n    ) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n        uint256 chainId = IWmbGateway(wmbGateway).chainId();\\r\\n        \\r\\n        _isTokenSupportedToSend[token] = isSupported;\\r\\n        _allowedTokenOperations[chainId][token] = allowedOp;\\r\\n\\r\\n        emit SupportedTokenForSendUpdated(token, isSupported, allowedOp);\\r\\n    }\\r\\n\\r\\n    function setFee(uint256 _fee) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(_fee <= percentConverter, \\\"Invalid fee\\\");\\r\\n\\r\\n        feeInBp = _fee;\\r\\n\\r\\n        emit FeeUpdated(_fee);\\r\\n    }\\r\\n\\r\\n    function setFeeFreelist(address account, bool add) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(account != address(0), \\\"Invalid account address\\\");\\r\\n\\r\\n        isFeeFree[account] = add;\\r\\n\\r\\n        emit FeeFreeListUpdated(account, add);\\r\\n    }\\r\\n\\r\\n    function setMinBridgedAmounts(address token, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(token != address(0), \\\"Invalid token address\\\");\\r\\n\\r\\n        minBridgedAmounts[token] = amount;\\r\\n\\r\\n        emit MinBridgetAmountsUpdated(token, amount);\\r\\n    }\\r\\n\\r\\n    event TokenDeposit(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenRedeem(address indexed to, uint256 chainId, IERC20 token, uint256 amount, uint256 feeAmount);\\r\\n    event TokenWithdraw(address indexed to, IERC20 token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenMint(address indexed to, IERC20Mintable token, uint256 amount, uint256 feeInBp, bytes32 indexed messageId);\\r\\n    event TokenAddedToEmergencyTokenStorage(address indexed account, address indexed token, uint256 amount);\\r\\n\\r\\n    event WethAddressUpdated(address newWethAddress);\\r\\n    event SupportedBridgeUpdated(uint256 chainId, address newBridgeAddress);\\r\\n    event WrappedTokenMaxSupplyUpdated(address token, uint256 newMaxSupply);\\r\\n    event MessageGasLimitUpdated(uint256 newGasLimit);\\r\\n    event SupportedTokenForReceiveUpdated(uint256 fromChainId, address fromToken, address toToken, Operation allowedOp);\\r\\n    event SupportedTokenForSendUpdated(address token, bool isSupported, Operation allowedOp);\\r\\n    event FeeUpdated(uint256 fee);\\r\\n    event FeeFreeListUpdated(address account, bool isFeeFree);\\r\\n    event MinBridgetAmountsUpdated(address token, uint256 amount);\\r\\n\\r\\n    // VIEW FUNCTIONS ***/\\r\\n\\r\\n    function getWrappedTokenMaxSupply(address dioneERC20) public view returns (uint256) {\\r\\n        return _wrappedTokenMaxSupply[dioneERC20] == 0 ? type(uint256).max : _wrappedTokenMaxSupply[dioneERC20];\\r\\n    }\\r\\n\\r\\n    function getSupportedTokensForReceive(uint256 fromChainId, address fromToken) external view returns(address) {\\r\\n        return _supportedTokensForReceive[fromChainId][fromToken];\\r\\n    }\\r\\n\\r\\n    function getSupportedBridges(uint256 chainId) external view returns(address) {\\r\\n        return _supportedBridges[chainId];\\r\\n    }\\r\\n\\r\\n    function getIsTokenSupportedToSend(address token) external view returns(bool) {\\r\\n        return _isTokenSupportedToSend[token];\\r\\n    }\\r\\n\\r\\n    function getAllowedTokenOperations(uint256 chainId, address token) external view returns(Operation) {\\r\\n        return _allowedTokenOperations[chainId][token];\\r\\n    }\\r\\n\\r\\n    // PAUSABLE FUNCTIONS ***/\\r\\n    function pause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() external {\\r\\n        require(hasRole(GOVERNANCE_ROLE, msg.sender), \\\"Not governance\\\");\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes to transfers an ERC20 token cross-chain\\r\\n     * @param to address on other chain to bridge assets to\\r\\n     * @param chainId which chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function deposit(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        IERC20 token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        address tokenAddress = address(token) == address(0) ? WETH_ADDRESS : address(token);\\r\\n        require(_isTokenSupportedToSend[tokenAddress], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][tokenAddress] == Operation.Deposit, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(amount >= minBridgedAmounts[tokenAddress], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n\\r\\n        uint256 recievedAmount = 0;\\r\\n        uint256 receivedMessageFee = 0;\\r\\n        if (address(token) == address(0)) {\\r\\n            require(msg.value >= (messageFee + amount), \\\"Insufficient amount or message feeInBp\\\");\\r\\n\\r\\n            IWETH9(WETH_ADDRESS).deposit{value: amount}();\\r\\n            recievedAmount = amount;\\r\\n            receivedMessageFee = msg.value - amount;\\r\\n        } else {\\r\\n            require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n            uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n            recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n            receivedMessageFee = msg.value;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n        _balances[tokenAddress] += recievedAmount - feeAmount;\\r\\n        _accumulatedFees[tokenAddress] += feeAmount;\\r\\n        emit TokenDeposit(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n\\r\\n        if (receivedMessageFee - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: receivedMessageFee - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(\\r\\n            to,\\r\\n            tokenAddress,\\r\\n            recievedAmount - feeAmount,\\r\\n            Operation.Mint\\r\\n        );\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Relays to nodes that (typically) a wrapped dioneAsset ERC20 token has been burned and the underlying needs to be redeeemed on the native chain\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param chainId which underlying chain to bridge assets onto\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain pre-fees\\r\\n     **/\\r\\n    function redeem(\\r\\n        address to,\\r\\n        uint256 chainId,\\r\\n        ERC20Burnable token,\\r\\n        uint256 amount\\r\\n    ) external payable nonReentrant whenNotPaused {\\r\\n        require(_isTokenSupportedToSend[address(token)], \\\"Unsupported token\\\");\\r\\n        uint256 curChainId = IWmbGateway(wmbGateway).chainId();\\r\\n        require(_allowedTokenOperations[curChainId][address(token)] == Operation.Redeem, \\\"Unsupported operation\\\");\\r\\n        uint256 messageFee = estimateFee(chainId, messageGasLimit);\\r\\n        require(msg.value >= messageFee, \\\"Insufficient message feeInBp\\\");\\r\\n        require(amount >= minBridgedAmounts[address(token)], \\\"Amount of tokens does not exceed the minimum bridged value\\\");\\r\\n        uint256 prevBalance = token.balanceOf(address(this));\\r\\n\\r\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        uint256 recievedAmount = token.balanceOf(address(this)) - prevBalance;\\r\\n        uint256 feeAmount = _calcBridgeFee(recievedAmount);\\r\\n\\r\\n        _accumulatedFees[address(token)] += feeAmount;\\r\\n        emit TokenRedeem(to, chainId, token, recievedAmount - feeAmount, feeAmount);\\r\\n        token.burn(recievedAmount - feeAmount);\\r\\n\\r\\n        if (msg.value - messageFee > 0) {\\r\\n            (bool success, ) = msg.sender.call{value: msg.value - messageFee}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        }\\r\\n\\r\\n        bytes memory data = _encodeMessageData(to, address(token), recievedAmount - feeAmount, Operation.Withdraw);\\r\\n        _sendMessage(chainId, data, messageFee);\\r\\n    }\\r\\n\\r\\n    function withdrawFromEmergencyStorage(address token, uint256 amount) external {\\r\\n        address owner = msg.sender;\\r\\n        require(emergencyTokenStorage[owner][token] >= amount, \\\"Amount exceeds the tokens stored in the storage\\\");\\r\\n        \\r\\n        emergencyTokenStorage[owner][token] -= amount;\\r\\n        if (token == address(0)) {\\r\\n            (bool success, ) = owner.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            IERC20(token).safeTransfer(owner, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Rescues tokens that are sent to the contract by mistake and cannot be retrieved by other means\\r\\n     * USE WITH EXTREME CAUTION - CAN BREAK THE ACCOUNTING OF THE BRIDGE\\r\\n     * @param token ERC20 compatible token to retrieve from the bridge\\r\\n     * @param to address of the receiver\\r\\n     * @param amount amount in token decimals to transfer\\r\\n     **/\\r\\n    function rescueTokens(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external nonReentrant {\\r\\n        require(hasRole(RESCUER_ROLE, msg.sender), \\\"Not rescuer\\\");\\r\\n        uint256 contractBalance = address(token) == address(0) ? address(this).balance : token.balanceOf(address(this));\\r\\n        require(contractBalance - (_balances[address(token)] + _accumulatedFees[address(token)]) >= amount, \\\"Cannot withdraw user deposited tokens or accumulated fees\\\");\\r\\n        if(address(token) == address(0)) {\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            require(success, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n        } else {\\r\\n            token.safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawFees(address token, address to, uint256 amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to != address(0), \\\"Zero address\\\");\\r\\n        require(_accumulatedFees[token] >= amount, \\\"Amount exeeds accumulated fees\\\");\\r\\n        \\r\\n        _accumulatedFees[token] -= amount;\\r\\n        IERC20(token).safeTransfer(to, amount);\\r\\n    }\\r\\n\\r\\n    function mintToken(address token, address[] calldata to, uint256[] calldata amount) external {\\r\\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \\\"Not admin\\\");\\r\\n        require(to.length == amount.length, \\\"Array length not equal\\\");\\r\\n        \\r\\n        for (uint i = 0; i < to.length; i++) {\\r\\n            require(to[i] != address(0), \\\"Zero address\\\");\\r\\n            require(amount[i] > 0, \\\"Zero amount\\\");\\r\\n            \\r\\n            IERC20Mintable(token).mint(to[i], amount[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ADMIN ROLES\\r\\n\\r\\n    /**\\r\\n     * @notice Grant role after a delay\\r\\n     * @param role role hash\\r\\n     * @param account assignee\\r\\n     * @param validAtTimestamp timestamp at which user can accept the role, 0 will revoke pending role\\r\\n     **/\\r\\n    function grantRole(bytes32 role, address account, uint256 validAtTimestamp) public {\\r\\n        bytes32 roleAdmin = getRoleAdmin(role);\\r\\n        require(hasRole(roleAdmin, msg.sender), \\\"AccessControl: sender must be an admin to grant\\\");\\r\\n        if (!hasRole(role, account)) {\\r\\n            pendingRoles[role][account] = validAtTimestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accept role after a delay\\r\\n     * @param role role hash\\r\\n     **/\\r\\n    function acceptRole(bytes32 role) public {\\r\\n        uint256 timestamp = pendingRoles[role][msg.sender];\\r\\n        require(timestamp <= block.timestamp && timestamp !=0, \\\"Role not assigned\\\");\\r\\n        _setupRole(role, msg.sender);\\r\\n        pendingRoles[role][msg.sender] = 0;\\r\\n    }\\r\\n\\r\\n    function grantRole(bytes32 /*role*/, address /*account*/) public pure override {\\r\\n        revert(\\\"Direct role assignment not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function _wmbReceive(\\r\\n        bytes calldata data,\\r\\n        bytes32 messageId,\\r\\n        uint256 fromChainId,\\r\\n        address /*fromSC*/\\r\\n    ) internal override {\\r\\n\\t\\t(address to, address token, uint256 amount, Operation op) = _decodeMessageData(data);\\r\\n        require(_supportedTokensForReceive[fromChainId][token] != address(0), \\\"Unsupported token\\\");\\r\\n        require(_allowedTokenOperations[fromChainId][token] == op, \\\"Not allowed operation\\\");\\r\\n\\r\\n        if (op == Operation.Withdraw) {\\r\\n            _withdraw(\\r\\n                to,\\r\\n                IERC20(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else if (op == Operation.Mint) {\\r\\n            _mint(\\r\\n                payable(to),\\r\\n                IERC20Mintable(_supportedTokensForReceive[fromChainId][token]),\\r\\n                amount,\\r\\n                messageId\\r\\n            );\\r\\n        } else {\\r\\n            revert(\\\"Invalid operation\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _encodeMessageData(\\r\\n        address to,\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        Operation op\\r\\n    ) internal pure returns(bytes memory) {\\r\\n        return abi.encode(\\r\\n            to,\\r\\n            token,\\r\\n            amount,\\r\\n            op\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _decodeMessageData(\\r\\n        bytes memory data\\r\\n    ) internal pure returns(address to, address token, uint256 amount, Operation op) {\\r\\n        (to, token, amount, op) = abi.decode(data, (address, address, uint256, Operation));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Function to be called by the node group to withdraw the underlying assets from the contract\\r\\n     * @param to address on chain to send underlying assets to\\r\\n     * @param token ERC20 compatible token to withdraw from the bridge\\r\\n     * @param amount Amount in native token decimals to withdraw\\r\\n     **/\\r\\n    function _withdraw(\\r\\n        address to,\\r\\n        IERC20 token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n        _balances[address(token)] -= amount;\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (success) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } else {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            try token.transfer(to, amount) {\\r\\n                emit TokenWithdraw(to, token, amount, 0, messageId);\\r\\n            } catch {\\r\\n                emergencyTokenStorage[to][address(token)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(token), amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Nodes call this function to mint a DioneBridgeERC20 (or any asset that the bridge is given minter access to). This is called by the nodes after a TokenDeposit event is emitted.\\r\\n     * @dev This means the DioneBridge.sol contract must have minter access to the token attempting to be minted\\r\\n     * @param to address on other chain to redeem underlying assets to\\r\\n     * @param token ERC20 compatible token to deposit into the bridge\\r\\n     * @param amount Amount in native token decimals to transfer cross-chain post-fees\\r\\n     **/\\r\\n    function _mint(\\r\\n        address payable to,\\r\\n        IERC20Mintable token,\\r\\n        uint256 amount,\\r\\n        bytes32 messageId\\r\\n    ) internal nonReentrant {\\r\\n        emit TokenMint(to, token, amount, 0, messageId);\\r\\n        if (address(token) == WETH_ADDRESS && WETH_ADDRESS != address(0)) {\\r\\n            require(_balances[address(token)] >= amount, \\\"Amount exeeds balance\\\");\\r\\n            _balances[address(token)] -= amount;\\r\\n            IWETH9(WETH_ADDRESS).withdraw(amount);\\r\\n            (bool success, ) = to.call{value: amount}(\\\"\\\");\\r\\n            if (!success) {\\r\\n                emergencyTokenStorage[to][address(0)] += amount;\\r\\n                emit TokenAddedToEmergencyTokenStorage(to, address(0), amount);\\r\\n            }\\r\\n        } else {\\r\\n            uint256 balance = _balances[address(token)];\\r\\n            if (balance < amount) {\\r\\n                _balances[address(token)] -= balance;\\r\\n                uint256 mintAmount = amount - balance;\\r\\n                require(token.totalSupply() + mintAmount <= getWrappedTokenMaxSupply(address(token)) , \\\"Exceeds max supply\\\");\\r\\n                token.mint(address(this), mintAmount);\\r\\n            } else {\\r\\n                _balances[address(token)] -= amount;\\r\\n            }\\r\\n            IERC20(token).safeTransfer(to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sendMessage(\\r\\n        uint256 toChainId,\\r\\n        bytes memory msgData,\\r\\n        uint256 messageFee\\r\\n    ) internal {\\r\\n        require(_supportedBridges[toChainId] != address(0), \\\"Destination bridge address zero\\\");\\r\\n        _dispatchMessage(toChainId, _supportedBridges[toChainId], msgData, messageFee);\\r\\n    }\\r\\n\\r\\n    function _calcBridgeFee(uint256 amount) internal view returns(uint256) {\\r\\n        return isFeeFree[msg.sender] \\r\\n            ? 0\\r\\n            : amount * feeInBp / percentConverter;\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}