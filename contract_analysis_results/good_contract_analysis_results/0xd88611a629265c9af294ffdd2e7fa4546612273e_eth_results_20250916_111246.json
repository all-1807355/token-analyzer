{
  "total_matches": 9,
  "patterns_found": {
    "minting_mechanics": {
      "count": 9,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IMPROMasterDistributor {\\n    function getBurnAmount(\\n        address _from,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isDistributor(address account) external view returns (bool);\\n\\n    function mintAllowed(address minter) external view returns (bool);\\n\\n    function approveAllowed(address, address) external view returns (bool);\\n\\n    function transferAllowed(\\n        address _from,\\n        address _to,\\n        address _msgSender\\n    ) external view returns (bool);\\n}\\n\\ncontract MPRO is OFT, ERC20Votes {\\n    IMPROMasterDistributor private mproMasterDistributor;\\n\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Public constant representing the maximum cap on the token's total supply.\\n     *\\n     * This constant defines the maximum number of tokens that can ever be minted in the lifetime\\n     * of the contract. The cap is set to 500 million tokens, considering the decimal factor of\\n     * the token. Since Solidity does not support floating-point numbers, the token amounts are\\n     * often expressed in the smallest units, similar to how cents are used for dollars in the\\n     * traditional currency system. Here, `10 ** 18` represents 1 token in its smallest unit (like wei\\n     * in Ethereum), making the cap effectively 500 million tokens.\\n     *\\n     * The purpose of setting a maximum cap is to provide assurances about the maximum supply of\\n     * tokens that can exist, which is an important aspect of the token's economic and governance\\n     * model. It ensures transparency and trust in the token's scarcity and value.\\n     */\\n\\n    uint256 private constant _maxCap = 500_000_000 * 10 ** 18;\\n\\n    /**\\n     * @dev Constructor to initialize the contract with specific parameters.\\n     *\\n     * This constructor initializes the contract with a name, symbol, and several key addresses\\n     * relevant to its operation. It also handles the preminting of tokens to a list of addresses.\\n     *\\n     * The constructor performs the following operations:\\n     * - Inherits from OFTV2 and ERC20Permit by passing `_name`, `_symbol`, and other parameters\\n     *   to these base contracts.\\n     * - Loops through the `premintAddresses` array, minting tokens in the amounts specified in\\n     *   `premintValues` to each address. This is used to distribute an initial supply of tokens.\\n     * - Sets the `mproRoleManager` by casting the `_mproRoleManager` address to the\\n     *   IMPRORoleManager interface, which is expected to manage role-based access in the contract.\\n     * - Sets the `mproMasterDistributor` by casting the `_mproMasterDistributor` address to the\\n     *   IMPROMasterDistributor interface, which is expected to handle distribution-related logic.\\n     *\\n     * The `_lzEndpoint` parameter is specific to the OFTV2 initialization and is related to LayerZero\\n     * endpoint configurations.\\n     *\\n     * This constructor is critical for setting up the initial state of the contract, including\\n     * roles, token distribution, and other essential configurations.\\n     *\\n     * @param _name The name of the token.\\n     * @param _symbol The symbol of the token.\\n     * @param premintAddresses Array of addresses that will receive the preminted tokens.\\n     * @param premintValues Array of token amounts corresponding to each premint address.\\n     * @param _lzEndpoint Address for the LayerZero endpoint, used in OFTV2 initialization.\\n     * @param _mproMasterDistributor Address of the contract managing token distributions.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address[] memory premintAddresses,\\n        uint256[] memory premintValues,\\n        address _lzEndpoint,\\n        address _mproMasterDistributor,\\n        address _owner\\n    ) OFT(_name, _symbol, _lzEndpoint, _owner) ERC20Permit(_name) {\\n        for (uint256 i = 0; i < premintAddresses.length; i++) {\\n            _mint(premintAddresses[i], premintValues[i]);\\n        }\\n        mproMasterDistributor = IMPROMasterDistributor(_mproMasterDistributor);\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint tokens.\\n     *\\n     * This function is an override of the `_mint` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing flexibility in extending the token minting logic.\\n     *\\n     * The function calls `super._mint` to invoke the minting logic defined in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that the token minting process adheres to the standard\\n     * ERC20 implementation, while also updating any additional state or logic defined in ERC20Votes,\\n     * such as vote tracking.\\n     *\\n     * The overriding of this function may be used to introduce additional logic before or after the\\n     * standard minting process, such as custom events, access controls, or other state updates\\n     * specific to the derived contract's requirements.\\n     *\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to be minted.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to mint new tokens.\\n     *\\n     * This function allows for the external minting of tokens, but restricts access to only those\\n     * accounts that have been granted distributor privileges by the mproRoleManager. The\\n     * `isDistributor` function of the mproRoleManager is used to check if the caller (_msgSender())\\n     * has the necessary role to perform the minting.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the minting process or introduction of additional logic.\\n     *\\n     * If the caller is authorized as a distributor, the function proceeds to call the internal `_mint`\\n     * function, which handles the actual creation and allocation of tokens to the specified account.\\n     * This two-tier structure (external `mint` calling internal `_mint`) allows for separation of\\n     * concerns, where access control is handled externally, while the token creation logic is\\n     * encapsulated within the internal function.\\n     *\\n     * @param account The address to which the minted tokens will be allocated.\\n     * @param amount The amount of tokens to be minted and allocated to the account.\\n     */\\n    function mint(address account, uint256 amount) external virtual {\\n        mproMasterDistributor.mintAllowed(_msgSender());\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens.\\n     *\\n     * This function is an override of the `_burn` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing the flexibility to modify the token burning logic.\\n     *\\n     * The function delegates to `super._burn` to execute the burning logic defined in the parent\\n     * contracts (ERC20 and ERC20Votes). This ensures that the token burning process complies with\\n     * the ERC20 standard, while also accommodating any additional state or logic updates defined in\\n     * ERC20Votes, such as vote tracking adjustments.\\n     *\\n     * Overriding this function allows the introduction of additional functionality specific to the\\n     * contract's requirements, which could include custom events, access controls, or other state\\n     * modifications that need to occur alongside the standard token burning process.\\n     *\\n     * @param account The address from which the tokens will be burned.\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to burn tokens.\\n     *\\n     * This function provides an external interface to burn tokens from a specified account. It is\\n     * accessible externally and allows for tokens to be burned, reducing the total supply in\\n     * circulation. The function does not include specific access control checks, meaning any external\\n     * caller can potentially invoke it, subject to the contract's overall design and security model.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the burning process or the introduction of additional logic, such\\n     * as access control restrictions or pre-burn validations.\\n     *\\n     * The actual burning of tokens is delegated to the internal `_burn` function, which encapsulates\\n     * the logic for removing tokens from an account's balance and updating the total supply. This\\n     * separation of concerns allows the `_burn` function to handle the core logic, while the external\\n     * `burn` function can be adapted or extended in derived contracts.\\n     *\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev Public function to approve another account to spend tokens on behalf of the message sender.\\n     *\\n     * This function overrides the standard `approve` function of the ERC20 token standard. It allows\\n     * a token holder to grant permission to another account (referred to as the spender) to transfer\\n     * up to a specified number of tokens on their behalf.\\n     *\\n     * The function includes an additional security feature using the `mproRoleManager` to check\\n     * whether the approval is allowed. This could be based on additional business logic or\\n     * restrictions defined in the role manager contract.\\n     *\\n     * After the custom check, the function calls the internal `_approve` function of the ERC20\\n     * contract to handle the actual approval mechanism, updating the allowance set for the spender.\\n     *\\n     * @param _spender The address which is being granted permission to spend tokens on behalf of the\\n     *                 message sender.\\n     * @param _value The maximum number of tokens the spender is allowed to transfer.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.approveAllowed(_msgSender(), _spender);\\n        super._approve(_msgSender(), _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens from the message sender's account to another account.\\n     *\\n     * This function overrides the standard `transfer` function of the ERC20 token standard. It\\n     * enables a token holder to transfer tokens to another address. In addition to the standard\\n     * transfer functionality, this implementation includes custom logic for additional checks and\\n     * burning tokens on transfer.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom checks based on the contract's\\n     *   business logic. This might include restrictions on who can send or receive tokens or other\\n     *   specific conditions.\\n     * - Calls the internal `_burnOnTransfer` function to calculate the amount after applying the\\n     *   burn rate, if applicable, based on the contract's burning mechanism.\\n     * - Executes the token transfer through `super._transfer`, using the potentially adjusted amount\\n     *   from `_burnOnTransfer`.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This custom implementation ensures compliance with additional rules and token burn mechanisms\\n     * while maintaining the basic functionality of ERC20 transfers.\\n     *\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.transferAllowed(_msgSender(), _to, _msgSender());\\n        _transfer(_msgSender(), _to, _burnOnTransfer(_msgSender(), _value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens on behalf of another account.\\n     *\\n     * This function overrides the standard `transferFrom` function of the ERC20 token standard.\\n     * It is used to transfer tokens from one account to another, based on a previously set allowance.\\n     * The caller must have been previously authorized by the token holder (_from) to spend up to\\n     * a specified number of tokens on their behalf.\\n     *\\n     * The function includes additional logic as follows:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom validation. This could involve\\n     *   checks based on specific business rules, like validating the roles of the involved parties\\n     *   (_from, _to, and the message sender).\\n     * - Executes the transfer through the internal `_transferFrom` function, which handles the actual\\n     *   token transfer logic. Before the transfer, it applies the `_burnOnTransfer` function to\\n     *   calculate the final amount after considering any burn mechanism that might be in place.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This implementation ensures that any transfers made through this function comply with\\n     * additional constraints or business logic defined in the contract, along with the standard\\n     * ERC20 transferFrom functionality.\\n     *\\n     * @param _from The address of the token holder whose tokens are being transferred.\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        address spender = _msgSender();\\n        mproMasterDistributor.transferAllowed(_from, _to, spender);\\n        // Chack allowance before passing deducted amount by burn rate to _transferFrom\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\n        _transfer(_from, _to, _burnOnTransfer(_from, _amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to handle token burning on transfers.\\n     *\\n     * This function calculates and executes the burning of a portion of tokens during a transfer,\\n     * based on the current burn rate as determined by the `mproMasterDistributor.getBurnAmount`\\n     * function. It is designed to be called as part of the token transfer process to automatically\\n     * apply a burn mechanism on transfers, reducing the amount of tokens ultimately transferred.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `getBurnAmount` from `mproMasterDistributor` to determine the amount of tokens that\\n     *   should be burned from the transfer amount, based on the sender and the total transfer amount.\\n     * - If the calculated burn amount is greater than zero and less than the total transfer amount,\\n     *   it proceeds to burn that portion of tokens from the sender's balance by calling the internal\\n     *   `_burn` function.\\n     * - Returns the remaining amount after the burn has been applied. This remaining amount is what\\n     *   will be actually transferred to the recipient.\\n     *\\n     * Note: It's important to ensure the burn amount is valid (not exceeding the transfer amount) to\\n     * prevent issues with token balances and supply.\\n     *\\n     * @param _sender The address from which the tokens are being transferred (and potentially burned).\\n     * @param _amount The total amount of tokens being transferred before burn is applied.\\n     * @return The amount of tokens to be transferred after applying the burn.\\n     */\\n    function _burnOnTransfer(\\n        address _sender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        uint256 burnAmount = mproMasterDistributor.getBurnAmount(\\n            _sender,\\n            _amount\\n        );\\n        if (burnAmount > 0 && burnAmount < _amount) {\\n            _burn(_sender, burnAmount);\\n        }\\n        return _amount.sub(burnAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_beforeTokenTransfer` hook from the ERC20 standard. It is called\\n     * automatically before every transfer, minting, or burning operation, allowing for additional\\n     * custom logic to be executed.\\n     *\\n     * The function specifically enforces a maximum cap on the total token supply during minting. When\\n     * tokens are being minted (indicated by the `from` address being the zero address), it checks\\n     * whether the minting would cause the total token supply to exceed a predefined maximum cap\\n     * (`_maxCap`). If so, it reverts the transaction to prevent exceeding the cap.\\n     *\\n     * This cap ensures that the total number of tokens in circulation does not surpass a certain\\n     * limit, aligning with the token's economic design and providing a safeguard against\\n     * uncontrolled token issuance.\\n     *\\n     * After performing this check (or in cases of transfer and burning), it calls the base\\n     * implementation of `_beforeTokenTransfer` from the ERC20 contract to handle any additional\\n     * standard logic.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20) {\\n        if (from == address(0)) {\\n            // Chack if minting would exceed the cap based on the total supply and the minted amount\\n            require(\\n                totalSupply() + amount <= _maxCap,\\n                \\\"ERC20Capped: cap exceeded\\\"\\n            );\\n        }\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_afterTokenTransfer` hook from both the ERC20 and ERC20Votes\\n     * contracts. It is called automatically after every transfer, minting, or burning operation.\\n     * The function provides a point to insert custom logic that needs to occur after a token\\n     * transfer, mint, or burn.\\n     *\\n     * In its current implementation, this function does not introduce any additional logic but\\n     * rather delegates to the base implementation of `_afterTokenTransfer` in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that any necessary post-transfer processing defined in\\n     * these base contracts, such as updating vote balances in ERC20Votes, is executed.\\n     *\\n     * This function can be extended in derived contracts to include additional post-transfer\\n     * actions, making it a versatile hook for custom behaviors that should occur after token\\n     * transactions.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20, ERC20Votes) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function maxCap() external pure returns (uint256) {\\n        return _maxCap;\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Permit.sol\\\";\\nimport \\\"../../../interfaces/IERC5805.sol\\\";\\nimport \\\"../../../utils/math/Math.sol\\\";\\nimport \\\"../../../utils/math/SafeCast.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\\n *\\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\\n *\\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\\n *\\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\\n *\\n * _Available since v4.2._\\n */\\nabstract contract ERC20Votes is ERC20Permit, IERC5805 {\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint224 votes;\\n    }\\n\\n    bytes32 private constant _DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    mapping(address => address) private _delegates;\\n    mapping(address => Checkpoint[]) private _checkpoints;\\n    Checkpoint[] private _totalSupplyCheckpoints;\\n\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() public view virtual override returns (uint48) {\\n        return SafeCast.toUint48(block.number);\\n    }\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() public view virtual override returns (string memory) {\\n        // Check that the clock was not modified\\n        require(clock() == block.number, \\\"ERC20Votes: broken clock mode\\\");\\n        return \\\"mode=blocknumber&from=default\\\";\\n    }\\n\\n    /**\\n     * @dev Get the `pos`-th checkpoint for `account`.\\n     */\\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\\n        return _checkpoints[account][pos];\\n    }\\n\\n    /**\\n     * @dev Get number of checkpoints for `account`.\\n     */\\n    function numCheckpoints(address account) public view virtual returns (uint32) {\\n        return SafeCast.toUint32(_checkpoints[account].length);\\n    }\\n\\n    /**\\n     * @dev Get the address `account` is currently delegating to.\\n     */\\n    function delegates(address account) public view virtual override returns (address) {\\n        return _delegates[account];\\n    }\\n\\n    /**\\n     * @dev Gets the current votes balance for `account`\\n     */\\n    function getVotes(address account) public view virtual override returns (uint256) {\\n        uint256 pos = _checkpoints[account].length;\\n        unchecked {\\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_checkpoints[account], timepoint);\\n    }\\n\\n    /**\\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\\n     * It is NOT the sum of all the delegated votes!\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\\n    }\\n\\n    /**\\n     * @dev Lookup a value in a list of (sorted) checkpoints.\\n     */\\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\\n        //\\n        // Initially we check if the block is recent to narrow the search range.\\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\\n        // the same.\\n        uint256 length = ckpts.length;\\n\\n        uint256 low = 0;\\n        uint256 high = length;\\n\\n        if (length > 5) {\\n            uint256 mid = length - Math.sqrt(length);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        unchecked {\\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegate votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) public virtual override {\\n        _delegate(_msgSender(), delegatee);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= expiry, \\\"ERC20Votes: signature expired\\\");\\n        address signer = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == _useNonce(signer), \\\"ERC20Votes: invalid nonce\\\");\\n        _delegate(signer, delegatee);\\n    }\\n\\n    /**\\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\\n     */\\n    function _maxSupply() internal view virtual returns (uint224) {\\n        return type(uint224).max;\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been increased.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual override {\\n        super._mint(account, amount);\\n        require(totalSupply() <= _maxSupply(), \\\"ERC20Votes: total supply risks overflowing votes\\\");\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been decreased.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual override {\\n        super._burn(account, amount);\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\\n    }\\n\\n    /**\\n     * @dev Move voting power when tokens are transferred.\\n     *\\n     * Emits a {IVotes-DelegateVotesChanged} event.\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._afterTokenTransfer(from, to, amount);\\n\\n        _moveVotingPower(delegates(from), delegates(to), amount);\\n    }\\n\\n    /**\\n     * @dev Change delegation for `delegator` to `delegatee`.\\n     *\\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\\n     */\\n    function _delegate(address delegator, address delegatee) internal virtual {\\n        address currentDelegate = delegates(delegator);\\n        uint256 delegatorBalance = balanceOf(delegator);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\\n        if (src != dst && amount > 0) {\\n            if (src != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\\n            }\\n\\n            if (dst != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        Checkpoint[] storage ckpts,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\\n        uint256 pos = ckpts.length;\\n\\n        unchecked {\\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\\n\\n            oldWeight = oldCkpt.votes;\\n            newWeight = op(oldWeight, delta);\\n\\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);\\n            } else {\\n                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));\\n            }\\n        }\\n    }\\n\\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, ckpts.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Votes.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20Permit.sol\\\";\\nimport \\\"../../../interfaces/IERC5805.sol\\\";\\nimport \\\"../../../utils/math/Math.sol\\\";\\nimport \\\"../../../utils/math/SafeCast.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\n\\n/**\\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\\n *\\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\\n *\\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\\n *\\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\\n *\\n * _Available since v4.2._\\n */\\nabstract contract ERC20Votes is ERC20Permit, IERC5805 {\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint224 votes;\\n    }\\n\\n    bytes32 private constant _DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    mapping(address => address) private _delegates;\\n    mapping(address => Checkpoint[]) private _checkpoints;\\n    Checkpoint[] private _totalSupplyCheckpoints;\\n\\n    /**\\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\\n     */\\n    function clock() public view virtual override returns (uint48) {\\n        return SafeCast.toUint48(block.number);\\n    }\\n\\n    /**\\n     * @dev Description of the clock\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function CLOCK_MODE() public view virtual override returns (string memory) {\\n        // Check that the clock was not modified\\n        require(clock() == block.number, \\\"ERC20Votes: broken clock mode\\\");\\n        return \\\"mode=blocknumber&from=default\\\";\\n    }\\n\\n    /**\\n     * @dev Get the `pos`-th checkpoint for `account`.\\n     */\\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\\n        return _checkpoints[account][pos];\\n    }\\n\\n    /**\\n     * @dev Get number of checkpoints for `account`.\\n     */\\n    function numCheckpoints(address account) public view virtual returns (uint32) {\\n        return SafeCast.toUint32(_checkpoints[account].length);\\n    }\\n\\n    /**\\n     * @dev Get the address `account` is currently delegating to.\\n     */\\n    function delegates(address account) public view virtual override returns (address) {\\n        return _delegates[account];\\n    }\\n\\n    /**\\n     * @dev Gets the current votes balance for `account`\\n     */\\n    function getVotes(address account) public view virtual override returns (uint256) {\\n        uint256 pos = _checkpoints[account].length;\\n        unchecked {\\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_checkpoints[account], timepoint);\\n    }\\n\\n    /**\\n     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.\\n     * It is NOT the sum of all the delegated votes!\\n     *\\n     * Requirements:\\n     *\\n     * - `timepoint` must be in the past\\n     */\\n    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {\\n        require(timepoint < clock(), \\\"ERC20Votes: future lookup\\\");\\n        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);\\n    }\\n\\n    /**\\n     * @dev Lookup a value in a list of (sorted) checkpoints.\\n     */\\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {\\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timepoint`.\\n        //\\n        // Initially we check if the block is recent to narrow the search range.\\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\\n        // - If the middle checkpoint is after `timepoint`, we look in [low, mid)\\n        // - If the middle checkpoint is before or equal to `timepoint`, we look in [mid+1, high)\\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\\n        // Note that if the latest checkpoint available is exactly for `timepoint`, we end up with an index that is\\n        // past the end of the array, so we technically don't find a checkpoint after `timepoint`, but it works out\\n        // the same.\\n        uint256 length = ckpts.length;\\n\\n        uint256 low = 0;\\n        uint256 high = length;\\n\\n        if (length > 5) {\\n            uint256 mid = length - Math.sqrt(length);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        unchecked {\\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegate votes from the sender to `delegatee`.\\n     */\\n    function delegate(address delegatee) public virtual override {\\n        _delegate(_msgSender(), delegatee);\\n    }\\n\\n    /**\\n     * @dev Delegates votes from signer to `delegatee`\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= expiry, \\\"ERC20Votes: signature expired\\\");\\n        address signer = ECDSA.recover(\\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\\n            v,\\n            r,\\n            s\\n        );\\n        require(nonce == _useNonce(signer), \\\"ERC20Votes: invalid nonce\\\");\\n        _delegate(signer, delegatee);\\n    }\\n\\n    /**\\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\\n     */\\n    function _maxSupply() internal view virtual returns (uint224) {\\n        return type(uint224).max;\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been increased.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual override {\\n        super._mint(account, amount);\\n        require(totalSupply() <= _maxSupply(), \\\"ERC20Votes: total supply risks overflowing votes\\\");\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\\n    }\\n\\n    /**\\n     * @dev Snapshots the totalSupply after it has been decreased.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual override {\\n        super._burn(account, amount);\\n\\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\\n    }\\n\\n    /**\\n     * @dev Move voting power when tokens are transferred.\\n     *\\n     * Emits a {IVotes-DelegateVotesChanged} event.\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._afterTokenTransfer(from, to, amount);\\n\\n        _moveVotingPower(delegates(from), delegates(to), amount);\\n    }\\n\\n    /**\\n     * @dev Change delegation for `delegator` to `delegatee`.\\n     *\\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\\n     */\\n    function _delegate(address delegator, address delegatee) internal virtual {\\n        address currentDelegate = delegates(delegator);\\n        uint256 delegatorBalance = balanceOf(delegator);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveVotingPower(address src, address dst, uint256 amount) private {\\n        if (src != dst && amount > 0) {\\n            if (src != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\\n            }\\n\\n            if (dst != address(0)) {\\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        Checkpoint[] storage ckpts,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\\n        uint256 pos = ckpts.length;\\n\\n        unchecked {\\n            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);\\n\\n            oldWeight = oldCkpt.votes;\\n            newWeight = op(oldWeight, delta);\\n\\n            if (pos > 0 && oldCkpt.fromBlock == clock()) {\\n                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);\\n            } else {\\n                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));\\n            }\\n        }\\n    }\\n\\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, ckpts.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(premintaddresses[i], premintvalues[i])",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IMPROMasterDistributor {\\n    function getBurnAmount(\\n        address _from,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isDistributor(address account) external view returns (bool);\\n\\n    function mintAllowed(address minter) external view returns (bool);\\n\\n    function approveAllowed(address, address) external view returns (bool);\\n\\n    function transferAllowed(\\n        address _from,\\n        address _to,\\n        address _msgSender\\n    ) external view returns (bool);\\n}\\n\\ncontract MPRO is OFT, ERC20Votes {\\n    IMPROMasterDistributor private mproMasterDistributor;\\n\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Public constant representing the maximum cap on the token's total supply.\\n     *\\n     * This constant defines the maximum number of tokens that can ever be minted in the lifetime\\n     * of the contract. The cap is set to 500 million tokens, considering the decimal factor of\\n     * the token. Since Solidity does not support floating-point numbers, the token amounts are\\n     * often expressed in the smallest units, similar to how cents are used for dollars in the\\n     * traditional currency system. Here, `10 ** 18` represents 1 token in its smallest unit (like wei\\n     * in Ethereum), making the cap effectively 500 million tokens.\\n     *\\n     * The purpose of setting a maximum cap is to provide assurances about the maximum supply of\\n     * tokens that can exist, which is an important aspect of the token's economic and governance\\n     * model. It ensures transparency and trust in the token's scarcity and value.\\n     */\\n\\n    uint256 private constant _maxCap = 500_000_000 * 10 ** 18;\\n\\n    /**\\n     * @dev Constructor to initialize the contract with specific parameters.\\n     *\\n     * This constructor initializes the contract with a name, symbol, and several key addresses\\n     * relevant to its operation. It also handles the preminting of tokens to a list of addresses.\\n     *\\n     * The constructor performs the following operations:\\n     * - Inherits from OFTV2 and ERC20Permit by passing `_name`, `_symbol`, and other parameters\\n     *   to these base contracts.\\n     * - Loops through the `premintAddresses` array, minting tokens in the amounts specified in\\n     *   `premintValues` to each address. This is used to distribute an initial supply of tokens.\\n     * - Sets the `mproRoleManager` by casting the `_mproRoleManager` address to the\\n     *   IMPRORoleManager interface, which is expected to manage role-based access in the contract.\\n     * - Sets the `mproMasterDistributor` by casting the `_mproMasterDistributor` address to the\\n     *   IMPROMasterDistributor interface, which is expected to handle distribution-related logic.\\n     *\\n     * The `_lzEndpoint` parameter is specific to the OFTV2 initialization and is related to LayerZero\\n     * endpoint configurations.\\n     *\\n     * This constructor is critical for setting up the initial state of the contract, including\\n     * roles, token distribution, and other essential configurations.\\n     *\\n     * @param _name The name of the token.\\n     * @param _symbol The symbol of the token.\\n     * @param premintAddresses Array of addresses that will receive the preminted tokens.\\n     * @param premintValues Array of token amounts corresponding to each premint address.\\n     * @param _lzEndpoint Address for the LayerZero endpoint, used in OFTV2 initialization.\\n     * @param _mproMasterDistributor Address of the contract managing token distributions.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address[] memory premintAddresses,\\n        uint256[] memory premintValues,\\n        address _lzEndpoint,\\n        address _mproMasterDistributor,\\n        address _owner\\n    ) OFT(_name, _symbol, _lzEndpoint, _owner) ERC20Permit(_name) {\\n        for (uint256 i = 0; i < premintAddresses.length; i++) {\\n            _mint(premintAddresses[i], premintValues[i]);\\n        }\\n        mproMasterDistributor = IMPROMasterDistributor(_mproMasterDistributor);\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint tokens.\\n     *\\n     * This function is an override of the `_mint` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing flexibility in extending the token minting logic.\\n     *\\n     * The function calls `super._mint` to invoke the minting logic defined in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that the token minting process adheres to the standard\\n     * ERC20 implementation, while also updating any additional state or logic defined in ERC20Votes,\\n     * such as vote tracking.\\n     *\\n     * The overriding of this function may be used to introduce additional logic before or after the\\n     * standard minting process, such as custom events, access controls, or other state updates\\n     * specific to the derived contract's requirements.\\n     *\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to be minted.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to mint new tokens.\\n     *\\n     * This function allows for the external minting of tokens, but restricts access to only those\\n     * accounts that have been granted distributor privileges by the mproRoleManager. The\\n     * `isDistributor` function of the mproRoleManager is used to check if the caller (_msgSender())\\n     * has the necessary role to perform the minting.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the minting process or introduction of additional logic.\\n     *\\n     * If the caller is authorized as a distributor, the function proceeds to call the internal `_mint`\\n     * function, which handles the actual creation and allocation of tokens to the specified account.\\n     * This two-tier structure (external `mint` calling internal `_mint`) allows for separation of\\n     * concerns, where access control is handled externally, while the token creation logic is\\n     * encapsulated within the internal function.\\n     *\\n     * @param account The address to which the minted tokens will be allocated.\\n     * @param amount The amount of tokens to be minted and allocated to the account.\\n     */\\n    function mint(address account, uint256 amount) external virtual {\\n        mproMasterDistributor.mintAllowed(_msgSender());\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens.\\n     *\\n     * This function is an override of the `_burn` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing the flexibility to modify the token burning logic.\\n     *\\n     * The function delegates to `super._burn` to execute the burning logic defined in the parent\\n     * contracts (ERC20 and ERC20Votes). This ensures that the token burning process complies with\\n     * the ERC20 standard, while also accommodating any additional state or logic updates defined in\\n     * ERC20Votes, such as vote tracking adjustments.\\n     *\\n     * Overriding this function allows the introduction of additional functionality specific to the\\n     * contract's requirements, which could include custom events, access controls, or other state\\n     * modifications that need to occur alongside the standard token burning process.\\n     *\\n     * @param account The address from which the tokens will be burned.\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to burn tokens.\\n     *\\n     * This function provides an external interface to burn tokens from a specified account. It is\\n     * accessible externally and allows for tokens to be burned, reducing the total supply in\\n     * circulation. The function does not include specific access control checks, meaning any external\\n     * caller can potentially invoke it, subject to the contract's overall design and security model.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the burning process or the introduction of additional logic, such\\n     * as access control restrictions or pre-burn validations.\\n     *\\n     * The actual burning of tokens is delegated to the internal `_burn` function, which encapsulates\\n     * the logic for removing tokens from an account's balance and updating the total supply. This\\n     * separation of concerns allows the `_burn` function to handle the core logic, while the external\\n     * `burn` function can be adapted or extended in derived contracts.\\n     *\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev Public function to approve another account to spend tokens on behalf of the message sender.\\n     *\\n     * This function overrides the standard `approve` function of the ERC20 token standard. It allows\\n     * a token holder to grant permission to another account (referred to as the spender) to transfer\\n     * up to a specified number of tokens on their behalf.\\n     *\\n     * The function includes an additional security feature using the `mproRoleManager` to check\\n     * whether the approval is allowed. This could be based on additional business logic or\\n     * restrictions defined in the role manager contract.\\n     *\\n     * After the custom check, the function calls the internal `_approve` function of the ERC20\\n     * contract to handle the actual approval mechanism, updating the allowance set for the spender.\\n     *\\n     * @param _spender The address which is being granted permission to spend tokens on behalf of the\\n     *                 message sender.\\n     * @param _value The maximum number of tokens the spender is allowed to transfer.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.approveAllowed(_msgSender(), _spender);\\n        super._approve(_msgSender(), _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens from the message sender's account to another account.\\n     *\\n     * This function overrides the standard `transfer` function of the ERC20 token standard. It\\n     * enables a token holder to transfer tokens to another address. In addition to the standard\\n     * transfer functionality, this implementation includes custom logic for additional checks and\\n     * burning tokens on transfer.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom checks based on the contract's\\n     *   business logic. This might include restrictions on who can send or receive tokens or other\\n     *   specific conditions.\\n     * - Calls the internal `_burnOnTransfer` function to calculate the amount after applying the\\n     *   burn rate, if applicable, based on the contract's burning mechanism.\\n     * - Executes the token transfer through `super._transfer`, using the potentially adjusted amount\\n     *   from `_burnOnTransfer`.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This custom implementation ensures compliance with additional rules and token burn mechanisms\\n     * while maintaining the basic functionality of ERC20 transfers.\\n     *\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.transferAllowed(_msgSender(), _to, _msgSender());\\n        _transfer(_msgSender(), _to, _burnOnTransfer(_msgSender(), _value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens on behalf of another account.\\n     *\\n     * This function overrides the standard `transferFrom` function of the ERC20 token standard.\\n     * It is used to transfer tokens from one account to another, based on a previously set allowance.\\n     * The caller must have been previously authorized by the token holder (_from) to spend up to\\n     * a specified number of tokens on their behalf.\\n     *\\n     * The function includes additional logic as follows:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom validation. This could involve\\n     *   checks based on specific business rules, like validating the roles of the involved parties\\n     *   (_from, _to, and the message sender).\\n     * - Executes the transfer through the internal `_transferFrom` function, which handles the actual\\n     *   token transfer logic. Before the transfer, it applies the `_burnOnTransfer` function to\\n     *   calculate the final amount after considering any burn mechanism that might be in place.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This implementation ensures that any transfers made through this function comply with\\n     * additional constraints or business logic defined in the contract, along with the standard\\n     * ERC20 transferFrom functionality.\\n     *\\n     * @param _from The address of the token holder whose tokens are being transferred.\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        address spender = _msgSender();\\n        mproMasterDistributor.transferAllowed(_from, _to, spender);\\n        // Chack allowance before passing deducted amount by burn rate to _transferFrom\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\n        _transfer(_from, _to, _burnOnTransfer(_from, _amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to handle token burning on transfers.\\n     *\\n     * This function calculates and executes the burning of a portion of tokens during a transfer,\\n     * based on the current burn rate as determined by the `mproMasterDistributor.getBurnAmount`\\n     * function. It is designed to be called as part of the token transfer process to automatically\\n     * apply a burn mechanism on transfers, reducing the amount of tokens ultimately transferred.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `getBurnAmount` from `mproMasterDistributor` to determine the amount of tokens that\\n     *   should be burned from the transfer amount, based on the sender and the total transfer amount.\\n     * - If the calculated burn amount is greater than zero and less than the total transfer amount,\\n     *   it proceeds to burn that portion of tokens from the sender's balance by calling the internal\\n     *   `_burn` function.\\n     * - Returns the remaining amount after the burn has been applied. This remaining amount is what\\n     *   will be actually transferred to the recipient.\\n     *\\n     * Note: It's important to ensure the burn amount is valid (not exceeding the transfer amount) to\\n     * prevent issues with token balances and supply.\\n     *\\n     * @param _sender The address from which the tokens are being transferred (and potentially burned).\\n     * @param _amount The total amount of tokens being transferred before burn is applied.\\n     * @return The amount of tokens to be transferred after applying the burn.\\n     */\\n    function _burnOnTransfer(\\n        address _sender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        uint256 burnAmount = mproMasterDistributor.getBurnAmount(\\n            _sender,\\n            _amount\\n        );\\n        if (burnAmount > 0 && burnAmount < _amount) {\\n            _burn(_sender, burnAmount);\\n        }\\n        return _amount.sub(burnAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_beforeTokenTransfer` hook from the ERC20 standard. It is called\\n     * automatically before every transfer, minting, or burning operation, allowing for additional\\n     * custom logic to be executed.\\n     *\\n     * The function specifically enforces a maximum cap on the total token supply during minting. When\\n     * tokens are being minted (indicated by the `from` address being the zero address), it checks\\n     * whether the minting would cause the total token supply to exceed a predefined maximum cap\\n     * (`_maxCap`). If so, it reverts the transaction to prevent exceeding the cap.\\n     *\\n     * This cap ensures that the total number of tokens in circulation does not surpass a certain\\n     * limit, aligning with the token's economic design and providing a safeguard against\\n     * uncontrolled token issuance.\\n     *\\n     * After performing this check (or in cases of transfer and burning), it calls the base\\n     * implementation of `_beforeTokenTransfer` from the ERC20 contract to handle any additional\\n     * standard logic.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20) {\\n        if (from == address(0)) {\\n            // Chack if minting would exceed the cap based on the total supply and the minted amount\\n            require(\\n                totalSupply() + amount <= _maxCap,\\n                \\\"ERC20Capped: cap exceeded\\\"\\n            );\\n        }\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_afterTokenTransfer` hook from both the ERC20 and ERC20Votes\\n     * contracts. It is called automatically after every transfer, minting, or burning operation.\\n     * The function provides a point to insert custom logic that needs to occur after a token\\n     * transfer, mint, or burn.\\n     *\\n     * In its current implementation, this function does not introduce any additional logic but\\n     * rather delegates to the base implementation of `_afterTokenTransfer` in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that any necessary post-transfer processing defined in\\n     * these base contracts, such as updating vote balances in ERC20Votes, is executed.\\n     *\\n     * This function can be extended in derived contracts to include additional post-transfer\\n     * actions, making it a versatile hook for custom behaviors that should occur after token\\n     * transactions.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20, ERC20Votes) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function maxCap() external pure returns (uint256) {\\n        return _maxCap;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(\\n        address account,\\n        uint256 amount\\n    )",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IMPROMasterDistributor {\\n    function getBurnAmount(\\n        address _from,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isDistributor(address account) external view returns (bool);\\n\\n    function mintAllowed(address minter) external view returns (bool);\\n\\n    function approveAllowed(address, address) external view returns (bool);\\n\\n    function transferAllowed(\\n        address _from,\\n        address _to,\\n        address _msgSender\\n    ) external view returns (bool);\\n}\\n\\ncontract MPRO is OFT, ERC20Votes {\\n    IMPROMasterDistributor private mproMasterDistributor;\\n\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Public constant representing the maximum cap on the token's total supply.\\n     *\\n     * This constant defines the maximum number of tokens that can ever be minted in the lifetime\\n     * of the contract. The cap is set to 500 million tokens, considering the decimal factor of\\n     * the token. Since Solidity does not support floating-point numbers, the token amounts are\\n     * often expressed in the smallest units, similar to how cents are used for dollars in the\\n     * traditional currency system. Here, `10 ** 18` represents 1 token in its smallest unit (like wei\\n     * in Ethereum), making the cap effectively 500 million tokens.\\n     *\\n     * The purpose of setting a maximum cap is to provide assurances about the maximum supply of\\n     * tokens that can exist, which is an important aspect of the token's economic and governance\\n     * model. It ensures transparency and trust in the token's scarcity and value.\\n     */\\n\\n    uint256 private constant _maxCap = 500_000_000 * 10 ** 18;\\n\\n    /**\\n     * @dev Constructor to initialize the contract with specific parameters.\\n     *\\n     * This constructor initializes the contract with a name, symbol, and several key addresses\\n     * relevant to its operation. It also handles the preminting of tokens to a list of addresses.\\n     *\\n     * The constructor performs the following operations:\\n     * - Inherits from OFTV2 and ERC20Permit by passing `_name`, `_symbol`, and other parameters\\n     *   to these base contracts.\\n     * - Loops through the `premintAddresses` array, minting tokens in the amounts specified in\\n     *   `premintValues` to each address. This is used to distribute an initial supply of tokens.\\n     * - Sets the `mproRoleManager` by casting the `_mproRoleManager` address to the\\n     *   IMPRORoleManager interface, which is expected to manage role-based access in the contract.\\n     * - Sets the `mproMasterDistributor` by casting the `_mproMasterDistributor` address to the\\n     *   IMPROMasterDistributor interface, which is expected to handle distribution-related logic.\\n     *\\n     * The `_lzEndpoint` parameter is specific to the OFTV2 initialization and is related to LayerZero\\n     * endpoint configurations.\\n     *\\n     * This constructor is critical for setting up the initial state of the contract, including\\n     * roles, token distribution, and other essential configurations.\\n     *\\n     * @param _name The name of the token.\\n     * @param _symbol The symbol of the token.\\n     * @param premintAddresses Array of addresses that will receive the preminted tokens.\\n     * @param premintValues Array of token amounts corresponding to each premint address.\\n     * @param _lzEndpoint Address for the LayerZero endpoint, used in OFTV2 initialization.\\n     * @param _mproMasterDistributor Address of the contract managing token distributions.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address[] memory premintAddresses,\\n        uint256[] memory premintValues,\\n        address _lzEndpoint,\\n        address _mproMasterDistributor,\\n        address _owner\\n    ) OFT(_name, _symbol, _lzEndpoint, _owner) ERC20Permit(_name) {\\n        for (uint256 i = 0; i < premintAddresses.length; i++) {\\n            _mint(premintAddresses[i], premintValues[i]);\\n        }\\n        mproMasterDistributor = IMPROMasterDistributor(_mproMasterDistributor);\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint tokens.\\n     *\\n     * This function is an override of the `_mint` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing flexibility in extending the token minting logic.\\n     *\\n     * The function calls `super._mint` to invoke the minting logic defined in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that the token minting process adheres to the standard\\n     * ERC20 implementation, while also updating any additional state or logic defined in ERC20Votes,\\n     * such as vote tracking.\\n     *\\n     * The overriding of this function may be used to introduce additional logic before or after the\\n     * standard minting process, such as custom events, access controls, or other state updates\\n     * specific to the derived contract's requirements.\\n     *\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to be minted.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to mint new tokens.\\n     *\\n     * This function allows for the external minting of tokens, but restricts access to only those\\n     * accounts that have been granted distributor privileges by the mproRoleManager. The\\n     * `isDistributor` function of the mproRoleManager is used to check if the caller (_msgSender())\\n     * has the necessary role to perform the minting.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the minting process or introduction of additional logic.\\n     *\\n     * If the caller is authorized as a distributor, the function proceeds to call the internal `_mint`\\n     * function, which handles the actual creation and allocation of tokens to the specified account.\\n     * This two-tier structure (external `mint` calling internal `_mint`) allows for separation of\\n     * concerns, where access control is handled externally, while the token creation logic is\\n     * encapsulated within the internal function.\\n     *\\n     * @param account The address to which the minted tokens will be allocated.\\n     * @param amount The amount of tokens to be minted and allocated to the account.\\n     */\\n    function mint(address account, uint256 amount) external virtual {\\n        mproMasterDistributor.mintAllowed(_msgSender());\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens.\\n     *\\n     * This function is an override of the `_burn` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing the flexibility to modify the token burning logic.\\n     *\\n     * The function delegates to `super._burn` to execute the burning logic defined in the parent\\n     * contracts (ERC20 and ERC20Votes). This ensures that the token burning process complies with\\n     * the ERC20 standard, while also accommodating any additional state or logic updates defined in\\n     * ERC20Votes, such as vote tracking adjustments.\\n     *\\n     * Overriding this function allows the introduction of additional functionality specific to the\\n     * contract's requirements, which could include custom events, access controls, or other state\\n     * modifications that need to occur alongside the standard token burning process.\\n     *\\n     * @param account The address from which the tokens will be burned.\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to burn tokens.\\n     *\\n     * This function provides an external interface to burn tokens from a specified account. It is\\n     * accessible externally and allows for tokens to be burned, reducing the total supply in\\n     * circulation. The function does not include specific access control checks, meaning any external\\n     * caller can potentially invoke it, subject to the contract's overall design and security model.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the burning process or the introduction of additional logic, such\\n     * as access control restrictions or pre-burn validations.\\n     *\\n     * The actual burning of tokens is delegated to the internal `_burn` function, which encapsulates\\n     * the logic for removing tokens from an account's balance and updating the total supply. This\\n     * separation of concerns allows the `_burn` function to handle the core logic, while the external\\n     * `burn` function can be adapted or extended in derived contracts.\\n     *\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev Public function to approve another account to spend tokens on behalf of the message sender.\\n     *\\n     * This function overrides the standard `approve` function of the ERC20 token standard. It allows\\n     * a token holder to grant permission to another account (referred to as the spender) to transfer\\n     * up to a specified number of tokens on their behalf.\\n     *\\n     * The function includes an additional security feature using the `mproRoleManager` to check\\n     * whether the approval is allowed. This could be based on additional business logic or\\n     * restrictions defined in the role manager contract.\\n     *\\n     * After the custom check, the function calls the internal `_approve` function of the ERC20\\n     * contract to handle the actual approval mechanism, updating the allowance set for the spender.\\n     *\\n     * @param _spender The address which is being granted permission to spend tokens on behalf of the\\n     *                 message sender.\\n     * @param _value The maximum number of tokens the spender is allowed to transfer.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.approveAllowed(_msgSender(), _spender);\\n        super._approve(_msgSender(), _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens from the message sender's account to another account.\\n     *\\n     * This function overrides the standard `transfer` function of the ERC20 token standard. It\\n     * enables a token holder to transfer tokens to another address. In addition to the standard\\n     * transfer functionality, this implementation includes custom logic for additional checks and\\n     * burning tokens on transfer.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom checks based on the contract's\\n     *   business logic. This might include restrictions on who can send or receive tokens or other\\n     *   specific conditions.\\n     * - Calls the internal `_burnOnTransfer` function to calculate the amount after applying the\\n     *   burn rate, if applicable, based on the contract's burning mechanism.\\n     * - Executes the token transfer through `super._transfer`, using the potentially adjusted amount\\n     *   from `_burnOnTransfer`.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This custom implementation ensures compliance with additional rules and token burn mechanisms\\n     * while maintaining the basic functionality of ERC20 transfers.\\n     *\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.transferAllowed(_msgSender(), _to, _msgSender());\\n        _transfer(_msgSender(), _to, _burnOnTransfer(_msgSender(), _value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens on behalf of another account.\\n     *\\n     * This function overrides the standard `transferFrom` function of the ERC20 token standard.\\n     * It is used to transfer tokens from one account to another, based on a previously set allowance.\\n     * The caller must have been previously authorized by the token holder (_from) to spend up to\\n     * a specified number of tokens on their behalf.\\n     *\\n     * The function includes additional logic as follows:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom validation. This could involve\\n     *   checks based on specific business rules, like validating the roles of the involved parties\\n     *   (_from, _to, and the message sender).\\n     * - Executes the transfer through the internal `_transferFrom` function, which handles the actual\\n     *   token transfer logic. Before the transfer, it applies the `_burnOnTransfer` function to\\n     *   calculate the final amount after considering any burn mechanism that might be in place.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This implementation ensures that any transfers made through this function comply with\\n     * additional constraints or business logic defined in the contract, along with the standard\\n     * ERC20 transferFrom functionality.\\n     *\\n     * @param _from The address of the token holder whose tokens are being transferred.\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        address spender = _msgSender();\\n        mproMasterDistributor.transferAllowed(_from, _to, spender);\\n        // Chack allowance before passing deducted amount by burn rate to _transferFrom\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\n        _transfer(_from, _to, _burnOnTransfer(_from, _amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to handle token burning on transfers.\\n     *\\n     * This function calculates and executes the burning of a portion of tokens during a transfer,\\n     * based on the current burn rate as determined by the `mproMasterDistributor.getBurnAmount`\\n     * function. It is designed to be called as part of the token transfer process to automatically\\n     * apply a burn mechanism on transfers, reducing the amount of tokens ultimately transferred.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `getBurnAmount` from `mproMasterDistributor` to determine the amount of tokens that\\n     *   should be burned from the transfer amount, based on the sender and the total transfer amount.\\n     * - If the calculated burn amount is greater than zero and less than the total transfer amount,\\n     *   it proceeds to burn that portion of tokens from the sender's balance by calling the internal\\n     *   `_burn` function.\\n     * - Returns the remaining amount after the burn has been applied. This remaining amount is what\\n     *   will be actually transferred to the recipient.\\n     *\\n     * Note: It's important to ensure the burn amount is valid (not exceeding the transfer amount) to\\n     * prevent issues with token balances and supply.\\n     *\\n     * @param _sender The address from which the tokens are being transferred (and potentially burned).\\n     * @param _amount The total amount of tokens being transferred before burn is applied.\\n     * @return The amount of tokens to be transferred after applying the burn.\\n     */\\n    function _burnOnTransfer(\\n        address _sender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        uint256 burnAmount = mproMasterDistributor.getBurnAmount(\\n            _sender,\\n            _amount\\n        );\\n        if (burnAmount > 0 && burnAmount < _amount) {\\n            _burn(_sender, burnAmount);\\n        }\\n        return _amount.sub(burnAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_beforeTokenTransfer` hook from the ERC20 standard. It is called\\n     * automatically before every transfer, minting, or burning operation, allowing for additional\\n     * custom logic to be executed.\\n     *\\n     * The function specifically enforces a maximum cap on the total token supply during minting. When\\n     * tokens are being minted (indicated by the `from` address being the zero address), it checks\\n     * whether the minting would cause the total token supply to exceed a predefined maximum cap\\n     * (`_maxCap`). If so, it reverts the transaction to prevent exceeding the cap.\\n     *\\n     * This cap ensures that the total number of tokens in circulation does not surpass a certain\\n     * limit, aligning with the token's economic design and providing a safeguard against\\n     * uncontrolled token issuance.\\n     *\\n     * After performing this check (or in cases of transfer and burning), it calls the base\\n     * implementation of `_beforeTokenTransfer` from the ERC20 contract to handle any additional\\n     * standard logic.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20) {\\n        if (from == address(0)) {\\n            // Chack if minting would exceed the cap based on the total supply and the minted amount\\n            require(\\n                totalSupply() + amount <= _maxCap,\\n                \\\"ERC20Capped: cap exceeded\\\"\\n            );\\n        }\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_afterTokenTransfer` hook from both the ERC20 and ERC20Votes\\n     * contracts. It is called automatically after every transfer, minting, or burning operation.\\n     * The function provides a point to insert custom logic that needs to occur after a token\\n     * transfer, mint, or burn.\\n     *\\n     * In its current implementation, this function does not introduce any additional logic but\\n     * rather delegates to the base implementation of `_afterTokenTransfer` in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that any necessary post-transfer processing defined in\\n     * these base contracts, such as updating vote balances in ERC20Votes, is executed.\\n     *\\n     * This function can be extended in derived contracts to include additional post-transfer\\n     * actions, making it a versatile hook for custom behaviors that should occur after token\\n     * transactions.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20, ERC20Votes) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function maxCap() external pure returns (uint256) {\\n        return _maxCap;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IMPROMasterDistributor {\\n    function getBurnAmount(\\n        address _from,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isDistributor(address account) external view returns (bool);\\n\\n    function mintAllowed(address minter) external view returns (bool);\\n\\n    function approveAllowed(address, address) external view returns (bool);\\n\\n    function transferAllowed(\\n        address _from,\\n        address _to,\\n        address _msgSender\\n    ) external view returns (bool);\\n}\\n\\ncontract MPRO is OFT, ERC20Votes {\\n    IMPROMasterDistributor private mproMasterDistributor;\\n\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Public constant representing the maximum cap on the token's total supply.\\n     *\\n     * This constant defines the maximum number of tokens that can ever be minted in the lifetime\\n     * of the contract. The cap is set to 500 million tokens, considering the decimal factor of\\n     * the token. Since Solidity does not support floating-point numbers, the token amounts are\\n     * often expressed in the smallest units, similar to how cents are used for dollars in the\\n     * traditional currency system. Here, `10 ** 18` represents 1 token in its smallest unit (like wei\\n     * in Ethereum), making the cap effectively 500 million tokens.\\n     *\\n     * The purpose of setting a maximum cap is to provide assurances about the maximum supply of\\n     * tokens that can exist, which is an important aspect of the token's economic and governance\\n     * model. It ensures transparency and trust in the token's scarcity and value.\\n     */\\n\\n    uint256 private constant _maxCap = 500_000_000 * 10 ** 18;\\n\\n    /**\\n     * @dev Constructor to initialize the contract with specific parameters.\\n     *\\n     * This constructor initializes the contract with a name, symbol, and several key addresses\\n     * relevant to its operation. It also handles the preminting of tokens to a list of addresses.\\n     *\\n     * The constructor performs the following operations:\\n     * - Inherits from OFTV2 and ERC20Permit by passing `_name`, `_symbol`, and other parameters\\n     *   to these base contracts.\\n     * - Loops through the `premintAddresses` array, minting tokens in the amounts specified in\\n     *   `premintValues` to each address. This is used to distribute an initial supply of tokens.\\n     * - Sets the `mproRoleManager` by casting the `_mproRoleManager` address to the\\n     *   IMPRORoleManager interface, which is expected to manage role-based access in the contract.\\n     * - Sets the `mproMasterDistributor` by casting the `_mproMasterDistributor` address to the\\n     *   IMPROMasterDistributor interface, which is expected to handle distribution-related logic.\\n     *\\n     * The `_lzEndpoint` parameter is specific to the OFTV2 initialization and is related to LayerZero\\n     * endpoint configurations.\\n     *\\n     * This constructor is critical for setting up the initial state of the contract, including\\n     * roles, token distribution, and other essential configurations.\\n     *\\n     * @param _name The name of the token.\\n     * @param _symbol The symbol of the token.\\n     * @param premintAddresses Array of addresses that will receive the preminted tokens.\\n     * @param premintValues Array of token amounts corresponding to each premint address.\\n     * @param _lzEndpoint Address for the LayerZero endpoint, used in OFTV2 initialization.\\n     * @param _mproMasterDistributor Address of the contract managing token distributions.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address[] memory premintAddresses,\\n        uint256[] memory premintValues,\\n        address _lzEndpoint,\\n        address _mproMasterDistributor,\\n        address _owner\\n    ) OFT(_name, _symbol, _lzEndpoint, _owner) ERC20Permit(_name) {\\n        for (uint256 i = 0; i < premintAddresses.length; i++) {\\n            _mint(premintAddresses[i], premintValues[i]);\\n        }\\n        mproMasterDistributor = IMPROMasterDistributor(_mproMasterDistributor);\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint tokens.\\n     *\\n     * This function is an override of the `_mint` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing flexibility in extending the token minting logic.\\n     *\\n     * The function calls `super._mint` to invoke the minting logic defined in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that the token minting process adheres to the standard\\n     * ERC20 implementation, while also updating any additional state or logic defined in ERC20Votes,\\n     * such as vote tracking.\\n     *\\n     * The overriding of this function may be used to introduce additional logic before or after the\\n     * standard minting process, such as custom events, access controls, or other state updates\\n     * specific to the derived contract's requirements.\\n     *\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to be minted.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to mint new tokens.\\n     *\\n     * This function allows for the external minting of tokens, but restricts access to only those\\n     * accounts that have been granted distributor privileges by the mproRoleManager. The\\n     * `isDistributor` function of the mproRoleManager is used to check if the caller (_msgSender())\\n     * has the necessary role to perform the minting.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the minting process or introduction of additional logic.\\n     *\\n     * If the caller is authorized as a distributor, the function proceeds to call the internal `_mint`\\n     * function, which handles the actual creation and allocation of tokens to the specified account.\\n     * This two-tier structure (external `mint` calling internal `_mint`) allows for separation of\\n     * concerns, where access control is handled externally, while the token creation logic is\\n     * encapsulated within the internal function.\\n     *\\n     * @param account The address to which the minted tokens will be allocated.\\n     * @param amount The amount of tokens to be minted and allocated to the account.\\n     */\\n    function mint(address account, uint256 amount) external virtual {\\n        mproMasterDistributor.mintAllowed(_msgSender());\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens.\\n     *\\n     * This function is an override of the `_burn` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing the flexibility to modify the token burning logic.\\n     *\\n     * The function delegates to `super._burn` to execute the burning logic defined in the parent\\n     * contracts (ERC20 and ERC20Votes). This ensures that the token burning process complies with\\n     * the ERC20 standard, while also accommodating any additional state or logic updates defined in\\n     * ERC20Votes, such as vote tracking adjustments.\\n     *\\n     * Overriding this function allows the introduction of additional functionality specific to the\\n     * contract's requirements, which could include custom events, access controls, or other state\\n     * modifications that need to occur alongside the standard token burning process.\\n     *\\n     * @param account The address from which the tokens will be burned.\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to burn tokens.\\n     *\\n     * This function provides an external interface to burn tokens from a specified account. It is\\n     * accessible externally and allows for tokens to be burned, reducing the total supply in\\n     * circulation. The function does not include specific access control checks, meaning any external\\n     * caller can potentially invoke it, subject to the contract's overall design and security model.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the burning process or the introduction of additional logic, such\\n     * as access control restrictions or pre-burn validations.\\n     *\\n     * The actual burning of tokens is delegated to the internal `_burn` function, which encapsulates\\n     * the logic for removing tokens from an account's balance and updating the total supply. This\\n     * separation of concerns allows the `_burn` function to handle the core logic, while the external\\n     * `burn` function can be adapted or extended in derived contracts.\\n     *\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev Public function to approve another account to spend tokens on behalf of the message sender.\\n     *\\n     * This function overrides the standard `approve` function of the ERC20 token standard. It allows\\n     * a token holder to grant permission to another account (referred to as the spender) to transfer\\n     * up to a specified number of tokens on their behalf.\\n     *\\n     * The function includes an additional security feature using the `mproRoleManager` to check\\n     * whether the approval is allowed. This could be based on additional business logic or\\n     * restrictions defined in the role manager contract.\\n     *\\n     * After the custom check, the function calls the internal `_approve` function of the ERC20\\n     * contract to handle the actual approval mechanism, updating the allowance set for the spender.\\n     *\\n     * @param _spender The address which is being granted permission to spend tokens on behalf of the\\n     *                 message sender.\\n     * @param _value The maximum number of tokens the spender is allowed to transfer.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.approveAllowed(_msgSender(), _spender);\\n        super._approve(_msgSender(), _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens from the message sender's account to another account.\\n     *\\n     * This function overrides the standard `transfer` function of the ERC20 token standard. It\\n     * enables a token holder to transfer tokens to another address. In addition to the standard\\n     * transfer functionality, this implementation includes custom logic for additional checks and\\n     * burning tokens on transfer.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom checks based on the contract's\\n     *   business logic. This might include restrictions on who can send or receive tokens or other\\n     *   specific conditions.\\n     * - Calls the internal `_burnOnTransfer` function to calculate the amount after applying the\\n     *   burn rate, if applicable, based on the contract's burning mechanism.\\n     * - Executes the token transfer through `super._transfer`, using the potentially adjusted amount\\n     *   from `_burnOnTransfer`.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This custom implementation ensures compliance with additional rules and token burn mechanisms\\n     * while maintaining the basic functionality of ERC20 transfers.\\n     *\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.transferAllowed(_msgSender(), _to, _msgSender());\\n        _transfer(_msgSender(), _to, _burnOnTransfer(_msgSender(), _value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens on behalf of another account.\\n     *\\n     * This function overrides the standard `transferFrom` function of the ERC20 token standard.\\n     * It is used to transfer tokens from one account to another, based on a previously set allowance.\\n     * The caller must have been previously authorized by the token holder (_from) to spend up to\\n     * a specified number of tokens on their behalf.\\n     *\\n     * The function includes additional logic as follows:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom validation. This could involve\\n     *   checks based on specific business rules, like validating the roles of the involved parties\\n     *   (_from, _to, and the message sender).\\n     * - Executes the transfer through the internal `_transferFrom` function, which handles the actual\\n     *   token transfer logic. Before the transfer, it applies the `_burnOnTransfer` function to\\n     *   calculate the final amount after considering any burn mechanism that might be in place.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This implementation ensures that any transfers made through this function comply with\\n     * additional constraints or business logic defined in the contract, along with the standard\\n     * ERC20 transferFrom functionality.\\n     *\\n     * @param _from The address of the token holder whose tokens are being transferred.\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        address spender = _msgSender();\\n        mproMasterDistributor.transferAllowed(_from, _to, spender);\\n        // Chack allowance before passing deducted amount by burn rate to _transferFrom\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\n        _transfer(_from, _to, _burnOnTransfer(_from, _amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to handle token burning on transfers.\\n     *\\n     * This function calculates and executes the burning of a portion of tokens during a transfer,\\n     * based on the current burn rate as determined by the `mproMasterDistributor.getBurnAmount`\\n     * function. It is designed to be called as part of the token transfer process to automatically\\n     * apply a burn mechanism on transfers, reducing the amount of tokens ultimately transferred.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `getBurnAmount` from `mproMasterDistributor` to determine the amount of tokens that\\n     *   should be burned from the transfer amount, based on the sender and the total transfer amount.\\n     * - If the calculated burn amount is greater than zero and less than the total transfer amount,\\n     *   it proceeds to burn that portion of tokens from the sender's balance by calling the internal\\n     *   `_burn` function.\\n     * - Returns the remaining amount after the burn has been applied. This remaining amount is what\\n     *   will be actually transferred to the recipient.\\n     *\\n     * Note: It's important to ensure the burn amount is valid (not exceeding the transfer amount) to\\n     * prevent issues with token balances and supply.\\n     *\\n     * @param _sender The address from which the tokens are being transferred (and potentially burned).\\n     * @param _amount The total amount of tokens being transferred before burn is applied.\\n     * @return The amount of tokens to be transferred after applying the burn.\\n     */\\n    function _burnOnTransfer(\\n        address _sender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        uint256 burnAmount = mproMasterDistributor.getBurnAmount(\\n            _sender,\\n            _amount\\n        );\\n        if (burnAmount > 0 && burnAmount < _amount) {\\n            _burn(_sender, burnAmount);\\n        }\\n        return _amount.sub(burnAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_beforeTokenTransfer` hook from the ERC20 standard. It is called\\n     * automatically before every transfer, minting, or burning operation, allowing for additional\\n     * custom logic to be executed.\\n     *\\n     * The function specifically enforces a maximum cap on the total token supply during minting. When\\n     * tokens are being minted (indicated by the `from` address being the zero address), it checks\\n     * whether the minting would cause the total token supply to exceed a predefined maximum cap\\n     * (`_maxCap`). If so, it reverts the transaction to prevent exceeding the cap.\\n     *\\n     * This cap ensures that the total number of tokens in circulation does not surpass a certain\\n     * limit, aligning with the token's economic design and providing a safeguard against\\n     * uncontrolled token issuance.\\n     *\\n     * After performing this check (or in cases of transfer and burning), it calls the base\\n     * implementation of `_beforeTokenTransfer` from the ERC20 contract to handle any additional\\n     * standard logic.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20) {\\n        if (from == address(0)) {\\n            // Chack if minting would exceed the cap based on the total supply and the minted amount\\n            require(\\n                totalSupply() + amount <= _maxCap,\\n                \\\"ERC20Capped: cap exceeded\\\"\\n            );\\n        }\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_afterTokenTransfer` hook from both the ERC20 and ERC20Votes\\n     * contracts. It is called automatically after every transfer, minting, or burning operation.\\n     * The function provides a point to insert custom logic that needs to occur after a token\\n     * transfer, mint, or burn.\\n     *\\n     * In its current implementation, this function does not introduce any additional logic but\\n     * rather delegates to the base implementation of `_afterTokenTransfer` in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that any necessary post-transfer processing defined in\\n     * these base contracts, such as updating vote balances in ERC20Votes, is executed.\\n     *\\n     * This function can be extended in derived contracts to include additional post-transfer\\n     * actions, making it a versatile hook for custom behaviors that should occur after token\\n     * transactions.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20, ERC20Votes) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function maxCap() external pure returns (uint256) {\\n        return _maxCap;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(account, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/OFT.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface IMPROMasterDistributor {\\n    function getBurnAmount(\\n        address _from,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function isDistributor(address account) external view returns (bool);\\n\\n    function mintAllowed(address minter) external view returns (bool);\\n\\n    function approveAllowed(address, address) external view returns (bool);\\n\\n    function transferAllowed(\\n        address _from,\\n        address _to,\\n        address _msgSender\\n    ) external view returns (bool);\\n}\\n\\ncontract MPRO is OFT, ERC20Votes {\\n    IMPROMasterDistributor private mproMasterDistributor;\\n\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Public constant representing the maximum cap on the token's total supply.\\n     *\\n     * This constant defines the maximum number of tokens that can ever be minted in the lifetime\\n     * of the contract. The cap is set to 500 million tokens, considering the decimal factor of\\n     * the token. Since Solidity does not support floating-point numbers, the token amounts are\\n     * often expressed in the smallest units, similar to how cents are used for dollars in the\\n     * traditional currency system. Here, `10 ** 18` represents 1 token in its smallest unit (like wei\\n     * in Ethereum), making the cap effectively 500 million tokens.\\n     *\\n     * The purpose of setting a maximum cap is to provide assurances about the maximum supply of\\n     * tokens that can exist, which is an important aspect of the token's economic and governance\\n     * model. It ensures transparency and trust in the token's scarcity and value.\\n     */\\n\\n    uint256 private constant _maxCap = 500_000_000 * 10 ** 18;\\n\\n    /**\\n     * @dev Constructor to initialize the contract with specific parameters.\\n     *\\n     * This constructor initializes the contract with a name, symbol, and several key addresses\\n     * relevant to its operation. It also handles the preminting of tokens to a list of addresses.\\n     *\\n     * The constructor performs the following operations:\\n     * - Inherits from OFTV2 and ERC20Permit by passing `_name`, `_symbol`, and other parameters\\n     *   to these base contracts.\\n     * - Loops through the `premintAddresses` array, minting tokens in the amounts specified in\\n     *   `premintValues` to each address. This is used to distribute an initial supply of tokens.\\n     * - Sets the `mproRoleManager` by casting the `_mproRoleManager` address to the\\n     *   IMPRORoleManager interface, which is expected to manage role-based access in the contract.\\n     * - Sets the `mproMasterDistributor` by casting the `_mproMasterDistributor` address to the\\n     *   IMPROMasterDistributor interface, which is expected to handle distribution-related logic.\\n     *\\n     * The `_lzEndpoint` parameter is specific to the OFTV2 initialization and is related to LayerZero\\n     * endpoint configurations.\\n     *\\n     * This constructor is critical for setting up the initial state of the contract, including\\n     * roles, token distribution, and other essential configurations.\\n     *\\n     * @param _name The name of the token.\\n     * @param _symbol The symbol of the token.\\n     * @param premintAddresses Array of addresses that will receive the preminted tokens.\\n     * @param premintValues Array of token amounts corresponding to each premint address.\\n     * @param _lzEndpoint Address for the LayerZero endpoint, used in OFTV2 initialization.\\n     * @param _mproMasterDistributor Address of the contract managing token distributions.\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address[] memory premintAddresses,\\n        uint256[] memory premintValues,\\n        address _lzEndpoint,\\n        address _mproMasterDistributor,\\n        address _owner\\n    ) OFT(_name, _symbol, _lzEndpoint, _owner) ERC20Permit(_name) {\\n        for (uint256 i = 0; i < premintAddresses.length; i++) {\\n            _mint(premintAddresses[i], premintValues[i]);\\n        }\\n        mproMasterDistributor = IMPROMasterDistributor(_mproMasterDistributor);\\n        _transferOwnership(_owner);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint tokens.\\n     *\\n     * This function is an override of the `_mint` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing flexibility in extending the token minting logic.\\n     *\\n     * The function calls `super._mint` to invoke the minting logic defined in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that the token minting process adheres to the standard\\n     * ERC20 implementation, while also updating any additional state or logic defined in ERC20Votes,\\n     * such as vote tracking.\\n     *\\n     * The overriding of this function may be used to introduce additional logic before or after the\\n     * standard minting process, such as custom events, access controls, or other state updates\\n     * specific to the derived contract's requirements.\\n     *\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to be minted.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to mint new tokens.\\n     *\\n     * This function allows for the external minting of tokens, but restricts access to only those\\n     * accounts that have been granted distributor privileges by the mproRoleManager. The\\n     * `isDistributor` function of the mproRoleManager is used to check if the caller (_msgSender())\\n     * has the necessary role to perform the minting.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the minting process or introduction of additional logic.\\n     *\\n     * If the caller is authorized as a distributor, the function proceeds to call the internal `_mint`\\n     * function, which handles the actual creation and allocation of tokens to the specified account.\\n     * This two-tier structure (external `mint` calling internal `_mint`) allows for separation of\\n     * concerns, where access control is handled externally, while the token creation logic is\\n     * encapsulated within the internal function.\\n     *\\n     * @param account The address to which the minted tokens will be allocated.\\n     * @param amount The amount of tokens to be minted and allocated to the account.\\n     */\\n    function mint(address account, uint256 amount) external virtual {\\n        mproMasterDistributor.mintAllowed(_msgSender());\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn tokens.\\n     *\\n     * This function is an override of the `_burn` function in both ERC20 and ERC20Votes contracts.\\n     * It is marked as `internal`, meaning it can only be called from within this contract or its\\n     * derivatives. The `virtual` keyword indicates that this function can be overridden in derived\\n     * contracts, providing the flexibility to modify the token burning logic.\\n     *\\n     * The function delegates to `super._burn` to execute the burning logic defined in the parent\\n     * contracts (ERC20 and ERC20Votes). This ensures that the token burning process complies with\\n     * the ERC20 standard, while also accommodating any additional state or logic updates defined in\\n     * ERC20Votes, such as vote tracking adjustments.\\n     *\\n     * Overriding this function allows the introduction of additional functionality specific to the\\n     * contract's requirements, which could include custom events, access controls, or other state\\n     * modifications that need to occur alongside the standard token burning process.\\n     *\\n     * @param account The address from which the tokens will be burned.\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 amount\\n    ) internal virtual override(ERC20, ERC20Votes) {\\n        super._burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev External function to burn tokens.\\n     *\\n     * This function provides an external interface to burn tokens from a specified account. It is\\n     * accessible externally and allows for tokens to be burned, reducing the total supply in\\n     * circulation. The function does not include specific access control checks, meaning any external\\n     * caller can potentially invoke it, subject to the contract's overall design and security model.\\n     *\\n     * The `virtual` keyword indicates that this function can be overridden in derived contracts,\\n     * allowing for customization of the burning process or the introduction of additional logic, such\\n     * as access control restrictions or pre-burn validations.\\n     *\\n     * The actual burning of tokens is delegated to the internal `_burn` function, which encapsulates\\n     * the logic for removing tokens from an account's balance and updating the total supply. This\\n     * separation of concerns allows the `_burn` function to handle the core logic, while the external\\n     * `burn` function can be adapted or extended in derived contracts.\\n     *\\n     * @param amount The amount of tokens to be burned from the specified account.\\n     */\\n    function burn(uint256 amount) external virtual {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev Public function to approve another account to spend tokens on behalf of the message sender.\\n     *\\n     * This function overrides the standard `approve` function of the ERC20 token standard. It allows\\n     * a token holder to grant permission to another account (referred to as the spender) to transfer\\n     * up to a specified number of tokens on their behalf.\\n     *\\n     * The function includes an additional security feature using the `mproRoleManager` to check\\n     * whether the approval is allowed. This could be based on additional business logic or\\n     * restrictions defined in the role manager contract.\\n     *\\n     * After the custom check, the function calls the internal `_approve` function of the ERC20\\n     * contract to handle the actual approval mechanism, updating the allowance set for the spender.\\n     *\\n     * @param _spender The address which is being granted permission to spend tokens on behalf of the\\n     *                 message sender.\\n     * @param _value The maximum number of tokens the spender is allowed to transfer.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.approveAllowed(_msgSender(), _spender);\\n        super._approve(_msgSender(), _spender, _value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens from the message sender's account to another account.\\n     *\\n     * This function overrides the standard `transfer` function of the ERC20 token standard. It\\n     * enables a token holder to transfer tokens to another address. In addition to the standard\\n     * transfer functionality, this implementation includes custom logic for additional checks and\\n     * burning tokens on transfer.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom checks based on the contract's\\n     *   business logic. This might include restrictions on who can send or receive tokens or other\\n     *   specific conditions.\\n     * - Calls the internal `_burnOnTransfer` function to calculate the amount after applying the\\n     *   burn rate, if applicable, based on the contract's burning mechanism.\\n     * - Executes the token transfer through `super._transfer`, using the potentially adjusted amount\\n     *   from `_burnOnTransfer`.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This custom implementation ensures compliance with additional rules and token burn mechanisms\\n     * while maintaining the basic functionality of ERC20 transfers.\\n     *\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    ) public override returns (bool) {\\n        mproMasterDistributor.transferAllowed(_msgSender(), _to, _msgSender());\\n        _transfer(_msgSender(), _to, _burnOnTransfer(_msgSender(), _value));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Public function to transfer tokens on behalf of another account.\\n     *\\n     * This function overrides the standard `transferFrom` function of the ERC20 token standard.\\n     * It is used to transfer tokens from one account to another, based on a previously set allowance.\\n     * The caller must have been previously authorized by the token holder (_from) to spend up to\\n     * a specified number of tokens on their behalf.\\n     *\\n     * The function includes additional logic as follows:\\n     * - Calls `mproRoleManager.transferAllowed` to perform custom validation. This could involve\\n     *   checks based on specific business rules, like validating the roles of the involved parties\\n     *   (_from, _to, and the message sender).\\n     * - Executes the transfer through the internal `_transferFrom` function, which handles the actual\\n     *   token transfer logic. Before the transfer, it applies the `_burnOnTransfer` function to\\n     *   calculate the final amount after considering any burn mechanism that might be in place.\\n     * - Returns `true` to indicate successful execution of the function.\\n     *\\n     * This implementation ensures that any transfers made through this function comply with\\n     * additional constraints or business logic defined in the contract, along with the standard\\n     * ERC20 transferFrom functionality.\\n     *\\n     * @param _from The address of the token holder whose tokens are being transferred.\\n     * @param _to The address of the recipient to whom the tokens are being transferred.\\n     * @param _amount The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation was successful.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public override returns (bool) {\\n        address spender = _msgSender();\\n        mproMasterDistributor.transferAllowed(_from, _to, spender);\\n        // Chack allowance before passing deducted amount by burn rate to _transferFrom\\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\\n        _transfer(_from, _to, _burnOnTransfer(_from, _amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Internal function to handle token burning on transfers.\\n     *\\n     * This function calculates and executes the burning of a portion of tokens during a transfer,\\n     * based on the current burn rate as determined by the `mproMasterDistributor.getBurnAmount`\\n     * function. It is designed to be called as part of the token transfer process to automatically\\n     * apply a burn mechanism on transfers, reducing the amount of tokens ultimately transferred.\\n     *\\n     * The function performs the following operations:\\n     * - Calls `getBurnAmount` from `mproMasterDistributor` to determine the amount of tokens that\\n     *   should be burned from the transfer amount, based on the sender and the total transfer amount.\\n     * - If the calculated burn amount is greater than zero and less than the total transfer amount,\\n     *   it proceeds to burn that portion of tokens from the sender's balance by calling the internal\\n     *   `_burn` function.\\n     * - Returns the remaining amount after the burn has been applied. This remaining amount is what\\n     *   will be actually transferred to the recipient.\\n     *\\n     * Note: It's important to ensure the burn amount is valid (not exceeding the transfer amount) to\\n     * prevent issues with token balances and supply.\\n     *\\n     * @param _sender The address from which the tokens are being transferred (and potentially burned).\\n     * @param _amount The total amount of tokens being transferred before burn is applied.\\n     * @return The amount of tokens to be transferred after applying the burn.\\n     */\\n    function _burnOnTransfer(\\n        address _sender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        uint256 burnAmount = mproMasterDistributor.getBurnAmount(\\n            _sender,\\n            _amount\\n        );\\n        if (burnAmount > 0 && burnAmount < _amount) {\\n            _burn(_sender, burnAmount);\\n        }\\n        return _amount.sub(burnAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_beforeTokenTransfer` hook from the ERC20 standard. It is called\\n     * automatically before every transfer, minting, or burning operation, allowing for additional\\n     * custom logic to be executed.\\n     *\\n     * The function specifically enforces a maximum cap on the total token supply during minting. When\\n     * tokens are being minted (indicated by the `from` address being the zero address), it checks\\n     * whether the minting would cause the total token supply to exceed a predefined maximum cap\\n     * (`_maxCap`). If so, it reverts the transaction to prevent exceeding the cap.\\n     *\\n     * This cap ensures that the total number of tokens in circulation does not surpass a certain\\n     * limit, aligning with the token's economic design and providing a safeguard against\\n     * uncontrolled token issuance.\\n     *\\n     * After performing this check (or in cases of transfer and burning), it calls the base\\n     * implementation of `_beforeTokenTransfer` from the ERC20 contract to handle any additional\\n     * standard logic.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20) {\\n        if (from == address(0)) {\\n            // Chack if minting would exceed the cap based on the total supply and the minted amount\\n            require(\\n                totalSupply() + amount <= _maxCap,\\n                \\\"ERC20Capped: cap exceeded\\\"\\n            );\\n        }\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function that hooks into the ERC20 token transfer process.\\n     *\\n     * This function overrides the `_afterTokenTransfer` hook from both the ERC20 and ERC20Votes\\n     * contracts. It is called automatically after every transfer, minting, or burning operation.\\n     * The function provides a point to insert custom logic that needs to occur after a token\\n     * transfer, mint, or burn.\\n     *\\n     * In its current implementation, this function does not introduce any additional logic but\\n     * rather delegates to the base implementation of `_afterTokenTransfer` in the parent contracts\\n     * (ERC20 and ERC20Votes). This ensures that any necessary post-transfer processing defined in\\n     * these base contracts, such as updating vote balances in ERC20Votes, is executed.\\n     *\\n     * This function can be extended in derived contracts to include additional post-transfer\\n     * actions, making it a versatile hook for custom behaviors that should occur after token\\n     * transactions.\\n     *\\n     * @param from The address of the sender. A zero address indicates tokens are being minted.\\n     * @param to The address of the receiver. A zero address indicates tokens are being burned.\\n     * @param amount The amount of tokens being transferred, minted, or burned.\\n     */\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override(ERC20, ERC20Votes) {\\n        super._afterTokenTransfer(from, to, amount);\\n    }\\n\\n    function maxCap() external pure returns (uint256) {\\n        return _maxCap;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}