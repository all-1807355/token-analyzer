{
  "total_matches": 2,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer Memes: https://deployyyyer.fun\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\n\\npragma solidity ^0.8.23; \\nimport {IStaking} from \\\"../interfaces/IStaking.sol\\\";\\nimport {StakingPool} from \\\"./StakingPool.sol\\\";\\n\\nlibrary SafeCall {\\n    /**\\n     * @notice Perform a low level call without copying any returndata\\n     *\\n     * @param _target   Address to call\\n     * @param _gas      Amount of gas to pass to the call\\n     * @param _value    Amount of value to pass to the call\\n     * @param _calldata Calldata to pass to the call\\n     */\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    ) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                _value, // ether value\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n        }\\n        return _success;\\n    }\\n}\\n\\n\\ninterface IHelper {\\n\\tfunction isValidRouter(address router) external view returns (bool);\\n}\\n\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed ownerAddress, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\\ninterface ITeamFinanceLocker {\\n    function lockToken(\\n        address _tokenAddress,\\n        address _withdrawalAddress,\\n        uint256 _amount,\\n        uint256 _unlockTime,\\n        bool _mintNFT, \\n        address referrer\\n    ) external payable returns (uint256 _id);\\n}\\n\\n\\n/// @title DeployyyyerToken \\n/// @notice Contains methods related to ERC20\\n/// @dev \\ncontract DeployyyyerToken is IERC20 {\\n    address owner_; \\n    uint256 minLiq;\\n    uint256 lockerId;\\n    address teamFinanceLocker;\\n\\n    mapping(address => bool)  isExTxLimit; //is excluded from transaction limit\\n    mapping(address => bool)  isExWaLimit; //is excluded from wallet limit\\n    mapping (address => uint256)  balances; //ERC20 balance\\n    mapping (address => mapping (address => uint256))  allowances; //ERC20 balance\\n\\n    address payable taxWallet; //tax wallet for the token\\n    address payable deployyyyerCa; //deployyyyer contract address\\n\\n    \\n    // Reduction Rules\\n    uint256  buyCount; \\n\\n    uint256 initTaxType; //0-time,1-buyCount,2-hybrid,3-none\\n    //interval*1, lastIntEnd+(interval*2), lastIntEnd+(interval*3)\\n    uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n    uint256 countInterval; //0-100 \\n\\n    //current taxes\\n    uint256  taxBuy; \\n    uint256  maxBuyTax; //40%\\n    uint256  minBuyTax; //0\\n\\n    uint256  taxSell; \\n    uint256  maxSellTax; //40%\\n    uint256  minSellTax; //0\\n\\n    uint256  tradingOpened;\\n\\n    // Token Information\\n    uint8   decimals_;\\n    uint256   tTotal;\\n    string   name_;\\n    string   symbol_;\\n\\n    // Contract Swap Rules \\n    uint256 lastSwapBlock;\\n    uint256 preventSwap; //50            \\n    uint256  taxSwapThreshold; //0.1%\\n    uint256  maxTaxSwap; //1%\\n    uint256  maxWallet; //1%\\n    uint256  maxTx;\\n\\n    IUniswapV2Router02  uniswapV2Router;\\n    address  uniswapV2Pair;\\n    \\n    bool  tradingOpen; //true if liquidity pool is created\\n    bool  inSwap;\\n    bool  walletLimited;\\n    bool isFreeTier;\\n    bool isBurnt;\\n    bool isRetrieved;\\n    uint256 lockPeriod_;\\n    uint256 stakingShare;\\n    address stakingContract;\\n\\n    uint256 lastSwap;\\n\\n\\n    bool liquidityOpen;\\n    uint256 halfLp;\\n    uint256 lpTax;\\n    event TradingEnabled(address pair, uint256 liq, uint256 lockPeriod, bool isBurnt, address router);\\n\\tevent TaxMade(uint256 amount);\\n    event TaxGiven(uint256 amount);\\n    event StakingMade(uint256 amount);\\n    event ExternalLocked(uint256 id, uint256 lockPeriod);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    event IncreasedLimits(uint256 maxWallet, uint256 maxTx);\\n    event LockUpdated(uint256 ldays);\\n    event LockRetrieved();\\n    event SocialsSet(string telegram, string twitter, string website);\\n    event LpBurnt();\\n    event StakingLaunched(address stakingPool, address owner, uint256 share);\\n    event StakingShareIncreased(uint256 share);\\n    event StakingArgs(IStaking.StakingParams params);\\n\\n    struct InitParams {\\n        address owner;\\n        address taxWallet;\\n        address teamFinanceLocker;\\n        uint256 minLiq; \\n        uint256 supply;\\n        uint256 initTaxType; //0-time,1-buyCount,2-hybrid\\n        uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n        uint256 countInterval; //0-100 \\n        uint256  maxBuyTax; //40%\\n        uint256  minBuyTax; //0\\n        uint256  maxSellTax; //40%\\n        uint256  minSellTax; //0\\n        uint256 lpTax;\\n        uint256 maxWallet;\\n        uint256 maxTx;\\n        uint256 preventSwap;\\n        uint256 maxSwap;\\n        uint256 taxSwapThreshold;\\n        string  name;\\n        string  symbol;\\n        bool isFreeTier;\\n    }\\n\\n\\n    struct LPDetails {\\n        address pair;\\n        uint256 buycount;\\n        uint256 taxBuy;\\n        uint256 taxSell;\\n        uint256 lockDays;\\n        bool isBurnt;\\n        uint256 tradingOpened;\\n        bool walletLimited;\\n        address stakingContract; //address(0) backward comp\\n        uint256 stakingShare; //external lock id here\\n        uint256 maxTx;\\n        uint256 maxWallet;\\n        address router;\\n        address presale; //address(0) backward comp\\n    }\\n\\n    //reentrancy lock\\n    modifier lockTheSwap {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    /// @notice Constructor of Diamond Proxy for a launched token\\n    constructor(InitParams memory params) {\\n        owner_ = params.owner;\\n        emit OwnershipTransferred(address(0), owner_);\\n        teamFinanceLocker = params.teamFinanceLocker;\\n        // adding ERC165 data\\n\\n        deployyyyerCa = payable(msg.sender);\\n \\n        minLiq = params.minLiq;\\n        taxBuy = params.maxBuyTax; //20%\\n        maxBuyTax = params.maxBuyTax;\\n        minBuyTax = params.minBuyTax;\\n\\n        taxSell = params.maxSellTax; //20%\\n        maxSellTax = params.maxSellTax;\\n        minSellTax = params.minSellTax;\\n        lpTax = params.lpTax;\\n        \\n        initTaxType = params.initTaxType;\\n        initInterval = params.initInterval;\\n        countInterval = params.countInterval;\\n\\n        // Reduction Rules\\n        buyCount = 0; \\n        isFreeTier = params.isFreeTier;\\n    \\n\\n        // Token Information\\n        decimals_ = 18;\\n\\n        taxWallet = payable(params.taxWallet);\\n        \\n        name_ = params.name;\\n        symbol_ = params.symbol;\\n        tTotal = params.supply;\\n\\n        // Contract Swap Rules            \\n        taxSwapThreshold = params.taxSwapThreshold; //0.1%\\n        maxTaxSwap = params.maxSwap; //1%\\n        walletLimited = true;\\n        \\n        \\n        maxWallet = tTotal * params.maxWallet / 10000;  //1% (allow 1 - 100)\\n        maxTx = tTotal * params.maxTx / 10000;\\n        if (params.maxWallet == 10000 && params.maxTx == 10000) {\\n            walletLimited = false;\\n        }\\n        emit IncreasedLimits(params.maxWallet, params.maxTx);\\n        balances[address(this)] = tTotal;\\n        emit Transfer(address(0), address(this), tTotal);\\n\\n        preventSwap = params.preventSwap;\\n\\n    } \\n\\n\\n    /// @notice Create liquidity pool and start trading for the token\\n    /// @dev\\n    function startTrading(uint256 lockPeriod, bool shouldBurn, address router) external payable  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!tradingOpen, \\\"1\\\");\\n        require(address(this).balance >= minLiq, \\\"2\\\");\\n        if(!shouldBurn) {\\n            require(lockPeriod >= 14);\\n        } \\n        \\n        tradingOpen = true;\\n\\n        uint256 maxTxTemp = maxTx;\\n        uint256 maxWalletTemp = maxWallet;\\n        bool walletLimitedTemp = walletLimited;\\n        \\n        if(walletLimited == true) {\\n            maxTx = tTotal;\\n            maxWallet = tTotal;\\n            walletLimited = false;\\n        }\\n        \\n\\n        isExTxLimit[address(this)] = true;\\n        isExTxLimit[owner_] = true;\\n        isExTxLimit[address(0x000000000000000000000000000000000000dEaD)] = true;\\n\\n        isExWaLimit[address(this)] = true;\\n        isExWaLimit[owner_] = true;\\n        isExWaLimit[address(0x000000000000000000000000000000000000dEaD)] = true;\\n        \\n        //0x000000000000000000000000000000000000dEaD or address(0)\\n        address liqOwner = address(this);\\n        if(shouldBurn) {\\n            liqOwner = address(0);\\n            isBurnt = true;\\n        } else {\\n            lockPeriod_ = lockPeriod;\\n            isBurnt = false;\\n        }\\n\\n        uint256 liqBalance = balances[address(this)];\\n        tradingOpened = block.timestamp;\\n        \\n        require(IHelper(deployyyyerCa).isValidRouter(router));\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        allowances[address(this)][address(uniswapV2Router)] = tTotal;\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\n        isExWaLimit[address(uniswapV2Pair)] = true;\\n        isExTxLimit[address(uniswapV2Pair)] = true;\\n        isExTxLimit[address(uniswapV2Router)] = true;\\n        isExWaLimit[address(uniswapV2Router)] = true;\\n        \\n        \\n        emit TradingEnabled(uniswapV2Pair, address(this).balance, lockPeriod_, shouldBurn, address(uniswapV2Router));\\n        require(IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max), \\\"3\\\");\\n        \\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),liqBalance,0,0,liqOwner,block.timestamp+60);\\n        liquidityOpen = true;\\n        \\n        if(walletLimitedTemp == true) {\\n            maxTx = maxTxTemp;\\n            maxWallet = maxWalletTemp;\\n            walletLimited = true;\\n        }\\n\\n    }\\n\\n    function lockOnTeamFinance(uint256 lps, bool ref) external payable  {\\n        require(msg.sender ==  owner_ && isBurnt == false && isRetrieved == false && tradingOpen == true && lps >= 3600 * 24 * 14, \\\"o\\\");\\n        //require(isBurnt == false && isRetrieved == false && tradingOpen == true, \\\"lt\\\");\\n        //require(lps >= 3600 * 24 * 14, \\\"ls\\\");\\n        uint256 lpBalance = IERC20(uniswapV2Pair).balanceOf(address(this));\\n        IERC20(uniswapV2Pair).approve(teamFinanceLocker, lpBalance);\\n        lockerId = ITeamFinanceLocker(teamFinanceLocker).lockToken{value: msg.value}(uniswapV2Pair, msg.sender, lpBalance, block.timestamp + lps, false, ref?address(deployyyyerCa):address(0));\\n        isRetrieved = true;\\n        emit ExternalLocked(lockerId, lps);\\n        //emit ExternalLocked(lockPeriodSec);\\n    }\\n\\n    /// @notice Burn the liquidity pool tokens of the token\\n    function burnLP() external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isBurnt && !isRetrieved && tradingOpen, \\\"a\\\"); \\n        isBurnt = true;\\n        emit LpBurnt();\\n        require(IERC20(uniswapV2Pair).transfer(address(0x000000000000000000000000000000000000dEaD), IERC20(   uniswapV2Pair).balanceOf(address(this))), \\\"o2\\\");        \\n    }\\n\\n    /// @notice Get lp lock period remaining\\n    /// @return lpldays lock days remaining \\n    function getLockleft() private view returns (uint256) {\\n        if(!tradingOpen) {\\n            return 0;\\n        }\\n        //time traversed in days\\n        uint256 tt = ((block.timestamp - tradingOpened)/86400);\\n        if (tt > lockPeriod_) {\\n            return 0;\\n        } else {\\n            return lockPeriod_ - tt;\\n        }\\n\\n    }\\n    \\n    /// @notice Extend LP lock\\n    /// @dev should not be already retrieved or burnt\\n    /// @param ldays no of days to extend\\n    function extendLock(uint256 ldays) external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isRetrieved && !isBurnt && tradingOpen, \\\"a\\\");\\n        //expired lock \\n        if((tradingOpened + (lockPeriod_*86400)) < block.timestamp) {\\n            lockPeriod_ = (block.timestamp - tradingOpened)/86400;\\n        }\\n        lockPeriod_ += ldays; \\n        emit LockUpdated(lockPeriod_);\\n        \\n    }\\n    \\n    /// @notice Retrieve LP tokens\\n    /// @dev should not be already retrieved or burnt\\n    function retrieveLock() external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isRetrieved && !isBurnt && tradingOpen, \\\"a\\\");\\n        if((tradingOpened + (lockPeriod_*60*60*24)) < block.timestamp) {\\n            isRetrieved = true;\\n            \\n            uint256 bal = IERC20(uniswapV2Pair).balanceOf(address(this));\\n            emit LockRetrieved();\\n            require(IERC20(uniswapV2Pair).transfer(msg.sender, bal), \\\"b\\\");\\n            \\n        }\\n    }\\n\\n    function increaseLimits(uint256 maxwallet, uint256 maxtx) external {\\n        require(msg.sender ==  owner_ && walletLimited, \\\"o\\\");\\n        //require(walletLimited);\\n        require(tTotal * maxwallet / 10000 >= maxWallet && maxwallet <= 10000, \\\"a\\\");\\n        require(tTotal * maxtx / 10000 >= maxTx && maxtx <= 10000, \\\"b\\\");\\n        maxWallet = tTotal * maxwallet / 10000;   \\n        maxTx = tTotal * maxtx / 10000;\\n        \\n        if (maxwallet == 10000 && maxtx == 10000) {\\n            walletLimited = false;\\n        }\\n\\n        emit IncreasedLimits(maxwallet, maxtx);\\n    }\\n\\n    ///@dev Returns the name of the token.\\n    function name() external view override returns (string memory) {\\n        return name_;\\n    }\\n\\n    ///@dev Returns the symbol of the token, usually a shorter version of name.\\n    function symbol() external view override returns (string memory) {\\n        return symbol_;\\n    }\\n\\n    ///@dev Returns the number of decimals used to get its user representation.\\n    function decimals() external view override returns (uint8) {\\n        return decimals_;\\n    }\\n\\n    ///@dev Returns the value of tokens in existence.\\n    function totalSupply() public view override returns (uint256) {\\n        return tTotal;\\n    }\\n\\n    ///@dev Returns the value of tokens owned by account.\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    ///@dev Moves a amount of tokens from the caller's account to receipient.\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    ///@dev Returns the remaining number of tokens that `spender` will be\\n    // allowed to spend on behalf of `owner` through {transferFrom}. This is\\n    // zero by default\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's token   \\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        require(amount <= allowances[sender][msg.sender], \\\"25\\\");\\n        _approve(sender, msg.sender,allowances[sender][msg.sender] - amount);\\n        _transfer(sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _approve(address _owner, address _spender, uint256 _amount) private {\\n        require(_owner != address(0));\\n        require(_spender != address(0));\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /// @notice sets tax for the trade\\n    /// @dev \\n    function _setTax(bool isBuy) private {\\n        uint256 maxTax;\\n        uint256 minTax;\\n        uint256 tax;\\n        if(isBuy) {\\n            maxTax = maxBuyTax;\\n            minTax = minBuyTax;\\n            tax = taxBuy;\\n        } else {\\n            maxTax = maxSellTax;\\n            minTax = minSellTax;\\n            tax = taxSell;\\n        }\\n\\n        if(tax != minTax) {\\n            if(initTaxType == 0) {\\n                if (block.timestamp >= (tradingOpened + (initInterval))) {\\n                    tax = minTax; \\n                }\\n                else if (block.timestamp >= (tradingOpened + (initInterval/2))) {\\n                    tax = minTax + (maxTax - minTax)/4;\\n                }\\n                else if (block.timestamp >= (tradingOpened + (initInterval/4))) {\\n                    tax = minTax + ((maxTax - minTax)/2);\\n                }\\n                else {       \\n                    tax = maxTax; \\n                }        \\n                  \\n            } else if(initTaxType == 1) {\\n                if (buyCount > (countInterval)) {\\n                    tax = minTax; \\n                } else {       \\n                    tax = maxTax; \\n                } \\n                //this is forced after 2hrs\\n                if(block.timestamp >= (tradingOpened + 7200)) {\\n                    tax = minTax;\\n                }      \\n\\n            } else if(initTaxType == 2){\\n                if (buyCount > (countInterval) || block.timestamp >= (tradingOpened + (initInterval))) {\\n                    tax = minTax; \\n                }\\n                else if (buyCount > (countInterval/2) || block.timestamp >= (tradingOpened + (initInterval/2))) {\\n                    tax = minTax + (maxTax - minTax)/4;\\n                }\\n                else if (buyCount > (countInterval/4) || block.timestamp >= (tradingOpened + (initInterval/4))) {\\n                    tax = minTax + ((maxTax - minTax)/2);\\n                }\\n                else {       \\n                    tax = maxTax; \\n                }        \\n            // } else if(   initTaxType == 3) { //check block number}        \\n                \\n            } else {\\n                tax = minTax; \\n            }\\n\\n            if(isBuy) {\\n                   taxBuy = tax;\\n            } else {\\n                   taxSell = tax;\\n            }\\n        }\\n\\n    }\\n\\n    /// @notice internal method of transfer\\n    /// @dev \\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0) && to != address(0));\\n        //require(to != address(0));\\n        //require(amount > 0); //compliance erc20\\n        require(balances[from] >= amount, \\\"66\\\");\\n        uint256 taxAmount=0;\\n        \\n        if (tradingOpen &&  walletLimited && !isExTxLimit[from] && !isExTxLimit[to])\\n            require(maxTx >= amount, \\\"30\\\");\\n        if (tradingOpen && walletLimited && !isExWaLimit[to])\\n            require((balances[to] + amount) <= maxWallet, \\\"31\\\");\\n         \\n        if (from != owner_ && to != owner_ && liquidityOpen == true) {\\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\\n            \\t//buy from uniswap, only if amount > 0\\n                buyCount++;\\n                _setTax(true);\\n\\n            \\ttaxAmount = amount * taxBuy / 100;\\n                //console.log(\\\"_setTaxDone\\\");\\n                \\n                \\n            }\\n            if(to == uniswapV2Pair && from!= address(this)) {\\n            \\t//sell from uniswap\\n                _setTax(false);\\n                taxAmount = amount * taxSell / 100;    \\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        bool swapped = false;\\n        if (!inSwap && to == uniswapV2Pair && from!= address(this) && contractTokenBalance > 0 && buyCount > preventSwap) {\\n            //we swap only on sell to uniswap pool\\n            if(contractTokenBalance > taxSwapThreshold || ((block.timestamp - tradingOpened) > (86400) && minBuyTax == 0 && minSellTax == 0)) {\\n                if(block.number > lastSwapBlock) {\\n                    if(contractTokenBalance < maxTaxSwap) {\\n                        swapTokensForEth(contractTokenBalance);\\n                    }\\n                    else {\\n                        swapTokensForEth(maxTaxSwap);\\n                    }\\n                    sendETHToFee(address(this).balance);\\n                    swapped = true;\\n                    lastSwapBlock = block.number;\\n                }\\n            }\\n        }\\n\\n        if(taxAmount > 0) {\\n            balances[address(this)] = balances[address(this)] + (taxAmount);\\n            emit Transfer(from, address(this), taxAmount);\\n        }\\n\\n        //from can be taxWallet\\n        balances[from] = balances[from] - amount;\\n        balances[to] = balances[to] + amount - taxAmount;\\n        emit Transfer(from, to, amount - taxAmount);\\n        \\n        if(swapped) {\\n            //everything else is taken care, anything left is for token's tax wallet\\n            //this call needs to be safe from reverts, consuming all gas and return bombs\\n            bool ttax = SafeCall.call(taxWallet, 100000, address(this).balance, \\\"\\\");\\n            if(ttax)\\n                emit TaxMade(address(this).balance);\\n        }\\n\\n    }\\n\\n    /// @notice swaps tokens from tax into eth\\n    /// @dev this is nonrentrant using lockTheSwap\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        if(lpTax > 0) { \\n            halfLp = tokenAmount * lpTax / 200;  \\n            tokenAmount -= halfLp; \\n            lastSwap = tokenAmount;\\n        }\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n           uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /// @notice sends the eth to respective tax wallets \\n    /// @dev \\n    function sendETHToFee(uint256 amount) private {  \\n        uint256 da = 0;\\n        uint256 ethLpShare = 0;\\n        uint256 spshare = 0;\\n        uint256 halfLpTemp;\\n        //s.isFreeTier && \\n        if(isFreeTier == true && ((block.timestamp - tradingOpened) < (86400*90))) {     \\n            da = amount * 10 / 100;\\n            emit TaxGiven(da);\\n            (bool stax, ) =  deployyyyerCa.call{value: da}(\\\"\\\");\\n            require(stax, \\\"99\\\");\\n        }\\n        if(lpTax > 0 && halfLp > 0) {\\n            //newly added liquidity is also locked\\n            //address liqOwner = address(this);\\n            \\n            //we should also be keeping half of lp in tokens, so that u add equal amount of eth and token to lp\\n            ethLpShare = halfLp * amount / lastSwap;\\n            halfLpTemp = halfLp;\\n            halfLp = 0;\\n            lastSwap = 0;\\n            _approve(address(this), address(uniswapV2Router), halfLpTemp);\\n            uniswapV2Router.addLiquidityETH{ value: ethLpShare }(\\n                address(this),\\n                halfLpTemp,\\n                0,\\n                0,\\n                address(this),\\n                block.timestamp + 60\\n            );\\n\\n            \\n        }\\n        if(stakingContract != address(0)) {\\n            spshare = (amount - da - ethLpShare) * stakingShare / 100;\\n            //stakingContract is safe since its our own! \\n            (bool sent, ) = stakingContract.call{value: spshare}(\\\"\\\");\\n            require(sent, \\\"s9\\\");\\n            emit StakingMade(spshare);\\n        }\\n    }\\n\\n    /// @notice recovers eth to tax wallet if any\\n    /// @dev \\n    function recoverEth() private {\\n        //blocked while trading is disabled\\n        if(!inSwap && tradingOpen) { \\n            uint256 contractETHBalance = address(this).balance;\\n            if(contractETHBalance > 0) {\\n                sendETHToFee(contractETHBalance);\\n                (bool ttax, ) = taxWallet.call{value: address(this).balance}(\\\"\\\");\\n                if(ttax)\\n                    emit TaxMade(address(this).balance);\\n            }\\n        }\\n\\n    }\\n\\n    /// @notice rescues any erc20 tokens sent to contract, also recovers eth to tax wallet if any\\n    /// @dev trying to rescue own token or own lp tokens will revert\\n    function rescueERC20(address _address) external {\\n        //block pulling out lp\\n        require(_address != uniswapV2Pair); \\n        require(_address != address(this));\\n        \\n        require(IERC20(_address).transfer(taxWallet, IERC20(_address).balanceOf(address(this))), \\\"r\\\");\\n        recoverEth();\\n    }\\n    \\n    /// @notice Set the address of the new owner of the contract\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        emit OwnershipTransferred(owner_, _newOwner);\\n        //isExTxLimit[owner_] = false;\\n        //isExWaLimit[owner_] = false;\\n        owner_ = _newOwner;\\n        isExTxLimit[owner_] = true;\\n        isExWaLimit[owner_] = true;\\n        \\n    }\\n    \\n    /// @notice Get the address of the owner\\n    /// @return The address of the owner.\\n    function owner() public view returns (address) {\\n        //address _owner = owner_;\\n        return owner_;\\n    }\\n    \\n\\n    /// @notice Get liquidity pool details of the token\\n    /// @return IOwnership.LPDetails\\n    /// @dev \\n    function getLPDetails() external view returns (LPDetails memory) {\\n        return LPDetails(uniswapV2Pair, buyCount, taxBuy, taxSell, getLockleft(), isBurnt, tradingOpened, walletLimited, stakingContract, stakingShare, maxTx, maxWallet, address(uniswapV2Router), address(0));\\n    }\\n\\n\\n    /// @notice increase revenue share to staking pool for the token\\n    /// @dev \\n    function increaseStakingShare(uint256 share) external {\\n        require(msg.sender == owner_ && stakingShare > 0 && share > 0, \\\"o\\\");\\n        //staking pool is live\\n        //require(stakingShare > 0 && share > 0);\\n        stakingShare += share;\\n        require(stakingShare <= 100, \\\"os\\\");\\n        emit StakingShareIncreased(stakingShare);\\n    }\\n\\n    /// @notice launch staking pool for the token\\n    /// @dev \\n    function launchStaking(uint256 share, IStaking.StakingParams memory params) external {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(stakingShare == 0 && share > 0 && share <= 100, \\\"y\\\");\\n        //require(stakingShare == 0, \\\"o12\\\");\\n        require(params.withdrawTimeout >= 2 days && params.withdrawTimeout < 10 days, \\\"z\\\");\\n        stakingShare = share;\\n        params.owner = msg.sender;\\n        \\n        StakingPool stakingPool = new StakingPool(params);\\n        isExTxLimit[address(stakingPool)] = true;\\n        isExWaLimit[address(stakingPool)] = true;\\n        emit StakingLaunched(address(stakingPool), msg.sender, stakingShare);\\n        emit StakingArgs(params);\\n        stakingContract = payable(address(stakingPool));\\n\\n    }\\n    \\n    /// @notice receive eth\\n    receive() external payable {}\\n\\n}\"\n    },\n    \"contracts/utils/StakingPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer Memes: https://deployyyyer.fun\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\n\\npragma solidity ^0.8.23;\\n\\nimport \\\"../interfaces/IStaking.sol\\\";\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\"; \\n\\nstruct AppStorageStaking {\\n    address token;\\n    address owner;\\n    uint256 accRewardsPrecision;\\n    uint256 totalStakedAmount;\\n    uint256 withdrawTimeout;\\n    uint256 unallocatedETH;\\n    uint256 accRewardsPerShare;\\n    uint256 totalETHCollected;\\n    mapping(address => uint256) totalRewards;\\n    mapping(address => uint256) rewardDebt;\\n    mapping(address => uint256) stakedAmount;\\n    mapping(address => uint256) claimedAmount;\\n    mapping(address => uint256) claimableRewards;\\n    mapping(address => uint256) lastUnstakeTime;\\n    mapping(address => uint256) unstakedAmount;\\n\\n}\\n\\ncontract Modifiers {\\n    AppStorageStaking internal s;\\n}\\n/// @title StakingPool\\n/// @dev \\ncontract StakingPool is IStaking, Modifiers {\\n    event Stake(address indexed user, uint256 amount);\\n    event Unstake(address indexed user, uint256 amount);\\n    event Withdraw(address indexed user, uint256 amount);\\n    event ClaimRewards(address indexed user, uint256 amount);\\n    event RewardsReceived(address indexed sender, uint256 amount, uint256 accRewardsPerShare);\\n    //event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor(IStaking.StakingParams memory params) {\\n        require(params.owner != address(0));\\n        s.owner = params.owner;\\n        //init appStorage \\n        s.accRewardsPrecision = 1e18;  \\n        s.token = msg.sender;\\n        s.withdrawTimeout = params.withdrawTimeout;\\n\\n    } \\n\\n    //tracking ownership in subgraph is not needed here, since ownership is unimportant\\n    /// @notice transfer ownership\\n    /// @dev\\n    function transferOwnership(address _newOwner) external override {\\n        require(msg.sender == s.owner);\\n        s.owner =  _newOwner;\\n    }\\n    \\n    /// @notice return owner address\\n    /// @dev\\n    function owner() external override view returns (address owner_) {\\n        owner_ = s.owner;\\n    }\\n\\n    /// @notice rescue erc20 tokens from the contract\\n    /// @dev\\n    function rescueERC20(address _address) external {\\n        //only use of owner: as the rescue wallet! \\n        bool ret = IERC20(_address).transfer(s.owner, IERC20(_address).balanceOf(address(this)));\\n        require(ret, \\\"1\\\");\\n    }\\n\\n    /// @notice stake tokens\\n    /// @dev\\n    function stake(uint256 _amount) external override {\\n        uint256 pending = 0;\\n        require(_amount > 0);\\n        if (s.stakedAmount[msg.sender] > 0) {\\n            pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        }\\n\\n        uint256 unstakedAmount = s.unstakedAmount[msg.sender];\\n        if (unstakedAmount >= _amount) {\\n            s.unstakedAmount[msg.sender] -= _amount;\\n        } else {\\n            uint256 tokensNeeded = _amount - unstakedAmount;\\n            s.unstakedAmount[msg.sender] = 0;\\n            //requires staking contract to be approved by user\\n        \\trequire(IERC20(s.token).transferFrom(msg.sender, address(this), tokensNeeded), \\\"2\\\");\\n        }\\n        \\n        s.stakedAmount[msg.sender] += _amount;\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision; \\n        s.totalStakedAmount += _amount;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n        \\n        emit Stake(msg.sender, _amount);\\n    }\\n\\n    /// @notice unstake staked tokens\\n    /// @dev\\n    function unstake(uint256 _amount) external override {\\n        require(_amount > 0 && s.stakedAmount[msg.sender] >= _amount, \\\"3\\\"); \\n        uint256 pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        s.stakedAmount[msg.sender] -= _amount;\\n        s.lastUnstakeTime[msg.sender] = block.timestamp;\\n        s.unstakedAmount[msg.sender] += _amount;\\n\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        s.totalStakedAmount -= _amount;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n\\n        emit Unstake(msg.sender, _amount);\\n    }\\n\\n    /// @notice restake unstaked tokens\\n    /// @dev\\n    function restake() external override {\\n        uint256 pending = 0;\\n        uint256 amountToRestake = s.unstakedAmount[msg.sender];\\n        require(amountToRestake > 0, \\\"4\\\"); \\n        //allocateRewards();\\n        if (s.stakedAmount[msg.sender] > 0) {\\n            pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        }\\n\\n        s.unstakedAmount[msg.sender] = 0;\\n        s.stakedAmount[msg.sender] += amountToRestake;\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        s.totalStakedAmount += amountToRestake;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n        emit Stake(msg.sender, amountToRestake);\\n    }\\n\\n    /// @notice withdraw unstaked tokens\\n    /// @dev\\n    function withdraw() external override {\\n        uint256 toWithdraw = s.unstakedAmount[msg.sender];\\n        require(toWithdraw > 0, \\\"5\\\");\\n        require(block.timestamp >= s.lastUnstakeTime[msg.sender] + s.withdrawTimeout, \\\"6\\\");\\n        s.unstakedAmount[msg.sender] = 0;\\n        emit Withdraw(msg.sender, toWithdraw);\\n        require(IERC20(s.token).transfer(msg.sender, toWithdraw), \\\"7\\\");\\n        \\n    }\\n\\n    /// @notice claim rewards in eth\\n    /// @dev\\n    function claimRewards() external override {\\n        s.claimableRewards[msg.sender] += ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        uint256 claimable = s.claimableRewards[msg.sender];\\n        require(claimable > 0, \\\"8\\\");\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        uint256 amount = address(this).balance > claimable ? claimable : address(this).balance;\\n        s.claimableRewards[msg.sender] -= amount;\\n        s.claimedAmount[msg.sender] += amount; \\n        emit ClaimRewards(msg.sender, amount);\\n        (bool sent,) = payable(msg.sender).call{value: amount}(\\\"\\\");\\n        require(sent, \\\"9\\\");\\n        \\n    }\\n    \\n    /// @notice get details related to the user\\n    /// @dev\\n    function getUserDetails(address _user) external view returns (IStaking.StakingDetails memory) {\\n    \\tuint256 withdrawable = 0;\\n    \\tuint256 timeToWithdraw = 0;\\n    \\tuint256 claimable = s.claimableRewards[_user] + ((s.stakedAmount[_user] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[_user];\\n    \\t\\n    \\tif (block.timestamp >= s.lastUnstakeTime[_user] + s.withdrawTimeout) {\\n            withdrawable = s.unstakedAmount[_user];\\n        } else {\\n        \\ttimeToWithdraw = block.timestamp - s.lastUnstakeTime[_user] + s.withdrawTimeout;\\n        }\\n\\n        return IStaking.StakingDetails(claimable, withdrawable, s.unstakedAmount[_user], s.totalRewards[_user], timeToWithdraw, s.stakedAmount[_user]);\\n    }\\n\\n    /// @notice receive\\n    /// @dev staing rewards in eth, sets accRewardsPerShare\\n    receive() external payable {\\n        uint256 amount = msg.value;\\n        require(amount > 0, \\\"r\\\");\\n        s.totalRewards[msg.sender] += amount;\\n        s.totalETHCollected += amount;\\n        if (s.totalStakedAmount == 0) {\\n            s.unallocatedETH += amount;\\n        } else {\\n            s.accRewardsPerShare += ((amount+s.unallocatedETH) * s.accRewardsPrecision) / s.totalStakedAmount;  \\n            s.unallocatedETH = 0;         \\n        }\\n        emit RewardsReceived(msg.sender, amount, s.accRewardsPerShare);\\n    }\\n\\n}\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 800\n    },\n    \"evmVersion\": \"paris\",\n    \"outputSelection\": {\n      \"*\": {",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "router_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "modifier locktheswap",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer Memes: https://deployyyyer.fun\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\n\\npragma solidity ^0.8.23; \\nimport {IStaking} from \\\"../interfaces/IStaking.sol\\\";\\nimport {StakingPool} from \\\"./StakingPool.sol\\\";\\n\\nlibrary SafeCall {\\n    /**\\n     * @notice Perform a low level call without copying any returndata\\n     *\\n     * @param _target   Address to call\\n     * @param _gas      Amount of gas to pass to the call\\n     * @param _value    Amount of value to pass to the call\\n     * @param _calldata Calldata to pass to the call\\n     */\\n    function call(\\n        address _target,\\n        uint256 _gas,\\n        uint256 _value,\\n        bytes memory _calldata\\n    ) internal returns (bool) {\\n        bool _success;\\n        assembly {\\n            _success := call(\\n                _gas, // gas\\n                _target, // recipient\\n                _value, // ether value\\n                add(_calldata, 0x20), // inloc\\n                mload(_calldata), // inlen\\n                0, // outloc\\n                0 // outlen\\n            )\\n        }\\n        return _success;\\n    }\\n}\\n\\n\\ninterface IHelper {\\n\\tfunction isValidRouter(address router) external view returns (bool);\\n}\\n\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) external returns (bool success);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed ownerAddress, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\\ninterface ITeamFinanceLocker {\\n    function lockToken(\\n        address _tokenAddress,\\n        address _withdrawalAddress,\\n        uint256 _amount,\\n        uint256 _unlockTime,\\n        bool _mintNFT, \\n        address referrer\\n    ) external payable returns (uint256 _id);\\n}\\n\\n\\n/// @title DeployyyyerToken \\n/// @notice Contains methods related to ERC20\\n/// @dev \\ncontract DeployyyyerToken is IERC20 {\\n    address owner_; \\n    uint256 minLiq;\\n    uint256 lockerId;\\n    address teamFinanceLocker;\\n\\n    mapping(address => bool)  isExTxLimit; //is excluded from transaction limit\\n    mapping(address => bool)  isExWaLimit; //is excluded from wallet limit\\n    mapping (address => uint256)  balances; //ERC20 balance\\n    mapping (address => mapping (address => uint256))  allowances; //ERC20 balance\\n\\n    address payable taxWallet; //tax wallet for the token\\n    address payable deployyyyerCa; //deployyyyer contract address\\n\\n    \\n    // Reduction Rules\\n    uint256  buyCount; \\n\\n    uint256 initTaxType; //0-time,1-buyCount,2-hybrid,3-none\\n    //interval*1, lastIntEnd+(interval*2), lastIntEnd+(interval*3)\\n    uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n    uint256 countInterval; //0-100 \\n\\n    //current taxes\\n    uint256  taxBuy; \\n    uint256  maxBuyTax; //40%\\n    uint256  minBuyTax; //0\\n\\n    uint256  taxSell; \\n    uint256  maxSellTax; //40%\\n    uint256  minSellTax; //0\\n\\n    uint256  tradingOpened;\\n\\n    // Token Information\\n    uint8   decimals_;\\n    uint256   tTotal;\\n    string   name_;\\n    string   symbol_;\\n\\n    // Contract Swap Rules \\n    uint256 lastSwapBlock;\\n    uint256 preventSwap; //50            \\n    uint256  taxSwapThreshold; //0.1%\\n    uint256  maxTaxSwap; //1%\\n    uint256  maxWallet; //1%\\n    uint256  maxTx;\\n\\n    IUniswapV2Router02  uniswapV2Router;\\n    address  uniswapV2Pair;\\n    \\n    bool  tradingOpen; //true if liquidity pool is created\\n    bool  inSwap;\\n    bool  walletLimited;\\n    bool isFreeTier;\\n    bool isBurnt;\\n    bool isRetrieved;\\n    uint256 lockPeriod_;\\n    uint256 stakingShare;\\n    address stakingContract;\\n\\n    uint256 lastSwap;\\n\\n\\n    bool liquidityOpen;\\n    uint256 halfLp;\\n    uint256 lpTax;\\n    event TradingEnabled(address pair, uint256 liq, uint256 lockPeriod, bool isBurnt, address router);\\n\\tevent TaxMade(uint256 amount);\\n    event TaxGiven(uint256 amount);\\n    event StakingMade(uint256 amount);\\n    event ExternalLocked(uint256 id, uint256 lockPeriod);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    \\n    event IncreasedLimits(uint256 maxWallet, uint256 maxTx);\\n    event LockUpdated(uint256 ldays);\\n    event LockRetrieved();\\n    event SocialsSet(string telegram, string twitter, string website);\\n    event LpBurnt();\\n    event StakingLaunched(address stakingPool, address owner, uint256 share);\\n    event StakingShareIncreased(uint256 share);\\n    event StakingArgs(IStaking.StakingParams params);\\n\\n    struct InitParams {\\n        address owner;\\n        address taxWallet;\\n        address teamFinanceLocker;\\n        uint256 minLiq; \\n        uint256 supply;\\n        uint256 initTaxType; //0-time,1-buyCount,2-hybrid\\n        uint256 initInterval; //seconds 0-1 hour(if 1m: 1m, 3m, 6m, 10m)\\n        uint256 countInterval; //0-100 \\n        uint256  maxBuyTax; //40%\\n        uint256  minBuyTax; //0\\n        uint256  maxSellTax; //40%\\n        uint256  minSellTax; //0\\n        uint256 lpTax;\\n        uint256 maxWallet;\\n        uint256 maxTx;\\n        uint256 preventSwap;\\n        uint256 maxSwap;\\n        uint256 taxSwapThreshold;\\n        string  name;\\n        string  symbol;\\n        bool isFreeTier;\\n    }\\n\\n\\n    struct LPDetails {\\n        address pair;\\n        uint256 buycount;\\n        uint256 taxBuy;\\n        uint256 taxSell;\\n        uint256 lockDays;\\n        bool isBurnt;\\n        uint256 tradingOpened;\\n        bool walletLimited;\\n        address stakingContract; //address(0) backward comp\\n        uint256 stakingShare; //external lock id here\\n        uint256 maxTx;\\n        uint256 maxWallet;\\n        address router;\\n        address presale; //address(0) backward comp\\n    }\\n\\n    //reentrancy lock\\n    modifier lockTheSwap {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    /// @notice Constructor of Diamond Proxy for a launched token\\n    constructor(InitParams memory params) {\\n        owner_ = params.owner;\\n        emit OwnershipTransferred(address(0), owner_);\\n        teamFinanceLocker = params.teamFinanceLocker;\\n        // adding ERC165 data\\n\\n        deployyyyerCa = payable(msg.sender);\\n \\n        minLiq = params.minLiq;\\n        taxBuy = params.maxBuyTax; //20%\\n        maxBuyTax = params.maxBuyTax;\\n        minBuyTax = params.minBuyTax;\\n\\n        taxSell = params.maxSellTax; //20%\\n        maxSellTax = params.maxSellTax;\\n        minSellTax = params.minSellTax;\\n        lpTax = params.lpTax;\\n        \\n        initTaxType = params.initTaxType;\\n        initInterval = params.initInterval;\\n        countInterval = params.countInterval;\\n\\n        // Reduction Rules\\n        buyCount = 0; \\n        isFreeTier = params.isFreeTier;\\n    \\n\\n        // Token Information\\n        decimals_ = 18;\\n\\n        taxWallet = payable(params.taxWallet);\\n        \\n        name_ = params.name;\\n        symbol_ = params.symbol;\\n        tTotal = params.supply;\\n\\n        // Contract Swap Rules            \\n        taxSwapThreshold = params.taxSwapThreshold; //0.1%\\n        maxTaxSwap = params.maxSwap; //1%\\n        walletLimited = true;\\n        \\n        \\n        maxWallet = tTotal * params.maxWallet / 10000;  //1% (allow 1 - 100)\\n        maxTx = tTotal * params.maxTx / 10000;\\n        if (params.maxWallet == 10000 && params.maxTx == 10000) {\\n            walletLimited = false;\\n        }\\n        emit IncreasedLimits(params.maxWallet, params.maxTx);\\n        balances[address(this)] = tTotal;\\n        emit Transfer(address(0), address(this), tTotal);\\n\\n        preventSwap = params.preventSwap;\\n\\n    } \\n\\n\\n    /// @notice Create liquidity pool and start trading for the token\\n    /// @dev\\n    function startTrading(uint256 lockPeriod, bool shouldBurn, address router) external payable  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!tradingOpen, \\\"1\\\");\\n        require(address(this).balance >= minLiq, \\\"2\\\");\\n        if(!shouldBurn) {\\n            require(lockPeriod >= 14);\\n        } \\n        \\n        tradingOpen = true;\\n\\n        uint256 maxTxTemp = maxTx;\\n        uint256 maxWalletTemp = maxWallet;\\n        bool walletLimitedTemp = walletLimited;\\n        \\n        if(walletLimited == true) {\\n            maxTx = tTotal;\\n            maxWallet = tTotal;\\n            walletLimited = false;\\n        }\\n        \\n\\n        isExTxLimit[address(this)] = true;\\n        isExTxLimit[owner_] = true;\\n        isExTxLimit[address(0x000000000000000000000000000000000000dEaD)] = true;\\n\\n        isExWaLimit[address(this)] = true;\\n        isExWaLimit[owner_] = true;\\n        isExWaLimit[address(0x000000000000000000000000000000000000dEaD)] = true;\\n        \\n        //0x000000000000000000000000000000000000dEaD or address(0)\\n        address liqOwner = address(this);\\n        if(shouldBurn) {\\n            liqOwner = address(0);\\n            isBurnt = true;\\n        } else {\\n            lockPeriod_ = lockPeriod;\\n            isBurnt = false;\\n        }\\n\\n        uint256 liqBalance = balances[address(this)];\\n        tradingOpened = block.timestamp;\\n        \\n        require(IHelper(deployyyyerCa).isValidRouter(router));\\n        uniswapV2Router = IUniswapV2Router02(router);\\n        allowances[address(this)][address(uniswapV2Router)] = tTotal;\\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\\n        isExWaLimit[address(uniswapV2Pair)] = true;\\n        isExTxLimit[address(uniswapV2Pair)] = true;\\n        isExTxLimit[address(uniswapV2Router)] = true;\\n        isExWaLimit[address(uniswapV2Router)] = true;\\n        \\n        \\n        emit TradingEnabled(uniswapV2Pair, address(this).balance, lockPeriod_, shouldBurn, address(uniswapV2Router));\\n        require(IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max), \\\"3\\\");\\n        \\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),liqBalance,0,0,liqOwner,block.timestamp+60);\\n        liquidityOpen = true;\\n        \\n        if(walletLimitedTemp == true) {\\n            maxTx = maxTxTemp;\\n            maxWallet = maxWalletTemp;\\n            walletLimited = true;\\n        }\\n\\n    }\\n\\n    function lockOnTeamFinance(uint256 lps, bool ref) external payable  {\\n        require(msg.sender ==  owner_ && isBurnt == false && isRetrieved == false && tradingOpen == true && lps >= 3600 * 24 * 14, \\\"o\\\");\\n        //require(isBurnt == false && isRetrieved == false && tradingOpen == true, \\\"lt\\\");\\n        //require(lps >= 3600 * 24 * 14, \\\"ls\\\");\\n        uint256 lpBalance = IERC20(uniswapV2Pair).balanceOf(address(this));\\n        IERC20(uniswapV2Pair).approve(teamFinanceLocker, lpBalance);\\n        lockerId = ITeamFinanceLocker(teamFinanceLocker).lockToken{value: msg.value}(uniswapV2Pair, msg.sender, lpBalance, block.timestamp + lps, false, ref?address(deployyyyerCa):address(0));\\n        isRetrieved = true;\\n        emit ExternalLocked(lockerId, lps);\\n        //emit ExternalLocked(lockPeriodSec);\\n    }\\n\\n    /// @notice Burn the liquidity pool tokens of the token\\n    function burnLP() external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isBurnt && !isRetrieved && tradingOpen, \\\"a\\\"); \\n        isBurnt = true;\\n        emit LpBurnt();\\n        require(IERC20(uniswapV2Pair).transfer(address(0x000000000000000000000000000000000000dEaD), IERC20(   uniswapV2Pair).balanceOf(address(this))), \\\"o2\\\");        \\n    }\\n\\n    /// @notice Get lp lock period remaining\\n    /// @return lpldays lock days remaining \\n    function getLockleft() private view returns (uint256) {\\n        if(!tradingOpen) {\\n            return 0;\\n        }\\n        //time traversed in days\\n        uint256 tt = ((block.timestamp - tradingOpened)/86400);\\n        if (tt > lockPeriod_) {\\n            return 0;\\n        } else {\\n            return lockPeriod_ - tt;\\n        }\\n\\n    }\\n    \\n    /// @notice Extend LP lock\\n    /// @dev should not be already retrieved or burnt\\n    /// @param ldays no of days to extend\\n    function extendLock(uint256 ldays) external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isRetrieved && !isBurnt && tradingOpen, \\\"a\\\");\\n        //expired lock \\n        if((tradingOpened + (lockPeriod_*86400)) < block.timestamp) {\\n            lockPeriod_ = (block.timestamp - tradingOpened)/86400;\\n        }\\n        lockPeriod_ += ldays; \\n        emit LockUpdated(lockPeriod_);\\n        \\n    }\\n    \\n    /// @notice Retrieve LP tokens\\n    /// @dev should not be already retrieved or burnt\\n    function retrieveLock() external  {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(!isRetrieved && !isBurnt && tradingOpen, \\\"a\\\");\\n        if((tradingOpened + (lockPeriod_*60*60*24)) < block.timestamp) {\\n            isRetrieved = true;\\n            \\n            uint256 bal = IERC20(uniswapV2Pair).balanceOf(address(this));\\n            emit LockRetrieved();\\n            require(IERC20(uniswapV2Pair).transfer(msg.sender, bal), \\\"b\\\");\\n            \\n        }\\n    }\\n\\n    function increaseLimits(uint256 maxwallet, uint256 maxtx) external {\\n        require(msg.sender ==  owner_ && walletLimited, \\\"o\\\");\\n        //require(walletLimited);\\n        require(tTotal * maxwallet / 10000 >= maxWallet && maxwallet <= 10000, \\\"a\\\");\\n        require(tTotal * maxtx / 10000 >= maxTx && maxtx <= 10000, \\\"b\\\");\\n        maxWallet = tTotal * maxwallet / 10000;   \\n        maxTx = tTotal * maxtx / 10000;\\n        \\n        if (maxwallet == 10000 && maxtx == 10000) {\\n            walletLimited = false;\\n        }\\n\\n        emit IncreasedLimits(maxwallet, maxtx);\\n    }\\n\\n    ///@dev Returns the name of the token.\\n    function name() external view override returns (string memory) {\\n        return name_;\\n    }\\n\\n    ///@dev Returns the symbol of the token, usually a shorter version of name.\\n    function symbol() external view override returns (string memory) {\\n        return symbol_;\\n    }\\n\\n    ///@dev Returns the number of decimals used to get its user representation.\\n    function decimals() external view override returns (uint8) {\\n        return decimals_;\\n    }\\n\\n    ///@dev Returns the value of tokens in existence.\\n    function totalSupply() public view override returns (uint256) {\\n        return tTotal;\\n    }\\n\\n    ///@dev Returns the value of tokens owned by account.\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return balances[account];\\n    }\\n\\n    ///@dev Moves a amount of tokens from the caller's account to receipient.\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    ///@dev Returns the remaining number of tokens that `spender` will be\\n    // allowed to spend on behalf of `owner` through {transferFrom}. This is\\n    // zero by default\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's token   \\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        require(amount <= allowances[sender][msg.sender], \\\"25\\\");\\n        _approve(sender, msg.sender,allowances[sender][msg.sender] - amount);\\n        _transfer(sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _approve(address _owner, address _spender, uint256 _amount) private {\\n        require(_owner != address(0));\\n        require(_spender != address(0));\\n        allowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /// @notice sets tax for the trade\\n    /// @dev \\n    function _setTax(bool isBuy) private {\\n        uint256 maxTax;\\n        uint256 minTax;\\n        uint256 tax;\\n        if(isBuy) {\\n            maxTax = maxBuyTax;\\n            minTax = minBuyTax;\\n            tax = taxBuy;\\n        } else {\\n            maxTax = maxSellTax;\\n            minTax = minSellTax;\\n            tax = taxSell;\\n        }\\n\\n        if(tax != minTax) {\\n            if(initTaxType == 0) {\\n                if (block.timestamp >= (tradingOpened + (initInterval))) {\\n                    tax = minTax; \\n                }\\n                else if (block.timestamp >= (tradingOpened + (initInterval/2))) {\\n                    tax = minTax + (maxTax - minTax)/4;\\n                }\\n                else if (block.timestamp >= (tradingOpened + (initInterval/4))) {\\n                    tax = minTax + ((maxTax - minTax)/2);\\n                }\\n                else {       \\n                    tax = maxTax; \\n                }        \\n                  \\n            } else if(initTaxType == 1) {\\n                if (buyCount > (countInterval)) {\\n                    tax = minTax; \\n                } else {       \\n                    tax = maxTax; \\n                } \\n                //this is forced after 2hrs\\n                if(block.timestamp >= (tradingOpened + 7200)) {\\n                    tax = minTax;\\n                }      \\n\\n            } else if(initTaxType == 2){\\n                if (buyCount > (countInterval) || block.timestamp >= (tradingOpened + (initInterval))) {\\n                    tax = minTax; \\n                }\\n                else if (buyCount > (countInterval/2) || block.timestamp >= (tradingOpened + (initInterval/2))) {\\n                    tax = minTax + (maxTax - minTax)/4;\\n                }\\n                else if (buyCount > (countInterval/4) || block.timestamp >= (tradingOpened + (initInterval/4))) {\\n                    tax = minTax + ((maxTax - minTax)/2);\\n                }\\n                else {       \\n                    tax = maxTax; \\n                }        \\n            // } else if(   initTaxType == 3) { //check block number}        \\n                \\n            } else {\\n                tax = minTax; \\n            }\\n\\n            if(isBuy) {\\n                   taxBuy = tax;\\n            } else {\\n                   taxSell = tax;\\n            }\\n        }\\n\\n    }\\n\\n    /// @notice internal method of transfer\\n    /// @dev \\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0) && to != address(0));\\n        //require(to != address(0));\\n        //require(amount > 0); //compliance erc20\\n        require(balances[from] >= amount, \\\"66\\\");\\n        uint256 taxAmount=0;\\n        \\n        if (tradingOpen &&  walletLimited && !isExTxLimit[from] && !isExTxLimit[to])\\n            require(maxTx >= amount, \\\"30\\\");\\n        if (tradingOpen && walletLimited && !isExWaLimit[to])\\n            require((balances[to] + amount) <= maxWallet, \\\"31\\\");\\n         \\n        if (from != owner_ && to != owner_ && liquidityOpen == true) {\\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\\n            \\t//buy from uniswap, only if amount > 0\\n                buyCount++;\\n                _setTax(true);\\n\\n            \\ttaxAmount = amount * taxBuy / 100;\\n                //console.log(\\\"_setTaxDone\\\");\\n                \\n                \\n            }\\n            if(to == uniswapV2Pair && from!= address(this)) {\\n            \\t//sell from uniswap\\n                _setTax(false);\\n                taxAmount = amount * taxSell / 100;    \\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        bool swapped = false;\\n        if (!inSwap && to == uniswapV2Pair && from!= address(this) && contractTokenBalance > 0 && buyCount > preventSwap) {\\n            //we swap only on sell to uniswap pool\\n            if(contractTokenBalance > taxSwapThreshold || ((block.timestamp - tradingOpened) > (86400) && minBuyTax == 0 && minSellTax == 0)) {\\n                if(block.number > lastSwapBlock) {\\n                    if(contractTokenBalance < maxTaxSwap) {\\n                        swapTokensForEth(contractTokenBalance);\\n                    }\\n                    else {\\n                        swapTokensForEth(maxTaxSwap);\\n                    }\\n                    sendETHToFee(address(this).balance);\\n                    swapped = true;\\n                    lastSwapBlock = block.number;\\n                }\\n            }\\n        }\\n\\n        if(taxAmount > 0) {\\n            balances[address(this)] = balances[address(this)] + (taxAmount);\\n            emit Transfer(from, address(this), taxAmount);\\n        }\\n\\n        //from can be taxWallet\\n        balances[from] = balances[from] - amount;\\n        balances[to] = balances[to] + amount - taxAmount;\\n        emit Transfer(from, to, amount - taxAmount);\\n        \\n        if(swapped) {\\n            //everything else is taken care, anything left is for token's tax wallet\\n            //this call needs to be safe from reverts, consuming all gas and return bombs\\n            bool ttax = SafeCall.call(taxWallet, 100000, address(this).balance, \\\"\\\");\\n            if(ttax)\\n                emit TaxMade(address(this).balance);\\n        }\\n\\n    }\\n\\n    /// @notice swaps tokens from tax into eth\\n    /// @dev this is nonrentrant using lockTheSwap\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        if(lpTax > 0) { \\n            halfLp = tokenAmount * lpTax / 200;  \\n            tokenAmount -= halfLp; \\n            lastSwap = tokenAmount;\\n        }\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n           uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /// @notice sends the eth to respective tax wallets \\n    /// @dev \\n    function sendETHToFee(uint256 amount) private {  \\n        uint256 da = 0;\\n        uint256 ethLpShare = 0;\\n        uint256 spshare = 0;\\n        uint256 halfLpTemp;\\n        //s.isFreeTier && \\n        if(isFreeTier == true && ((block.timestamp - tradingOpened) < (86400*90))) {     \\n            da = amount * 10 / 100;\\n            emit TaxGiven(da);\\n            (bool stax, ) =  deployyyyerCa.call{value: da}(\\\"\\\");\\n            require(stax, \\\"99\\\");\\n        }\\n        if(lpTax > 0 && halfLp > 0) {\\n            //newly added liquidity is also locked\\n            //address liqOwner = address(this);\\n            \\n            //we should also be keeping half of lp in tokens, so that u add equal amount of eth and token to lp\\n            ethLpShare = halfLp * amount / lastSwap;\\n            halfLpTemp = halfLp;\\n            halfLp = 0;\\n            lastSwap = 0;\\n            _approve(address(this), address(uniswapV2Router), halfLpTemp);\\n            uniswapV2Router.addLiquidityETH{ value: ethLpShare }(\\n                address(this),\\n                halfLpTemp,\\n                0,\\n                0,\\n                address(this),\\n                block.timestamp + 60\\n            );\\n\\n            \\n        }\\n        if(stakingContract != address(0)) {\\n            spshare = (amount - da - ethLpShare) * stakingShare / 100;\\n            //stakingContract is safe since its our own! \\n            (bool sent, ) = stakingContract.call{value: spshare}(\\\"\\\");\\n            require(sent, \\\"s9\\\");\\n            emit StakingMade(spshare);\\n        }\\n    }\\n\\n    /// @notice recovers eth to tax wallet if any\\n    /// @dev \\n    function recoverEth() private {\\n        //blocked while trading is disabled\\n        if(!inSwap && tradingOpen) { \\n            uint256 contractETHBalance = address(this).balance;\\n            if(contractETHBalance > 0) {\\n                sendETHToFee(contractETHBalance);\\n                (bool ttax, ) = taxWallet.call{value: address(this).balance}(\\\"\\\");\\n                if(ttax)\\n                    emit TaxMade(address(this).balance);\\n            }\\n        }\\n\\n    }\\n\\n    /// @notice rescues any erc20 tokens sent to contract, also recovers eth to tax wallet if any\\n    /// @dev trying to rescue own token or own lp tokens will revert\\n    function rescueERC20(address _address) external {\\n        //block pulling out lp\\n        require(_address != uniswapV2Pair); \\n        require(_address != address(this));\\n        \\n        require(IERC20(_address).transfer(taxWallet, IERC20(_address).balanceOf(address(this))), \\\"r\\\");\\n        recoverEth();\\n    }\\n    \\n    /// @notice Set the address of the new owner of the contract\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        emit OwnershipTransferred(owner_, _newOwner);\\n        //isExTxLimit[owner_] = false;\\n        //isExWaLimit[owner_] = false;\\n        owner_ = _newOwner;\\n        isExTxLimit[owner_] = true;\\n        isExWaLimit[owner_] = true;\\n        \\n    }\\n    \\n    /// @notice Get the address of the owner\\n    /// @return The address of the owner.\\n    function owner() public view returns (address) {\\n        //address _owner = owner_;\\n        return owner_;\\n    }\\n    \\n\\n    /// @notice Get liquidity pool details of the token\\n    /// @return IOwnership.LPDetails\\n    /// @dev \\n    function getLPDetails() external view returns (LPDetails memory) {\\n        return LPDetails(uniswapV2Pair, buyCount, taxBuy, taxSell, getLockleft(), isBurnt, tradingOpened, walletLimited, stakingContract, stakingShare, maxTx, maxWallet, address(uniswapV2Router), address(0));\\n    }\\n\\n\\n    /// @notice increase revenue share to staking pool for the token\\n    /// @dev \\n    function increaseStakingShare(uint256 share) external {\\n        require(msg.sender == owner_ && stakingShare > 0 && share > 0, \\\"o\\\");\\n        //staking pool is live\\n        //require(stakingShare > 0 && share > 0);\\n        stakingShare += share;\\n        require(stakingShare <= 100, \\\"os\\\");\\n        emit StakingShareIncreased(stakingShare);\\n    }\\n\\n    /// @notice launch staking pool for the token\\n    /// @dev \\n    function launchStaking(uint256 share, IStaking.StakingParams memory params) external {\\n        require(msg.sender == owner_, \\\"o\\\");\\n        require(stakingShare == 0 && share > 0 && share <= 100, \\\"y\\\");\\n        //require(stakingShare == 0, \\\"o12\\\");\\n        require(params.withdrawTimeout >= 2 days && params.withdrawTimeout < 10 days, \\\"z\\\");\\n        stakingShare = share;\\n        params.owner = msg.sender;\\n        \\n        StakingPool stakingPool = new StakingPool(params);\\n        isExTxLimit[address(stakingPool)] = true;\\n        isExWaLimit[address(stakingPool)] = true;\\n        emit StakingLaunched(address(stakingPool), msg.sender, stakingShare);\\n        emit StakingArgs(params);\\n        stakingContract = payable(address(stakingPool));\\n\\n    }\\n    \\n    /// @notice receive eth\\n    receive() external payable {}\\n\\n}\"\n    },\n    \"contracts/utils/StakingPool.sol\": {\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*********************************************************************************************\\\\\\n* Deployyyyer Memes: https://deployyyyer.fun\\n* Deployyyyer: https://deployyyyer.io\\n* Twitter: https://x.com/deployyyyer\\n* Telegram: https://t.me/Deployyyyer\\n/*********************************************************************************************/\\n\\npragma solidity ^0.8.23;\\n\\nimport \\\"../interfaces/IStaking.sol\\\";\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\"; \\n\\nstruct AppStorageStaking {\\n    address token;\\n    address owner;\\n    uint256 accRewardsPrecision;\\n    uint256 totalStakedAmount;\\n    uint256 withdrawTimeout;\\n    uint256 unallocatedETH;\\n    uint256 accRewardsPerShare;\\n    uint256 totalETHCollected;\\n    mapping(address => uint256) totalRewards;\\n    mapping(address => uint256) rewardDebt;\\n    mapping(address => uint256) stakedAmount;\\n    mapping(address => uint256) claimedAmount;\\n    mapping(address => uint256) claimableRewards;\\n    mapping(address => uint256) lastUnstakeTime;\\n    mapping(address => uint256) unstakedAmount;\\n\\n}\\n\\ncontract Modifiers {\\n    AppStorageStaking internal s;\\n}\\n/// @title StakingPool\\n/// @dev \\ncontract StakingPool is IStaking, Modifiers {\\n    event Stake(address indexed user, uint256 amount);\\n    event Unstake(address indexed user, uint256 amount);\\n    event Withdraw(address indexed user, uint256 amount);\\n    event ClaimRewards(address indexed user, uint256 amount);\\n    event RewardsReceived(address indexed sender, uint256 amount, uint256 accRewardsPerShare);\\n    //event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor(IStaking.StakingParams memory params) {\\n        require(params.owner != address(0));\\n        s.owner = params.owner;\\n        //init appStorage \\n        s.accRewardsPrecision = 1e18;  \\n        s.token = msg.sender;\\n        s.withdrawTimeout = params.withdrawTimeout;\\n\\n    } \\n\\n    //tracking ownership in subgraph is not needed here, since ownership is unimportant\\n    /// @notice transfer ownership\\n    /// @dev\\n    function transferOwnership(address _newOwner) external override {\\n        require(msg.sender == s.owner);\\n        s.owner =  _newOwner;\\n    }\\n    \\n    /// @notice return owner address\\n    /// @dev\\n    function owner() external override view returns (address owner_) {\\n        owner_ = s.owner;\\n    }\\n\\n    /// @notice rescue erc20 tokens from the contract\\n    /// @dev\\n    function rescueERC20(address _address) external {\\n        //only use of owner: as the rescue wallet! \\n        bool ret = IERC20(_address).transfer(s.owner, IERC20(_address).balanceOf(address(this)));\\n        require(ret, \\\"1\\\");\\n    }\\n\\n    /// @notice stake tokens\\n    /// @dev\\n    function stake(uint256 _amount) external override {\\n        uint256 pending = 0;\\n        require(_amount > 0);\\n        if (s.stakedAmount[msg.sender] > 0) {\\n            pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        }\\n\\n        uint256 unstakedAmount = s.unstakedAmount[msg.sender];\\n        if (unstakedAmount >= _amount) {\\n            s.unstakedAmount[msg.sender] -= _amount;\\n        } else {\\n            uint256 tokensNeeded = _amount - unstakedAmount;\\n            s.unstakedAmount[msg.sender] = 0;\\n            //requires staking contract to be approved by user\\n        \\trequire(IERC20(s.token).transferFrom(msg.sender, address(this), tokensNeeded), \\\"2\\\");\\n        }\\n        \\n        s.stakedAmount[msg.sender] += _amount;\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision; \\n        s.totalStakedAmount += _amount;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n        \\n        emit Stake(msg.sender, _amount);\\n    }\\n\\n    /// @notice unstake staked tokens\\n    /// @dev\\n    function unstake(uint256 _amount) external override {\\n        require(_amount > 0 && s.stakedAmount[msg.sender] >= _amount, \\\"3\\\"); \\n        uint256 pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        s.stakedAmount[msg.sender] -= _amount;\\n        s.lastUnstakeTime[msg.sender] = block.timestamp;\\n        s.unstakedAmount[msg.sender] += _amount;\\n\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        s.totalStakedAmount -= _amount;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n\\n        emit Unstake(msg.sender, _amount);\\n    }\\n\\n    /// @notice restake unstaked tokens\\n    /// @dev\\n    function restake() external override {\\n        uint256 pending = 0;\\n        uint256 amountToRestake = s.unstakedAmount[msg.sender];\\n        require(amountToRestake > 0, \\\"4\\\"); \\n        //allocateRewards();\\n        if (s.stakedAmount[msg.sender] > 0) {\\n            pending = ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        }\\n\\n        s.unstakedAmount[msg.sender] = 0;\\n        s.stakedAmount[msg.sender] += amountToRestake;\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        s.totalStakedAmount += amountToRestake;\\n\\n        if(pending > 0) {\\n            s.claimableRewards[msg.sender] += pending;\\n        }\\n        emit Stake(msg.sender, amountToRestake);\\n    }\\n\\n    /// @notice withdraw unstaked tokens\\n    /// @dev\\n    function withdraw() external override {\\n        uint256 toWithdraw = s.unstakedAmount[msg.sender];\\n        require(toWithdraw > 0, \\\"5\\\");\\n        require(block.timestamp >= s.lastUnstakeTime[msg.sender] + s.withdrawTimeout, \\\"6\\\");\\n        s.unstakedAmount[msg.sender] = 0;\\n        emit Withdraw(msg.sender, toWithdraw);\\n        require(IERC20(s.token).transfer(msg.sender, toWithdraw), \\\"7\\\");\\n        \\n    }\\n\\n    /// @notice claim rewards in eth\\n    /// @dev\\n    function claimRewards() external override {\\n        s.claimableRewards[msg.sender] += ((s.stakedAmount[msg.sender] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[msg.sender];\\n        uint256 claimable = s.claimableRewards[msg.sender];\\n        require(claimable > 0, \\\"8\\\");\\n        s.rewardDebt[msg.sender] = s.stakedAmount[msg.sender] * s.accRewardsPerShare / s.accRewardsPrecision;\\n        uint256 amount = address(this).balance > claimable ? claimable : address(this).balance;\\n        s.claimableRewards[msg.sender] -= amount;\\n        s.claimedAmount[msg.sender] += amount; \\n        emit ClaimRewards(msg.sender, amount);\\n        (bool sent,) = payable(msg.sender).call{value: amount}(\\\"\\\");\\n        require(sent, \\\"9\\\");\\n        \\n    }\\n    \\n    /// @notice get details related to the user\\n    /// @dev\\n    function getUserDetails(address _user) external view returns (IStaking.StakingDetails memory) {\\n    \\tuint256 withdrawable = 0;\\n    \\tuint256 timeToWithdraw = 0;\\n    \\tuint256 claimable = s.claimableRewards[_user] + ((s.stakedAmount[_user] * s.accRewardsPerShare) / s.accRewardsPrecision) - s.rewardDebt[_user];\\n    \\t\\n    \\tif (block.timestamp >= s.lastUnstakeTime[_user] + s.withdrawTimeout) {\\n            withdrawable = s.unstakedAmount[_user];\\n        } else {\\n        \\ttimeToWithdraw = block.timestamp - s.lastUnstakeTime[_user] + s.withdrawTimeout;\\n        }\\n\\n        return IStaking.StakingDetails(claimable, withdrawable, s.unstakedAmount[_user], s.totalRewards[_user], timeToWithdraw, s.stakedAmount[_user]);\\n    }\\n\\n    /// @notice receive\\n    /// @dev staing rewards in eth, sets accRewardsPerShare\\n    receive() external payable {\\n        uint256 amount = msg.value;\\n        require(amount > 0, \\\"r\\\");\\n        s.totalRewards[msg.sender] += amount;\\n        s.totalETHCollected += amount;\\n        if (s.totalStakedAmount == 0) {\\n            s.unallocatedETH += amount;\\n        } else {\\n            s.accRewardsPerShare += ((amount+s.unallocatedETH) * s.accRewardsPrecision) / s.totalStakedAmount;  \\n            s.unallocatedETH = 0;         \\n        }\\n        emit RewardsReceived(msg.sender, amount, s.accRewardsPerShare);\\n    }\\n\\n}\"\n    }\n  },\n  \"settings\": {\n    \"optimizer\": {\n      \"enabled\": true,\n      \"runs\": 800\n    },\n    \"evmVersion\": \"paris\",\n    \"outputSelection\": {\n      \"*\": {",
          "pattern": "modifier\\s+lockTheSwap"
        }
      ]
    }
  }
}