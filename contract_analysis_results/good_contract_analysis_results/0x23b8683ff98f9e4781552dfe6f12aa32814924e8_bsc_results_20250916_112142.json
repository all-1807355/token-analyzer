{
  "total_matches": 7,
  "patterns_found": {
    "minting_mechanics": {
      "count": 7,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumLiquidityPool} from './interfaces/ILiquidityPool.sol';\\nimport {\\n  ISynthereumLiquidityPoolStorage\\n} from './interfaces/ILiquidityPoolStorage.sol';\\nimport {\\n  ISynthereumLiquidityPoolGeneral\\n} from './interfaces/ILiquidityPoolGeneral.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\nimport {SynthereumLiquidityPoolLib} from './LiquidityPoolLib.sol';\\nimport {\\n  ReentrancyGuard\\n} from '../../../@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport {ERC2771Context} from '../../common//ERC2771Context.sol';\\nimport {\\n  AccessControlEnumerable,\\n  Context\\n} from '../../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title Token Issuer Contract\\n * @notice Collects collateral and issues synthetic assets\\n */\\ncontract SynthereumLiquidityPool is\\n  ISynthereumLiquidityPoolStorage,\\n  ISynthereumLiquidityPool,\\n  AccessControlEnumerable,\\n  ERC2771Context,\\n  ReentrancyGuard\\n{\\n  using SynthereumLiquidityPoolLib for Storage;\\n  using SynthereumLiquidityPoolLib for Liquidation;\\n\\n  struct ConstructorParams {\\n    // Synthereum finder\\n    ISynthereumFinder finder;\\n    // Synthereum pool version\\n    uint8 version;\\n    // ERC20 collateral token\\n    IStandardERC20 collateralToken;\\n    // ERC20 synthetic token\\n    IMintableBurnableERC20 syntheticToken;\\n    // The addresses of admin, maintainer, liquidity provider\\n    Roles roles;\\n    // Overcollateralization percentage\\n    uint256 overCollateralization;\\n    // The feeData structure\\n    FeeData feeData;\\n    // Identifier of price to be used in the price feed\\n    bytes32 priceIdentifier;\\n    // Percentage of overcollateralization to which a liquidation can triggered\\n    uint256 collateralRequirement;\\n    // Percentage of reward for correct liquidation by a liquidator\\n    uint256 liquidationReward;\\n  }\\n\\n  //----------------------------------------\\n  // Constants\\n  //----------------------------------------\\n\\n  string public constant override typology = 'POOL';\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  bytes32 public constant LIQUIDITY_PROVIDER_ROLE =\\n    keccak256('Liquidity Provider');\\n\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  Storage private poolStorage;\\n\\n  LPPosition private lpPosition;\\n\\n  Liquidation private liquidationData;\\n\\n  FeeStatus private feeStatus;\\n\\n  Shutdown private emergencyShutdownData;\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event Mint(\\n    address indexed account,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event WithdrawLiquidity(\\n    address indexed lp,\\n    uint256 liquidityWithdrawn,\\n    uint256 remainingLiquidity\\n  );\\n\\n  event IncreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralAdded,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event DecreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralRemoved,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event ClaimFee(\\n    address indexed claimer,\\n    uint256 feeAmount,\\n    uint256 totalRemainingFees\\n  );\\n\\n  event Liquidate(\\n    address indexed liquidator,\\n    uint256 tokensLiquidated,\\n    uint256 price,\\n    uint256 collateralExpected,\\n    uint256 collateralReceived,\\n    uint256 rewardReceived\\n  );\\n\\n  event EmergencyShutdown(\\n    uint256 timestamp,\\n    uint256 price,\\n    uint256 finalCollateral\\n  );\\n\\n  event Settle(\\n    address indexed account,\\n    uint256 numTokensSettled,\\n    uint256 collateralExpected,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event SetOverCollateralization(uint256 overCollateralization);\\n\\n  event SetLiquidationReward(uint256 liquidationReward);\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, _msgSender()),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyLiquidityProvider() {\\n    require(\\n      hasRole(LIQUIDITY_PROVIDER_ROLE, _msgSender()),\\n      'Sender must be the liquidity provider'\\n    );\\n    _;\\n  }\\n\\n  modifier notEmergencyShutdown() {\\n    require(emergencyShutdownData.timestamp == 0, 'Pool emergency shutdown');\\n    _;\\n  }\\n\\n  modifier isEmergencyShutdown() {\\n    require(\\n      emergencyShutdownData.timestamp != 0,\\n      'Pool not emergency shutdown'\\n    );\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructor of liquidity pool\\n\\n   */\\n  constructor(ConstructorParams memory params) nonReentrant {\\n    poolStorage.initialize(\\n      liquidationData,\\n      params.finder,\\n      params.version,\\n      params.collateralToken,\\n      params.syntheticToken,\\n      FixedPoint.Unsigned(params.overCollateralization),\\n      params.priceIdentifier,\\n      FixedPoint.Unsigned(params.collateralRequirement),\\n      FixedPoint.Unsigned(params.liquidationReward)\\n    );\\n    poolStorage.setFeePercentage(params.feeData.feePercentage);\\n    poolStorage.setFeeRecipients(\\n      params.feeData.feeRecipients,\\n      params.feeData.feeProportions\\n    );\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(LIQUIDITY_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, params.roles.admin);\\n    _setupRole(MAINTAINER_ROLE, params.roles.maintainer);\\n    _setupRole(LIQUIDITY_PROVIDER_ROLE, params.roles.liquidityProvider);\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(MintParams calldata mintParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 syntheticTokensMinted, uint256 feePaid)\\n  {\\n    (syntheticTokensMinted, feePaid) = poolStorage.mint(\\n      lpPosition,\\n      feeStatus,\\n      mintParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(RedeemParams calldata redeemParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 collateralRedeemed, uint256 feePaid)\\n  {\\n    (collateralRedeemed, feePaid) = poolStorage.redeem(\\n      lpPosition,\\n      feeStatus,\\n      redeemParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\\n   * @return destNumTokensMinted Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function exchange(ExchangeParams calldata exchangeParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 destNumTokensMinted, uint256 feePaid)\\n  {\\n    (destNumTokensMinted, feePaid) = poolStorage.exchange(\\n      lpPosition,\\n      feeStatus,\\n      exchangeParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Called by a source Pool's `exchange` function to mint destination tokens\\n   * @notice This functon can be called only by a pool registered in the PoolRegister contract\\n   * @param collateralAmount The amount of collateral to use from the source Pool\\n   * @param numTokens The number of new tokens to mint\\n   * @param recipient Recipient to which send synthetic token minted\\n   */\\n  function exchangeMint(\\n    uint256 collateralAmount,\\n    uint256 numTokens,\\n    address recipient\\n  ) external override notEmergencyShutdown nonReentrant {\\n    poolStorage.exchangeMint(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralAmount),\\n      FixedPoint.Unsigned(numTokens),\\n      recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function withdrawLiquidity(uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 remainingLiquidity)\\n  {\\n    remainingLiquidity = poolStorage.withdrawLiquidity(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralAmount),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Increase collaterallization of Lp position\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\\n   * @param collateralToIncrease Collateral to be added to the position\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function increaseCollateral(\\n    uint256 collateralToTransfer,\\n    uint256 collateralToIncrease\\n  )\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n    returns (uint256 newTotalCollateral)\\n  {\\n    newTotalCollateral = poolStorage.increaseCollateral(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralToTransfer),\\n      FixedPoint.Unsigned(collateralToIncrease),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Decrease collaterallization of Lp position\\n   * @notice Check that final poosition is not undercollateralized\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToDecrease Collateral to decreased from the position\\n   * @param collateralToWithdraw Collateral to be transferred to the LP\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function decreaseCollateral(\\n    uint256 collateralToDecrease,\\n    uint256 collateralToWithdraw\\n  )\\n    external\\n    override\\n    onlyLiquidityProvider\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 newTotalCollateral)\\n  {\\n    newTotalCollateral = poolStorage.decreaseCollateral(\\n      lpPosition,\\n      liquidationData,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralToDecrease),\\n      FixedPoint.Unsigned(collateralToWithdraw),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw fees gained by the sender\\n   * @return feeClaimed Amount of fee claimed\\n   */\\n  function claimFee()\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 feeClaimed)\\n  {\\n    feeClaimed = poolStorage.claimFee(feeStatus, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\\n   */\\n  function liquidate(uint256 numSynthTokens)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (\\n      uint256 synthTokensLiquidated,\\n      uint256 collateralReceived,\\n      uint256 rewardAmount\\n    )\\n  {\\n    (synthTokensLiquidated, collateralReceived, rewardAmount) = poolStorage\\n      .liquidate(\\n      lpPosition,\\n      liquidationData,\\n      feeStatus,\\n      FixedPoint.Unsigned(numSynthTokens),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Shutdown the pool in case of emergency\\n   * @notice Only Synthereum manager contract can call this function\\n   * @return timestamp Timestamp of emergency shutdown transaction\\n   * @return price Price of the pair at the moment of shutdown execution\\n   */\\n  function emergencyShutdown()\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 timestamp, uint256 price)\\n  {\\n    (timestamp, price) = poolStorage.emergencyShutdown(\\n      lpPosition,\\n      feeStatus,\\n      emergencyShutdownData\\n    );\\n  }\\n\\n  /**\\n   * @notice Redeem tokens after emergency shutdown\\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\\n   */\\n  function settleEmergencyShutdown()\\n    external\\n    override\\n    isEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 synthTokensSettled, uint256 collateralSettled)\\n  {\\n    address msgSender = _msgSender();\\n    bool isLiquidityProvider = hasRole(LIQUIDITY_PROVIDER_ROLE, msgSender);\\n    (synthTokensSettled, collateralSettled) = poolStorage\\n      .settleEmergencyShutdown(\\n      lpPosition,\\n      feeStatus,\\n      emergencyShutdownData,\\n      isLiquidityProvider,\\n      msgSender\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage, recipients and recipient proportions\\n   * @notice Only the maintainer can call this function\\n   * @param _feeData Fee info (percentage + recipients + weigths)\\n   */\\n  function setFee(ISynthereumLiquidityPoolStorage.FeeData calldata _feeData)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setFeePercentage(_feeData.feePercentage);\\n    poolStorage.setFeeRecipients(\\n      _feeData.feeRecipients,\\n      _feeData.feeProportions\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _feePercentage The new fee percentage\\n   */\\n  function setFeePercentage(uint256 _feePercentage)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setFeePercentage(FixedPoint.Unsigned(_feePercentage));\\n  }\\n\\n  /**\\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\\n   * @notice Only the maintainer can call this function\\n   * @param feeRecipients An array of the addresses of recipients that will receive generated fees\\n   * @param feeProportions An array of the proportions of fees generated each recipient will receive\\n   */\\n  function setFeeRecipients(\\n    address[] calldata feeRecipients,\\n    uint32[] calldata feeProportions\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.setFeeRecipients(feeRecipients, feeProportions);\\n  }\\n\\n  /**\\n   * @notice Update the overcollateralization percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _overCollateralization Overcollateralization percentage\\n   */\\n  function setOverCollateralization(uint256 _overCollateralization)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setOverCollateralization(\\n      liquidationData,\\n      FixedPoint.Unsigned(_overCollateralization)\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the liquidation reward percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function setLiquidationReward(uint256 _liquidationReward)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    liquidationData.setLiquidationReward(\\n      FixedPoint.Unsigned(_liquidationReward)\\n    );\\n  }\\n\\n  //----------------------------------------\\n  // External view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Get Synthereum finder of the pool\\n   * @return finder Returns finder contract\\n   */\\n  function synthereumFinder()\\n    external\\n    view\\n    override\\n    returns (ISynthereumFinder finder)\\n  {\\n    finder = poolStorage.finder;\\n  }\\n\\n  /**\\n   * @notice Get Synthereum version\\n   * @return poolVersion Returns the version of the Synthereum pool\\n   */\\n  function version() external view override returns (uint8 poolVersion) {\\n    poolVersion = poolStorage.version;\\n  }\\n\\n  /**\\n   * @notice Get the collateral token\\n   * @return collateralCurrency The ERC20 collateral token\\n   */\\n  function collateralToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 collateralCurrency)\\n  {\\n    collateralCurrency = poolStorage.collateralToken;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token associated to this pool\\n   * @return syntheticCurrency The ERC20 synthetic token\\n   */\\n  function syntheticToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 syntheticCurrency)\\n  {\\n    syntheticCurrency = poolStorage.syntheticToken;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token symbol associated to this pool\\n   * @return symbol The ERC20 synthetic token symbol\\n   */\\n  function syntheticTokenSymbol()\\n    external\\n    view\\n    override\\n    returns (string memory symbol)\\n  {\\n    symbol = IStandardERC20(address(poolStorage.syntheticToken)).symbol();\\n  }\\n\\n  /**\\n   * @notice Returns price identifier of the pool\\n   * @return identifier Price identifier\\n   */\\n  function getPriceFeedIdentifier()\\n    external\\n    view\\n    override\\n    returns (bytes32 identifier)\\n  {\\n    identifier = poolStorage.priceIdentifier;\\n  }\\n\\n  /**\\n   * @notice Return overcollateralization percentage from the storage\\n   * @return Overcollateralization percentage\\n   */\\n  function overCollateralization() external view override returns (uint256) {\\n    return poolStorage.overCollateralization.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns fee percentage set by the maintainer\\n   * @return Fee percentage\\n   */\\n  function feePercentage() external view override returns (uint256) {\\n    return poolStorage.fee.feeData.feePercentage.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns fee recipients info\\n   * @return Addresses, weigths and total of weigths\\n   */\\n  function feeRecipientsInfo()\\n    external\\n    view\\n    override\\n    returns (\\n      address[] memory,\\n      uint32[] memory,\\n      uint256\\n    )\\n  {\\n    FeeData storage _feeData = poolStorage.fee.feeData;\\n    return (\\n      _feeData.feeRecipients,\\n      _feeData.feeProportions,\\n      poolStorage.fee.totalFeeProportions\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns total number of synthetic tokens generated by this pool\\n   * @return Number of synthetic tokens\\n   */\\n  function totalSyntheticTokens() external view override returns (uint256) {\\n    return lpPosition.tokensCollateralized.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of collateral used for collateralizing tokens (users + LP)\\n   * @return Total collateral amount\\n   */\\n  function totalCollateralAmount() external view override returns (uint256) {\\n    return lpPosition.totalCollateralAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of liquidity deposited in the pool, but nut used as collateral\\n   * @return Total available liquidity\\n   */\\n  function totalAvailableLiquidity() external view override returns (uint256) {\\n    return poolStorage.totalAvailableLiquidity(lpPosition, feeStatus);\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of fees to be withdrawn\\n   * @return Total fee amount\\n   */\\n  function totalFeeAmount() external view override returns (uint256) {\\n    return feeStatus.totalFeeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the user's fee to be withdrawn\\n   * @param user User's address\\n   * @return User's fee\\n   */\\n  function userFee(address user) external view override returns (uint256) {\\n    return feeStatus.feeGained[user].rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\\n   * @return Percentage of overcollateralization\\n   */\\n  function collateralRequirement() external view override returns (uint256) {\\n    return liquidationData.collateralRequirement.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\\n   * @return Percentage of reward\\n   */\\n  function liquidationReward() external view override returns (uint256) {\\n    return liquidationData.liquidationReward.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the price of the pair at the moment of the shutdown\\n   * @return Price of the pair\\n   */\\n  function emergencyShutdownPrice() external view override returns (uint256) {\\n    return emergencyShutdownData.price.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the timestamp (unix time) at the moment of the shutdown\\n   * @return Timestamp\\n   */\\n  function emergencyShutdownTimestamp()\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return emergencyShutdownData.timestamp;\\n  }\\n\\n  /**\\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\\n   */\\n  function collateralCoverage() external view override returns (bool, uint256) {\\n    return poolStorage.collateralCoverage(lpPosition, liquidationData);\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param inputCollateral Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(uint256 inputCollateral)\\n    external\\n    view\\n    override\\n    returns (uint256 synthTokensReceived, uint256 feePaid)\\n  {\\n    (synthTokensReceived, feePaid) = poolStorage.getMintTradeInfo(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(inputCollateral)\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(uint256 syntheticTokens)\\n    external\\n    view\\n    override\\n    returns (uint256 collateralAmountReceived, uint256 feePaid)\\n  {\\n    (collateralAmountReceived, feePaid) = poolStorage.getRedeemTradeInfo(\\n      lpPosition,\\n      FixedPoint.Unsigned(syntheticTokens)\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @param  destinationPool Pool in which mint the destination synthetic token\\n   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getExchangeTradeInfo(\\n    uint256 syntheticTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    external\\n    view\\n    override\\n    returns (uint256 destSyntheticTokensReceived, uint256 feePaid)\\n  {\\n    (destSyntheticTokensReceived, feePaid) = poolStorage.getExchangeTradeInfo(\\n      lpPosition,\\n      FixedPoint.Unsigned(syntheticTokens),\\n      destinationPool\\n    );\\n  }\\n\\n  /**\\n   * @notice Check if an address is the trusted forwarder\\n   * @param  forwarder Address to check\\n   * @return True is the input address is the trusted forwarder, otherwise false\\n   */\\n  function isTrustedForwarder(address forwarder)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    try\\n      poolStorage.finder.getImplementationAddress(\\n        SynthereumInterfaces.TrustedForwarder\\n      )\\n    returns (address trustedForwarder) {\\n      if (forwarder == trustedForwarder) {\\n        return true;\\n      } else {\\n        return false;\\n      }\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  function _msgSender()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (address sender)\\n  {\\n    return ERC2771Context._msgSender();\\n  }\\n\\n  function _msgData()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData();\\n  }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {\\n  ISynthereumLiquidityPoolStorage\\n} from './interfaces/ILiquidityPoolStorage.sol';\\nimport {ISynthereumLiquidityPool} from './interfaces/ILiquidityPool.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumRegistry\\n} from '../../core/registries/interfaces/IRegistry.sol';\\nimport {\\n  ISynthereumPriceFeed\\n} from '../../oracle/common/interfaces/IPriceFeed.sol';\\nimport {\\n  ISynthereumLiquidityPoolGeneral\\n} from './interfaces/ILiquidityPoolGeneral.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\n/**\\n * @notice Pool implementation is stored here to reduce deployment costs\\n */\\n\\nlibrary SynthereumLiquidityPoolLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FixedPoint for uint256;\\n  using SafeERC20 for IStandardERC20;\\n  using SafeERC20 for IMintableBurnableERC20;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.Storage;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.LPPosition;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.FeeStatus;\\n\\n  struct ExecuteMintParams {\\n    // Amount of synth tokens to mint\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral (excluding fees) needed for mint\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral minted + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the mint transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteRedeemParams {\\n    //Amount of synth tokens needed for redeem\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral that user will receive\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral redeemed + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the redeem transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteExchangeParams {\\n    // Destination pool in which mint new tokens\\n    ISynthereumLiquidityPoolGeneral destPool;\\n    // Amount of tokens to send\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral (excluding fees) equivalent to synthetic token (exluding fees) to send\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral redemeed + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Amount of synthetic token to receive\\n    FixedPoint.Unsigned destNumTokens;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the exchange transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteSettlement {\\n    // Price of emergency shutdown\\n    FixedPoint.Unsigned emergencyPrice;\\n    // Amount of synthtic tokens to be liquidated\\n    FixedPoint.Unsigned userNumTokens;\\n    // Total amount of collateral (excluding unused and fees) deposited\\n    FixedPoint.Unsigned totalCollateralAmount;\\n    // Total amount of synthetic tokens\\n    FixedPoint.Unsigned tokensCollaterlized;\\n    // Total actual amount of fees to be withdrawn\\n    FixedPoint.Unsigned totalFeeAmount;\\n    // Overcollateral to be withdrawn by Lp (0 if standard user)\\n    FixedPoint.Unsigned overCollateral;\\n    // Amount of collateral which value is equal to the synthetic tokens value according to the emergency price\\n    FixedPoint.Unsigned totalRedeemableCollateral;\\n    // Exepected amount of collateral\\n    FixedPoint.Unsigned redeemableCollateral;\\n    // Collateral deposited but not used to collateralize\\n    FixedPoint.Unsigned unusedCollateral;\\n    // Amount of collateral settled to the sender\\n    FixedPoint.Unsigned transferableCollateral;\\n  }\\n\\n  struct ExecuteLiquidation {\\n    // Total amount of collateral in the Lp position\\n    FixedPoint.Unsigned totalCollateralAmount;\\n    // Total number of tokens collateralized in the Lp position\\n    FixedPoint.Unsigned tokensCollateralized;\\n    // Total number of tokens in liquidation\\n    FixedPoint.Unsigned tokensInLiquidation;\\n    // Amount of collateral used to collateralize user's tokens\\n    FixedPoint.Unsigned userCollateralization;\\n    // Available liquidity in the pool\\n    FixedPoint.Unsigned unusedCollateral;\\n    // Expected collateral received by the user according to the actual price\\n    FixedPoint.Unsigned expectedCollateral;\\n    // Collateral amount receieved by the user\\n    FixedPoint.Unsigned settledCollateral;\\n    // Reward amount received by the user\\n    FixedPoint.Unsigned rewardAmount;\\n    // Price rate at the moment of the liquidation\\n    FixedPoint.Unsigned priceRate;\\n  }\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event Mint(\\n    address indexed account,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event WithdrawLiquidity(\\n    address indexed lp,\\n    uint256 liquidityWithdrawn,\\n    uint256 remainingLiquidity\\n  );\\n\\n  event IncreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralAdded,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event DecreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralRemoved,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event ClaimFee(\\n    address indexed claimer,\\n    uint256 feeAmount,\\n    uint256 totalRemainingFees\\n  );\\n\\n  event Liquidate(\\n    address indexed liquidator,\\n    uint256 tokensLiquidated,\\n    uint256 price,\\n    uint256 collateralExpected,\\n    uint256 collateralReceived,\\n    uint256 rewardReceived\\n  );\\n\\n  event EmergencyShutdown(\\n    uint256 timestamp,\\n    uint256 price,\\n    uint256 finalCollateral\\n  );\\n\\n  event Settle(\\n    address indexed account,\\n    uint256 numTokensSettled,\\n    uint256 collateralExpected,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event SetOverCollateralization(uint256 overCollateralization);\\n\\n  event SetLiquidationReward(uint256 liquidationReward);\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Initializes a liquidity pool\\n   * @param self Data type the library is attached to\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _finder The Synthereum finder\\n   * @param _version Synthereum version\\n   * @param _collateralToken ERC20 collateral token\\n   * @param _syntheticToken ERC20 synthetic token\\n   * @param _overCollateralization Over-collateralization ratio\\n   * @param _priceIdentifier Identifier of price to be used in the price feed\\n   * @param _collateralRequirement Percentage of overcollateralization to which a liquidation can triggered\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function initialize(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumFinder _finder,\\n    uint8 _version,\\n    IStandardERC20 _collateralToken,\\n    IMintableBurnableERC20 _syntheticToken,\\n    FixedPoint.Unsigned calldata _overCollateralization,\\n    bytes32 _priceIdentifier,\\n    FixedPoint.Unsigned calldata _collateralRequirement,\\n    FixedPoint.Unsigned calldata _liquidationReward\\n  ) external {\\n    require(\\n      _collateralRequirement.isGreaterThan(1),\\n      'Collateral requirement must be bigger than 100%'\\n    );\\n\\n    require(\\n      _overCollateralization.isGreaterThan(_collateralRequirement.sub(1)),\\n      'Overcollateralization must be bigger than the Lp part of the collateral requirement'\\n    );\\n\\n    require(\\n      _liquidationReward.rawValue > 0 &&\\n        _liquidationReward.isLessThanOrEqual(1),\\n      'Liquidation reward must be between 0 and 100%'\\n    );\\n\\n    require(\\n      _collateralToken.decimals() <= 18,\\n      'Collateral has more than 18 decimals'\\n    );\\n\\n    require(\\n      _syntheticToken.decimals() == 18,\\n      'Synthetic token has more or less than 18 decimals'\\n    );\\n\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        _finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n\\n    require(\\n      priceFeed.isPriceSupported(_priceIdentifier),\\n      'Price identifier not supported'\\n    );\\n\\n    self.finder = _finder;\\n    self.version = _version;\\n    self.collateralToken = _collateralToken;\\n    self.syntheticToken = _syntheticToken;\\n    self.overCollateralization = _overCollateralization;\\n    self.priceIdentifier = _priceIdentifier;\\n    liquidationData.collateralRequirement = _collateralRequirement;\\n    liquidationData.liquidationReward = _liquidationReward;\\n  }\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @param sender Sender of the mint transaction\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.MintParams calldata mintParams,\\n    address sender\\n  ) external returns (uint256 syntheticTokensMinted, uint256 feePaid) {\\n    FixedPoint.Unsigned memory totCollateralAmount =\\n      FixedPoint.Unsigned(mintParams.collateralAmount);\\n\\n    (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory numTokens\\n    ) = self.mintCalculation(totCollateralAmount);\\n\\n    require(\\n      numTokens.rawValue >= mintParams.minNumTokens,\\n      'Number of tokens less than minimum limit'\\n    );\\n\\n    checkExpiration(mintParams.expiration);\\n\\n    self.executeMint(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteMintParams(\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        mintParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    syntheticTokensMinted = numTokens.rawValue;\\n    feePaid = feeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @param sender Sender of the redeem transaction\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.RedeemParams calldata redeemParams,\\n    address sender\\n  ) external returns (uint256 collateralRedeemed, uint256 feePaid) {\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(redeemParams.numTokens);\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount\\n    ) = self.redeemCalculation(numTokens);\\n\\n    require(\\n      collateralAmount.rawValue >= redeemParams.minCollateral,\\n      'Collateral amount less than minimum limit'\\n    );\\n\\n    checkExpiration(redeemParams.expiration);\\n\\n    self.executeRedeem(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteRedeemParams(\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        redeemParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    feePaid = feeAmount.rawValue;\\n    collateralRedeemed = collateralAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\\n   * @param sender Sender of the exchange transaction\\n   * @return destNumTokensMinted Amount of synthetic token minted in the destination pool\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function exchange(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.ExchangeParams calldata exchangeParams,\\n    address sender\\n  ) external returns (uint256 destNumTokensMinted, uint256 feePaid) {\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(exchangeParams.numTokens);\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory destNumTokens\\n    ) = self.exchangeCalculation(numTokens, exchangeParams.destPool);\\n\\n    require(\\n      destNumTokens.rawValue >= exchangeParams.minDestNumTokens,\\n      'Number of destination tokens less than minimum limit'\\n    );\\n\\n    checkExpiration(exchangeParams.expiration);\\n\\n    self.executeExchange(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteExchangeParams(\\n        exchangeParams.destPool,\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        destNumTokens,\\n        exchangeParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    destNumTokensMinted = destNumTokens.rawValue;\\n    feePaid = feeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Called by a source Pool's `exchange` function to mint destination tokens\\n   * @notice This functon can be called only by a pool registered in the deployer\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount The amount of collateral to use from the source Pool\\n   * @param numTokens The number of new tokens to mint\\n   * @param recipient Recipient to which send synthetic token minted\\n   */\\n  function exchangeMint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralAmount,\\n    FixedPoint.Unsigned calldata numTokens,\\n    address recipient\\n  ) external {\\n    self.checkPool(ISynthereumLiquidityPoolGeneral(msg.sender));\\n\\n    // Sending amount must be different from 0\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        collateralAmount\\n      );\\n\\n    // Update LP's collateralization status\\n    FixedPoint.Unsigned memory overCollateral =\\n      lpPosition.updateLpPositionInMint(\\n        self.overCollateralization,\\n        collateralAmount,\\n        numTokens\\n      );\\n\\n    //Check there is enough liquidity in the pool for overcollateralization\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for cover mint operation'\\n    );\\n\\n    // Mint synthetic asset and transfer to the recipient\\n    self.syntheticToken.mint(recipient, numTokens.rawValue);\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @param sender Sender of the withdrawLiquidity transaction\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function withdrawLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralAmount,\\n    address sender\\n  ) external returns (uint256 remainingLiquidity) {\\n    remainingLiquidity = self._withdrawLiquidity(\\n      lpPosition,\\n      feeStatus,\\n      collateralAmount,\\n      sender\\n    );\\n  }\\n\\n  /**\\n   * @notice Increase collaterallization of Lp position\\n   * @notice Only a sender with LP role can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\\n   * @param collateralToIncrease Collateral to be added to the position\\n   * @param sender Sender of the increaseCollateral transaction\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function increaseCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralToTransfer,\\n    FixedPoint.Unsigned calldata collateralToIncrease,\\n    address sender\\n  ) external returns (uint256 newTotalCollateral) {\\n    // Check the collateral to be increased is not 0\\n    require(collateralToIncrease.rawValue > 0, 'No collateral to be increased');\\n\\n    // Deposit collateral in the pool\\n    if (collateralToTransfer.rawValue > 0) {\\n      self.pullCollateral(sender, collateralToTransfer);\\n    }\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Check that there is enoush availabe collateral deposited in the pool\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(collateralToIncrease),\\n      'No enough liquidity for increasing collateral'\\n    );\\n\\n    // Update new total collateral amount\\n    FixedPoint.Unsigned memory _newTotalCollateral =\\n      lpPosition.totalCollateralAmount.add(collateralToIncrease);\\n\\n    lpPosition.totalCollateralAmount = _newTotalCollateral;\\n\\n    newTotalCollateral = _newTotalCollateral.rawValue;\\n\\n    emit IncreaseCollateral(\\n      sender,\\n      collateralToIncrease.rawValue,\\n      newTotalCollateral\\n    );\\n  }\\n\\n  /**\\n   * @notice Decrease collaterallization of Lp position\\n   * @notice Check that final position is not undercollateralized\\n   * @notice Only a sender with LP role can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralToDecrease Collateral to decreased from the position\\n   * @param collateralToWithdraw Collateral to be transferred to the LP\\n   * @param sender Sender of the decreaseCollateral transaction\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function decreaseCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralToDecrease,\\n    FixedPoint.Unsigned calldata collateralToWithdraw,\\n    address sender\\n  ) external returns (uint256 newTotalCollateral) {\\n    // Check that collateral to be decreased is not 0\\n    require(collateralToDecrease.rawValue > 0, 'No collateral to be decreased');\\n\\n    // Resulting total collateral amount\\n    FixedPoint.Unsigned memory _newTotalCollateral =\\n      lpPosition.totalCollateralAmount.sub(collateralToDecrease);\\n\\n    // Check that position doesn't become undercollateralized\\n    (bool _isOverCollateralized, ) =\\n      lpPosition.isOverCollateralized(\\n        liquidationData,\\n        getPriceFeedRate(self.finder, self.priceIdentifier),\\n        getCollateralDecimals(self.collateralToken),\\n        _newTotalCollateral\\n      );\\n\\n    require(_isOverCollateralized, 'Position undercollateralized');\\n\\n    // Update new total collateral amount\\n    lpPosition.totalCollateralAmount = _newTotalCollateral;\\n\\n    newTotalCollateral = _newTotalCollateral.rawValue;\\n\\n    emit DecreaseCollateral(\\n      sender,\\n      collateralToDecrease.rawValue,\\n      newTotalCollateral\\n    );\\n\\n    if (collateralToWithdraw.rawValue > 0) {\\n      self._withdrawLiquidity(\\n        lpPosition,\\n        feeStatus,\\n        collateralToWithdraw,\\n        sender\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Withdraw fees gained by the sender\\n   * @param self Data type the library is attached to\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param sender Sender of the claimFee transaction\\n   * @return feeClaimed Amount of fee claimed\\n   */\\n  function claimFee(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    address sender\\n  ) external returns (uint256 feeClaimed) {\\n    // Fee to claim\\n    FixedPoint.Unsigned memory _feeClaimed = feeStatus.feeGained[sender];\\n    feeClaimed = _feeClaimed.rawValue;\\n\\n    // Check that fee is available\\n    require(feeClaimed > 0, 'No fee to claim');\\n\\n    // Update fee status\\n    delete feeStatus.feeGained[sender];\\n\\n    FixedPoint.Unsigned memory _totalRemainingFees =\\n      feeStatus.totalFeeAmount.sub(_feeClaimed);\\n\\n    feeStatus.totalFeeAmount = _totalRemainingFees;\\n\\n    // Transfer amount to the sender\\n    self.collateralToken.safeTransfer(sender, feeClaimed);\\n\\n    emit ClaimFee(sender, feeClaimed, _totalRemainingFees.rawValue);\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @param sender Sender of the liquidation transaction\\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\\n   */\\n  function liquidate(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata numSynthTokens,\\n    address sender\\n  )\\n    external\\n    returns (\\n      uint256 synthTokensLiquidated,\\n      uint256 collateralReceived,\\n      uint256 rewardAmount\\n    )\\n  {\\n    // Memory struct for saving local varibales\\n    ExecuteLiquidation memory executeLiquidation;\\n\\n    executeLiquidation.totalCollateralAmount = lpPosition.totalCollateralAmount;\\n\\n    executeLiquidation.priceRate = getPriceFeedRate(\\n      self.finder,\\n      self.priceIdentifier\\n    );\\n\\n    uint8 collateralDecimals = getCollateralDecimals(self.collateralToken);\\n\\n    // Collateral value of the synthetic token passed\\n    {\\n      (bool _isOverCollaterlized, ) =\\n        lpPosition.isOverCollateralized(\\n          liquidationData,\\n          executeLiquidation.priceRate,\\n          collateralDecimals,\\n          executeLiquidation.totalCollateralAmount\\n        );\\n\\n      // Revert if position is not undercollataralized\\n      require(!_isOverCollaterlized, 'Position is overcollateralized');\\n    }\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    executeLiquidation.tokensCollateralized = lpPosition.tokensCollateralized;\\n\\n    executeLiquidation.tokensInLiquidation = FixedPoint.min(\\n      numSynthTokens,\\n      executeLiquidation.tokensCollateralized\\n    );\\n\\n    executeLiquidation.expectedCollateral = calculateCollateralAmount(\\n      executeLiquidation.priceRate,\\n      collateralDecimals,\\n      executeLiquidation.tokensInLiquidation\\n    );\\n\\n    executeLiquidation.userCollateralization = executeLiquidation\\n      .tokensInLiquidation\\n      .div(executeLiquidation.tokensCollateralized)\\n      .mul(executeLiquidation.totalCollateralAmount);\\n\\n    executeLiquidation.settledCollateral;\\n    executeLiquidation.rewardAmount;\\n\\n    if (\\n      executeLiquidation.userCollateralization.isGreaterThan(\\n        executeLiquidation.expectedCollateral\\n      )\\n    ) {\\n      executeLiquidation.settledCollateral = executeLiquidation\\n        .expectedCollateral;\\n      executeLiquidation.rewardAmount = executeLiquidation\\n        .userCollateralization\\n        .sub(executeLiquidation.expectedCollateral)\\n        .mul(liquidationData.liquidationReward);\\n    } else {\\n      executeLiquidation.unusedCollateral = self.calculateUnusedCollateral(\\n        executeLiquidation.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n      executeLiquidation.settledCollateral = FixedPoint.min(\\n        executeLiquidation.expectedCollateral,\\n        executeLiquidation.totalCollateralAmount.add(\\n          executeLiquidation.unusedCollateral\\n        )\\n      );\\n    }\\n\\n    // Update Lp position\\n    lpPosition.totalCollateralAmount = executeLiquidation\\n      .totalCollateralAmount\\n      .isGreaterThan(executeLiquidation.expectedCollateral)\\n      ? executeLiquidation\\n        .totalCollateralAmount\\n        .sub(executeLiquidation.expectedCollateral)\\n        .sub(executeLiquidation.rewardAmount)\\n      : FixedPoint.Unsigned(0);\\n\\n    lpPosition.tokensCollateralized = executeLiquidation\\n      .tokensCollateralized\\n      .sub(executeLiquidation.tokensInLiquidation);\\n\\n    collateralReceived = executeLiquidation.settledCollateral.rawValue;\\n\\n    rewardAmount = executeLiquidation.rewardAmount.rawValue;\\n\\n    synthTokensLiquidated = executeLiquidation.tokensInLiquidation.rawValue;\\n\\n    // Burn synthetic tokens to be liquidated\\n    self.burnSyntheticTokens(synthTokensLiquidated, sender);\\n\\n    // Transfer liquidated collateral and reward to the user\\n    _collateralToken.safeTransfer(sender, collateralReceived + rewardAmount);\\n\\n    emit Liquidate(\\n      sender,\\n      synthTokensLiquidated,\\n      executeLiquidation.priceRate.rawValue,\\n      executeLiquidation.expectedCollateral.rawValue,\\n      collateralReceived,\\n      rewardAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Shutdown the pool in case of emergency\\n   * @notice Only Synthereum manager contract can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param emergencyShutdownData Emergency shutdown info (see Shutdown struct)\\n   * @return timestamp Timestamp of emergency shutdown transaction\\n   * @return price Price of the pair at the moment of shutdown execution\\n   */\\n  function emergencyShutdown(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Shutdown storage emergencyShutdownData\\n  ) external returns (uint256 timestamp, uint256 price) {\\n    ISynthereumFinder _finder = self.finder;\\n\\n    require(\\n      msg.sender ==\\n        _finder.getImplementationAddress(SynthereumInterfaces.Manager),\\n      'Caller must be the Synthereum manager'\\n    );\\n\\n    timestamp = block.timestamp;\\n\\n    emergencyShutdownData.timestamp = timestamp;\\n\\n    FixedPoint.Unsigned memory _price =\\n      getPriceFeedRate(_finder, self.priceIdentifier);\\n\\n    emergencyShutdownData.price = _price;\\n\\n    price = _price.rawValue;\\n\\n    // Move available liquidity in the position\\n    FixedPoint.Unsigned memory totalCollateral =\\n      lpPosition.totalCollateralAmount;\\n\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        totalCollateral,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    FixedPoint.Unsigned memory finalCollateral =\\n      totalCollateral.add(unusedCollateral);\\n\\n    lpPosition.totalCollateralAmount = finalCollateral;\\n\\n    emit EmergencyShutdown(timestamp, price, finalCollateral.rawValue);\\n  }\\n\\n  /**\\n   * @notice Redeem tokens after emergency shutdown\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param emergencyShutdownData Emergency shutdown info (see Shutdown struct)\\n   * @param isLiquidityProvider True if the sender is an LP, otherwise false\\n   * @param sender Sender of the settleEmergencyShutdown transaction\\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\\n   */\\n  function settleEmergencyShutdown(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Shutdown storage emergencyShutdownData,\\n    bool isLiquidityProvider,\\n    address sender\\n  ) external returns (uint256 synthTokensSettled, uint256 collateralSettled) {\\n    // Memory struct for saving local varibales\\n    ExecuteSettlement memory executeSettlement;\\n\\n    IMintableBurnableERC20 syntheticToken = self.syntheticToken;\\n\\n    executeSettlement.emergencyPrice = emergencyShutdownData.price;\\n\\n    executeSettlement.userNumTokens = FixedPoint.Unsigned(\\n      syntheticToken.balanceOf(sender)\\n    );\\n\\n    require(\\n      executeSettlement.userNumTokens.rawValue > 0 || isLiquidityProvider,\\n      'Sender has nothing to settle'\\n    );\\n\\n    if (executeSettlement.userNumTokens.rawValue > 0) {\\n      // Move synthetic tokens from the user to the pool\\n      // - This is because derivative expects the tokens to come from the sponsor address\\n      syntheticToken.safeTransferFrom(\\n        sender,\\n        address(this),\\n        executeSettlement.userNumTokens.rawValue\\n      );\\n    }\\n\\n    executeSettlement.totalCollateralAmount = lpPosition.totalCollateralAmount;\\n    executeSettlement.tokensCollaterlized = lpPosition.tokensCollateralized;\\n    executeSettlement.totalFeeAmount = feeStatus.totalFeeAmount;\\n    executeSettlement.overCollateral;\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    uint8 collateralDecimals = getCollateralDecimals(_collateralToken);\\n\\n    // Add overcollateral and deposited synthetic tokens if the sender is the LP\\n    if (isLiquidityProvider) {\\n      FixedPoint.Unsigned memory totalRedeemableCollateral =\\n        calculateCollateralAmount(\\n          executeSettlement.emergencyPrice,\\n          collateralDecimals,\\n          executeSettlement.tokensCollaterlized\\n        );\\n\\n      executeSettlement.overCollateral = executeSettlement\\n        .totalCollateralAmount\\n        .isGreaterThan(totalRedeemableCollateral)\\n        ? executeSettlement.totalCollateralAmount.sub(totalRedeemableCollateral)\\n        : FixedPoint.Unsigned(0);\\n\\n      executeSettlement.userNumTokens = FixedPoint.Unsigned(\\n        syntheticToken.balanceOf(address(this))\\n      );\\n    }\\n\\n    // Calculate expected and settled collateral\\n    executeSettlement.redeemableCollateral = calculateCollateralAmount(\\n      executeSettlement\\n        .emergencyPrice,\\n      collateralDecimals,\\n      executeSettlement\\n        .userNumTokens\\n    )\\n      .add(executeSettlement.overCollateral);\\n\\n    executeSettlement.unusedCollateral = self.calculateUnusedCollateral(\\n      executeSettlement.totalCollateralAmount,\\n      executeSettlement.totalFeeAmount,\\n      FixedPoint.Unsigned(0)\\n    );\\n\\n    executeSettlement.transferableCollateral = FixedPoint.min(\\n      executeSettlement.redeemableCollateral,\\n      executeSettlement.totalCollateralAmount\\n    );\\n\\n    // Update Lp position\\n    lpPosition.totalCollateralAmount = executeSettlement\\n      .totalCollateralAmount\\n      .isGreaterThan(executeSettlement.redeemableCollateral)\\n      ? executeSettlement.totalCollateralAmount.sub(\\n        executeSettlement.redeemableCollateral\\n      )\\n      : FixedPoint.Unsigned(0);\\n\\n    lpPosition.tokensCollateralized = executeSettlement.tokensCollaterlized.sub(\\n      executeSettlement.userNumTokens\\n    );\\n\\n    synthTokensSettled = executeSettlement.userNumTokens.rawValue;\\n\\n    collateralSettled = executeSettlement.transferableCollateral.rawValue;\\n\\n    // Burn synthetic tokens\\n    syntheticToken.burn(synthTokensSettled);\\n\\n    // Transfer settled collateral to the user\\n    _collateralToken.safeTransfer(sender, collateralSettled);\\n\\n    emit Settle(\\n      sender,\\n      synthTokensSettled,\\n      executeSettlement.redeemableCollateral.rawValue,\\n      collateralSettled\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage\\n   * @param self Data type the library is attached to\\n   * @param _feePercentage The new fee percentage\\n   */\\n  function setFeePercentage(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned calldata _feePercentage\\n  ) external {\\n    require(\\n      _feePercentage.rawValue < 10**(18),\\n      'Fee Percentage must be less than 100%'\\n    );\\n\\n    self.fee.feeData.feePercentage = _feePercentage;\\n\\n    emit SetFeePercentage(_feePercentage.rawValue);\\n  }\\n\\n  /**\\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\\n   * @param self Data type the library is attached to\\n   * @param _feeRecipients An array of the addresses of recipients that will receive generated fees\\n   * @param _feeProportions An array of the proportions of fees generated each recipient will receive\\n   */\\n  function setFeeRecipients(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    address[] calldata _feeRecipients,\\n    uint32[] calldata _feeProportions\\n  ) external {\\n    require(\\n      _feeRecipients.length == _feeProportions.length,\\n      'Fee recipients and fee proportions do not match'\\n    );\\n\\n    uint256 totalActualFeeProportions;\\n\\n    // Store the sum of all proportions\\n    for (uint256 i = 0; i < _feeProportions.length; i++) {\\n      totalActualFeeProportions += _feeProportions[i];\\n    }\\n\\n    ISynthereumLiquidityPoolStorage.FeeData storage _feeData = self.fee.feeData;\\n\\n    _feeData.feeRecipients = _feeRecipients;\\n    _feeData.feeProportions = _feeProportions;\\n    self.fee.totalFeeProportions = totalActualFeeProportions;\\n\\n    emit SetFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n\\n  /**\\n   * @notice Update the overcollateralization percentage\\n   * @param self Data type the library is attached to\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _overCollateralization Overcollateralization percentage\\n   */\\n  function setOverCollateralization(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned calldata _overCollateralization\\n  ) external {\\n    require(\\n      _overCollateralization.isGreaterThan(\\n        liquidationData.collateralRequirement.sub(1)\\n      ),\\n      'Overcollateralization must be bigger than the Lp part of the collateral requirement'\\n    );\\n\\n    self.overCollateralization = _overCollateralization;\\n\\n    emit SetOverCollateralization(_overCollateralization.rawValue);\\n  }\\n\\n  /**\\n   * @notice Update the liquidation reward percentage\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function setLiquidationReward(\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned calldata _liquidationReward\\n  ) external {\\n    require(\\n      _liquidationReward.rawValue > 0 &&\\n        _liquidationReward.isLessThanOrEqual(1),\\n      'Liquidation reward must be between 0 and 100%'\\n    );\\n\\n    liquidationData.liquidationReward = _liquidationReward;\\n\\n    emit SetLiquidationReward(_liquidationReward.rawValue);\\n  }\\n\\n  //----------------------------------------\\n  // External view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Returns the total amount of liquidity deposited in the pool, but nut used as collateral\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @return Total available liquidity\\n   */\\n  function totalAvailableLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus\\n  ) external view returns (uint256) {\\n    return\\n      self\\n        .calculateUnusedCollateral(\\n        lpPosition\\n          .totalCollateralAmount,\\n        feeStatus\\n          .totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      )\\n        .rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\\n   */\\n  function collateralCoverage(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData\\n  ) external view returns (bool, uint256) {\\n    FixedPoint.Unsigned memory priceRate =\\n      getPriceFeedRate(self.finder, self.priceIdentifier);\\n\\n    uint8 collateralDecimals = getCollateralDecimals(self.collateralToken);\\n\\n    (bool _isOverCollateralized, ) =\\n      lpPosition.isOverCollateralized(\\n        liquidationData,\\n        priceRate,\\n        collateralDecimals,\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    FixedPoint.Unsigned memory _collateralCoverage =\\n      lpPosition.totalCollateralAmount.div(\\n        calculateCollateralAmount(\\n          priceRate,\\n          collateralDecimals,\\n          lpPosition.tokensCollateralized\\n        )\\n      );\\n\\n    return (_isOverCollateralized, _collateralCoverage.rawValue);\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param inputCollateral Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata inputCollateral\\n  ) external view returns (uint256 synthTokensReceived, uint256 feePaid) {\\n    (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory _synthTokensReceived\\n    ) = self.mintCalculation(inputCollateral);\\n\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory overCollateral =\\n      collateralAmount.mul(self.overCollateralization);\\n\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    synthTokensReceived = _synthTokensReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned calldata syntheticTokens\\n  ) external view returns (uint256 collateralAmountReceived, uint256 feePaid) {\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    require(\\n      syntheticTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    require(\\n      syntheticTokens.isLessThanOrEqual(totalActualTokens),\\n      'Sending tokens amount bigger than amount in the position'\\n    );\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory _collateralAmountReceived\\n    ) = self.redeemCalculation(syntheticTokens);\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      syntheticTokens.div(totalActualTokens).mul(\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(totCollateralAmount),\\n      'Position undercapitalized'\\n    );\\n\\n    collateralAmountReceived = _collateralAmountReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @param  destinationPool Pool in which mint the destination synthetic token\\n   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getExchangeTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned calldata syntheticTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    external\\n    view\\n    returns (uint256 destSyntheticTokensReceived, uint256 feePaid)\\n  {\\n    self.checkPool(destinationPool);\\n\\n    require(\\n      address(this) != address(destinationPool),\\n      'Same source and destination pool'\\n    );\\n\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    require(\\n      syntheticTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    require(\\n      syntheticTokens.isLessThanOrEqual(totalActualTokens),\\n      'Sending tokens amount bigger than amount in the position'\\n    );\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory _destSyntheticTokensReceived\\n    ) = self.exchangeCalculation(syntheticTokens, destinationPool);\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      syntheticTokens.div(totalActualTokens).mul(\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(totCollateralAmount),\\n      'Position undercapitalized'\\n    );\\n\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory destOverCollateral =\\n      collateralAmount.mul(\\n        FixedPoint.Unsigned(destinationPool.overCollateralization())\\n      );\\n\\n    FixedPoint.Unsigned memory destUnusedCollateral =\\n      FixedPoint.Unsigned(destinationPool.totalAvailableLiquidity());\\n\\n    require(\\n      destUnusedCollateral.isGreaterThanOrEqual(destOverCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    destSyntheticTokensReceived = _destSyntheticTokensReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  //----------------------------------------\\n  //  Internal functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Execute mint of synthetic tokens\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeMintParams Params for execution of mint (see ExecuteMintParams struct)\\n   */\\n  function executeMint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteMintParams memory executeMintParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeMintParams.collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Update LP's collateralization status\\n    FixedPoint.Unsigned memory overCollateral =\\n      lpPosition.updateLpPositionInMint(\\n        self.overCollateralization,\\n        executeMintParams.collateralAmount,\\n        executeMintParams.numTokens\\n      );\\n\\n    //Check there is enough liquidity in the pool for overcollateralization\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeMintParams.feeAmount);\\n\\n    // Pull user's collateral\\n    self.pullCollateral(\\n      executeMintParams.sender,\\n      executeMintParams.totCollateralAmount\\n    );\\n\\n    // Mint synthetic asset and transfer to the recipient\\n    self.syntheticToken.mint(\\n      executeMintParams.recipient,\\n      executeMintParams.numTokens.rawValue\\n    );\\n\\n    emit Mint(\\n      executeMintParams.sender,\\n      executeMintParams.totCollateralAmount.rawValue,\\n      executeMintParams.numTokens.rawValue,\\n      executeMintParams.feeAmount.rawValue,\\n      executeMintParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Execute redeem of collateral\\n   * @param self Data type the library is attached tfo\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeRedeemParams Params for execution of redeem (see ExecuteRedeemParams struct)\\n   */\\n  function executeRedeem(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteRedeemParams memory executeRedeemParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeRedeemParams.numTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      lpPosition.updateLpPositionInRedeem(executeRedeemParams.numTokens);\\n\\n    // Check that collateral redemeed is enough for cover the value of synthetic tokens\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(\\n        executeRedeemParams.totCollateralAmount\\n      ),\\n      'Position undercapitalized'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeRedeemParams.feeAmount);\\n\\n    // Burn synthetic tokens\\n    self.burnSyntheticTokens(\\n      executeRedeemParams.numTokens.rawValue,\\n      executeRedeemParams.sender\\n    );\\n\\n    //Send net amount of collateral to the user that submitted the redeem request\\n    self.collateralToken.safeTransfer(\\n      executeRedeemParams.recipient,\\n      executeRedeemParams.collateralAmount.rawValue\\n    );\\n\\n    emit Redeem(\\n      executeRedeemParams.sender,\\n      executeRedeemParams.numTokens.rawValue,\\n      executeRedeemParams.collateralAmount.rawValue,\\n      executeRedeemParams.feeAmount.rawValue,\\n      executeRedeemParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Execute exchange between synthetic tokens\\n   * @param self Data type the library is attached tfo\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeExchangeParams Params for execution of exchange (see ExecuteExchangeParams struct)\\n   */\\n  function executeExchange(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteExchangeParams memory executeExchangeParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeExchangeParams.numTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      lpPosition.updateLpPositionInRedeem(executeExchangeParams.numTokens);\\n\\n    // Check that collateral redemeed is enough for cover the value of synthetic tokens\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(\\n        executeExchangeParams.totCollateralAmount\\n      ),\\n      'Position undercapitalized'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeExchangeParams.feeAmount);\\n\\n    // Burn synthetic tokens\\n    self.burnSyntheticTokens(\\n      executeExchangeParams.numTokens.rawValue,\\n      executeExchangeParams.sender\\n    );\\n\\n    ISynthereumLiquidityPoolGeneral destinationPool =\\n      executeExchangeParams.destPool;\\n\\n    // Check that destination pool is different from this pool\\n    require(\\n      address(this) != address(destinationPool),\\n      'Same source and destination pool'\\n    );\\n\\n    self.checkPool(destinationPool);\\n\\n    // Transfer collateral amount (without overcollateralization) to the destination pool\\n    self.collateralToken.safeTransfer(\\n      address(destinationPool),\\n      executeExchangeParams.collateralAmount.rawValue\\n    );\\n\\n    // Mint the destination tokens with the withdrawn collateral\\n    destinationPool.exchangeMint(\\n      executeExchangeParams.collateralAmount.rawValue,\\n      executeExchangeParams.destNumTokens.rawValue,\\n      executeExchangeParams.recipient\\n    );\\n\\n    emit Exchange(\\n      executeExchangeParams.sender,\\n      address(destinationPool),\\n      executeExchangeParams.numTokens.rawValue,\\n      executeExchangeParams.destNumTokens.rawValue,\\n      executeExchangeParams.feeAmount.rawValue,\\n      executeExchangeParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @param sender Sender that withdraws liquidity\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function _withdrawLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    address sender\\n  ) internal returns (uint256 remainingLiquidity) {\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Check that available collateral is bigger than collateral to be withdrawn and returns the difference\\n    remainingLiquidity = (unusedCollateral.sub(collateralAmount)).rawValue;\\n\\n    // Transfer amount to the Lp\\n    uint256 _collateralAmount = collateralAmount.rawValue;\\n\\n    self.collateralToken.safeTransfer(sender, _collateralAmount);\\n\\n    emit WithdrawLiquidity(sender, _collateralAmount, remainingLiquidity);\\n  }\\n\\n  /**\\n   * @notice Update LP's collateralization status after a mint\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param overCollateralization Overcollateralization rate\\n   * @param collateralAmount Collateral amount to be added (only user collateral)\\n   * @param numTokens Tokens to be added\\n   * @return overCollateral Amount of collateral to be provided by LP for overcollateralization\\n   */\\n  function updateLpPositionInMint(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned storage overCollateralization,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (FixedPoint.Unsigned memory overCollateral) {\\n    overCollateral = collateralAmount.mul(overCollateralization);\\n\\n    lpPosition.totalCollateralAmount = lpPosition\\n      .totalCollateralAmount\\n      .add(collateralAmount)\\n      .add(overCollateral);\\n\\n    lpPosition.tokensCollateralized = lpPosition.tokensCollateralized.add(\\n      numTokens\\n    );\\n  }\\n\\n  /**\\n   * @notice Update LP's collateralization status after a redeem\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param numTokens Tokens to be removed\\n   * @return collateralRedeemed Collateral redeemed\\n   */\\n  function updateLpPositionInRedeem(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (FixedPoint.Unsigned memory collateralRedeemed) {\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    FixedPoint.Unsigned memory totalActualCollateral =\\n      lpPosition.totalCollateralAmount;\\n\\n    FixedPoint.Unsigned memory fractionRedeemed =\\n      numTokens.div(totalActualTokens);\\n\\n    collateralRedeemed = fractionRedeemed.mul(totalActualCollateral);\\n\\n    lpPosition.tokensCollateralized = totalActualTokens.sub(numTokens);\\n\\n    lpPosition.totalCollateralAmount = totalActualCollateral.sub(\\n      collateralRedeemed\\n    );\\n  }\\n\\n  /**\\n   * @notice Update fee gained by the fee recipients\\n   * @param feeStatus Actual status of fee gained to be withdrawn\\n   * @param feeInfo Actual status of fee recipients and their proportions\\n   * @param feeAmount Collateral fee charged\\n   */\\n  function updateFees(\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Fee storage feeInfo,\\n    FixedPoint.Unsigned memory feeAmount\\n  ) internal {\\n    FixedPoint.Unsigned memory feeCharged;\\n\\n    address[] storage feeRecipients = feeInfo.feeData.feeRecipients;\\n\\n    uint32[] storage feeProportions = feeInfo.feeData.feeProportions;\\n\\n    uint256 totalFeeProportions = feeInfo.totalFeeProportions;\\n\\n    uint256 numberOfRecipients = feeRecipients.length;\\n\\n    mapping(address => FixedPoint.Unsigned) storage feeGained =\\n      feeStatus.feeGained;\\n\\n    for (uint256 i = 0; i < numberOfRecipients - 1; i++) {\\n      address feeRecipient = feeRecipients[i];\\n      FixedPoint.Unsigned memory feeReceived =\\n        FixedPoint.Unsigned(\\n          (feeAmount.rawValue * feeProportions[i]) / totalFeeProportions\\n        );\\n      feeGained[feeRecipient] = feeGained[feeRecipient].add(feeReceived);\\n      feeCharged = feeCharged.add(feeReceived);\\n    }\\n\\n    address lastRecipient = feeRecipients[numberOfRecipients - 1];\\n\\n    feeGained[lastRecipient] = feeGained[lastRecipient].add(feeAmount).sub(\\n      feeCharged\\n    );\\n\\n    feeStatus.totalFeeAmount = feeStatus.totalFeeAmount.add(feeAmount);\\n  }\\n\\n  /**\\n   * @notice Pulls collateral tokens from the sender to store in the Pool\\n   * @param self Data type the library is attached to\\n   * @param numTokens The number of tokens to pull\\n   */\\n  function pullCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    address from,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    self.collateralToken.safeTransferFrom(\\n      from,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n  }\\n\\n  /**\\n   * @notice Pulls synthetic tokens from the sender and burn them\\n   * @param self Data type the library is attached to\\n   * @param numTokens The number of tokens to be burned\\n   * @param sender Sender of synthetic tokens\\n   */\\n  function burnSyntheticTokens(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    uint256 numTokens,\\n    address sender\\n  ) internal {\\n    IMintableBurnableERC20 synthToken = self.syntheticToken;\\n\\n    // Transfer synthetic token from the user to the pool\\n    synthToken.safeTransferFrom(sender, address(this), numTokens);\\n\\n    // Burn synthetic asset\\n    synthToken.burn(numTokens);\\n  }\\n\\n  //----------------------------------------\\n  //  Internal views functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Given a collateral value to be exchanged, returns the fee amount, net collateral and synthetic tokens\\n   * @param self Data type the library is attached tfo\\n   * @param totCollateralAmount Collateral amount to be exchanged\\n   * @return collateralAmount Net collateral amount (totCollateralAmount - feePercentage)\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return numTokens Number of synthetic tokens will be received according to the actual price in exchange for collateralAmount\\n   */\\n  function mintCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory totCollateralAmount\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory numTokens\\n    )\\n  {\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n\\n    numTokens = calculateNumberOfTokens(\\n      getPriceFeedRate(self.finder, self.priceIdentifier),\\n      getCollateralDecimals(self.collateralToken),\\n      collateralAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Given a an amount of synthetic tokens to be exchanged, returns the fee amount, net collateral and gross collateral\\n   * @param self Data type the library is attached tfo\\n   * @param numTokens Synthetic tokens amount to be exchanged\\n   * @return totCollateralAmount Gross collateral amount (collateralAmount + feeAmount)\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return collateralAmount Net collateral amount will be received according to the actual price in exchange for numTokens\\n   */\\n  function redeemCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory numTokens\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount\\n    )\\n  {\\n    totCollateralAmount = calculateCollateralAmount(\\n      getPriceFeedRate(self.finder, self.priceIdentifier),\\n      getCollateralDecimals(self.collateralToken),\\n      numTokens\\n    );\\n\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n  }\\n\\n  /**\\n   * @notice Given a an amount of synthetic tokens to be exchanged, returns the fee amount, net collateral and gross collateral and number of destination tokens\\n   * @param self Data type the library is attached tfo\\n   * @param numTokens Synthetic tokens amount to be exchanged\\n   * @param destinationPool Pool from which destination tokens will be received\\n   * @return totCollateralAmount Gross collateral amount according to the price\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return collateralAmount Net collateral amount (totCollateralAmount - feeAmount)\\n   * @return destNumTokens Number of destination synthetic tokens will be received according to the actual price in exchange for synthetic tokens\\n   */\\n  function exchangeCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory numTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory destNumTokens\\n    )\\n  {\\n    ISynthereumFinder _finder = self.finder;\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    uint8 collateralDecimals = getCollateralDecimals(_collateralToken);\\n\\n    totCollateralAmount = calculateCollateralAmount(\\n      getPriceFeedRate(_finder, self.priceIdentifier),\\n      collateralDecimals,\\n      numTokens\\n    );\\n\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n\\n    destNumTokens = calculateNumberOfTokens(\\n      getPriceFeedRate(_finder, destinationPool.getPriceFeedIdentifier()),\\n      collateralDecimals,\\n      collateralAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Check expiration of mint, redeem and exchange transaction\\n   * @param expiration Expiration time of the transaction\\n   */\\n  function checkExpiration(uint256 expiration) internal view {\\n    require(block.timestamp <= expiration, 'Transaction expired');\\n  }\\n\\n  /**\\n   * @notice Check if sender or receiver pool is a correct registered pool\\n   * @param self Data type the library is attached to\\n   * @param poolToCheck Pool that should be compared with this pool\\n   */\\n  function checkPool(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolGeneral poolToCheck\\n  ) internal view {\\n    IStandardERC20 collateralToken = self.collateralToken;\\n    require(\\n      collateralToken == poolToCheck.collateralToken(),\\n      'Collateral tokens do not match'\\n    );\\n\\n    ISynthereumFinder finder = self.finder;\\n\\n    require(finder == poolToCheck.synthereumFinder(), 'Finders do not match');\\n\\n    ISynthereumRegistry poolRegister =\\n      ISynthereumRegistry(\\n        finder.getImplementationAddress(SynthereumInterfaces.PoolRegistry)\\n      );\\n\\n    require(\\n      poolRegister.isDeployed(\\n        poolToCheck.syntheticTokenSymbol(),\\n        collateralToken,\\n        poolToCheck.version(),\\n        address(poolToCheck)\\n      ),\\n      'Destination pool not registered'\\n    );\\n  }\\n\\n  /**\\n   * @notice Check if an amount of collateral is enough to collateralize the position\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param collateralToCompare collateral used for checking the overcollaterlization\\n   * @return _isOverCollateralized True if position is overcollaterlized, otherwise false\\n   * @return collateralValue Collateral amount equal to the value of tokens\\n   */\\n  function isOverCollateralized(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory collateralToCompare\\n  )\\n    internal\\n    view\\n    returns (\\n      bool _isOverCollateralized,\\n      FixedPoint.Unsigned memory collateralValue\\n    )\\n  {\\n    collateralValue = calculateCollateralAmount(\\n      priceRate,\\n      collateralDecimals,\\n      lpPosition.tokensCollateralized\\n    );\\n\\n    _isOverCollateralized = collateralToCompare.isGreaterThanOrEqual(\\n      collateralValue.mul(liquidationData.collateralRequirement)\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate the unused collateral of this pool\\n   * @param self Data type the library is attached to\\n   * @param totalCollateral Total collateral used\\n   * @param totalFees Total fees gained to be whitdrawn\\n   * @param collateralReceived Collateral sent to the pool by a user or contract to be used for collateralization\\n   * @param unusedCollateral Unused collateral of the pool\\n   */\\n  function calculateUnusedCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory totalCollateral,\\n    FixedPoint.Unsigned memory totalFees,\\n    FixedPoint.Unsigned memory collateralReceived\\n  ) internal view returns (FixedPoint.Unsigned memory unusedCollateral) {\\n    // Collateral available\\n    FixedPoint.Unsigned memory actualBalance =\\n      FixedPoint.Unsigned(self.collateralToken.balanceOf(address(this)));\\n    unusedCollateral = actualBalance.sub(\\n      totalCollateral.add(totalFees).add(collateralReceived)\\n    );\\n  }\\n\\n  /**\\n   * @notice Retrun the on-chain oracle price for a pair\\n   * @param finder Synthereum finder\\n   * @param priceIdentifier Identifier of price pair\\n   * @return priceRate Latest rate of the pair\\n   */\\n  function getPriceFeedRate(ISynthereumFinder finder, bytes32 priceIdentifier)\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory priceRate)\\n  {\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n\\n    priceRate = FixedPoint.Unsigned(priceFeed.getLatestPrice(priceIdentifier));\\n  }\\n\\n  /**\\n   * @notice Retrun the number of decimals of collateral token\\n   * @param collateralToken Collateral token contract\\n   * @return decimals number of decimals\\n   */\\n  function getCollateralDecimals(IStandardERC20 collateralToken)\\n    internal\\n    view\\n    returns (uint8 decimals)\\n  {\\n    decimals = collateralToken.decimals();\\n  }\\n\\n  /**\\n   * @notice Calculate synthetic token amount starting from an amount of collateral\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param numTokens Amount of collateral from which you want to calculate synthetic token amount\\n   * @return numTokens Amount of tokens after on-chain oracle conversion\\n   */\\n  function calculateNumberOfTokens(\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) internal pure returns (FixedPoint.Unsigned memory numTokens) {\\n    numTokens = collateralAmount.mul(10**(18 - collateralDecimals)).div(\\n      priceRate\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate collateral amount starting from an amount of synthtic token\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param numTokens Amount of synthetic tokens from which you want to calculate collateral amount\\n   * @return collateralAmount Amount of collateral after on-chain oracle conversion\\n   */\\n  function calculateCollateralAmount(\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal pure returns (FixedPoint.Unsigned memory collateralAmount) {\\n    collateralAmount = numTokens.mul(priceRate).div(\\n      10**(18 - collateralDecimals)\\n    );\\n  }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {\\n  BaseControlledMintableBurnableERC20\\n} from './interfaces/BaseControlledMintableBurnableERC20.sol';\\nimport {\\n  AccessControlEnumerable\\n} from '../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title ERC20 token contract\\n */\\ncontract MintableBurnableERC20 is\\n  BaseControlledMintableBurnableERC20,\\n  AccessControlEnumerable\\n{\\n  bytes32 public constant MINTER_ROLE = keccak256('Minter');\\n\\n  bytes32 public constant BURNER_ROLE = keccak256('Burner');\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMinter() {\\n    require(hasRole(MINTER_ROLE, msg.sender), 'Sender must be the minter');\\n    _;\\n  }\\n\\n  modifier onlyBurner() {\\n    require(hasRole(BURNER_ROLE, msg.sender), 'Sender must be the burner');\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructors\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructs the ERC20 token contract\\n   * @param _tokenName Name of the token\\n   * @param _tokenSymbol Token symbol\\n   * @param _tokenDecimals Number of decimals for token\\n   */\\n  constructor(\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    uint8 _tokenDecimals\\n  )\\n    BaseControlledMintableBurnableERC20(\\n      _tokenName,\\n      _tokenSymbol,\\n      _tokenDecimals\\n    )\\n  {\\n    _setupDecimals(_tokenDecimals);\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Mint new ERC20 tokens\\n   * @param recipient Recipient of the minted tokens\\n   * @param value Amount of tokens to be minted\\n   */\\n  function mint(address recipient, uint256 value)\\n    external\\n    override\\n    onlyMinter()\\n    returns (bool)\\n  {\\n    _mint(recipient, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Burn ERC20 tokens\\n   * @param value Amount of ERC20 tokens to be burned\\n   */\\n  function burn(uint256 value) external override onlyBurner() {\\n    _burn(msg.sender, value);\\n  }\\n\\n  /**\\n   * @notice Assign a new minting role\\n   * @param account Address of the new minter\\n   */\\n  function addMinter(address account) public virtual override {\\n    grantRole(MINTER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign a new burning role\\n   * @param account Address of the new burner\\n   */\\n  function addBurner(address account) public virtual override {\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign new admin role\\n   * @param account Address of the new admin\\n   */\\n  function addAdmin(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign admin, minting and burning priviliges to an address\\n   * @param account Address to which roles are assigned\\n   */\\n  function addAdminAndMinterAndBurner(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n    grantRole(MINTER_ROLE, account);\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from minter role\\n   */\\n  function renounceMinter() public virtual override {\\n    renounceRole(MINTER_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from burner role\\n   */\\n  function renounceBurner() public virtual override {\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin role\\n   */\\n  function renounceAdmin() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin, minter and burner role\\n   */\\n  function renounceAdminAndMinterAndBurner() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(MINTER_ROLE, msg.sender);\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(owneraddress, value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport '../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\n/**\\n * @title An implementation of ERC20 with the same interface as the Compound project's testnet tokens (mainly DAI)\\n * @dev This contract can be deployed or the interface can be used to communicate with Compound's ERC20 tokens.  Note:\\n * this token should never be used to store real value since it allows permissionless minting.\\n */\\n\\ncontract TestnetERC20 is ERC20 {\\n  uint8 _decimals;\\n\\n  /**\\n   * @notice Constructs the TestnetERC20.\\n   * @param _name The name which describes the new token.\\n   * @param _symbol The ticker abbreviation of the name. Ideally < 5 chars.\\n   * @param _tokenDecimals The number of decimals to define token precision.\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint8 _tokenDecimals\\n  ) ERC20(_name, _symbol) {\\n    _decimals = _tokenDecimals;\\n  }\\n\\n  function decimals() public view virtual override(ERC20) returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  // Sample token information.\\n\\n  /**\\n   * @notice Mints value tokens to the owner address.\\n   * @param ownerAddress the address to mint to.\\n   * @param value the amount of tokens to mint.\\n   */\\n  function allocateTo(address ownerAddress, uint256 value) external {\\n    _mint(ownerAddress, value);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(recipient, value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {\\n  BaseControlledMintableBurnableERC20\\n} from './interfaces/BaseControlledMintableBurnableERC20.sol';\\nimport {\\n  AccessControlEnumerable\\n} from '../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title ERC20 token contract\\n */\\ncontract MintableBurnableERC20 is\\n  BaseControlledMintableBurnableERC20,\\n  AccessControlEnumerable\\n{\\n  bytes32 public constant MINTER_ROLE = keccak256('Minter');\\n\\n  bytes32 public constant BURNER_ROLE = keccak256('Burner');\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMinter() {\\n    require(hasRole(MINTER_ROLE, msg.sender), 'Sender must be the minter');\\n    _;\\n  }\\n\\n  modifier onlyBurner() {\\n    require(hasRole(BURNER_ROLE, msg.sender), 'Sender must be the burner');\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructors\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructs the ERC20 token contract\\n   * @param _tokenName Name of the token\\n   * @param _tokenSymbol Token symbol\\n   * @param _tokenDecimals Number of decimals for token\\n   */\\n  constructor(\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    uint8 _tokenDecimals\\n  )\\n    BaseControlledMintableBurnableERC20(\\n      _tokenName,\\n      _tokenSymbol,\\n      _tokenDecimals\\n    )\\n  {\\n    _setupDecimals(_tokenDecimals);\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(BURNER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Mint new ERC20 tokens\\n   * @param recipient Recipient of the minted tokens\\n   * @param value Amount of tokens to be minted\\n   */\\n  function mint(address recipient, uint256 value)\\n    external\\n    override\\n    onlyMinter()\\n    returns (bool)\\n  {\\n    _mint(recipient, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Burn ERC20 tokens\\n   * @param value Amount of ERC20 tokens to be burned\\n   */\\n  function burn(uint256 value) external override onlyBurner() {\\n    _burn(msg.sender, value);\\n  }\\n\\n  /**\\n   * @notice Assign a new minting role\\n   * @param account Address of the new minter\\n   */\\n  function addMinter(address account) public virtual override {\\n    grantRole(MINTER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign a new burning role\\n   * @param account Address of the new burner\\n   */\\n  function addBurner(address account) public virtual override {\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign new admin role\\n   * @param account Address of the new admin\\n   */\\n  function addAdmin(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Assign admin, minting and burning priviliges to an address\\n   * @param account Address to which roles are assigned\\n   */\\n  function addAdminAndMinterAndBurner(address account) public virtual override {\\n    grantRole(DEFAULT_ADMIN_ROLE, account);\\n    grantRole(MINTER_ROLE, account);\\n    grantRole(BURNER_ROLE, account);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from minter role\\n   */\\n  function renounceMinter() public virtual override {\\n    renounceRole(MINTER_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from burner role\\n   */\\n  function renounceBurner() public virtual override {\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin role\\n   */\\n  function renounceAdmin() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin, minter and burner role\\n   */\\n  function renounceAdminAndMinterAndBurner() public virtual override {\\n    renounceRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    renounceRole(MINTER_ROLE, msg.sender);\\n    renounceRole(BURNER_ROLE, msg.sender);\\n  }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}