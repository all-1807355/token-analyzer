{
  "total_matches": 8,
  "patterns_found": {
    "minting_mechanics": {
      "count": 8,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./utils/ERC20PermitLight.sol\\\";\\r\\nimport \\\"./Equity.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FrankenCoin\\r\\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\\r\\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\\r\\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\\r\\n */\\r\\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\\r\\n    /**\\r\\n     * @notice Minimal fee and application period when suggesting a new minter.\\r\\n     */\\r\\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\\r\\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\\r\\n\\r\\n    /**\\r\\n     * @notice The contract that holds the reserve.\\r\\n     */\\r\\n    IReserve public immutable override reserve;\\r\\n\\r\\n    /**\\r\\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\\r\\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\\r\\n     * million (ppm) in reserve calculations.\\r\\n     */\\r\\n    uint256 private minterReserveE6;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\\r\\n     * to mint Frankencoins.\\r\\n     */\\r\\n    mapping(address minter => uint256 validityStart) public minters;\\r\\n\\r\\n    /**\\r\\n     * @notice List of positions that are allowed to mint and the minter that registered them.\\r\\n     */\\r\\n    mapping(address position => address registeringMinter) public positions;\\r\\n\\r\\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\\r\\n    event MinterDenied(address indexed minter, string message);\\r\\n    event Loss(address indexed reportingMinter, uint256 amount);\\r\\n    event Profit(address indexed reportingMinter, uint256 amount);\\r\\n\\r\\n    error PeriodTooShort();\\r\\n    error FeeTooLow();\\r\\n    error AlreadyRegistered();\\r\\n    error NotMinter();\\r\\n    error TooLate();\\r\\n\\r\\n    modifier minterOnly() {\\r\\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\\r\\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\\r\\n     */\\r\\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\\r\\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\\r\\n        reserve = new Equity(this);\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"ZCHF\\\";\\r\\n    }\\r\\n\\r\\n    function initialize(address _minter, string calldata _message) external {\\r\\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\\r\\n        minters[_minter] = block.timestamp;\\r\\n        emit MinterApplied(_minter, 0, 0, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\\r\\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\\r\\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\\r\\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\\r\\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\\r\\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\\r\\n     * the proposed minter.\\r\\n     *\\r\\n     * @param _minter              An address that is given the permission to mint Frankencoins\\r\\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\\r\\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\\r\\n     * @param _message             An optional human readable message to everyone watching this contract\\r\\n     */\\r\\n    function suggestMinter(\\r\\n        address _minter,\\r\\n        uint256 _applicationPeriod,\\r\\n        uint256 _applicationFee,\\r\\n        string calldata _message\\r\\n    ) external override {\\r\\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\\r\\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\\r\\n        if (minters[_minter] != 0) revert AlreadyRegistered();\\r\\n        _collectProfits(address(this), msg.sender, _applicationFee);\\r\\n        minters[_minter] = block.timestamp + _applicationPeriod;\\r\\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\\r\\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\\r\\n     * giving them arbitrary allowances does not pose an additional risk.\\r\\n     */\\r\\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\\r\\n        uint256 explicit = super._allowance(owner, spender);\\r\\n        if (explicit > 0) {\\r\\n            return explicit; // don't waste gas checking minter\\r\\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\\r\\n            return INFINITY;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve provided by the owners of collateralized positions.\\r\\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\\r\\n     */\\r\\n    function minterReserve() public view returns (uint256) {\\r\\n        return minterReserveE6 / 1000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\\r\\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\\r\\n     */\\r\\n    function registerPosition(address _position) external override {\\r\\n        if (!isMinter(msg.sender)) revert NotMinter();\\r\\n        positions[_position] = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\\r\\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\\r\\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\\r\\n     * constitutes profits attributable to the pool share holders.\\r\\n     */\\r\\n    function equity() public view returns (uint256) {\\r\\n        uint256 balance = balanceOf(address(reserve));\\r\\n        uint256 minReserve = minterReserve();\\r\\n        if (balance <= minReserve) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return balance - minReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Qualified pool share holders can deny minters during the application period.\\r\\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\\r\\n     */\\r\\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\\r\\n        if (block.timestamp > minters[_minter]) revert TooLate();\\r\\n        reserve.checkQualified(msg.sender, _helpers);\\r\\n        delete minters[_minter];\\r\\n        emit MinterDenied(_minter, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\\r\\n     * the minting fee and the reserve to the right place.\\r\\n     */\\r\\n    function mintWithReserve(\\r\\n        address _target,\\r\\n        uint256 _amount,\\r\\n        uint32 _reservePPM,\\r\\n        uint32 _feesPPM\\r\\n    ) external override minterOnly {\\r\\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\\r\\n        _mint(_target, usableMint);\\r\\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\\r\\n        minterReserveE6 += _amount * _reservePPM;\\r\\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\\r\\n    }\\r\\n\\r\\n    function mint(address _target, uint256 _amount) external override minterOnly {\\r\\n        _mint(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Anyone is allowed to burn their ZCHF.\\r\\n     */\\r\\n    function burn(uint256 _amount) external {\\r\\n        _burn(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn someone elses ZCHF.\\r\\n     */\\r\\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\\r\\n        _burn(_owner, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\\r\\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\\r\\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\\r\\n     *\\r\\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\\r\\n     * the same _reservePPM amount.\\r\\n     *\\r\\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\\r\\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\\r\\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\\r\\n     * reassigned to the pool share holders.\\r\\n     */\\r\\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 reserveReduction = amount * reservePPM;\\r\\n        if (reserveReduction > minterReserveE6) {\\r\\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\\r\\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\\r\\n        } else {\\r\\n            minterReserveE6 -= reserveReduction;\\r\\n            emit Profit(msg.sender, reserveReduction / 1000_000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\\r\\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\\r\\n     * same _reservePPM amount.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\\r\\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\\r\\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\\r\\n     * they owe.\\r\\n     */\\r\\n    function burnWithReserve(\\r\\n        uint256 _amountExcludingReserve,\\r\\n        uint32 _reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\\r\\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\\r\\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\\r\\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\\r\\n        return freedAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\\r\\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\\r\\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\\r\\n     * reducing the minter reserve by 10.\\r\\n     */\\r\\n    function burnFromWithReserve(\\r\\n        address payer,\\r\\n        uint256 targetTotalBurnAmount,\\r\\n        uint32 reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\\r\\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\\r\\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\\r\\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\\r\\n        return assigned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\\r\\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\\r\\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\\r\\n     */\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\\r\\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\\r\\n        uint256 currentReserve = balanceOf(address(reserve));\\r\\n        uint256 minterReserve_ = minterReserve();\\r\\n        if (currentReserve < minterReserve_) {\\r\\n            // not enough reserves, owner has to take a loss\\r\\n            return (theoreticalReserve * currentReserve) / minterReserve_;\\r\\n        } else {\\r\\n            return theoreticalReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\\r\\n     * taking into account potential losses. Example values in the comments.\\r\\n     */\\r\\n    function calculateFreedAmount(\\r\\n        uint256 amountExcludingReserve /* 41 */,\\r\\n        uint32 reservePPM /* 20% */\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\\r\\n        uint256 minterReserve_ = minterReserve(); // 20\\r\\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\\r\\n            ? (reservePPM * currentReserve) / minterReserve_\\r\\n            : reservePPM; // 18%\\r\\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\\r\\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\\r\\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\\r\\n     *\\r\\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\\r\\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\\r\\n     * by the reserve.\\r\\n     */\\r\\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\\r\\n        uint256 reserveLeft = balanceOf(address(reserve));\\r\\n        if (reserveLeft >= _amount) {\\r\\n            _transfer(address(reserve), source, _amount);\\r\\n        } else {\\r\\n            _transfer(address(reserve), source, reserveLeft);\\r\\n            _mint(source, _amount - reserveLeft);\\r\\n        }\\r\\n        emit Loss(source, _amount);\\r\\n    }\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\\r\\n        _collectProfits(msg.sender, source, _amount);\\r\\n    }\\r\\n\\r\\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\\r\\n        _transfer(source, address(reserve), _amount);\\r\\n        emit Profit(minter, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is an approved minter.\\r\\n     */\\r\\n    function isMinter(address _minter) public view override returns (bool) {\\r\\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\\r\\n     */\\r\\n    function getPositionParent(address _position) public view override returns (address) {\\r\\n        return positions[_position];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(msg.sender, shares)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Frankencoin.sol\\\";\\r\\nimport \\\"./utils/MathUtil.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Equity\\r\\n * @notice If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\\r\\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\\r\\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\\r\\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\\r\\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\\r\\n * weighted reserve pool shares gains veto power and can veto new proposals.\\r\\n */\\r\\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\\r\\n    /**\\r\\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\\r\\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\\r\\n     *\\r\\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\\r\\n     *\\r\\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\\r\\n     * |          1000 |          3000 |             3 |         1000 |\\r\\n     * |       1000000 |       3000000 |           300 |        10000 |\\r\\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\\r\\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\\r\\n     *\\r\\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\\r\\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\\r\\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\\r\\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\\r\\n     */\\r\\n    uint32 public constant VALUATION_FACTOR = 3;\\r\\n\\r\\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\\r\\n\\r\\n    /**\\r\\n     * @notice The quorum in basis points. 100 is 1%.\\r\\n     */\\r\\n    uint32 private constant QUORUM = 200;\\r\\n\\r\\n    /**\\r\\n     * @notice The number of digits to store the average holding time of share tokens.\\r\\n     */\\r\\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\\r\\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\\r\\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\\r\\n     * holding duration of your shares is only 55 days < 90 days.\\r\\n     */\\r\\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\\r\\n\\r\\n    Frankencoin public immutable zchf;\\r\\n\\r\\n    /**\\r\\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\\r\\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\\r\\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\\r\\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\\r\\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\\r\\n     *   192 - 60 - 44 - 20 = 68 Bits\\r\\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\\r\\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\\r\\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\\r\\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\\r\\n     */\\r\\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\\r\\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\\r\\n\\r\\n    /**\\r\\n     * @notice Keeping track on who delegated votes to whom.\\r\\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\\r\\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\\r\\n     */\\r\\n    mapping(address owner => address delegate) public delegates;\\r\\n\\r\\n    /**\\r\\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\\r\\n     */\\r\\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\\r\\n\\r\\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\\r\\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\\r\\n\\r\\n    constructor(Frankencoin zchf_) ERC20(18) {\\r\\n        zchf = zchf_;\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin Pool Share\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"FPS\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the price of one FPS in ZCHF with 18 decimals precision.\\r\\n     */\\r\\n    function price() public view returns (uint256) {\\r\\n        uint256 equity = zchf.equity();\\r\\n        if (equity == 0 || totalSupply() == 0) {\\r\\n            return ONE_DEC18; // initial price is 1000 ZCHF for the first 1000 FPS\\r\\n        } else {\\r\\n            return (VALUATION_FACTOR * zchf.equity() * ONE_DEC18) / totalSupply();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n        if (amount > 0) {\\r\\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\\r\\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\\r\\n            // faster in the future, requiring an adjustment of the anchor.\\r\\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\\r\\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\\r\\n            _adjustTotalVotes(from, amount, roundingLoss);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the given address is allowed to redeem FPS, which is the\\r\\n     * case after their average holding duration is larger than the required minimum.\\r\\n     */\\r\\n    function canRedeem(address owner) public view returns (bool) {\\r\\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\\r\\n     * @param from      sender\\r\\n     * @param amount    amount to be sent\\r\\n     */\\r\\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\\r\\n        uint64 time = _anchorTime();\\r\\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\\r\\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\\r\\n        totalVotesAnchorTime = time;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\\r\\n     * votes does not change despite the higher balance.\\r\\n     * @param to        receiver address\\r\\n     * @param amount    amount to be received\\r\\n     * @return the number of votes lost due to rounding errors\\r\\n     */\\r\\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\\r\\n        if (to != address(0x0)) {\\r\\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\\r\\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\\r\\n            // new example anchor is only 21 / 11 = 1 second in the past\\r\\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\\r\\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\\r\\n        } else {\\r\\n            // optimization for burn, vote anchor of null address does not matter\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Time stamp with some additional bits for higher resolution.\\r\\n     */\\r\\n    function _anchorTime() internal view returns (uint64) {\\r\\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The relative voting power of the address.\\r\\n     * @return A percentage with 1e18 being 100%\\r\\n     */\\r\\n    function relativeVotes(address holder) external view returns (uint256) {\\r\\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The votes of the holder, excluding votes from delegates.\\r\\n     */\\r\\n    function votes(address holder) public view returns (uint256) {\\r\\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice How long the holder already held onto their average FPS in seconds.\\r\\n     */\\r\\n    function holdingDuration(address holder) public view returns (uint256) {\\r\\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of votes in the system.\\r\\n     */\\r\\n    function totalVotes() public view returns (uint256) {\\r\\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\\r\\n     * @param sender    The address whose total voting power is of interest\\r\\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\\r\\n     *                  The call fails if the list contains an address that does not delegate to sender.\\r\\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\\r\\n     * @return          The total number of votes of sender at the current point in time.\\r\\n     */\\r\\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\\r\\n        uint256 _votes = votes(sender);\\r\\n        require(_checkDuplicatesAndSorted(helpers));\\r\\n        for (uint i = 0; i < helpers.length; i++) {\\r\\n            address current = helpers[i];\\r\\n            require(current != sender);\\r\\n            require(_canVoteFor(sender, current));\\r\\n            _votes += votes(current);\\r\\n        }\\r\\n        return _votes;\\r\\n    }\\r\\n\\r\\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\\r\\n        if (helpers.length <= 1) {\\r\\n            return true;\\r\\n        } else {\\r\\n            address prevAddress = helpers[0];\\r\\n            for (uint i = 1; i < helpers.length; i++) {\\r\\n                if (helpers[i] <= prevAddress) {\\r\\n                    return false;\\r\\n                }\\r\\n                prevAddress = helpers[i];\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\\r\\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\\r\\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events.\\r\\n     */\\r\\n    function checkQualified(address sender, address[] calldata helpers) public view override {\\r\\n        uint256 _votes = votesDelegated(sender, helpers);\\r\\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\\r\\n    }\\r\\n\\r\\n    error NotQualified();\\r\\n\\r\\n    /**\\r\\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\\r\\n     * from the sender.\\r\\n     */\\r\\n    function delegateVoteTo(address delegate) external {\\r\\n        delegates[msg.sender] = delegate;\\r\\n        emit Delegation(msg.sender, delegate);\\r\\n    }\\r\\n\\r\\n    function _canVoteFor(address delegate, address owner) internal view returns (bool) {\\r\\n        if (owner == delegate) {\\r\\n            return true;\\r\\n        } else if (owner == address(0x0)) {\\r\\n            return false;\\r\\n        } else {\\r\\n            return _canVoteFor(delegate, delegates[owner]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\\r\\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\\r\\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\\r\\n     * gives full control over the system to whoever has 51% of the votes.\\r\\n     *\\r\\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\\r\\n     * method on their own.\\r\\n     * @param targets   The target addresses to remove votes from\\r\\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\\r\\n     */\\r\\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\\r\\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\\r\\n        uint256 destroyedVotes = 0;\\r\\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\\r\\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\\r\\n        }\\r\\n        require(destroyedVotes > 0); // sanity check\\r\\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\\r\\n        totalVotesAnchorTime = _anchorTime();\\r\\n    }\\r\\n\\r\\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\\r\\n        uint256 votesBefore = votes(target);\\r\\n        if (amount >= votesBefore) {\\r\\n            amount = votesBefore;\\r\\n            voteAnchor[target] = _anchorTime();\\r\\n            return votesBefore;\\r\\n        } else {\\r\\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\\r\\n            return votesBefore - votes(target);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Call this method to obtain newly minted pool shares in exchange for Frankencoins.\\r\\n     * No allowance required (i.e. it is hardcoded in the Frankencoin token contract).\\r\\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\\r\\n     *\\r\\n     * @dev If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\\r\\n     *\\r\\n     * @param amount            Frankencoins to invest\\r\\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\\r\\n     */\\r\\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\\r\\n        zchf.transferFrom(msg.sender, address(this), amount);\\r\\n        uint256 equity = zchf.equity();\\r\\n        require(equity >= MINIMUM_EQUITY, \\\"insuf equity\\\"); // ensures that the initial deposit is at least 1000 ZCHF\\r\\n\\r\\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\\r\\n        require(shares >= expectedShares);\\r\\n        _mint(msg.sender, shares);\\r\\n        emit Trade(msg.sender, int(shares), amount, price());\\r\\n\\r\\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\\r\\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\\r\\n        require(totalSupply() <= type(uint96).max, \\\"total supply exceeded\\\");\\r\\n        return shares;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate shares received when investing Frankencoins\\r\\n     * @param investment    ZCHF to be invested\\r\\n     * @return shares to be received in return\\r\\n     */\\r\\n    function calculateShares(uint256 investment) external view returns (uint256) {\\r\\n        return _calculateShares(zchf.equity(), investment);\\r\\n    }\\r\\n\\r\\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\\r\\n        uint256 totalShares = totalSupply();\\r\\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\\r\\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\\r\\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\\r\\n            ? totalShares + 1000 * ONE_DEC18\\r\\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\\r\\n        return newTotalShares - totalShares;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\\r\\n     * @return The amount of ZCHF transferred to the target\\r\\n     */\\r\\n    function redeem(address target, uint256 shares) external returns (uint256) {\\r\\n        return _redeemFrom(msg.sender, target, shares);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\\r\\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\\r\\n     */\\r\\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\\r\\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\\r\\n        require(proceeds >= expectedProceeds);\\r\\n        return proceeds;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeem FPS based on an allowance from the owner to the caller.\\r\\n     * See also redeemExpected(...).\\r\\n     */\\r\\n    function redeemFrom(\\r\\n        address owner,\\r\\n        address target,\\r\\n        uint256 shares,\\r\\n        uint256 expectedProceeds\\r\\n    ) external returns (uint256) {\\r\\n        _useAllowance(owner, msg.sender, shares);\\r\\n        uint256 proceeds = _redeemFrom(owner, target, shares);\\r\\n        require(proceeds >= expectedProceeds);\\r\\n        return proceeds;\\r\\n    }\\r\\n\\r\\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\\r\\n        require(canRedeem(owner));\\r\\n        uint256 proceeds = calculateProceeds(shares);\\r\\n        _burn(owner, shares);\\r\\n        zchf.transfer(target, proceeds);\\r\\n        emit Trade(owner, -int(shares), proceeds, price());\\r\\n        return proceeds;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate ZCHF received when depositing shares\\r\\n     * @param shares number of shares we want to exchange for ZCHF,\\r\\n     *               in dec18 format\\r\\n     * @return amount of ZCHF received for the shares\\r\\n     */\\r\\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\\r\\n        uint256 totalShares = totalSupply();\\r\\n        require(shares + ONE_DEC18 < totalShares, \\\"too many shares\\\"); // make sure there is always at least one share\\r\\n        uint256 capital = zchf.equity();\\r\\n        uint256 reductionAfterFees = (shares * 997) / 1000;\\r\\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\\r\\n        return capital - newCapital;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\\r\\n     * and we should allow qualified FPS holders to restructure the system.\\r\\n     *\\r\\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\\r\\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\\r\\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\\r\\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\\r\\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\\r\\n     *\\r\\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\\r\\n     * @param addressesToWipe  A list of addresses whose FPS will be burned to zero\\r\\n     */\\r\\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\\r\\n        require(zchf.equity() < MINIMUM_EQUITY);\\r\\n        checkQualified(msg.sender, helpers);\\r\\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\\r\\n            address current = addressesToWipe[i];\\r\\n            _burn(current, balanceOf(current));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_target, usablemint)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./utils/ERC20PermitLight.sol\\\";\\r\\nimport \\\"./Equity.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FrankenCoin\\r\\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\\r\\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\\r\\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\\r\\n */\\r\\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\\r\\n    /**\\r\\n     * @notice Minimal fee and application period when suggesting a new minter.\\r\\n     */\\r\\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\\r\\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\\r\\n\\r\\n    /**\\r\\n     * @notice The contract that holds the reserve.\\r\\n     */\\r\\n    IReserve public immutable override reserve;\\r\\n\\r\\n    /**\\r\\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\\r\\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\\r\\n     * million (ppm) in reserve calculations.\\r\\n     */\\r\\n    uint256 private minterReserveE6;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\\r\\n     * to mint Frankencoins.\\r\\n     */\\r\\n    mapping(address minter => uint256 validityStart) public minters;\\r\\n\\r\\n    /**\\r\\n     * @notice List of positions that are allowed to mint and the minter that registered them.\\r\\n     */\\r\\n    mapping(address position => address registeringMinter) public positions;\\r\\n\\r\\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\\r\\n    event MinterDenied(address indexed minter, string message);\\r\\n    event Loss(address indexed reportingMinter, uint256 amount);\\r\\n    event Profit(address indexed reportingMinter, uint256 amount);\\r\\n\\r\\n    error PeriodTooShort();\\r\\n    error FeeTooLow();\\r\\n    error AlreadyRegistered();\\r\\n    error NotMinter();\\r\\n    error TooLate();\\r\\n\\r\\n    modifier minterOnly() {\\r\\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\\r\\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\\r\\n     */\\r\\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\\r\\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\\r\\n        reserve = new Equity(this);\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"ZCHF\\\";\\r\\n    }\\r\\n\\r\\n    function initialize(address _minter, string calldata _message) external {\\r\\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\\r\\n        minters[_minter] = block.timestamp;\\r\\n        emit MinterApplied(_minter, 0, 0, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\\r\\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\\r\\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\\r\\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\\r\\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\\r\\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\\r\\n     * the proposed minter.\\r\\n     *\\r\\n     * @param _minter              An address that is given the permission to mint Frankencoins\\r\\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\\r\\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\\r\\n     * @param _message             An optional human readable message to everyone watching this contract\\r\\n     */\\r\\n    function suggestMinter(\\r\\n        address _minter,\\r\\n        uint256 _applicationPeriod,\\r\\n        uint256 _applicationFee,\\r\\n        string calldata _message\\r\\n    ) external override {\\r\\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\\r\\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\\r\\n        if (minters[_minter] != 0) revert AlreadyRegistered();\\r\\n        _collectProfits(address(this), msg.sender, _applicationFee);\\r\\n        minters[_minter] = block.timestamp + _applicationPeriod;\\r\\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\\r\\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\\r\\n     * giving them arbitrary allowances does not pose an additional risk.\\r\\n     */\\r\\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\\r\\n        uint256 explicit = super._allowance(owner, spender);\\r\\n        if (explicit > 0) {\\r\\n            return explicit; // don't waste gas checking minter\\r\\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\\r\\n            return INFINITY;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve provided by the owners of collateralized positions.\\r\\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\\r\\n     */\\r\\n    function minterReserve() public view returns (uint256) {\\r\\n        return minterReserveE6 / 1000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\\r\\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\\r\\n     */\\r\\n    function registerPosition(address _position) external override {\\r\\n        if (!isMinter(msg.sender)) revert NotMinter();\\r\\n        positions[_position] = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\\r\\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\\r\\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\\r\\n     * constitutes profits attributable to the pool share holders.\\r\\n     */\\r\\n    function equity() public view returns (uint256) {\\r\\n        uint256 balance = balanceOf(address(reserve));\\r\\n        uint256 minReserve = minterReserve();\\r\\n        if (balance <= minReserve) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return balance - minReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Qualified pool share holders can deny minters during the application period.\\r\\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\\r\\n     */\\r\\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\\r\\n        if (block.timestamp > minters[_minter]) revert TooLate();\\r\\n        reserve.checkQualified(msg.sender, _helpers);\\r\\n        delete minters[_minter];\\r\\n        emit MinterDenied(_minter, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\\r\\n     * the minting fee and the reserve to the right place.\\r\\n     */\\r\\n    function mintWithReserve(\\r\\n        address _target,\\r\\n        uint256 _amount,\\r\\n        uint32 _reservePPM,\\r\\n        uint32 _feesPPM\\r\\n    ) external override minterOnly {\\r\\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\\r\\n        _mint(_target, usableMint);\\r\\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\\r\\n        minterReserveE6 += _amount * _reservePPM;\\r\\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\\r\\n    }\\r\\n\\r\\n    function mint(address _target, uint256 _amount) external override minterOnly {\\r\\n        _mint(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Anyone is allowed to burn their ZCHF.\\r\\n     */\\r\\n    function burn(uint256 _amount) external {\\r\\n        _burn(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn someone elses ZCHF.\\r\\n     */\\r\\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\\r\\n        _burn(_owner, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\\r\\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\\r\\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\\r\\n     *\\r\\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\\r\\n     * the same _reservePPM amount.\\r\\n     *\\r\\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\\r\\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\\r\\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\\r\\n     * reassigned to the pool share holders.\\r\\n     */\\r\\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 reserveReduction = amount * reservePPM;\\r\\n        if (reserveReduction > minterReserveE6) {\\r\\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\\r\\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\\r\\n        } else {\\r\\n            minterReserveE6 -= reserveReduction;\\r\\n            emit Profit(msg.sender, reserveReduction / 1000_000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\\r\\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\\r\\n     * same _reservePPM amount.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\\r\\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\\r\\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\\r\\n     * they owe.\\r\\n     */\\r\\n    function burnWithReserve(\\r\\n        uint256 _amountExcludingReserve,\\r\\n        uint32 _reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\\r\\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\\r\\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\\r\\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\\r\\n        return freedAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\\r\\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\\r\\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\\r\\n     * reducing the minter reserve by 10.\\r\\n     */\\r\\n    function burnFromWithReserve(\\r\\n        address payer,\\r\\n        uint256 targetTotalBurnAmount,\\r\\n        uint32 reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\\r\\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\\r\\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\\r\\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\\r\\n        return assigned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\\r\\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\\r\\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\\r\\n     */\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\\r\\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\\r\\n        uint256 currentReserve = balanceOf(address(reserve));\\r\\n        uint256 minterReserve_ = minterReserve();\\r\\n        if (currentReserve < minterReserve_) {\\r\\n            // not enough reserves, owner has to take a loss\\r\\n            return (theoreticalReserve * currentReserve) / minterReserve_;\\r\\n        } else {\\r\\n            return theoreticalReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\\r\\n     * taking into account potential losses. Example values in the comments.\\r\\n     */\\r\\n    function calculateFreedAmount(\\r\\n        uint256 amountExcludingReserve /* 41 */,\\r\\n        uint32 reservePPM /* 20% */\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\\r\\n        uint256 minterReserve_ = minterReserve(); // 20\\r\\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\\r\\n            ? (reservePPM * currentReserve) / minterReserve_\\r\\n            : reservePPM; // 18%\\r\\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\\r\\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\\r\\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\\r\\n     *\\r\\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\\r\\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\\r\\n     * by the reserve.\\r\\n     */\\r\\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\\r\\n        uint256 reserveLeft = balanceOf(address(reserve));\\r\\n        if (reserveLeft >= _amount) {\\r\\n            _transfer(address(reserve), source, _amount);\\r\\n        } else {\\r\\n            _transfer(address(reserve), source, reserveLeft);\\r\\n            _mint(source, _amount - reserveLeft);\\r\\n        }\\r\\n        emit Loss(source, _amount);\\r\\n    }\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\\r\\n        _collectProfits(msg.sender, source, _amount);\\r\\n    }\\r\\n\\r\\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\\r\\n        _transfer(source, address(reserve), _amount);\\r\\n        emit Profit(minter, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is an approved minter.\\r\\n     */\\r\\n    function isMinter(address _minter) public view override returns (bool) {\\r\\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\\r\\n     */\\r\\n    function getPositionParent(address _position) public view override returns (address) {\\r\\n        return positions[_position];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(reserve)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./utils/ERC20PermitLight.sol\\\";\\r\\nimport \\\"./Equity.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FrankenCoin\\r\\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\\r\\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\\r\\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\\r\\n */\\r\\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\\r\\n    /**\\r\\n     * @notice Minimal fee and application period when suggesting a new minter.\\r\\n     */\\r\\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\\r\\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\\r\\n\\r\\n    /**\\r\\n     * @notice The contract that holds the reserve.\\r\\n     */\\r\\n    IReserve public immutable override reserve;\\r\\n\\r\\n    /**\\r\\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\\r\\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\\r\\n     * million (ppm) in reserve calculations.\\r\\n     */\\r\\n    uint256 private minterReserveE6;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\\r\\n     * to mint Frankencoins.\\r\\n     */\\r\\n    mapping(address minter => uint256 validityStart) public minters;\\r\\n\\r\\n    /**\\r\\n     * @notice List of positions that are allowed to mint and the minter that registered them.\\r\\n     */\\r\\n    mapping(address position => address registeringMinter) public positions;\\r\\n\\r\\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\\r\\n    event MinterDenied(address indexed minter, string message);\\r\\n    event Loss(address indexed reportingMinter, uint256 amount);\\r\\n    event Profit(address indexed reportingMinter, uint256 amount);\\r\\n\\r\\n    error PeriodTooShort();\\r\\n    error FeeTooLow();\\r\\n    error AlreadyRegistered();\\r\\n    error NotMinter();\\r\\n    error TooLate();\\r\\n\\r\\n    modifier minterOnly() {\\r\\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\\r\\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\\r\\n     */\\r\\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\\r\\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\\r\\n        reserve = new Equity(this);\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"ZCHF\\\";\\r\\n    }\\r\\n\\r\\n    function initialize(address _minter, string calldata _message) external {\\r\\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\\r\\n        minters[_minter] = block.timestamp;\\r\\n        emit MinterApplied(_minter, 0, 0, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\\r\\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\\r\\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\\r\\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\\r\\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\\r\\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\\r\\n     * the proposed minter.\\r\\n     *\\r\\n     * @param _minter              An address that is given the permission to mint Frankencoins\\r\\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\\r\\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\\r\\n     * @param _message             An optional human readable message to everyone watching this contract\\r\\n     */\\r\\n    function suggestMinter(\\r\\n        address _minter,\\r\\n        uint256 _applicationPeriod,\\r\\n        uint256 _applicationFee,\\r\\n        string calldata _message\\r\\n    ) external override {\\r\\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\\r\\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\\r\\n        if (minters[_minter] != 0) revert AlreadyRegistered();\\r\\n        _collectProfits(address(this), msg.sender, _applicationFee);\\r\\n        minters[_minter] = block.timestamp + _applicationPeriod;\\r\\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\\r\\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\\r\\n     * giving them arbitrary allowances does not pose an additional risk.\\r\\n     */\\r\\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\\r\\n        uint256 explicit = super._allowance(owner, spender);\\r\\n        if (explicit > 0) {\\r\\n            return explicit; // don't waste gas checking minter\\r\\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\\r\\n            return INFINITY;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve provided by the owners of collateralized positions.\\r\\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\\r\\n     */\\r\\n    function minterReserve() public view returns (uint256) {\\r\\n        return minterReserveE6 / 1000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\\r\\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\\r\\n     */\\r\\n    function registerPosition(address _position) external override {\\r\\n        if (!isMinter(msg.sender)) revert NotMinter();\\r\\n        positions[_position] = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\\r\\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\\r\\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\\r\\n     * constitutes profits attributable to the pool share holders.\\r\\n     */\\r\\n    function equity() public view returns (uint256) {\\r\\n        uint256 balance = balanceOf(address(reserve));\\r\\n        uint256 minReserve = minterReserve();\\r\\n        if (balance <= minReserve) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return balance - minReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Qualified pool share holders can deny minters during the application period.\\r\\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\\r\\n     */\\r\\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\\r\\n        if (block.timestamp > minters[_minter]) revert TooLate();\\r\\n        reserve.checkQualified(msg.sender, _helpers);\\r\\n        delete minters[_minter];\\r\\n        emit MinterDenied(_minter, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\\r\\n     * the minting fee and the reserve to the right place.\\r\\n     */\\r\\n    function mintWithReserve(\\r\\n        address _target,\\r\\n        uint256 _amount,\\r\\n        uint32 _reservePPM,\\r\\n        uint32 _feesPPM\\r\\n    ) external override minterOnly {\\r\\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\\r\\n        _mint(_target, usableMint);\\r\\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\\r\\n        minterReserveE6 += _amount * _reservePPM;\\r\\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\\r\\n    }\\r\\n\\r\\n    function mint(address _target, uint256 _amount) external override minterOnly {\\r\\n        _mint(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Anyone is allowed to burn their ZCHF.\\r\\n     */\\r\\n    function burn(uint256 _amount) external {\\r\\n        _burn(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn someone elses ZCHF.\\r\\n     */\\r\\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\\r\\n        _burn(_owner, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\\r\\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\\r\\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\\r\\n     *\\r\\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\\r\\n     * the same _reservePPM amount.\\r\\n     *\\r\\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\\r\\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\\r\\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\\r\\n     * reassigned to the pool share holders.\\r\\n     */\\r\\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 reserveReduction = amount * reservePPM;\\r\\n        if (reserveReduction > minterReserveE6) {\\r\\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\\r\\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\\r\\n        } else {\\r\\n            minterReserveE6 -= reserveReduction;\\r\\n            emit Profit(msg.sender, reserveReduction / 1000_000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\\r\\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\\r\\n     * same _reservePPM amount.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\\r\\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\\r\\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\\r\\n     * they owe.\\r\\n     */\\r\\n    function burnWithReserve(\\r\\n        uint256 _amountExcludingReserve,\\r\\n        uint32 _reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\\r\\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\\r\\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\\r\\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\\r\\n        return freedAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\\r\\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\\r\\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\\r\\n     * reducing the minter reserve by 10.\\r\\n     */\\r\\n    function burnFromWithReserve(\\r\\n        address payer,\\r\\n        uint256 targetTotalBurnAmount,\\r\\n        uint32 reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\\r\\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\\r\\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\\r\\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\\r\\n        return assigned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\\r\\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\\r\\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\\r\\n     */\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\\r\\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\\r\\n        uint256 currentReserve = balanceOf(address(reserve));\\r\\n        uint256 minterReserve_ = minterReserve();\\r\\n        if (currentReserve < minterReserve_) {\\r\\n            // not enough reserves, owner has to take a loss\\r\\n            return (theoreticalReserve * currentReserve) / minterReserve_;\\r\\n        } else {\\r\\n            return theoreticalReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\\r\\n     * taking into account potential losses. Example values in the comments.\\r\\n     */\\r\\n    function calculateFreedAmount(\\r\\n        uint256 amountExcludingReserve /* 41 */,\\r\\n        uint32 reservePPM /* 20% */\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\\r\\n        uint256 minterReserve_ = minterReserve(); // 20\\r\\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\\r\\n            ? (reservePPM * currentReserve) / minterReserve_\\r\\n            : reservePPM; // 18%\\r\\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\\r\\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\\r\\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\\r\\n     *\\r\\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\\r\\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\\r\\n     * by the reserve.\\r\\n     */\\r\\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\\r\\n        uint256 reserveLeft = balanceOf(address(reserve));\\r\\n        if (reserveLeft >= _amount) {\\r\\n            _transfer(address(reserve), source, _amount);\\r\\n        } else {\\r\\n            _transfer(address(reserve), source, reserveLeft);\\r\\n            _mint(source, _amount - reserveLeft);\\r\\n        }\\r\\n        emit Loss(source, _amount);\\r\\n    }\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\\r\\n        _collectProfits(msg.sender, source, _amount);\\r\\n    }\\r\\n\\r\\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\\r\\n        _transfer(source, address(reserve), _amount);\\r\\n        emit Profit(minter, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is an approved minter.\\r\\n     */\\r\\n    function isMinter(address _minter) public view override returns (bool) {\\r\\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\\r\\n     */\\r\\n    function getPositionParent(address _position) public view override returns (address) {\\r\\n        return positions[_position];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_target, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./utils/ERC20PermitLight.sol\\\";\\r\\nimport \\\"./Equity.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FrankenCoin\\r\\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\\r\\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\\r\\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\\r\\n */\\r\\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\\r\\n    /**\\r\\n     * @notice Minimal fee and application period when suggesting a new minter.\\r\\n     */\\r\\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\\r\\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\\r\\n\\r\\n    /**\\r\\n     * @notice The contract that holds the reserve.\\r\\n     */\\r\\n    IReserve public immutable override reserve;\\r\\n\\r\\n    /**\\r\\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\\r\\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\\r\\n     * million (ppm) in reserve calculations.\\r\\n     */\\r\\n    uint256 private minterReserveE6;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\\r\\n     * to mint Frankencoins.\\r\\n     */\\r\\n    mapping(address minter => uint256 validityStart) public minters;\\r\\n\\r\\n    /**\\r\\n     * @notice List of positions that are allowed to mint and the minter that registered them.\\r\\n     */\\r\\n    mapping(address position => address registeringMinter) public positions;\\r\\n\\r\\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\\r\\n    event MinterDenied(address indexed minter, string message);\\r\\n    event Loss(address indexed reportingMinter, uint256 amount);\\r\\n    event Profit(address indexed reportingMinter, uint256 amount);\\r\\n\\r\\n    error PeriodTooShort();\\r\\n    error FeeTooLow();\\r\\n    error AlreadyRegistered();\\r\\n    error NotMinter();\\r\\n    error TooLate();\\r\\n\\r\\n    modifier minterOnly() {\\r\\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\\r\\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\\r\\n     */\\r\\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\\r\\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\\r\\n        reserve = new Equity(this);\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"ZCHF\\\";\\r\\n    }\\r\\n\\r\\n    function initialize(address _minter, string calldata _message) external {\\r\\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\\r\\n        minters[_minter] = block.timestamp;\\r\\n        emit MinterApplied(_minter, 0, 0, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\\r\\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\\r\\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\\r\\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\\r\\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\\r\\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\\r\\n     * the proposed minter.\\r\\n     *\\r\\n     * @param _minter              An address that is given the permission to mint Frankencoins\\r\\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\\r\\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\\r\\n     * @param _message             An optional human readable message to everyone watching this contract\\r\\n     */\\r\\n    function suggestMinter(\\r\\n        address _minter,\\r\\n        uint256 _applicationPeriod,\\r\\n        uint256 _applicationFee,\\r\\n        string calldata _message\\r\\n    ) external override {\\r\\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\\r\\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\\r\\n        if (minters[_minter] != 0) revert AlreadyRegistered();\\r\\n        _collectProfits(address(this), msg.sender, _applicationFee);\\r\\n        minters[_minter] = block.timestamp + _applicationPeriod;\\r\\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\\r\\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\\r\\n     * giving them arbitrary allowances does not pose an additional risk.\\r\\n     */\\r\\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\\r\\n        uint256 explicit = super._allowance(owner, spender);\\r\\n        if (explicit > 0) {\\r\\n            return explicit; // don't waste gas checking minter\\r\\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\\r\\n            return INFINITY;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve provided by the owners of collateralized positions.\\r\\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\\r\\n     */\\r\\n    function minterReserve() public view returns (uint256) {\\r\\n        return minterReserveE6 / 1000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\\r\\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\\r\\n     */\\r\\n    function registerPosition(address _position) external override {\\r\\n        if (!isMinter(msg.sender)) revert NotMinter();\\r\\n        positions[_position] = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\\r\\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\\r\\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\\r\\n     * constitutes profits attributable to the pool share holders.\\r\\n     */\\r\\n    function equity() public view returns (uint256) {\\r\\n        uint256 balance = balanceOf(address(reserve));\\r\\n        uint256 minReserve = minterReserve();\\r\\n        if (balance <= minReserve) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return balance - minReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Qualified pool share holders can deny minters during the application period.\\r\\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\\r\\n     */\\r\\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\\r\\n        if (block.timestamp > minters[_minter]) revert TooLate();\\r\\n        reserve.checkQualified(msg.sender, _helpers);\\r\\n        delete minters[_minter];\\r\\n        emit MinterDenied(_minter, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\\r\\n     * the minting fee and the reserve to the right place.\\r\\n     */\\r\\n    function mintWithReserve(\\r\\n        address _target,\\r\\n        uint256 _amount,\\r\\n        uint32 _reservePPM,\\r\\n        uint32 _feesPPM\\r\\n    ) external override minterOnly {\\r\\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\\r\\n        _mint(_target, usableMint);\\r\\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\\r\\n        minterReserveE6 += _amount * _reservePPM;\\r\\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\\r\\n    }\\r\\n\\r\\n    function mint(address _target, uint256 _amount) external override minterOnly {\\r\\n        _mint(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Anyone is allowed to burn their ZCHF.\\r\\n     */\\r\\n    function burn(uint256 _amount) external {\\r\\n        _burn(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn someone elses ZCHF.\\r\\n     */\\r\\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\\r\\n        _burn(_owner, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\\r\\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\\r\\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\\r\\n     *\\r\\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\\r\\n     * the same _reservePPM amount.\\r\\n     *\\r\\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\\r\\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\\r\\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\\r\\n     * reassigned to the pool share holders.\\r\\n     */\\r\\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 reserveReduction = amount * reservePPM;\\r\\n        if (reserveReduction > minterReserveE6) {\\r\\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\\r\\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\\r\\n        } else {\\r\\n            minterReserveE6 -= reserveReduction;\\r\\n            emit Profit(msg.sender, reserveReduction / 1000_000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\\r\\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\\r\\n     * same _reservePPM amount.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\\r\\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\\r\\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\\r\\n     * they owe.\\r\\n     */\\r\\n    function burnWithReserve(\\r\\n        uint256 _amountExcludingReserve,\\r\\n        uint32 _reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\\r\\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\\r\\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\\r\\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\\r\\n        return freedAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\\r\\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\\r\\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\\r\\n     * reducing the minter reserve by 10.\\r\\n     */\\r\\n    function burnFromWithReserve(\\r\\n        address payer,\\r\\n        uint256 targetTotalBurnAmount,\\r\\n        uint32 reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\\r\\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\\r\\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\\r\\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\\r\\n        return assigned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\\r\\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\\r\\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\\r\\n     */\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\\r\\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\\r\\n        uint256 currentReserve = balanceOf(address(reserve));\\r\\n        uint256 minterReserve_ = minterReserve();\\r\\n        if (currentReserve < minterReserve_) {\\r\\n            // not enough reserves, owner has to take a loss\\r\\n            return (theoreticalReserve * currentReserve) / minterReserve_;\\r\\n        } else {\\r\\n            return theoreticalReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\\r\\n     * taking into account potential losses. Example values in the comments.\\r\\n     */\\r\\n    function calculateFreedAmount(\\r\\n        uint256 amountExcludingReserve /* 41 */,\\r\\n        uint32 reservePPM /* 20% */\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\\r\\n        uint256 minterReserve_ = minterReserve(); // 20\\r\\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\\r\\n            ? (reservePPM * currentReserve) / minterReserve_\\r\\n            : reservePPM; // 18%\\r\\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\\r\\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\\r\\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\\r\\n     *\\r\\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\\r\\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\\r\\n     * by the reserve.\\r\\n     */\\r\\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\\r\\n        uint256 reserveLeft = balanceOf(address(reserve));\\r\\n        if (reserveLeft >= _amount) {\\r\\n            _transfer(address(reserve), source, _amount);\\r\\n        } else {\\r\\n            _transfer(address(reserve), source, reserveLeft);\\r\\n            _mint(source, _amount - reserveLeft);\\r\\n        }\\r\\n        emit Loss(source, _amount);\\r\\n    }\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\\r\\n        _collectProfits(msg.sender, source, _amount);\\r\\n    }\\r\\n\\r\\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\\r\\n        _transfer(source, address(reserve), _amount);\\r\\n        emit Profit(minter, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is an approved minter.\\r\\n     */\\r\\n    function isMinter(address _minter) public view override returns (bool) {\\r\\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\\r\\n     */\\r\\n    function getPositionParent(address _position) public view override returns (address) {\\r\\n        return positions[_position];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(source, _amount - reserveleft)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./utils/ERC20PermitLight.sol\\\";\\r\\nimport \\\"./Equity.sol\\\";\\r\\nimport \\\"./interface/IReserve.sol\\\";\\r\\nimport \\\"./interface/IFrankencoin.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title FrankenCoin\\r\\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\\r\\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\\r\\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\\r\\n */\\r\\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\\r\\n    /**\\r\\n     * @notice Minimal fee and application period when suggesting a new minter.\\r\\n     */\\r\\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\\r\\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\\r\\n\\r\\n    /**\\r\\n     * @notice The contract that holds the reserve.\\r\\n     */\\r\\n    IReserve public immutable override reserve;\\r\\n\\r\\n    /**\\r\\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\\r\\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\\r\\n     * million (ppm) in reserve calculations.\\r\\n     */\\r\\n    uint256 private minterReserveE6;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\\r\\n     * to mint Frankencoins.\\r\\n     */\\r\\n    mapping(address minter => uint256 validityStart) public minters;\\r\\n\\r\\n    /**\\r\\n     * @notice List of positions that are allowed to mint and the minter that registered them.\\r\\n     */\\r\\n    mapping(address position => address registeringMinter) public positions;\\r\\n\\r\\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\\r\\n    event MinterDenied(address indexed minter, string message);\\r\\n    event Loss(address indexed reportingMinter, uint256 amount);\\r\\n    event Profit(address indexed reportingMinter, uint256 amount);\\r\\n\\r\\n    error PeriodTooShort();\\r\\n    error FeeTooLow();\\r\\n    error AlreadyRegistered();\\r\\n    error NotMinter();\\r\\n    error TooLate();\\r\\n\\r\\n    modifier minterOnly() {\\r\\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\\r\\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\\r\\n     */\\r\\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\\r\\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\\r\\n        reserve = new Equity(this);\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"Frankencoin\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"ZCHF\\\";\\r\\n    }\\r\\n\\r\\n    function initialize(address _minter, string calldata _message) external {\\r\\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\\r\\n        minters[_minter] = block.timestamp;\\r\\n        emit MinterApplied(_minter, 0, 0, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\\r\\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\\r\\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\\r\\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\\r\\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\\r\\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\\r\\n     * the proposed minter.\\r\\n     *\\r\\n     * @param _minter              An address that is given the permission to mint Frankencoins\\r\\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\\r\\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\\r\\n     * @param _message             An optional human readable message to everyone watching this contract\\r\\n     */\\r\\n    function suggestMinter(\\r\\n        address _minter,\\r\\n        uint256 _applicationPeriod,\\r\\n        uint256 _applicationFee,\\r\\n        string calldata _message\\r\\n    ) external override {\\r\\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\\r\\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\\r\\n        if (minters[_minter] != 0) revert AlreadyRegistered();\\r\\n        _collectProfits(address(this), msg.sender, _applicationFee);\\r\\n        minters[_minter] = block.timestamp + _applicationPeriod;\\r\\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\\r\\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\\r\\n     * giving them arbitrary allowances does not pose an additional risk.\\r\\n     */\\r\\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\\r\\n        uint256 explicit = super._allowance(owner, spender);\\r\\n        if (explicit > 0) {\\r\\n            return explicit; // don't waste gas checking minter\\r\\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\\r\\n            return INFINITY;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The reserve provided by the owners of collateralized positions.\\r\\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\\r\\n     */\\r\\n    function minterReserve() public view returns (uint256) {\\r\\n        return minterReserveE6 / 1000000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\\r\\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\\r\\n     */\\r\\n    function registerPosition(address _position) external override {\\r\\n        if (!isMinter(msg.sender)) revert NotMinter();\\r\\n        positions[_position] = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\\r\\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\\r\\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\\r\\n     * constitutes profits attributable to the pool share holders.\\r\\n     */\\r\\n    function equity() public view returns (uint256) {\\r\\n        uint256 balance = balanceOf(address(reserve));\\r\\n        uint256 minReserve = minterReserve();\\r\\n        if (balance <= minReserve) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return balance - minReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Qualified pool share holders can deny minters during the application period.\\r\\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\\r\\n     */\\r\\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\\r\\n        if (block.timestamp > minters[_minter]) revert TooLate();\\r\\n        reserve.checkQualified(msg.sender, _helpers);\\r\\n        delete minters[_minter];\\r\\n        emit MinterDenied(_minter, _message);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\\r\\n     * the minting fee and the reserve to the right place.\\r\\n     */\\r\\n    function mintWithReserve(\\r\\n        address _target,\\r\\n        uint256 _amount,\\r\\n        uint32 _reservePPM,\\r\\n        uint32 _feesPPM\\r\\n    ) external override minterOnly {\\r\\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\\r\\n        _mint(_target, usableMint);\\r\\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\\r\\n        minterReserveE6 += _amount * _reservePPM;\\r\\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\\r\\n    }\\r\\n\\r\\n    function mint(address _target, uint256 _amount) external override minterOnly {\\r\\n        _mint(_target, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Anyone is allowed to burn their ZCHF.\\r\\n     */\\r\\n    function burn(uint256 _amount) external {\\r\\n        _burn(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn someone elses ZCHF.\\r\\n     */\\r\\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\\r\\n        _burn(_owner, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\\r\\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\\r\\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\\r\\n     *\\r\\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\\r\\n     * the same _reservePPM amount.\\r\\n     *\\r\\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\\r\\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\\r\\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\\r\\n     * reassigned to the pool share holders.\\r\\n     */\\r\\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 reserveReduction = amount * reservePPM;\\r\\n        if (reserveReduction > minterReserveE6) {\\r\\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\\r\\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\\r\\n        } else {\\r\\n            minterReserveE6 -= reserveReduction;\\r\\n            emit Profit(msg.sender, reserveReduction / 1000_000);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\\r\\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\\r\\n     * same _reservePPM amount.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\\r\\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\\r\\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\\r\\n     * they owe.\\r\\n     */\\r\\n    function burnWithReserve(\\r\\n        uint256 _amountExcludingReserve,\\r\\n        uint32 _reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\\r\\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\\r\\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\\r\\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\\r\\n        return freedAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\\r\\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\\r\\n     *\\r\\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\\r\\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\\r\\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\\r\\n     * reducing the minter reserve by 10.\\r\\n     */\\r\\n    function burnFromWithReserve(\\r\\n        address payer,\\r\\n        uint256 targetTotalBurnAmount,\\r\\n        uint32 reservePPM\\r\\n    ) external override minterOnly returns (uint256) {\\r\\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\\r\\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\\r\\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\\r\\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\\r\\n        return assigned;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\\r\\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\\r\\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\\r\\n     */\\r\\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\\r\\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\\r\\n        uint256 currentReserve = balanceOf(address(reserve));\\r\\n        uint256 minterReserve_ = minterReserve();\\r\\n        if (currentReserve < minterReserve_) {\\r\\n            // not enough reserves, owner has to take a loss\\r\\n            return (theoreticalReserve * currentReserve) / minterReserve_;\\r\\n        } else {\\r\\n            return theoreticalReserve;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\\r\\n     * taking into account potential losses. Example values in the comments.\\r\\n     */\\r\\n    function calculateFreedAmount(\\r\\n        uint256 amountExcludingReserve /* 41 */,\\r\\n        uint32 reservePPM /* 20% */\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\\r\\n        uint256 minterReserve_ = minterReserve(); // 20\\r\\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\\r\\n            ? (reservePPM * currentReserve) / minterReserve_\\r\\n            : reservePPM; // 18%\\r\\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\\r\\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\\r\\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\\r\\n     *\\r\\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\\r\\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\\r\\n     * by the reserve.\\r\\n     */\\r\\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\\r\\n        uint256 reserveLeft = balanceOf(address(reserve));\\r\\n        if (reserveLeft >= _amount) {\\r\\n            _transfer(address(reserve), source, _amount);\\r\\n        } else {\\r\\n            _transfer(address(reserve), source, reserveLeft);\\r\\n            _mint(source, _amount - reserveLeft);\\r\\n        }\\r\\n        emit Loss(source, _amount);\\r\\n    }\\r\\n\\r\\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\\r\\n        _collectProfits(msg.sender, source, _amount);\\r\\n    }\\r\\n\\r\\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\\r\\n        _transfer(source, address(reserve), _amount);\\r\\n        emit Profit(minter, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is an approved minter.\\r\\n     */\\r\\n    function isMinter(address _minter) public view override returns (bool) {\\r\\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\\r\\n     */\\r\\n    function getPositionParent(address _position) public view override returns (address) {\\r\\n        return positions[_position];\\r\\n    }\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address recipient, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Copied and adjusted from OpenZeppelin\\r\\n// Adjustments:\\r\\n// - modifications to support ERC-677\\r\\n// - removed require messages to save space\\r\\n// - removed unnecessary require statements\\r\\n// - removed GSN Context\\r\\n// - upgraded to 0.8 to drop SafeMath\\r\\n// - let name() and symbol() be implemented by subclass\\r\\n// - infinite allowance support, with 2^255 and above considered infinite\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interface/IERC20.sol\\\";\\r\\nimport \\\"../interface/IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the `IERC20` interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\r\\n * For a generic mechanism see `ERC20Mintable`.\\r\\n *\\r\\n * *For a detailed writeup see our guide [How to implement supply\\r\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n */\\r\\n\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    mapping(address account => uint256 balance) private _balances;\\r\\n\\r\\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\\r\\n\\r\\n    uint256 internal constant INFINITY = (1 << 255);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    uint8 public immutable override decimals;\\r\\n\\r\\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\\r\\n    // Indicates an error related to the current balance of a sender. Used in transfers.\\r\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\r\\n    // Indicates a failure with the spender\u2019s allowance. Used in transfers.\\r\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\r\\n\\r\\n    constructor(uint8 _decimals) {\\r\\n        decimals = _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.totalSupply`.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.balanceOf`.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transfer`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.allowance`.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\r\\n        return _allowance(owner, spender);\\r\\n    }\\r\\n\\r\\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.approve`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transferFrom`.\\r\\n     *\\r\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `value`.\\r\\n     * - the caller must have allowance for `sender`'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _useAllowance(sender, msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\\r\\n        uint256 currentAllowance = _allowance(owner, spender);\\r\\n        if (currentAllowance < INFINITY) {\\r\\n            // Only decrease the allowance if it was not set to 'infinite'\\r\\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\\r\\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\\r\\n            _approve(owner, spender, currentAllowance - amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to `transfer`, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(address(0), recipient, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(address(0), recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `to` set to the zero address.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _totalSupply -= amount;\\r\\n        _balances[account] -= amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n}\\r\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Copied and adjusted from OpenZeppelin\\r\\n// Adjustments:\\r\\n// - modifications to support ERC-677\\r\\n// - removed require messages to save space\\r\\n// - removed unnecessary require statements\\r\\n// - removed GSN Context\\r\\n// - upgraded to 0.8 to drop SafeMath\\r\\n// - let name() and symbol() be implemented by subclass\\r\\n// - infinite allowance support, with 2^255 and above considered infinite\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interface/IERC20.sol\\\";\\r\\nimport \\\"../interface/IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the `IERC20` interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\r\\n * For a generic mechanism see `ERC20Mintable`.\\r\\n *\\r\\n * *For a detailed writeup see our guide [How to implement supply\\r\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n */\\r\\n\\r\\nabstract contract ERC20 is IERC20 {\\r\\n    mapping(address account => uint256 balance) private _balances;\\r\\n\\r\\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\\r\\n\\r\\n    uint256 internal constant INFINITY = (1 << 255);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    uint8 public immutable override decimals;\\r\\n\\r\\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\\r\\n    // Indicates an error related to the current balance of a sender. Used in transfers.\\r\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\r\\n    // Indicates a failure with the spender\u2019s allowance. Used in transfers.\\r\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\r\\n\\r\\n    constructor(uint8 _decimals) {\\r\\n        decimals = _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.totalSupply`.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.balanceOf`.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transfer`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.allowance`.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\r\\n        return _allowance(owner, spender);\\r\\n    }\\r\\n\\r\\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.approve`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transferFrom`.\\r\\n     *\\r\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `value`.\\r\\n     * - the caller must have allowance for `sender`'s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _useAllowance(sender, msg.sender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\\r\\n        uint256 currentAllowance = _allowance(owner, spender);\\r\\n        if (currentAllowance < INFINITY) {\\r\\n            // Only decrease the allowance if it was not set to 'infinite'\\r\\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\\r\\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\\r\\n            _approve(owner, spender, currentAllowance - amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to `transfer`, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(address(0), recipient, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(address(0), recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `to` set to the zero address.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _totalSupply -= amount;\\r\\n        _balances[account] -= amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\r\\n}\\r\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}