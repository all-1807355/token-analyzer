{
  "total_matches": 10,
  "patterns_found": {
    "minting_mechanics": {
      "count": 10,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(marketingwalletaddress, (initialsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(developerwalletaddress, (initialsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(liquiditywalletaddress, (initialsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(airdropwalletaddress, (initialsupply)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(receiver_, consumedamount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(receiver, consumedamount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// OSEAN DAO token contract for ETHEREUM - https://osean.online\\n// Official telegram: https://t.me/oseadao \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./supertoken/Base.sol\\\";\\nimport \\\"./interfaces/Uniswap.sol\\\";\\n\\ncontract Osean is ERC20, Base {\\n    struct UpdateLimitParams {\\n        bool isMint;\\n        uint32 siblingChainSlug;\\n        uint256 maxLimit;\\n        uint256 ratePerSecond;\\n    }\\n\\n    bytes32 constant RESCUE_ROLE = keccak256(\\\"RESCUE_ROLE\\\");\\n    bytes32 constant LIMIT_UPDATER_ROLE = keccak256(\\\"LIMIT_UPDATER_ROLE\\\");\\n\\n    // bridge contract address which provides AMB support\\n    IMessageBridge public bridge__;\\n\\n    // siblingChainSlug => mintLimitParams\\n    mapping(uint32 => LimitParams) _receivingLimitParams;\\n\\n    // siblingChainSlug => burnLimitParams\\n    mapping(uint32 => LimitParams) _sendingLimitParams;\\n\\n    // siblingChainSlug => receiver => identifier => amount\\n    mapping(uint32 => mapping(address => mapping(bytes32 => uint256)))\\n        public pendingMints;\\n\\n    // siblingChainSlug => amount\\n    mapping(uint32 => uint256) public siblingPendingMints;\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// ERRORS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    error SiblingNotSupported();\\n    error MessageIdMisMatched();\\n    error ZeroAmount();\\n    error NotMessageBridge();\\n    error InvalidReceiver();\\n    error InvalidSiblingChainSlug();\\n\\n    ////////////////////////////////////////////////////////\\n    ////////////////////// EVENTS //////////////////////////\\n    ////////////////////////////////////////////////////////\\n\\n    // emitted when limit params are updated\\n    event LimitParamsUpdated(UpdateLimitParams[] updates);\\n    // emitted when message bridge is updated\\n    event MessageBridgeUpdated(address newBridge);\\n    // emitted at source when tokens are bridged to a sibling chain\\n    event BridgeTokens(\\n        uint32 siblingChainSlug,\\n        address withdrawer,\\n        address receiver,\\n        uint256 bridgedAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted to the receiver\\n    event PendingTokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 pendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when transfer reaches limit and token mint is added to pending queue\\n    event TokensPending(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 pendingAmount,\\n        uint256 totalPendingAmount,\\n        bytes32 identifier\\n    );\\n    // emitted when pending tokens are minted as limits are replenished\\n    event TokensBridged(\\n        uint32 siblingChainSlug,\\n        address receiver,\\n        uint256 mintAmount,\\n        uint256 totalAmount,\\n        bytes32 identifier\\n    );\\n\\n    // Mapping to exclude some contracts from fees. Transfers are excluded from fees if address in this mapping is recipient or sender.\\n    mapping (address => bool) public excludedFromFees;\\n           \\n    // Yacht funds wallet address that will be used for DAO treasury and buy Yachts.\\n    address payable public oseanWalletAddress;\\n    \\n    // Marketing wallet address used for funding marketing.\\n    address payable public marketingWalletAddress;\\n    \\n    // Developer wallet address used for funding the team.\\n    address payable public developerWalletAddress;\\n    \\n    // Liquidity wallet address used to hold the 75% of OSEAN tokens for the liquidity pool.\\n    // After these coins are moved to the DEX, this address will no longer be used.\\n    address public liquidityWalletAddress;\\n    \\n    // Address of the wallet that will keep OSEAN tokens for burn.\\n    address payable public tobeburntWalletAddress;\\n    \\n    // Address of the contract responsible for the air dropping.\\n    address public airDropWalletAddress;\\n    \\n    // The PancakeSwap router address for swapping OSEAN tokens for WBNB.\\n    address public uniswapRouterAddress;\\n    \\n    // The initial block timestamp of the token contract.\\n    uint256 public initialTimeStamp;\\n\\n    // Yacht transaction fee - deployed at 1%.\\n    uint256 public yachtTransactionFeePercent = 1;\\n\\n    // Developer team transaction fee - deployed at 1%.\\n    uint256 public developerFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public marketingFeePercent = 1;\\n\\n    // Marketing transaction fee - deployed at 1%.\\n    uint256 public burnFeePercent = 1;\\n    \\n    // PancakeSwap router interface.\\n    IUniswapV2Router02 private uniswapRouter;\\n\\n    // Address of the WBNB to OSEAN token pair on PancakeSwap.\\n    address public uniswapPair;\\n\\n    /**\\n     * @notice constructor for creating Osean.\\n     * @param owner_ owner of this contract\\n     * @param initialSupply initial supply of Osean token\\n     * @param bridge_ message bridge address\\n     */\\n    constructor(\\n        uint256 initialSupply,\\n        address owner_,\\n        address bridge_,\\n        address payable _oseanWalletAddress,\\n        address payable _marketingWalletAddress,\\n        address payable _developerWalletAddress,\\n        address _liquidityWalletAddress,\\n        address payable _tobeburntWalletAddress,\\n        address _airDropWalletAddress,\\n        address _uniswapRouterAddress,\\n        address executionHelper_\\n    ) ERC20(\\\"Osean\\\", \\\"OSEAN\\\") AccessControl(owner_) {\\n        bridge__ = IMessageBridge(bridge_);\\n        executionHelper__ = ExecutionHelper(executionHelper_);\\n\\n        initialTimeStamp = block.timestamp;\\n        oseanWalletAddress = _oseanWalletAddress;\\n        marketingWalletAddress = _marketingWalletAddress;\\n        developerWalletAddress = _developerWalletAddress;\\n        liquidityWalletAddress = _liquidityWalletAddress;\\n        tobeburntWalletAddress = _tobeburntWalletAddress;\\n        airDropWalletAddress = _airDropWalletAddress;\\n        uniswapRouterAddress = _uniswapRouterAddress;\\n\\n        excludedFromFees[oseanWalletAddress] = true;\\n        excludedFromFees[marketingWalletAddress] = true;\\n        excludedFromFees[developerWalletAddress] = true;\\n        excludedFromFees[liquidityWalletAddress] = true;\\n        excludedFromFees[tobeburntWalletAddress] = true;\\n        excludedFromFees[airDropWalletAddress] = true;\\n                    \\n        _mint(marketingWalletAddress, (initialSupply) * 5 / 100);\\n        _mint(developerWalletAddress, (initialSupply) * 10 / 100);\\n        _mint(liquidityWalletAddress, (initialSupply) * 75 / 100);\\n        _mint(airDropWalletAddress, (initialSupply) * 10 / 100);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(uniswapRouterAddress);\\n        uniswapRouter = _uniswapV2Router;\\n        _approve(address(this), address(uniswapRouter), initialSupply);\\n        uniswapPair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n        IERC20(uniswapPair).approve(address(uniswapRouter), type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice this function is used to update message bridge\\n     * @dev it can only be updated by owner\\n     * @dev should be carefully migrated as it can risk user funds\\n     * @param bridge_ new bridge address\\n     */\\n    function updateMessageBridge(address bridge_) external onlyOwner {\\n        bridge__ = IMessageBridge(bridge_);\\n        emit MessageBridgeUpdated(bridge_);\\n    }\\n\\n    /**\\n     * @notice this function is used to set bridge limits\\n     * @dev it can only be updated by owner\\n     * @param updates_ can be used to set mint and burn limits for all siblings in one call.\\n     */\\n    function updateLimitParams(\\n        UpdateLimitParams[] calldata updates_\\n    ) external onlyRole(LIMIT_UPDATER_ROLE) {\\n        for (uint256 i; i < updates_.length; i++) {\\n            if (updates_[i].isMint) {\\n                _consumePartLimit(\\n                    0,\\n                    _receivingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _receivingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            } else {\\n                _consumePartLimit(\\n                    0,\\n                    _sendingLimitParams[updates_[i].siblingChainSlug]\\n                ); // to keep current limit in sync\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .maxLimit = updates_[i].maxLimit;\\n                _sendingLimitParams[updates_[i].siblingChainSlug]\\n                    .ratePerSecond = updates_[i].ratePerSecond;\\n            }\\n        }\\n\\n        emit LimitParamsUpdated(updates_);\\n    }\\n\\n    /**\\n     * @notice this function is called by users to bridge their funds to a sibling chain\\n     * @dev it is payable to receive message bridge fees to be paid.\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param sendingAmount_ amount bridged\\n     * @param msgGasLimit_ min gas limit needed for execution at destination\\n     * @param payload_ payload which is executed at destination with bridged amount at receiver address.\\n     * @param options_ additional message bridge options can be provided using this param\\n     */\\n    function bridge(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        uint256 sendingAmount_,\\n        uint256 msgGasLimit_,\\n        bytes calldata payload_,\\n        bytes calldata options_\\n    ) external payable {\\n        if (_sendingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        if (sendingAmount_ == 0) revert ZeroAmount();\\n\\n        _consumeFullLimit(\\n            sendingAmount_,\\n            _sendingLimitParams[siblingChainSlug_]\\n        ); // reverts on limit hit\\n        _burn(msg.sender, sendingAmount_);\\n\\n        bytes32 messageId = bridge__.getMessageId(siblingChainSlug_);\\n\\n        // important to get message id as it is used as an\\n        // identifier for pending amount and payload caching\\n        bytes32 returnedMessageId = bridge__.outbound{value: msg.value}(\\n            siblingChainSlug_,\\n            msgGasLimit_,\\n            abi.encode(receiver_, sendingAmount_, messageId, payload_),\\n            options_\\n        );\\n        if (returnedMessageId != messageId) revert MessageIdMisMatched();\\n        emit BridgeTokens(\\n            siblingChainSlug_,\\n            msg.sender,\\n            receiver_,\\n            sendingAmount_,\\n            messageId\\n        );\\n    }\\n\\n    /**\\n     * @notice this function can be used to mint funds which were in pending state due to limits\\n     * @param receiver_ address receiving bridged tokens\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param identifier_ message identifier where message was received to mint funds\\n     */\\n    function mintPendingFor(\\n        address receiver_,\\n        uint32 siblingChainSlug_,\\n        bytes32 identifier_\\n    ) external nonReentrant {\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        uint256 pendingMint = pendingMints[siblingChainSlug_][receiver_][\\n            identifier_\\n        ];\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            pendingMint,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        pendingMints[siblingChainSlug_][receiver_][identifier_] = pendingAmount;\\n        siblingPendingMints[siblingChainSlug_] -= consumedAmount;\\n\\n        _mint(receiver_, consumedAmount);\\n\\n        address receiver = pendingExecutions[identifier_].receiver;\\n        if (pendingAmount == 0 && receiver != address(0)) {\\n            if (receiver_ != receiver) revert InvalidReceiver();\\n\\n            uint32 siblingChainSlug = pendingExecutions[identifier_]\\n                .siblingChainSlug;\\n            if (siblingChainSlug != siblingChainSlug_)\\n                revert InvalidSiblingChainSlug();\\n\\n            // execute\\n            pendingExecutions[identifier_].isAmountPending = false;\\n            bool success = executionHelper__.execute(\\n                receiver_,\\n                pendingExecutions[identifier_].payload\\n            );\\n            if (success) _clearPayload(identifier_);\\n        }\\n\\n        emit PendingTokensBridged(\\n            siblingChainSlug_,\\n            receiver_,\\n            consumedAmount,\\n            pendingAmount,\\n            identifier_\\n        );\\n    }\\n\\n    /**\\n     * @notice this function receives the message from message bridge\\n     * @dev Only bridge can call this function.\\n     * @param siblingChainSlug_ The unique identifier of the sibling chain.\\n     * @param payload_ payload which is decoded to get `receiver`, `amount to mint`, `message id` and `payload` to execute after token transfer.\\n     */\\n    function inbound(\\n        uint32 siblingChainSlug_,\\n        bytes memory payload_\\n    ) external payable override nonReentrant {\\n        if (msg.sender != address(bridge__)) revert NotMessageBridge();\\n\\n        if (_receivingLimitParams[siblingChainSlug_].maxLimit == 0)\\n            revert SiblingNotSupported();\\n\\n        (\\n            address receiver,\\n            uint256 mintAmount,\\n            bytes32 identifier,\\n            bytes memory execPayload\\n        ) = abi.decode(payload_, (address, uint256, bytes32, bytes));\\n\\n        (uint256 consumedAmount, uint256 pendingAmount) = _consumePartLimit(\\n            mintAmount,\\n            _receivingLimitParams[siblingChainSlug_]\\n        );\\n\\n        if (receiver == address(this) || receiver == address(bridge__))\\n            revert CannotExecuteOnBridgeContracts();\\n\\n        _mint(receiver, consumedAmount);\\n\\n        if (pendingAmount > 0) {\\n            pendingMints[siblingChainSlug_][receiver][\\n                identifier\\n            ] = pendingAmount;\\n            siblingPendingMints[siblingChainSlug_] += pendingAmount;\\n\\n            // if pending amount is more than 0, payload is cached\\n            if (execPayload.length > 0)\\n                _cachePayload(\\n                    identifier,\\n                    true,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n\\n            emit TokensPending(\\n                siblingChainSlug_,\\n                receiver,\\n                pendingAmount,\\n                pendingMints[siblingChainSlug_][receiver][identifier],\\n                identifier\\n            );\\n        } else if (execPayload.length > 0) {\\n            // execute\\n            bool success = executionHelper__.execute(receiver, execPayload);\\n\\n            if (!success)\\n                _cachePayload(\\n                    identifier,\\n                    false,\\n                    siblingChainSlug_,\\n                    receiver,\\n                    execPayload\\n                );\\n        }\\n\\n        emit TokensBridged(\\n            siblingChainSlug_,\\n            receiver,\\n            consumedAmount,\\n            mintAmount,\\n            identifier\\n        );\\n    }\\n\\n    function getCurrentReceivingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_receivingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getCurrentSendingLimit(\\n        uint32 siblingChainSlug_\\n    ) external view returns (uint256) {\\n        return _getCurrentLimit(_sendingLimitParams[siblingChainSlug_]);\\n    }\\n\\n    function getReceivingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _receivingLimitParams[siblingChainSlug_];\\n    }\\n\\n    function getSendingLimitParams(\\n        uint32 siblingChainSlug_\\n    ) external view returns (LimitParams memory) {\\n        return _sendingLimitParams[siblingChainSlug_];\\n    }\\n\\n    /**\\n     * @notice Rescues funds from the contract if they are locked by mistake.\\n     * @param token_ The address of the token contract.\\n     * @param rescueTo_ The address where rescued tokens need to be sent.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address rescueTo_,\\n        uint256 amount_\\n    ) external onlyRole(RESCUE_ROLE) {\\n        RescueFundsLib.rescueFunds(token_, rescueTo_, amount_);\\n    }\\n\\n    /**\\n     * Returns the contract address\\n     * Return contract address\\n     */\\n    function getContractAddress() public view returns (address){\\n        return address(this);\\n    }\\n\\n    /**\\n    * @dev Adds a user to be excluded from fees.\\n    * @param user address of the user to be excluded from fees.\\n     */\\n    function excludeUserFromFees(address user) public onlyOwner {\\n        excludedFromFees[user] = true;\\n    }\\n\\n    /**\\n    * @dev Gets the current timestamp, used for testing + verification\\n    * @return the the timestamp of the current block\\n     */\\n    function getCurrentTimestamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n    * @dev Removes a user from the fee exclusion.\\n    * @param user address of the user than will now have to pay transaction fees.\\n     */\\n    function includeUsersInFees(address user) public onlyOwner {\\n        excludedFromFees[user] = false;\\n    }\\n\\n        \\n    // Internal Transfer function override to collect taxes only on Swap.   \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n\\n        // Check in exchanges between wallets for 1% of total supply\\n        if (sender != uniswapPair && recipient != uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");    \\n            }\\n\\n        //when to collect taxes      \\n        if((sender == uniswapPair || recipient == uniswapPair) && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n            \\n            //Investor cannot have more than 1% of total supply\\n            if(sender == uniswapPair && !excludedFromFees[sender] && !excludedFromFees[recipient]) {\\n                require((balanceOf(recipient) + amount) < (totalSupply() / 75), \\\"You can't have more than 1% of the total supply.\\\");                                \\n            }\\n\\n            // Yacht transaction fee.\\n            uint256 yachtFee = (amount * yachtTransactionFeePercent) / 100;\\n            // Marketing team transaction fee.\\n            uint256 marketingFee = (amount * marketingFeePercent) / 100;\\n            // Developer team transaction fee.\\n            uint256 developerFee = (amount * developerFeePercent) / 100;\\n            // Burn fee\\n            uint256 burnFee = (amount * burnFeePercent) / 100;\\n\\n            // The total fee to send to the contract address.\\n            uint256 totalFee = yachtFee + marketingFee + developerFee + burnFee;\\n    \\n            // Sends the transaction fees to the contract address\\n            super._transfer(sender, address(this), totalFee);\\n            \\n            // Prepares amount afterfees\\n            amount -= totalFee;\\n        \\n        }\\n\\n        super._transfer(sender, recipient, amount);\\n    }\\n    \\n    /**\\n     * @dev Swaps OSEAN tokens from transaction fees to ETH.\\n     * @param amount the amount of OSEAN tokens to swap\\n     */\\n    function swapOSEANForETH(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapRouter.WETH();\\n        _approve(address(this), address(uniswapRouter), amount);\\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n    \\n     /**\\n     * @dev Sends ETH to transaction fee wallets after OSEAN swaps.\\n     * @param amount the amount to be transfered\\n     */\\n    function sendFeesToWallets(uint256 amount) private {\\n        uint256 totalFee = yachtTransactionFeePercent + marketingFeePercent + developerFeePercent + burnFeePercent;\\n        oseanWalletAddress.transfer((amount * yachtTransactionFeePercent) / totalFee);\\n        marketingWalletAddress.transfer((amount * marketingFeePercent) / totalFee);\\n        developerWalletAddress.transfer((amount * developerFeePercent) / totalFee);\\n        tobeburntWalletAddress.transfer((amount * burnFeePercent) / totalFee);\\n    }\\n\\n     /**\\n     * @dev Swaps OSEAN to ETH.\\n     */\\n    function swapFeesManually() public onlyOwner {\\n        uint256 contractOSEANBalance = balanceOf(address(this));        \\n        if (contractOSEANBalance > 0) {\\n            swapOSEANForETH(contractOSEANBalance);                        \\n        }          \\n    }\\n    \\n    /**\\n     * @dev Sends ETH to Wallets\\n     */\\n    function disperseFeesManually() public onlyOwner {\\n        uint256 contractETHBalance = address(this).balance;\\n        sendFeesToWallets(contractETHBalance);\\n    }\\n    \\n    receive() external payable {} \\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address to, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}