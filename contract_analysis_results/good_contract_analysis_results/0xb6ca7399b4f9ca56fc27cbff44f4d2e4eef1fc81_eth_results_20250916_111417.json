{
  "total_matches": 19,
  "patterns_found": {
    "minting_mechanics": {
      "count": 18,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n// import \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n// import \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// ******************\\n// this is for staking lp tokens and getting back $pet tokens\\n// We can use this \\\"MasterChef.sol\\\" conract introduced by SuhiSwap, they do exactly what we need and the code is already used by many smart contracts and battle tested with $100s of millions staked in sushiswap\\n// *******************\\n\\n// @TODO maybe lets add the roles library to this also to have more then one wallet being able to run this\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, _msgSender()));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(\\n            hasRole(_roles[role].adminRole, _msgSender()),\\n            \\\"AccessControl: sender must be an admin to grant\\\"\\n        );\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(\\n            hasRole(_roles[role].adminRole, _msgSender()),\\n            \\\"AccessControl: sender must be an admin to revoke\\\"\\n        );\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(\\n            account == _msgSender(),\\n            \\\"AccessControl: can only renounce roles for self\\\"\\n        );\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\\n// File: contracts/access/Roles.sol\\n\\npragma solidity ^0.6.0;\\n\\ncontract Roles is AccessControl {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER\\\");\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR\\\");\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n}\\n\\ninterface IMigratorChef {\\n    // Perform LP token migration from legacy UniswapV2 to SushiSwap.\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    // Return the new LP token address.\\n    //\\n    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\\n    // SushiSwap must mint EXACTLY the same amount of SushiSwap LP tokens or\\n    // else something bad will happen. Traditional UniswapV2 does not\\n    // do that so be careful!\\n    function migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mint(address to, uint256 amount) external;\\n}\\n\\n// MasterChef is the master of Sushi. He can make Sushi and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once SUSHI is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable, Roles {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accSushiPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.\\n        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\\n    }\\n\\n    // The Muse TOKEN!\\n    IMuseToken public museToken;\\n    // adding this just in case of nobody using the game but degens hacking the farming\\n    bool devFee = false;\\n    // Dev address.\\n    address public devaddr;\\n    // Block number when bonus SUSHI period ends.\\n    uint256 public bonusEndBlock;\\n    // SUSHI tokens created per block.\\n    uint256 public sushiPerBlock;\\n    // Bonus muliplier for early sushi makers.\\n    uint256 public constant BONUS_MULTIPLIER = 10;\\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when SUSHI mining starts.\\n    uint256 public startBlock;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        IMuseToken _museToken,\\n        // address _devaddr,\\n        uint256 _sushiPerBlock,\\n        uint256 _startBlock,\\n        uint256 _bonusEndBlock\\n    ) public {\\n        museToken = _museToken;\\n        devaddr = msg.sender;\\n        sushiPerBlock = _sushiPerBlock;\\n        bonusEndBlock = _bonusEndBlock;\\n        startBlock = _startBlock;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    function allowDevFee(bool _allow) public onlyOperator {\\n        devFee = _allow;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _lpToken,\\n        bool _withUpdate\\n    ) public onlyOperator {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock\\n            ? block.number\\n            : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(\\n            PoolInfo({\\n                lpToken: _lpToken,\\n                allocPoint: _allocPoint,\\n                lastRewardBlock: lastRewardBlock,\\n                accSushiPerShare: 0\\n            })\\n        );\\n    }\\n\\n    // Update the given pool's SUSHI allocation point. Can only be called by the owner.\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        bool _withUpdate\\n    ) public onlyOperator {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    // Set the migrator contract. Can only be called by the owner.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\\n    function migrate(uint256 _pid) public {\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IERC20 lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        lpToken.safeApprove(address(migrator), bal);\\n        IERC20 newLpToken = migrator.migrate(lpToken);\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n        pool.lpToken = newLpToken;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_to <= bonusEndBlock) {\\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n        } else if (_from >= bonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return\\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\\n                    _to.sub(bonusEndBlock)\\n                );\\n        }\\n    }\\n\\n    // View function to see pending SUSHIs on frontend.\\n    function pendingSushi(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(\\n                pool.lastRewardBlock,\\n                block.number\\n            );\\n            uint256 sushiReward = multiplier\\n                .mul(sushiPerBlock)\\n                .mul(pool.allocPoint)\\n                .div(totalAllocPoint);\\n            accSushiPerShare = accSushiPerShare.add(\\n                sushiReward.mul(1e12).div(lpSupply)\\n            );\\n        }\\n        return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward vairables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 sushiReward = multiplier\\n            .mul(sushiPerBlock)\\n            .mul(pool.allocPoint)\\n            .div(totalAllocPoint);\\n\\n        //no dev fee as of now\\n        if (devFee) {\\n            museToken.mint(devaddr, sushiReward.div(10));\\n        }\\n        museToken.mint(address(this), sushiReward);\\n        pool.accSushiPerShare = pool.accSushiPerShare.add(\\n            sushiReward.mul(1e12).div(lpSupply)\\n        );\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Deposit LP tokens to MasterChef for SUSHI allocation.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = user\\n                .amount\\n                .mul(pool.accSushiPerShare)\\n                .div(1e12)\\n                .sub(user.rewardDebt);\\n            safeSushiTransfer(msg.sender, pending);\\n        }\\n        pool.lpToken.safeTransferFrom(\\n            address(msg.sender),\\n            address(this),\\n            _amount\\n        );\\n        user.amount = user.amount.add(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(\\n            user.rewardDebt\\n        );\\n        safeSushiTransfer(msg.sender, pending);\\n        user.amount = user.amount.sub(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n    }\\n\\n    // Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.\\n    function safeSushiTransfer(address _to, uint256 _amount) internal {\\n        uint256 sushiBal = museToken.balanceOf(address(this));\\n        if (_amount > sushiBal) {\\n            museToken.transfer(_to, sushiBal);\\n        } else {\\n            museToken.transfer(_to, _amount);\\n        }\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"../token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"../token/ERC20/ERC20Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC20PresetMinterPauser is Context, AccessControl, ERC20Burnable, ERC20Pausable {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/presets/ERC721PresetMinterPauserAutoId.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ncontract TokenRecover is Ownable {\\n    /**\\n     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\\n     * @param tokenAddress The token contract address\\n     * @param tokenAmount Number of tokens to be sent\\n     */\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        public\\n        onlyOwner\\n    {\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n    }\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mintingFinished() external view returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\n/*\\n * Deployment checklist::\\n *  1. Deploy all contracts\\n *  2. Give minter role to the claiming contract\\n *  3. Add objects (most basic cost 5 and give 1 day and 1 score)\\n *  4.\\n */\\n\\n// ERC721,\\ncontract VNFT is\\n    Ownable,\\n    ERC721PresetMinterPauserAutoId,\\n    TokenRecover,\\n    ERC1155Holder\\n{\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    IMuseToken public muse;\\n\\n    struct VNFTObj {\\n        address token;\\n        uint256 id;\\n        uint256 standard; //the type\\n    }\\n\\n    // Mapping from token ID to NFT struct details\\n    mapping(uint256 => VNFTObj) public vnftDetails;\\n\\n    // max dev allocation is 10% of total supply\\n    uint256 public maxDevAllocation = 100000 * 10**18;\\n    uint256 public devAllocation = 0;\\n\\n    // External NFTs\\n    struct NFTInfo {\\n        address token; // Address of LP token contract.\\n        bool active;\\n        uint256 standard; //the nft standard ERC721 || ERC1155\\n    }\\n\\n    NFTInfo[] public supportedNfts;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _tokenIds;\\n    Counters.Counter private _itemIds;\\n\\n    // how many tokens to burn every time the VNFT is given an accessory, the remaining goes to the community and devs\\n    uint256 public burnPercentage = 90;\\n    uint256 public giveLifePrice = 5 * 10**18;\\n\\n    bool public gameStopped = false;\\n\\n    // mining tokens\\n    mapping(uint256 => uint256) public lastTimeMined;\\n\\n    // VNFT properties\\n    mapping(uint256 => uint256) public timeUntilStarving;\\n    mapping(uint256 => uint256) public vnftScore;\\n    mapping(uint256 => uint256) public timeVnftBorn;\\n\\n    // items/benefits for the VNFT could be anything in the future.\\n    mapping(uint256 => uint256) public itemPrice;\\n    mapping(uint256 => uint256) public itemPoints;\\n    mapping(uint256 => string) public itemName;\\n    mapping(uint256 => uint256) public itemTimeExtension;\\n\\n    // mapping(uint256 => address) public careTaker;\\n    mapping(uint256 => mapping(address => address)) public careTaker;\\n\\n    event BurnPercentageChanged(uint256 percentage);\\n    event ClaimedMiningRewards(uint256 who, address owner, uint256 amount);\\n    event VnftConsumed(uint256 nftId, address giver, uint256 itemId);\\n    event VnftMinted(address to);\\n    event VnftFatalized(uint256 nftId, address killer);\\n    event ItemCreated(uint256 id, string name, uint256 price, uint256 points);\\n    event LifeGiven(address forSupportedNFT, uint256 id);\\n    event Unwrapped(uint256 nftId);\\n    event CareTakerAdded(uint256 nftId, address _to);\\n    event CareTakerRemoved(uint256 nftId);\\n\\n    constructor(address _museToken)\\n        public\\n        ERC721PresetMinterPauserAutoId(\\n            \\\"VNFT\\\",\\n            \\\"VNFT\\\",\\n            \\\"https://gallery.verynify.io/api/\\\"\\n        )\\n    {\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n        muse = IMuseToken(_museToken);\\n    }\\n\\n    modifier notPaused() {\\n        require(!gameStopped, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    function contractURI() public pure returns (string memory) {\\n        return \\\"https://gallery.verynifty.io/api\\\";\\n    }\\n\\n    // in case a bug happens or we upgrade to another smart contract\\n    function pauseGame(bool _pause) external onlyOperator {\\n        gameStopped = _pause;\\n    }\\n\\n    // change how much to burn on each buy and how much goes to community.\\n    function changeBurnPercentage(uint256 percentage) external onlyOperator {\\n        require(percentage <= 100);\\n        burnPercentage = burnPercentage;\\n        emit BurnPercentageChanged(burnPercentage);\\n    }\\n\\n    function changeGiveLifePrice(uint256 _newPrice) external onlyOperator {\\n        giveLifePrice = _newPrice * 10**18;\\n    }\\n\\n    function changeMaxDevAllocation(uint256 amount) external onlyOperator {\\n        maxDevAllocation = amount;\\n    }\\n\\n    function itemExists(uint256 itemId) public view returns (bool) {\\n        if (bytes(itemName[itemId]).length > 0) {\\n            return true;\\n        }\\n    }\\n\\n    // check that VNFT didn't starve\\n    function isVnftAlive(uint256 _nftId) public view returns (bool) {\\n        uint256 _timeUntilStarving = timeUntilStarving[_nftId];\\n        if (_timeUntilStarving != 0 && _timeUntilStarving >= block.timestamp) {\\n            return true;\\n        }\\n    }\\n\\n    function getVnftScore(uint256 _nftId) public view returns (uint256) {\\n        return vnftScore[_nftId];\\n    }\\n\\n    function getItemInfo(uint256 _itemId)\\n        public\\n        view\\n        returns (\\n            string memory _name,\\n            uint256 _price,\\n            uint256 _points,\\n            uint256 _timeExtension\\n        )\\n    {\\n        _name = itemName[_itemId];\\n        _price = itemPrice[_itemId];\\n        _timeExtension = itemTimeExtension[_itemId];\\n        _points = itemPoints[_itemId];\\n    }\\n\\n    function getVnftInfo(uint256 _nftId)\\n        public\\n        view\\n        returns (\\n            uint256 _vNFT,\\n            bool _isAlive,\\n            uint256 _score,\\n            uint256 _level,\\n            uint256 _expectedReward,\\n            uint256 _timeUntilStarving,\\n            uint256 _lastTimeMined,\\n            uint256 _timeVnftBorn,\\n            address _owner,\\n            address _token,\\n            uint256 _tokenId,\\n            uint256 _fatalityReward\\n        )\\n    {\\n        _vNFT = _nftId;\\n        _isAlive = this.isVnftAlive(_nftId);\\n        _score = this.getVnftScore(_nftId);\\n        _level = this.level(_nftId);\\n        _expectedReward = this.getRewards(_nftId);\\n        _timeUntilStarving = timeUntilStarving[_nftId];\\n        _lastTimeMined = lastTimeMined[_nftId];\\n        _timeVnftBorn = timeVnftBorn[_nftId];\\n        _owner = this.ownerOf(_nftId);\\n        _token = vnftDetails[_nftId].token;\\n        _tokenId = vnftDetails[_nftId].id;\\n        _fatalityReward = getFatalityReward(_nftId);\\n    }\\n\\n    function editCurves(\\n        uint256 _la,\\n        uint256 _lb,\\n        uint256 _ra,\\n        uint256 _rb\\n    ) external onlyOperator {\\n        la = _la;\\n        lb = _lb;\\n        ra = _ra;\\n        lb = _rb;\\n    }\\n\\n    uint256 la = 2;\\n    uint256 lb = 2;\\n    uint256 ra = 6;\\n    uint256 rb = 7;\\n\\n    // get the level the vNFT is on to calculate points\\n    function level(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula L(x) = 2 * sqrt(x * 2)\\n        uint256 _score = vnftScore[tokenId].div(100);\\n        if (_score == 0) {\\n            return 1;\\n        }\\n        uint256 _level = sqrtu(_score.mul(la));\\n        return (_level.mul(lb));\\n    }\\n\\n    // get the level the vNFT is on to calculate the token reward\\n    function getRewards(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula to get token rewards R(level)=(level)*6/7+6\\n        uint256 _level = this.level(tokenId);\\n        if (_level == 1) {\\n            return 6 ether;\\n        }\\n        _level = _level.mul(1 ether).mul(ra).div(rb);\\n        return (_level.add(5 ether));\\n    }\\n\\n    // edit specific item in case token goes up in value and the price for items gets to expensive for normal users.\\n    function editItem(\\n        uint256 _id,\\n        uint256 _price,\\n        uint256 _points,\\n        string calldata _name,\\n        uint256 _timeExtension\\n    ) external onlyOperator {\\n        itemPrice[_id] = _price;\\n        itemPoints[_id] = _points;\\n        itemName[_id] = _name;\\n        itemTimeExtension[_id] = _timeExtension;\\n    }\\n\\n    //can mine once every 24 hours per token.\\n    function claimMiningRewards(uint256 nftId) external notPaused {\\n        require(isVnftAlive(nftId), \\\"Your vNFT is dead, you can't mine\\\");\\n        require(\\n            block.timestamp >= lastTimeMined[nftId].add(1 minutes) ||\\n                lastTimeMined[nftId] == 0,\\n            \\\"Current timestamp is over the limit to claim the tokens\\\"\\n        );\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT to claim rewards\\\"\\n        );\\n\\n        //reset last start mined so can't remine and cheat\\n        lastTimeMined[nftId] = block.timestamp;\\n        uint256 _reward = this.getRewards(nftId);\\n        muse.mint(msg.sender, _reward);\\n        emit ClaimedMiningRewards(nftId, msg.sender, _reward);\\n    }\\n\\n    // Buy accesory to the VNFT\\n    function buyAccesory(uint256 nftId, uint256 itemId) external notPaused {\\n        require(itemExists(itemId), \\\"This item doesn't exist\\\");\\n        uint256 amount = itemPrice[itemId];\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT or be a care taker to buy items\\\"\\n        );\\n        // require(isVnftAlive(nftId), \\\"Your vNFT is dead\\\");\\n        uint256 amountToBurn = amount.mul(burnPercentage).div(100);\\n\\n        if (!isVnftAlive(nftId)) {\\n            vnftScore[nftId] = itemPoints[itemId];\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n        } else {\\n            //recalculate timeUntilStarving.\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n            vnftScore[nftId] = vnftScore[nftId].add(itemPoints[itemId]);\\n        }\\n        // burn 90% so they go back to community mining and staking, and send 10% to devs\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(amount.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), amount);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, amount);\\n        }\\n        emit VnftConsumed(nftId, msg.sender, itemId);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOperator {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function mint(address player) public override onlyMinter {\\n        //pet minted has 3 days until it starves at first\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            address(this),\\n            _tokenIds.current(),\\n            721\\n        );\\n        super._mint(player, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit VnftMinted(msg.sender);\\n    }\\n\\n    // kill starverd NFT and get 10% of his points.\\n    function fatality(uint256 _deadId, uint256 _tokenId) external notPaused {\\n        require(\\n            !isVnftAlive(_deadId),\\n            \\\"The vNFT has to be starved to claim his points\\\"\\n        );\\n        vnftScore[_tokenId] = vnftScore[_tokenId].add(\\n            (vnftScore[_deadId].mul(60).div(100))\\n        );\\n        // delete vnftDetails[_deadId];\\n        _burn(_deadId);\\n        emit VnftFatalized(_deadId, msg.sender);\\n    }\\n\\n    // Check how much score you'll get by fatality someone.\\n    function getFatalityReward(uint256 _deadId) public view returns (uint256) {\\n        if (isVnftAlive(_deadId)) {\\n            return 0;\\n        } else {\\n            return (vnftScore[_deadId].mul(50).div(100));\\n        }\\n    }\\n\\n    // add items/accessories\\n    function createItem(\\n        string calldata name,\\n        uint256 price,\\n        uint256 points,\\n        uint256 timeExtension\\n    ) external onlyOperator returns (bool) {\\n        _itemIds.increment();\\n        uint256 newItemId = _itemIds.current();\\n        itemName[newItemId] = name;\\n        itemPrice[newItemId] = price * 10**18;\\n        itemPoints[newItemId] = points;\\n        itemTimeExtension[newItemId] = timeExtension;\\n        emit ItemCreated(newItemId, name, price, points);\\n    }\\n\\n    //  *****************************\\n    //  LOGIC FOR EXTERNAL NFTS\\n    //  ****************************\\n    // support an external nft to mine rewards and play\\n    function addNft(address _nftToken, uint256 _type) public onlyOperator {\\n        supportedNfts.push(\\n            NFTInfo({token: _nftToken, active: true, standard: _type})\\n        );\\n    }\\n\\n    function supportedNftLength() external view returns (uint256) {\\n        return supportedNfts.length;\\n    }\\n\\n    function updateSupportedNFT(\\n        uint256 index,\\n        bool _active,\\n        address _address\\n    ) public onlyOperator {\\n        supportedNfts[index].active = _active;\\n        supportedNfts[index].token = _address;\\n    }\\n\\n    // aka WRAP: lets give life to your erc721 token and make it fun to mint $muse!\\n    function giveLife(\\n        uint256 index,\\n        uint256 _id,\\n        uint256 nftType\\n    ) external notPaused {\\n        uint256 amountToBurn = giveLifePrice.mul(burnPercentage).div(100);\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(giveLifePrice.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), giveLifePrice);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, giveLifePrice);\\n        }\\n\\n        if (nftType == 721) {\\n            IERC721(supportedNfts[index].token).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _id\\n            );\\n        } else if (nftType == 1155) {\\n            IERC1155(supportedNfts[index].token).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _id,\\n                1, //the amount of tokens to transfer which always be 1\\n                \\\"0x0\\\"\\n            );\\n        }\\n\\n        // mint a vNFT\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            supportedNfts[index].token,\\n            _id,\\n            nftType\\n        );\\n\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        super._mint(msg.sender, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit LifeGiven(supportedNfts[index].token, _id);\\n    }\\n\\n    // unwrap your vNFT if it is not dead, and get back your original NFT\\n    function unwrap(uint256 _vnftId) external {\\n        require(isVnftAlive(_vnftId), \\\"Your vNFT is dead, you can't unwrap it\\\");\\n        transferFrom(msg.sender, address(this), _vnftId);\\n        VNFTObj memory details = vnftDetails[_vnftId];\\n        timeUntilStarving[_vnftId] = 1;\\n        vnftScore[_vnftId] = 0;\\n        emit Unwrapped(_vnftId);\\n        _withdraw(details.id, details.token, msg.sender, details.standard);\\n    }\\n\\n    // withdraw dead wrapped NFTs or send them to the burn address.\\n    function withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) external onlyOperator {\\n        _withdraw(_id, _contractAddr, _to, _type);\\n    }\\n\\n    function _withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) internal {\\n        if (_type == 1155) {\\n            IERC1155(_contractAddr).safeTransferFrom(\\n                address(this),\\n                _to,\\n                _id,\\n                1,\\n                \\\"\\\"\\n            );\\n        } else if (_type == 721) {\\n            IERC721(_contractAddr).transferFrom(address(this), _to, _id);\\n        }\\n    }\\n\\n    // add care taker so in the future if vNFTs are sent to tokenizing platforms like niftex we can whitelist and the previous owner could still mine and do interesting stuff.\\n    function addCareTaker(uint256 _tokenId, address _careTaker) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        careTaker[_tokenId][msg.sender] = _careTaker;\\n        emit CareTakerAdded(_tokenId, _careTaker);\\n    }\\n\\n    function clearCareTaker(uint256 _tokenId) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        delete careTaker[_tokenId][msg.sender];\\n        emit CareTakerRemoved(_tokenId);\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n     * number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return unsigned 128-bit integer number\\n     */\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint128(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/presets/ERC721PresetMinterPauserAutoId.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ncontract TokenRecover is Ownable {\\n    /**\\n     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\\n     * @param tokenAddress The token contract address\\n     * @param tokenAmount Number of tokens to be sent\\n     */\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        public\\n        onlyOwner\\n    {\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n    }\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mintingFinished() external view returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\n/*\\n * Deployment checklist::\\n *  1. Deploy all contracts\\n *  2. Give minter role to the claiming contract\\n *  3. Add objects (most basic cost 5 and give 1 day and 1 score)\\n *  4.\\n */\\n\\n// ERC721,\\ncontract VNFT is\\n    Ownable,\\n    ERC721PresetMinterPauserAutoId,\\n    TokenRecover,\\n    ERC1155Holder\\n{\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    IMuseToken public muse;\\n\\n    struct VNFTObj {\\n        address token;\\n        uint256 id;\\n        uint256 standard; //the type\\n    }\\n\\n    // Mapping from token ID to NFT struct details\\n    mapping(uint256 => VNFTObj) public vnftDetails;\\n\\n    // max dev allocation is 10% of total supply\\n    uint256 public maxDevAllocation = 100000 * 10**18;\\n    uint256 public devAllocation = 0;\\n\\n    // External NFTs\\n    struct NFTInfo {\\n        address token; // Address of LP token contract.\\n        bool active;\\n        uint256 standard; //the nft standard ERC721 || ERC1155\\n    }\\n\\n    NFTInfo[] public supportedNfts;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _tokenIds;\\n    Counters.Counter private _itemIds;\\n\\n    // how many tokens to burn every time the VNFT is given an accessory, the remaining goes to the community and devs\\n    uint256 public burnPercentage = 90;\\n    uint256 public giveLifePrice = 5 * 10**18;\\n\\n    bool public gameStopped = false;\\n\\n    // mining tokens\\n    mapping(uint256 => uint256) public lastTimeMined;\\n\\n    // VNFT properties\\n    mapping(uint256 => uint256) public timeUntilStarving;\\n    mapping(uint256 => uint256) public vnftScore;\\n    mapping(uint256 => uint256) public timeVnftBorn;\\n\\n    // items/benefits for the VNFT could be anything in the future.\\n    mapping(uint256 => uint256) public itemPrice;\\n    mapping(uint256 => uint256) public itemPoints;\\n    mapping(uint256 => string) public itemName;\\n    mapping(uint256 => uint256) public itemTimeExtension;\\n\\n    // mapping(uint256 => address) public careTaker;\\n    mapping(uint256 => mapping(address => address)) public careTaker;\\n\\n    event BurnPercentageChanged(uint256 percentage);\\n    event ClaimedMiningRewards(uint256 who, address owner, uint256 amount);\\n    event VnftConsumed(uint256 nftId, address giver, uint256 itemId);\\n    event VnftMinted(address to);\\n    event VnftFatalized(uint256 nftId, address killer);\\n    event ItemCreated(uint256 id, string name, uint256 price, uint256 points);\\n    event LifeGiven(address forSupportedNFT, uint256 id);\\n    event Unwrapped(uint256 nftId);\\n    event CareTakerAdded(uint256 nftId, address _to);\\n    event CareTakerRemoved(uint256 nftId);\\n\\n    constructor(address _museToken)\\n        public\\n        ERC721PresetMinterPauserAutoId(\\n            \\\"VNFT\\\",\\n            \\\"VNFT\\\",\\n            \\\"https://gallery.verynify.io/api/\\\"\\n        )\\n    {\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n        muse = IMuseToken(_museToken);\\n    }\\n\\n    modifier notPaused() {\\n        require(!gameStopped, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    function contractURI() public pure returns (string memory) {\\n        return \\\"https://gallery.verynifty.io/api\\\";\\n    }\\n\\n    // in case a bug happens or we upgrade to another smart contract\\n    function pauseGame(bool _pause) external onlyOperator {\\n        gameStopped = _pause;\\n    }\\n\\n    // change how much to burn on each buy and how much goes to community.\\n    function changeBurnPercentage(uint256 percentage) external onlyOperator {\\n        require(percentage <= 100);\\n        burnPercentage = burnPercentage;\\n        emit BurnPercentageChanged(burnPercentage);\\n    }\\n\\n    function changeGiveLifePrice(uint256 _newPrice) external onlyOperator {\\n        giveLifePrice = _newPrice * 10**18;\\n    }\\n\\n    function changeMaxDevAllocation(uint256 amount) external onlyOperator {\\n        maxDevAllocation = amount;\\n    }\\n\\n    function itemExists(uint256 itemId) public view returns (bool) {\\n        if (bytes(itemName[itemId]).length > 0) {\\n            return true;\\n        }\\n    }\\n\\n    // check that VNFT didn't starve\\n    function isVnftAlive(uint256 _nftId) public view returns (bool) {\\n        uint256 _timeUntilStarving = timeUntilStarving[_nftId];\\n        if (_timeUntilStarving != 0 && _timeUntilStarving >= block.timestamp) {\\n            return true;\\n        }\\n    }\\n\\n    function getVnftScore(uint256 _nftId) public view returns (uint256) {\\n        return vnftScore[_nftId];\\n    }\\n\\n    function getItemInfo(uint256 _itemId)\\n        public\\n        view\\n        returns (\\n            string memory _name,\\n            uint256 _price,\\n            uint256 _points,\\n            uint256 _timeExtension\\n        )\\n    {\\n        _name = itemName[_itemId];\\n        _price = itemPrice[_itemId];\\n        _timeExtension = itemTimeExtension[_itemId];\\n        _points = itemPoints[_itemId];\\n    }\\n\\n    function getVnftInfo(uint256 _nftId)\\n        public\\n        view\\n        returns (\\n            uint256 _vNFT,\\n            bool _isAlive,\\n            uint256 _score,\\n            uint256 _level,\\n            uint256 _expectedReward,\\n            uint256 _timeUntilStarving,\\n            uint256 _lastTimeMined,\\n            uint256 _timeVnftBorn,\\n            address _owner,\\n            address _token,\\n            uint256 _tokenId,\\n            uint256 _fatalityReward\\n        )\\n    {\\n        _vNFT = _nftId;\\n        _isAlive = this.isVnftAlive(_nftId);\\n        _score = this.getVnftScore(_nftId);\\n        _level = this.level(_nftId);\\n        _expectedReward = this.getRewards(_nftId);\\n        _timeUntilStarving = timeUntilStarving[_nftId];\\n        _lastTimeMined = lastTimeMined[_nftId];\\n        _timeVnftBorn = timeVnftBorn[_nftId];\\n        _owner = this.ownerOf(_nftId);\\n        _token = vnftDetails[_nftId].token;\\n        _tokenId = vnftDetails[_nftId].id;\\n        _fatalityReward = getFatalityReward(_nftId);\\n    }\\n\\n    function editCurves(\\n        uint256 _la,\\n        uint256 _lb,\\n        uint256 _ra,\\n        uint256 _rb\\n    ) external onlyOperator {\\n        la = _la;\\n        lb = _lb;\\n        ra = _ra;\\n        lb = _rb;\\n    }\\n\\n    uint256 la = 2;\\n    uint256 lb = 2;\\n    uint256 ra = 6;\\n    uint256 rb = 7;\\n\\n    // get the level the vNFT is on to calculate points\\n    function level(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula L(x) = 2 * sqrt(x * 2)\\n        uint256 _score = vnftScore[tokenId].div(100);\\n        if (_score == 0) {\\n            return 1;\\n        }\\n        uint256 _level = sqrtu(_score.mul(la));\\n        return (_level.mul(lb));\\n    }\\n\\n    // get the level the vNFT is on to calculate the token reward\\n    function getRewards(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula to get token rewards R(level)=(level)*6/7+6\\n        uint256 _level = this.level(tokenId);\\n        if (_level == 1) {\\n            return 6 ether;\\n        }\\n        _level = _level.mul(1 ether).mul(ra).div(rb);\\n        return (_level.add(5 ether));\\n    }\\n\\n    // edit specific item in case token goes up in value and the price for items gets to expensive for normal users.\\n    function editItem(\\n        uint256 _id,\\n        uint256 _price,\\n        uint256 _points,\\n        string calldata _name,\\n        uint256 _timeExtension\\n    ) external onlyOperator {\\n        itemPrice[_id] = _price;\\n        itemPoints[_id] = _points;\\n        itemName[_id] = _name;\\n        itemTimeExtension[_id] = _timeExtension;\\n    }\\n\\n    //can mine once every 24 hours per token.\\n    function claimMiningRewards(uint256 nftId) external notPaused {\\n        require(isVnftAlive(nftId), \\\"Your vNFT is dead, you can't mine\\\");\\n        require(\\n            block.timestamp >= lastTimeMined[nftId].add(1 minutes) ||\\n                lastTimeMined[nftId] == 0,\\n            \\\"Current timestamp is over the limit to claim the tokens\\\"\\n        );\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT to claim rewards\\\"\\n        );\\n\\n        //reset last start mined so can't remine and cheat\\n        lastTimeMined[nftId] = block.timestamp;\\n        uint256 _reward = this.getRewards(nftId);\\n        muse.mint(msg.sender, _reward);\\n        emit ClaimedMiningRewards(nftId, msg.sender, _reward);\\n    }\\n\\n    // Buy accesory to the VNFT\\n    function buyAccesory(uint256 nftId, uint256 itemId) external notPaused {\\n        require(itemExists(itemId), \\\"This item doesn't exist\\\");\\n        uint256 amount = itemPrice[itemId];\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT or be a care taker to buy items\\\"\\n        );\\n        // require(isVnftAlive(nftId), \\\"Your vNFT is dead\\\");\\n        uint256 amountToBurn = amount.mul(burnPercentage).div(100);\\n\\n        if (!isVnftAlive(nftId)) {\\n            vnftScore[nftId] = itemPoints[itemId];\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n        } else {\\n            //recalculate timeUntilStarving.\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n            vnftScore[nftId] = vnftScore[nftId].add(itemPoints[itemId]);\\n        }\\n        // burn 90% so they go back to community mining and staking, and send 10% to devs\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(amount.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), amount);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, amount);\\n        }\\n        emit VnftConsumed(nftId, msg.sender, itemId);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOperator {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function mint(address player) public override onlyMinter {\\n        //pet minted has 3 days until it starves at first\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            address(this),\\n            _tokenIds.current(),\\n            721\\n        );\\n        super._mint(player, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit VnftMinted(msg.sender);\\n    }\\n\\n    // kill starverd NFT and get 10% of his points.\\n    function fatality(uint256 _deadId, uint256 _tokenId) external notPaused {\\n        require(\\n            !isVnftAlive(_deadId),\\n            \\\"The vNFT has to be starved to claim his points\\\"\\n        );\\n        vnftScore[_tokenId] = vnftScore[_tokenId].add(\\n            (vnftScore[_deadId].mul(60).div(100))\\n        );\\n        // delete vnftDetails[_deadId];\\n        _burn(_deadId);\\n        emit VnftFatalized(_deadId, msg.sender);\\n    }\\n\\n    // Check how much score you'll get by fatality someone.\\n    function getFatalityReward(uint256 _deadId) public view returns (uint256) {\\n        if (isVnftAlive(_deadId)) {\\n            return 0;\\n        } else {\\n            return (vnftScore[_deadId].mul(50).div(100));\\n        }\\n    }\\n\\n    // add items/accessories\\n    function createItem(\\n        string calldata name,\\n        uint256 price,\\n        uint256 points,\\n        uint256 timeExtension\\n    ) external onlyOperator returns (bool) {\\n        _itemIds.increment();\\n        uint256 newItemId = _itemIds.current();\\n        itemName[newItemId] = name;\\n        itemPrice[newItemId] = price * 10**18;\\n        itemPoints[newItemId] = points;\\n        itemTimeExtension[newItemId] = timeExtension;\\n        emit ItemCreated(newItemId, name, price, points);\\n    }\\n\\n    //  *****************************\\n    //  LOGIC FOR EXTERNAL NFTS\\n    //  ****************************\\n    // support an external nft to mine rewards and play\\n    function addNft(address _nftToken, uint256 _type) public onlyOperator {\\n        supportedNfts.push(\\n            NFTInfo({token: _nftToken, active: true, standard: _type})\\n        );\\n    }\\n\\n    function supportedNftLength() external view returns (uint256) {\\n        return supportedNfts.length;\\n    }\\n\\n    function updateSupportedNFT(\\n        uint256 index,\\n        bool _active,\\n        address _address\\n    ) public onlyOperator {\\n        supportedNfts[index].active = _active;\\n        supportedNfts[index].token = _address;\\n    }\\n\\n    // aka WRAP: lets give life to your erc721 token and make it fun to mint $muse!\\n    function giveLife(\\n        uint256 index,\\n        uint256 _id,\\n        uint256 nftType\\n    ) external notPaused {\\n        uint256 amountToBurn = giveLifePrice.mul(burnPercentage).div(100);\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(giveLifePrice.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), giveLifePrice);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, giveLifePrice);\\n        }\\n\\n        if (nftType == 721) {\\n            IERC721(supportedNfts[index].token).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _id\\n            );\\n        } else if (nftType == 1155) {\\n            IERC1155(supportedNfts[index].token).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _id,\\n                1, //the amount of tokens to transfer which always be 1\\n                \\\"0x0\\\"\\n            );\\n        }\\n\\n        // mint a vNFT\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            supportedNfts[index].token,\\n            _id,\\n            nftType\\n        );\\n\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        super._mint(msg.sender, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit LifeGiven(supportedNfts[index].token, _id);\\n    }\\n\\n    // unwrap your vNFT if it is not dead, and get back your original NFT\\n    function unwrap(uint256 _vnftId) external {\\n        require(isVnftAlive(_vnftId), \\\"Your vNFT is dead, you can't unwrap it\\\");\\n        transferFrom(msg.sender, address(this), _vnftId);\\n        VNFTObj memory details = vnftDetails[_vnftId];\\n        timeUntilStarving[_vnftId] = 1;\\n        vnftScore[_vnftId] = 0;\\n        emit Unwrapped(_vnftId);\\n        _withdraw(details.id, details.token, msg.sender, details.standard);\\n    }\\n\\n    // withdraw dead wrapped NFTs or send them to the burn address.\\n    function withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) external onlyOperator {\\n        _withdraw(_id, _contractAddr, _to, _type);\\n    }\\n\\n    function _withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) internal {\\n        if (_type == 1155) {\\n            IERC1155(_contractAddr).safeTransferFrom(\\n                address(this),\\n                _to,\\n                _id,\\n                1,\\n                \\\"\\\"\\n            );\\n        } else if (_type == 721) {\\n            IERC721(_contractAddr).transferFrom(address(this), _to, _id);\\n        }\\n    }\\n\\n    // add care taker so in the future if vNFTs are sent to tokenizing platforms like niftex we can whitelist and the previous owner could still mine and do interesting stuff.\\n    function addCareTaker(uint256 _tokenId, address _careTaker) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        careTaker[_tokenId][msg.sender] = _careTaker;\\n        emit CareTakerAdded(_tokenId, _careTaker);\\n    }\\n\\n    function clearCareTaker(uint256 _tokenId) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        delete careTaker[_tokenId][msg.sender];\\n        emit CareTakerRemoved(_tokenId);\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n     * number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return unsigned 128-bit integer number\\n     */\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint128(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../utils/Counters.sol\\\";\\nimport \\\"../token/ERC721/ERC721.sol\\\";\\nimport \\\"../token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"../token/ERC721/ERC721Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC721} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *  - token ID and URI autogeneration\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC721PresetMinterPauserAutoId is Context, AccessControl, ERC721Burnable, ERC721Pausable {\\n    using Counters for Counters.Counter;\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    Counters.Counter private _tokenIdTracker;\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\\n     * See {ERC721-tokenURI}.\\n     */\\n    constructor(string memory name, string memory symbol, string memory baseURI) public ERC721(name, symbol) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n\\n        _setBaseURI(baseURI);\\n    }\\n\\n    /**\\n     * @dev Creates a new token for `to`. Its token ID will be automatically\\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\\n     * URI autogenerated based on the base URI passed at construction.\\n     *\\n     * See {ERC721-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have minter role to mint\\\");\\n\\n        // We cannot just use balanceOf to create the new tokenId because tokens\\n        // can be burned (destroyed), so we need a separate counter.\\n        _mint(to, _tokenIdTracker.current());\\n        _tokenIdTracker.increment();\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC721Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC721Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Pausable) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract Roles is AccessControl {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER\\\");\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR\\\");\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n}\\n\\ninterface IERC721 is IERC165 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function mint(address to) external;\\n}\\n\\n// Stake to get vnfts\\ncontract StakeForVnfts is Roles {\\n    using SafeMath for uint256;\\n\\n    IERC20 public museToken;\\n    IERC721 public vNFT;\\n\\n    // min $muse amount required to stake\\n    uint256 public minStake = 5 * 10**18;\\n\\n    // amount of points needed to redeem a vnft, roughly 1 point is given each day;\\n    uint256 public vnftPrice = 5 * 10**18;\\n    uint256 public totalStaked;\\n\\n    mapping(address => uint256) public balance;\\n    mapping(address => uint256) public lastUpdateTime;\\n    mapping(address => uint256) public points;\\n\\n    event Staked(address who, uint256 amount);\\n    event Withdrawal(address who, uint256 amount);\\n    event VnftMinted(address to);\\n\\n    event StakeReqChanged(uint256 newAmount);\\n    event PriceOfvnftChanged(uint256 newAmount);\\n\\n    constructor(address _vNFT, address _museToken) public {\\n        vNFT = IERC721(_vNFT);\\n        museToken = IERC20(_museToken);\\n    }\\n\\n    // changes stake requirement\\n    function changeStakeReq(uint256 _newAmount) external onlyOperator {\\n        minStake = _newAmount;\\n        emit StakeReqChanged(_newAmount);\\n    }\\n\\n    function changePriceOfNFT(uint256 _newAmount) external onlyOperator {\\n        vnftPrice = _newAmount;\\n        emit PriceOfvnftChanged(_newAmount);\\n    }\\n\\n    modifier updateReward(address account) {\\n        if (account != address(0)) {\\n            points[account] = earned(account);\\n            lastUpdateTime[account] = block.timestamp;\\n        }\\n        _;\\n    }\\n\\n    //calculate how many points earned so far, this needs to give roughly 1 point a day per 5 tokens staked?.\\n    function earned(address account) public view returns (uint256) {\\n        uint256 blockTime = block.timestamp;\\n        return\\n            balance[account]\\n                .mul(blockTime.sub(lastUpdateTime[account]).mul(2314814814000))\\n                .div(1e18)\\n                .add(points[account]);\\n    }\\n\\n    function stake(uint256 _amount) external updateReward(msg.sender) {\\n        require(\\n            _amount >= minStake,\\n            \\\"You need to stake at least the min $muse\\\"\\n        );\\n\\n        // transfer tokens to this address to stake them\\n        totalStaked = totalStaked.add(_amount);\\n        balance[msg.sender] = balance[msg.sender].add(_amount);\\n        museToken.transferFrom(msg.sender, address(this), _amount);\\n        emit Staked(msg.sender, _amount);\\n    }\\n\\n    // withdraw part of your stake\\n    function withdraw(uint256 amount) public updateReward(msg.sender) {\\n        require(amount > 0, \\\"Amount can't be 0\\\");\\n        require(totalStaked >= amount);\\n        balance[msg.sender] = balance[msg.sender].sub(amount);\\n        totalStaked = totalStaked.sub(amount);\\n        // transfer erc20 back from the contract to the user\\n        museToken.transfer(msg.sender, amount);\\n        emit Withdrawal(msg.sender, amount);\\n    }\\n\\n    // withdraw all your amount staked\\n    function exit() external {\\n        withdraw(balance[msg.sender]);\\n    }\\n\\n    //redeem a vNFT based on a set points price\\n    function redeem() public updateReward(msg.sender) {\\n        require(\\n            points[msg.sender] >= vnftPrice,\\n            \\\"Not enough points to redeem vNFT\\\"\\n        );\\n        points[msg.sender] = points[msg.sender].sub(vnftPrice);\\n        vNFT.mint(msg.sender);\\n        emit VnftMinted(msg.sender);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155Burnable.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC1155} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC1155PresetMinterPauser is Context, AccessControl, ERC1155Burnable, ERC1155Pausable {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\\n     * deploys the contract.\\n     */\\n    constructor(string memory uri) public ERC1155(uri) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\\n     *\\n     * See {ERC1155-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have minter role to mint\\\");\\n\\n        _mint(to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\\n     */\\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have minter role to mint\\\");\\n\\n        _mintBatch(to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC1155Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal virtual override(ERC1155, ERC1155Pausable)\\n    {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC20/ERC20.sol\\\";\\nimport \\\"../token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"../token/ERC20/ERC20Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC20PresetMinterPauser is Context, AccessControl, ERC20Burnable, ERC20Pausable {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(player, _tokenids.current()",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/presets/ERC721PresetMinterPauserAutoId.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ncontract TokenRecover is Ownable {\\n    /**\\n     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\\n     * @param tokenAddress The token contract address\\n     * @param tokenAmount Number of tokens to be sent\\n     */\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        public\\n        onlyOwner\\n    {\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n    }\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mintingFinished() external view returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\n/*\\n * Deployment checklist::\\n *  1. Deploy all contracts\\n *  2. Give minter role to the claiming contract\\n *  3. Add objects (most basic cost 5 and give 1 day and 1 score)\\n *  4.\\n */\\n\\n// ERC721,\\ncontract VNFT is\\n    Ownable,\\n    ERC721PresetMinterPauserAutoId,\\n    TokenRecover,\\n    ERC1155Holder\\n{\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    IMuseToken public muse;\\n\\n    struct VNFTObj {\\n        address token;\\n        uint256 id;\\n        uint256 standard; //the type\\n    }\\n\\n    // Mapping from token ID to NFT struct details\\n    mapping(uint256 => VNFTObj) public vnftDetails;\\n\\n    // max dev allocation is 10% of total supply\\n    uint256 public maxDevAllocation = 100000 * 10**18;\\n    uint256 public devAllocation = 0;\\n\\n    // External NFTs\\n    struct NFTInfo {\\n        address token; // Address of LP token contract.\\n        bool active;\\n        uint256 standard; //the nft standard ERC721 || ERC1155\\n    }\\n\\n    NFTInfo[] public supportedNfts;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _tokenIds;\\n    Counters.Counter private _itemIds;\\n\\n    // how many tokens to burn every time the VNFT is given an accessory, the remaining goes to the community and devs\\n    uint256 public burnPercentage = 90;\\n    uint256 public giveLifePrice = 5 * 10**18;\\n\\n    bool public gameStopped = false;\\n\\n    // mining tokens\\n    mapping(uint256 => uint256) public lastTimeMined;\\n\\n    // VNFT properties\\n    mapping(uint256 => uint256) public timeUntilStarving;\\n    mapping(uint256 => uint256) public vnftScore;\\n    mapping(uint256 => uint256) public timeVnftBorn;\\n\\n    // items/benefits for the VNFT could be anything in the future.\\n    mapping(uint256 => uint256) public itemPrice;\\n    mapping(uint256 => uint256) public itemPoints;\\n    mapping(uint256 => string) public itemName;\\n    mapping(uint256 => uint256) public itemTimeExtension;\\n\\n    // mapping(uint256 => address) public careTaker;\\n    mapping(uint256 => mapping(address => address)) public careTaker;\\n\\n    event BurnPercentageChanged(uint256 percentage);\\n    event ClaimedMiningRewards(uint256 who, address owner, uint256 amount);\\n    event VnftConsumed(uint256 nftId, address giver, uint256 itemId);\\n    event VnftMinted(address to);\\n    event VnftFatalized(uint256 nftId, address killer);\\n    event ItemCreated(uint256 id, string name, uint256 price, uint256 points);\\n    event LifeGiven(address forSupportedNFT, uint256 id);\\n    event Unwrapped(uint256 nftId);\\n    event CareTakerAdded(uint256 nftId, address _to);\\n    event CareTakerRemoved(uint256 nftId);\\n\\n    constructor(address _museToken)\\n        public\\n        ERC721PresetMinterPauserAutoId(\\n            \\\"VNFT\\\",\\n            \\\"VNFT\\\",\\n            \\\"https://gallery.verynify.io/api/\\\"\\n        )\\n    {\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n        muse = IMuseToken(_museToken);\\n    }\\n\\n    modifier notPaused() {\\n        require(!gameStopped, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    function contractURI() public pure returns (string memory) {\\n        return \\\"https://gallery.verynifty.io/api\\\";\\n    }\\n\\n    // in case a bug happens or we upgrade to another smart contract\\n    function pauseGame(bool _pause) external onlyOperator {\\n        gameStopped = _pause;\\n    }\\n\\n    // change how much to burn on each buy and how much goes to community.\\n    function changeBurnPercentage(uint256 percentage) external onlyOperator {\\n        require(percentage <= 100);\\n        burnPercentage = burnPercentage;\\n        emit BurnPercentageChanged(burnPercentage);\\n    }\\n\\n    function changeGiveLifePrice(uint256 _newPrice) external onlyOperator {\\n        giveLifePrice = _newPrice * 10**18;\\n    }\\n\\n    function changeMaxDevAllocation(uint256 amount) external onlyOperator {\\n        maxDevAllocation = amount;\\n    }\\n\\n    function itemExists(uint256 itemId) public view returns (bool) {\\n        if (bytes(itemName[itemId]).length > 0) {\\n            return true;\\n        }\\n    }\\n\\n    // check that VNFT didn't starve\\n    function isVnftAlive(uint256 _nftId) public view returns (bool) {\\n        uint256 _timeUntilStarving = timeUntilStarving[_nftId];\\n        if (_timeUntilStarving != 0 && _timeUntilStarving >= block.timestamp) {\\n            return true;\\n        }\\n    }\\n\\n    function getVnftScore(uint256 _nftId) public view returns (uint256) {\\n        return vnftScore[_nftId];\\n    }\\n\\n    function getItemInfo(uint256 _itemId)\\n        public\\n        view\\n        returns (\\n            string memory _name,\\n            uint256 _price,\\n            uint256 _points,\\n            uint256 _timeExtension\\n        )\\n    {\\n        _name = itemName[_itemId];\\n        _price = itemPrice[_itemId];\\n        _timeExtension = itemTimeExtension[_itemId];\\n        _points = itemPoints[_itemId];\\n    }\\n\\n    function getVnftInfo(uint256 _nftId)\\n        public\\n        view\\n        returns (\\n            uint256 _vNFT,\\n            bool _isAlive,\\n            uint256 _score,\\n            uint256 _level,\\n            uint256 _expectedReward,\\n            uint256 _timeUntilStarving,\\n            uint256 _lastTimeMined,\\n            uint256 _timeVnftBorn,\\n            address _owner,\\n            address _token,\\n            uint256 _tokenId,\\n            uint256 _fatalityReward\\n        )\\n    {\\n        _vNFT = _nftId;\\n        _isAlive = this.isVnftAlive(_nftId);\\n        _score = this.getVnftScore(_nftId);\\n        _level = this.level(_nftId);\\n        _expectedReward = this.getRewards(_nftId);\\n        _timeUntilStarving = timeUntilStarving[_nftId];\\n        _lastTimeMined = lastTimeMined[_nftId];\\n        _timeVnftBorn = timeVnftBorn[_nftId];\\n        _owner = this.ownerOf(_nftId);\\n        _token = vnftDetails[_nftId].token;\\n        _tokenId = vnftDetails[_nftId].id;\\n        _fatalityReward = getFatalityReward(_nftId);\\n    }\\n\\n    function editCurves(\\n        uint256 _la,\\n        uint256 _lb,\\n        uint256 _ra,\\n        uint256 _rb\\n    ) external onlyOperator {\\n        la = _la;\\n        lb = _lb;\\n        ra = _ra;\\n        lb = _rb;\\n    }\\n\\n    uint256 la = 2;\\n    uint256 lb = 2;\\n    uint256 ra = 6;\\n    uint256 rb = 7;\\n\\n    // get the level the vNFT is on to calculate points\\n    function level(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula L(x) = 2 * sqrt(x * 2)\\n        uint256 _score = vnftScore[tokenId].div(100);\\n        if (_score == 0) {\\n            return 1;\\n        }\\n        uint256 _level = sqrtu(_score.mul(la));\\n        return (_level.mul(lb));\\n    }\\n\\n    // get the level the vNFT is on to calculate the token reward\\n    function getRewards(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula to get token rewards R(level)=(level)*6/7+6\\n        uint256 _level = this.level(tokenId);\\n        if (_level == 1) {\\n            return 6 ether;\\n        }\\n        _level = _level.mul(1 ether).mul(ra).div(rb);\\n        return (_level.add(5 ether));\\n    }\\n\\n    // edit specific item in case token goes up in value and the price for items gets to expensive for normal users.\\n    function editItem(\\n        uint256 _id,\\n        uint256 _price,\\n        uint256 _points,\\n        string calldata _name,\\n        uint256 _timeExtension\\n    ) external onlyOperator {\\n        itemPrice[_id] = _price;\\n        itemPoints[_id] = _points;\\n        itemName[_id] = _name;\\n        itemTimeExtension[_id] = _timeExtension;\\n    }\\n\\n    //can mine once every 24 hours per token.\\n    function claimMiningRewards(uint256 nftId) external notPaused {\\n        require(isVnftAlive(nftId), \\\"Your vNFT is dead, you can't mine\\\");\\n        require(\\n            block.timestamp >= lastTimeMined[nftId].add(1 minutes) ||\\n                lastTimeMined[nftId] == 0,\\n            \\\"Current timestamp is over the limit to claim the tokens\\\"\\n        );\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT to claim rewards\\\"\\n        );\\n\\n        //reset last start mined so can't remine and cheat\\n        lastTimeMined[nftId] = block.timestamp;\\n        uint256 _reward = this.getRewards(nftId);\\n        muse.mint(msg.sender, _reward);\\n        emit ClaimedMiningRewards(nftId, msg.sender, _reward);\\n    }\\n\\n    // Buy accesory to the VNFT\\n    function buyAccesory(uint256 nftId, uint256 itemId) external notPaused {\\n        require(itemExists(itemId), \\\"This item doesn't exist\\\");\\n        uint256 amount = itemPrice[itemId];\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT or be a care taker to buy items\\\"\\n        );\\n        // require(isVnftAlive(nftId), \\\"Your vNFT is dead\\\");\\n        uint256 amountToBurn = amount.mul(burnPercentage).div(100);\\n\\n        if (!isVnftAlive(nftId)) {\\n            vnftScore[nftId] = itemPoints[itemId];\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n        } else {\\n            //recalculate timeUntilStarving.\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n            vnftScore[nftId] = vnftScore[nftId].add(itemPoints[itemId]);\\n        }\\n        // burn 90% so they go back to community mining and staking, and send 10% to devs\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(amount.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), amount);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, amount);\\n        }\\n        emit VnftConsumed(nftId, msg.sender, itemId);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOperator {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function mint(address player) public override onlyMinter {\\n        //pet minted has 3 days until it starves at first\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            address(this),\\n            _tokenIds.current(),\\n            721\\n        );\\n        super._mint(player, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit VnftMinted(msg.sender);\\n    }\\n\\n    // kill starverd NFT and get 10% of his points.\\n    function fatality(uint256 _deadId, uint256 _tokenId) external notPaused {\\n        require(\\n            !isVnftAlive(_deadId),\\n            \\\"The vNFT has to be starved to claim his points\\\"\\n        );\\n        vnftScore[_tokenId] = vnftScore[_tokenId].add(\\n            (vnftScore[_deadId].mul(60).div(100))\\n        );\\n        // delete vnftDetails[_deadId];\\n        _burn(_deadId);\\n        emit VnftFatalized(_deadId, msg.sender);\\n    }\\n\\n    // Check how much score you'll get by fatality someone.\\n    function getFatalityReward(uint256 _deadId) public view returns (uint256) {\\n        if (isVnftAlive(_deadId)) {\\n            return 0;\\n        } else {\\n            return (vnftScore[_deadId].mul(50).div(100));\\n        }\\n    }\\n\\n    // add items/accessories\\n    function createItem(\\n        string calldata name,\\n        uint256 price,\\n        uint256 points,\\n        uint256 timeExtension\\n    ) external onlyOperator returns (bool) {\\n        _itemIds.increment();\\n        uint256 newItemId = _itemIds.current();\\n        itemName[newItemId] = name;\\n        itemPrice[newItemId] = price * 10**18;\\n        itemPoints[newItemId] = points;\\n        itemTimeExtension[newItemId] = timeExtension;\\n        emit ItemCreated(newItemId, name, price, points);\\n    }\\n\\n    //  *****************************\\n    //  LOGIC FOR EXTERNAL NFTS\\n    //  ****************************\\n    // support an external nft to mine rewards and play\\n    function addNft(address _nftToken, uint256 _type) public onlyOperator {\\n        supportedNfts.push(\\n            NFTInfo({token: _nftToken, active: true, standard: _type})\\n        );\\n    }\\n\\n    function supportedNftLength() external view returns (uint256) {\\n        return supportedNfts.length;\\n    }\\n\\n    function updateSupportedNFT(\\n        uint256 index,\\n        bool _active,\\n        address _address\\n    ) public onlyOperator {\\n        supportedNfts[index].active = _active;\\n        supportedNfts[index].token = _address;\\n    }\\n\\n    // aka WRAP: lets give life to your erc721 token and make it fun to mint $muse!\\n    function giveLife(\\n        uint256 index,\\n        uint256 _id,\\n        uint256 nftType\\n    ) external notPaused {\\n        uint256 amountToBurn = giveLifePrice.mul(burnPercentage).div(100);\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(giveLifePrice.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), giveLifePrice);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, giveLifePrice);\\n        }\\n\\n        if (nftType == 721) {\\n            IERC721(supportedNfts[index].token).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _id\\n            );\\n        } else if (nftType == 1155) {\\n            IERC1155(supportedNfts[index].token).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _id,\\n                1, //the amount of tokens to transfer which always be 1\\n                \\\"0x0\\\"\\n            );\\n        }\\n\\n        // mint a vNFT\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            supportedNfts[index].token,\\n            _id,\\n            nftType\\n        );\\n\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        super._mint(msg.sender, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit LifeGiven(supportedNfts[index].token, _id);\\n    }\\n\\n    // unwrap your vNFT if it is not dead, and get back your original NFT\\n    function unwrap(uint256 _vnftId) external {\\n        require(isVnftAlive(_vnftId), \\\"Your vNFT is dead, you can't unwrap it\\\");\\n        transferFrom(msg.sender, address(this), _vnftId);\\n        VNFTObj memory details = vnftDetails[_vnftId];\\n        timeUntilStarving[_vnftId] = 1;\\n        vnftScore[_vnftId] = 0;\\n        emit Unwrapped(_vnftId);\\n        _withdraw(details.id, details.token, msg.sender, details.standard);\\n    }\\n\\n    // withdraw dead wrapped NFTs or send them to the burn address.\\n    function withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) external onlyOperator {\\n        _withdraw(_id, _contractAddr, _to, _type);\\n    }\\n\\n    function _withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) internal {\\n        if (_type == 1155) {\\n            IERC1155(_contractAddr).safeTransferFrom(\\n                address(this),\\n                _to,\\n                _id,\\n                1,\\n                \\\"\\\"\\n            );\\n        } else if (_type == 721) {\\n            IERC721(_contractAddr).transferFrom(address(this), _to, _id);\\n        }\\n    }\\n\\n    // add care taker so in the future if vNFTs are sent to tokenizing platforms like niftex we can whitelist and the previous owner could still mine and do interesting stuff.\\n    function addCareTaker(uint256 _tokenId, address _careTaker) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        careTaker[_tokenId][msg.sender] = _careTaker;\\n        emit CareTakerAdded(_tokenId, _careTaker);\\n    }\\n\\n    function clearCareTaker(uint256 _tokenId) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        delete careTaker[_tokenId][msg.sender];\\n        emit CareTakerRemoved(_tokenId);\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n     * number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return unsigned 128-bit integer number\\n     */\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint128(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, _tokenids.current()",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/presets/ERC721PresetMinterPauserAutoId.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ncontract TokenRecover is Ownable {\\n    /**\\n     * @dev Remember that only owner can call so be careful when use on contracts generated from other contracts.\\n     * @param tokenAddress The token contract address\\n     * @param tokenAmount Number of tokens to be sent\\n     */\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount)\\n        public\\n        onlyOwner\\n    {\\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\\n    }\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mintingFinished() external view returns (bool);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\n/*\\n * Deployment checklist::\\n *  1. Deploy all contracts\\n *  2. Give minter role to the claiming contract\\n *  3. Add objects (most basic cost 5 and give 1 day and 1 score)\\n *  4.\\n */\\n\\n// ERC721,\\ncontract VNFT is\\n    Ownable,\\n    ERC721PresetMinterPauserAutoId,\\n    TokenRecover,\\n    ERC1155Holder\\n{\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    IMuseToken public muse;\\n\\n    struct VNFTObj {\\n        address token;\\n        uint256 id;\\n        uint256 standard; //the type\\n    }\\n\\n    // Mapping from token ID to NFT struct details\\n    mapping(uint256 => VNFTObj) public vnftDetails;\\n\\n    // max dev allocation is 10% of total supply\\n    uint256 public maxDevAllocation = 100000 * 10**18;\\n    uint256 public devAllocation = 0;\\n\\n    // External NFTs\\n    struct NFTInfo {\\n        address token; // Address of LP token contract.\\n        bool active;\\n        uint256 standard; //the nft standard ERC721 || ERC1155\\n    }\\n\\n    NFTInfo[] public supportedNfts;\\n\\n    using Counters for Counters.Counter;\\n    Counters.Counter private _tokenIds;\\n    Counters.Counter private _itemIds;\\n\\n    // how many tokens to burn every time the VNFT is given an accessory, the remaining goes to the community and devs\\n    uint256 public burnPercentage = 90;\\n    uint256 public giveLifePrice = 5 * 10**18;\\n\\n    bool public gameStopped = false;\\n\\n    // mining tokens\\n    mapping(uint256 => uint256) public lastTimeMined;\\n\\n    // VNFT properties\\n    mapping(uint256 => uint256) public timeUntilStarving;\\n    mapping(uint256 => uint256) public vnftScore;\\n    mapping(uint256 => uint256) public timeVnftBorn;\\n\\n    // items/benefits for the VNFT could be anything in the future.\\n    mapping(uint256 => uint256) public itemPrice;\\n    mapping(uint256 => uint256) public itemPoints;\\n    mapping(uint256 => string) public itemName;\\n    mapping(uint256 => uint256) public itemTimeExtension;\\n\\n    // mapping(uint256 => address) public careTaker;\\n    mapping(uint256 => mapping(address => address)) public careTaker;\\n\\n    event BurnPercentageChanged(uint256 percentage);\\n    event ClaimedMiningRewards(uint256 who, address owner, uint256 amount);\\n    event VnftConsumed(uint256 nftId, address giver, uint256 itemId);\\n    event VnftMinted(address to);\\n    event VnftFatalized(uint256 nftId, address killer);\\n    event ItemCreated(uint256 id, string name, uint256 price, uint256 points);\\n    event LifeGiven(address forSupportedNFT, uint256 id);\\n    event Unwrapped(uint256 nftId);\\n    event CareTakerAdded(uint256 nftId, address _to);\\n    event CareTakerRemoved(uint256 nftId);\\n\\n    constructor(address _museToken)\\n        public\\n        ERC721PresetMinterPauserAutoId(\\n            \\\"VNFT\\\",\\n            \\\"VNFT\\\",\\n            \\\"https://gallery.verynify.io/api/\\\"\\n        )\\n    {\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n        muse = IMuseToken(_museToken);\\n    }\\n\\n    modifier notPaused() {\\n        require(!gameStopped, \\\"Contract is paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    function contractURI() public pure returns (string memory) {\\n        return \\\"https://gallery.verynifty.io/api\\\";\\n    }\\n\\n    // in case a bug happens or we upgrade to another smart contract\\n    function pauseGame(bool _pause) external onlyOperator {\\n        gameStopped = _pause;\\n    }\\n\\n    // change how much to burn on each buy and how much goes to community.\\n    function changeBurnPercentage(uint256 percentage) external onlyOperator {\\n        require(percentage <= 100);\\n        burnPercentage = burnPercentage;\\n        emit BurnPercentageChanged(burnPercentage);\\n    }\\n\\n    function changeGiveLifePrice(uint256 _newPrice) external onlyOperator {\\n        giveLifePrice = _newPrice * 10**18;\\n    }\\n\\n    function changeMaxDevAllocation(uint256 amount) external onlyOperator {\\n        maxDevAllocation = amount;\\n    }\\n\\n    function itemExists(uint256 itemId) public view returns (bool) {\\n        if (bytes(itemName[itemId]).length > 0) {\\n            return true;\\n        }\\n    }\\n\\n    // check that VNFT didn't starve\\n    function isVnftAlive(uint256 _nftId) public view returns (bool) {\\n        uint256 _timeUntilStarving = timeUntilStarving[_nftId];\\n        if (_timeUntilStarving != 0 && _timeUntilStarving >= block.timestamp) {\\n            return true;\\n        }\\n    }\\n\\n    function getVnftScore(uint256 _nftId) public view returns (uint256) {\\n        return vnftScore[_nftId];\\n    }\\n\\n    function getItemInfo(uint256 _itemId)\\n        public\\n        view\\n        returns (\\n            string memory _name,\\n            uint256 _price,\\n            uint256 _points,\\n            uint256 _timeExtension\\n        )\\n    {\\n        _name = itemName[_itemId];\\n        _price = itemPrice[_itemId];\\n        _timeExtension = itemTimeExtension[_itemId];\\n        _points = itemPoints[_itemId];\\n    }\\n\\n    function getVnftInfo(uint256 _nftId)\\n        public\\n        view\\n        returns (\\n            uint256 _vNFT,\\n            bool _isAlive,\\n            uint256 _score,\\n            uint256 _level,\\n            uint256 _expectedReward,\\n            uint256 _timeUntilStarving,\\n            uint256 _lastTimeMined,\\n            uint256 _timeVnftBorn,\\n            address _owner,\\n            address _token,\\n            uint256 _tokenId,\\n            uint256 _fatalityReward\\n        )\\n    {\\n        _vNFT = _nftId;\\n        _isAlive = this.isVnftAlive(_nftId);\\n        _score = this.getVnftScore(_nftId);\\n        _level = this.level(_nftId);\\n        _expectedReward = this.getRewards(_nftId);\\n        _timeUntilStarving = timeUntilStarving[_nftId];\\n        _lastTimeMined = lastTimeMined[_nftId];\\n        _timeVnftBorn = timeVnftBorn[_nftId];\\n        _owner = this.ownerOf(_nftId);\\n        _token = vnftDetails[_nftId].token;\\n        _tokenId = vnftDetails[_nftId].id;\\n        _fatalityReward = getFatalityReward(_nftId);\\n    }\\n\\n    function editCurves(\\n        uint256 _la,\\n        uint256 _lb,\\n        uint256 _ra,\\n        uint256 _rb\\n    ) external onlyOperator {\\n        la = _la;\\n        lb = _lb;\\n        ra = _ra;\\n        lb = _rb;\\n    }\\n\\n    uint256 la = 2;\\n    uint256 lb = 2;\\n    uint256 ra = 6;\\n    uint256 rb = 7;\\n\\n    // get the level the vNFT is on to calculate points\\n    function level(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula L(x) = 2 * sqrt(x * 2)\\n        uint256 _score = vnftScore[tokenId].div(100);\\n        if (_score == 0) {\\n            return 1;\\n        }\\n        uint256 _level = sqrtu(_score.mul(la));\\n        return (_level.mul(lb));\\n    }\\n\\n    // get the level the vNFT is on to calculate the token reward\\n    function getRewards(uint256 tokenId) external view returns (uint256) {\\n        // This is the formula to get token rewards R(level)=(level)*6/7+6\\n        uint256 _level = this.level(tokenId);\\n        if (_level == 1) {\\n            return 6 ether;\\n        }\\n        _level = _level.mul(1 ether).mul(ra).div(rb);\\n        return (_level.add(5 ether));\\n    }\\n\\n    // edit specific item in case token goes up in value and the price for items gets to expensive for normal users.\\n    function editItem(\\n        uint256 _id,\\n        uint256 _price,\\n        uint256 _points,\\n        string calldata _name,\\n        uint256 _timeExtension\\n    ) external onlyOperator {\\n        itemPrice[_id] = _price;\\n        itemPoints[_id] = _points;\\n        itemName[_id] = _name;\\n        itemTimeExtension[_id] = _timeExtension;\\n    }\\n\\n    //can mine once every 24 hours per token.\\n    function claimMiningRewards(uint256 nftId) external notPaused {\\n        require(isVnftAlive(nftId), \\\"Your vNFT is dead, you can't mine\\\");\\n        require(\\n            block.timestamp >= lastTimeMined[nftId].add(1 minutes) ||\\n                lastTimeMined[nftId] == 0,\\n            \\\"Current timestamp is over the limit to claim the tokens\\\"\\n        );\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT to claim rewards\\\"\\n        );\\n\\n        //reset last start mined so can't remine and cheat\\n        lastTimeMined[nftId] = block.timestamp;\\n        uint256 _reward = this.getRewards(nftId);\\n        muse.mint(msg.sender, _reward);\\n        emit ClaimedMiningRewards(nftId, msg.sender, _reward);\\n    }\\n\\n    // Buy accesory to the VNFT\\n    function buyAccesory(uint256 nftId, uint256 itemId) external notPaused {\\n        require(itemExists(itemId), \\\"This item doesn't exist\\\");\\n        uint256 amount = itemPrice[itemId];\\n        require(\\n            ownerOf(nftId) == msg.sender ||\\n                careTaker[nftId][ownerOf(nftId)] == msg.sender,\\n            \\\"You must own the vNFT or be a care taker to buy items\\\"\\n        );\\n        // require(isVnftAlive(nftId), \\\"Your vNFT is dead\\\");\\n        uint256 amountToBurn = amount.mul(burnPercentage).div(100);\\n\\n        if (!isVnftAlive(nftId)) {\\n            vnftScore[nftId] = itemPoints[itemId];\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n        } else {\\n            //recalculate timeUntilStarving.\\n            timeUntilStarving[nftId] = block.timestamp.add(\\n                itemTimeExtension[itemId]\\n            );\\n            vnftScore[nftId] = vnftScore[nftId].add(itemPoints[itemId]);\\n        }\\n        // burn 90% so they go back to community mining and staking, and send 10% to devs\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(amount.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), amount);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, amount);\\n        }\\n        emit VnftConsumed(nftId, msg.sender, itemId);\\n    }\\n\\n    function setBaseURI(string memory baseURI_) public onlyOperator {\\n        _setBaseURI(baseURI_);\\n    }\\n\\n    function mint(address player) public override onlyMinter {\\n        //pet minted has 3 days until it starves at first\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            address(this),\\n            _tokenIds.current(),\\n            721\\n        );\\n        super._mint(player, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit VnftMinted(msg.sender);\\n    }\\n\\n    // kill starverd NFT and get 10% of his points.\\n    function fatality(uint256 _deadId, uint256 _tokenId) external notPaused {\\n        require(\\n            !isVnftAlive(_deadId),\\n            \\\"The vNFT has to be starved to claim his points\\\"\\n        );\\n        vnftScore[_tokenId] = vnftScore[_tokenId].add(\\n            (vnftScore[_deadId].mul(60).div(100))\\n        );\\n        // delete vnftDetails[_deadId];\\n        _burn(_deadId);\\n        emit VnftFatalized(_deadId, msg.sender);\\n    }\\n\\n    // Check how much score you'll get by fatality someone.\\n    function getFatalityReward(uint256 _deadId) public view returns (uint256) {\\n        if (isVnftAlive(_deadId)) {\\n            return 0;\\n        } else {\\n            return (vnftScore[_deadId].mul(50).div(100));\\n        }\\n    }\\n\\n    // add items/accessories\\n    function createItem(\\n        string calldata name,\\n        uint256 price,\\n        uint256 points,\\n        uint256 timeExtension\\n    ) external onlyOperator returns (bool) {\\n        _itemIds.increment();\\n        uint256 newItemId = _itemIds.current();\\n        itemName[newItemId] = name;\\n        itemPrice[newItemId] = price * 10**18;\\n        itemPoints[newItemId] = points;\\n        itemTimeExtension[newItemId] = timeExtension;\\n        emit ItemCreated(newItemId, name, price, points);\\n    }\\n\\n    //  *****************************\\n    //  LOGIC FOR EXTERNAL NFTS\\n    //  ****************************\\n    // support an external nft to mine rewards and play\\n    function addNft(address _nftToken, uint256 _type) public onlyOperator {\\n        supportedNfts.push(\\n            NFTInfo({token: _nftToken, active: true, standard: _type})\\n        );\\n    }\\n\\n    function supportedNftLength() external view returns (uint256) {\\n        return supportedNfts.length;\\n    }\\n\\n    function updateSupportedNFT(\\n        uint256 index,\\n        bool _active,\\n        address _address\\n    ) public onlyOperator {\\n        supportedNfts[index].active = _active;\\n        supportedNfts[index].token = _address;\\n    }\\n\\n    // aka WRAP: lets give life to your erc721 token and make it fun to mint $muse!\\n    function giveLife(\\n        uint256 index,\\n        uint256 _id,\\n        uint256 nftType\\n    ) external notPaused {\\n        uint256 amountToBurn = giveLifePrice.mul(burnPercentage).div(100);\\n\\n        if (devAllocation <= maxDevAllocation) {\\n            devAllocation = devAllocation.add(giveLifePrice.sub(amountToBurn));\\n            muse.transferFrom(msg.sender, address(this), giveLifePrice);\\n            // burn 90% of token, 10% stay for dev and community fund\\n            muse.burn(amountToBurn);\\n        } else {\\n            muse.burnFrom(msg.sender, giveLifePrice);\\n        }\\n\\n        if (nftType == 721) {\\n            IERC721(supportedNfts[index].token).transferFrom(\\n                msg.sender,\\n                address(this),\\n                _id\\n            );\\n        } else if (nftType == 1155) {\\n            IERC1155(supportedNfts[index].token).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                _id,\\n                1, //the amount of tokens to transfer which always be 1\\n                \\\"0x0\\\"\\n            );\\n        }\\n\\n        // mint a vNFT\\n        vnftDetails[_tokenIds.current()] = VNFTObj(\\n            supportedNfts[index].token,\\n            _id,\\n            nftType\\n        );\\n\\n        timeUntilStarving[_tokenIds.current()] = block.timestamp.add(3 days);\\n        timeVnftBorn[_tokenIds.current()] = block.timestamp;\\n\\n        super._mint(msg.sender, _tokenIds.current());\\n        _tokenIds.increment();\\n        emit LifeGiven(supportedNfts[index].token, _id);\\n    }\\n\\n    // unwrap your vNFT if it is not dead, and get back your original NFT\\n    function unwrap(uint256 _vnftId) external {\\n        require(isVnftAlive(_vnftId), \\\"Your vNFT is dead, you can't unwrap it\\\");\\n        transferFrom(msg.sender, address(this), _vnftId);\\n        VNFTObj memory details = vnftDetails[_vnftId];\\n        timeUntilStarving[_vnftId] = 1;\\n        vnftScore[_vnftId] = 0;\\n        emit Unwrapped(_vnftId);\\n        _withdraw(details.id, details.token, msg.sender, details.standard);\\n    }\\n\\n    // withdraw dead wrapped NFTs or send them to the burn address.\\n    function withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) external onlyOperator {\\n        _withdraw(_id, _contractAddr, _to, _type);\\n    }\\n\\n    function _withdraw(\\n        uint256 _id,\\n        address _contractAddr,\\n        address _to,\\n        uint256 _type\\n    ) internal {\\n        if (_type == 1155) {\\n            IERC1155(_contractAddr).safeTransferFrom(\\n                address(this),\\n                _to,\\n                _id,\\n                1,\\n                \\\"\\\"\\n            );\\n        } else if (_type == 721) {\\n            IERC721(_contractAddr).transferFrom(address(this), _to, _id);\\n        }\\n    }\\n\\n    // add care taker so in the future if vNFTs are sent to tokenizing platforms like niftex we can whitelist and the previous owner could still mine and do interesting stuff.\\n    function addCareTaker(uint256 _tokenId, address _careTaker) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        careTaker[_tokenId][msg.sender] = _careTaker;\\n        emit CareTakerAdded(_tokenId, _careTaker);\\n    }\\n\\n    function clearCareTaker(uint256 _tokenId) external {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()) ||\\n                ownerOf(_tokenId) == msg.sender,\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        delete careTaker[_tokenId][msg.sender];\\n        emit CareTakerRemoved(_tokenId);\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n     * number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return unsigned 128-bit integer number\\n     */\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint128(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, tokenid)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address to, uint256 tokenid)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, _tokenidtracker.current()",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../utils/Counters.sol\\\";\\nimport \\\"../token/ERC721/ERC721.sol\\\";\\nimport \\\"../token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"../token/ERC721/ERC721Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC721} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *  - token ID and URI autogeneration\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC721PresetMinterPauserAutoId is Context, AccessControl, ERC721Burnable, ERC721Pausable {\\n    using Counters for Counters.Counter;\\n\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    Counters.Counter private _tokenIdTracker;\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * Token URIs will be autogenerated based on `baseURI` and their token IDs.\\n     * See {ERC721-tokenURI}.\\n     */\\n    constructor(string memory name, string memory symbol, string memory baseURI) public ERC721(name, symbol) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n\\n        _setBaseURI(baseURI);\\n    }\\n\\n    /**\\n     * @dev Creates a new token for `to`. Its token ID will be automatically\\n     * assigned (and available on the emitted {IERC721-Transfer} event), and the token\\n     * URI autogenerated based on the base URI passed at construction.\\n     *\\n     * See {ERC721-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have minter role to mint\\\");\\n\\n        // We cannot just use balanceOf to create the new tokenId because tokens\\n        // can be burned (destroyed), so we need a separate counter.\\n        _mint(to, _tokenIdTracker.current());\\n        _tokenIdTracker.increment();\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC721Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC721Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Pausable) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, id, amount, data)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../access/AccessControl.sol\\\";\\nimport \\\"../GSN/Context.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155Burnable.sol\\\";\\nimport \\\"../token/ERC1155/ERC1155Pausable.sol\\\";\\n\\n/**\\n * @dev {ERC1155} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC1155PresetMinterPauser is Context, AccessControl, ERC1155Burnable, ERC1155Pausable {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that\\n     * deploys the contract.\\n     */\\n    constructor(string memory uri) public ERC1155(uri) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`, of token type `id`.\\n     *\\n     * See {ERC1155-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have minter role to mint\\\");\\n\\n        _mint(to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.\\n     */\\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have minter role to mint\\\");\\n\\n        _mintBatch(to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC1155Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC1155Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC1155PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal virtual override(ERC1155, ERC1155Pausable)\\n    {\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 id, uint256 amount, bytes memory data)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri) public {\\n        _setURI(uri);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            require(accounts[i] != address(0), \\\"ERC1155: batch balance query for the zero address\\\");\\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(_baseURI).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "liquidity_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "function emergencywithdraw",
          "function_context": "\"content\": \"pragma solidity ^0.6.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n// import \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n// import \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// ******************\\n// this is for staking lp tokens and getting back $pet tokens\\n// We can use this \\\"MasterChef.sol\\\" conract introduced by SuhiSwap, they do exactly what we need and the code is already used by many smart contracts and battle tested with $100s of millions staked in sushiswap\\n// *******************\\n\\n// @TODO maybe lets add the roles library to this also to have more then one wallet being able to run this\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, _msgSender()));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(\\n            hasRole(_roles[role].adminRole, _msgSender()),\\n            \\\"AccessControl: sender must be an admin to grant\\\"\\n        );\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(\\n            hasRole(_roles[role].adminRole, _msgSender()),\\n            \\\"AccessControl: sender must be an admin to revoke\\\"\\n        );\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(\\n            account == _msgSender(),\\n            \\\"AccessControl: can only renounce roles for self\\\"\\n        );\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\\n// File: contracts/access/Roles.sol\\n\\npragma solidity ^0.6.0;\\n\\ncontract Roles is AccessControl {\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER\\\");\\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR\\\");\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(OPERATOR_ROLE, _msgSender());\\n    }\\n\\n    modifier onlyMinter() {\\n        require(\\n            hasRole(MINTER_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the MINTER role\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            hasRole(OPERATOR_ROLE, _msgSender()),\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n}\\n\\ninterface IMigratorChef {\\n    // Perform LP token migration from legacy UniswapV2 to SushiSwap.\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    // Return the new LP token address.\\n    //\\n    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\\n    // SushiSwap must mint EXACTLY the same amount of SushiSwap LP tokens or\\n    // else something bad will happen. Traditional UniswapV2 does not\\n    // do that so be careful!\\n    function migrate(IERC20 token) external returns (IERC20);\\n}\\n\\n// Interface for our erc20 token\\ninterface IMuseToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mint(address to, uint256 amount) external;\\n}\\n\\n// MasterChef is the master of Sushi. He can make Sushi and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once SUSHI is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable, Roles {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount; // How many LP tokens the user has provided.\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accSushiPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IERC20 lpToken; // Address of LP token contract.\\n        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.\\n        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.\\n    }\\n\\n    // The Muse TOKEN!\\n    IMuseToken public museToken;\\n    // adding this just in case of nobody using the game but degens hacking the farming\\n    bool devFee = false;\\n    // Dev address.\\n    address public devaddr;\\n    // Block number when bonus SUSHI period ends.\\n    uint256 public bonusEndBlock;\\n    // SUSHI tokens created per block.\\n    uint256 public sushiPerBlock;\\n    // Bonus muliplier for early sushi makers.\\n    uint256 public constant BONUS_MULTIPLIER = 10;\\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when SUSHI mining starts.\\n    uint256 public startBlock;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(\\n        address indexed user,\\n        uint256 indexed pid,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        IMuseToken _museToken,\\n        // address _devaddr,\\n        uint256 _sushiPerBlock,\\n        uint256 _startBlock,\\n        uint256 _bonusEndBlock\\n    ) public {\\n        museToken = _museToken;\\n        devaddr = msg.sender;\\n        sushiPerBlock = _sushiPerBlock;\\n        bonusEndBlock = _bonusEndBlock;\\n        startBlock = _startBlock;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    function allowDevFee(bool _allow) public onlyOperator {\\n        devFee = _allow;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(\\n        uint256 _allocPoint,\\n        IERC20 _lpToken,\\n        bool _withUpdate\\n    ) public onlyOperator {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock\\n            ? block.number\\n            : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(\\n            PoolInfo({\\n                lpToken: _lpToken,\\n                allocPoint: _allocPoint,\\n                lastRewardBlock: lastRewardBlock,\\n                accSushiPerShare: 0\\n            })\\n        );\\n    }\\n\\n    // Update the given pool's SUSHI allocation point. Can only be called by the owner.\\n    function set(\\n        uint256 _pid,\\n        uint256 _allocPoint,\\n        bool _withUpdate\\n    ) public onlyOperator {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\\n            _allocPoint\\n        );\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n    }\\n\\n    // Set the migrator contract. Can only be called by the owner.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\\n    function migrate(uint256 _pid) public {\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IERC20 lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        lpToken.safeApprove(address(migrator), bal);\\n        IERC20 newLpToken = migrator.migrate(lpToken);\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n        pool.lpToken = newLpToken;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_to <= bonusEndBlock) {\\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n        } else if (_from >= bonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return\\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\\n                    _to.sub(bonusEndBlock)\\n                );\\n        }\\n    }\\n\\n    // View function to see pending SUSHIs on frontend.\\n    function pendingSushi(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accSushiPerShare = pool.accSushiPerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(\\n                pool.lastRewardBlock,\\n                block.number\\n            );\\n            uint256 sushiReward = multiplier\\n                .mul(sushiPerBlock)\\n                .mul(pool.allocPoint)\\n                .div(totalAllocPoint);\\n            accSushiPerShare = accSushiPerShare.add(\\n                sushiReward.mul(1e12).div(lpSupply)\\n            );\\n        }\\n        return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\\n    }\\n\\n    // Update reward vairables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 sushiReward = multiplier\\n            .mul(sushiPerBlock)\\n            .mul(pool.allocPoint)\\n            .div(totalAllocPoint);\\n\\n        //no dev fee as of now\\n        if (devFee) {\\n            museToken.mint(devaddr, sushiReward.div(10));\\n        }\\n        museToken.mint(address(this), sushiReward);\\n        pool.accSushiPerShare = pool.accSushiPerShare.add(\\n            sushiReward.mul(1e12).div(lpSupply)\\n        );\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Deposit LP tokens to MasterChef for SUSHI allocation.\\n    function deposit(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = user\\n                .amount\\n                .mul(pool.accSushiPerShare)\\n                .div(1e12)\\n                .sub(user.rewardDebt);\\n            safeSushiTransfer(msg.sender, pending);\\n        }\\n        pool.lpToken.safeTransferFrom(\\n            address(msg.sender),\\n            address(this),\\n            _amount\\n        );\\n        user.amount = user.amount.add(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        updatePool(_pid);\\n        uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(\\n            user.rewardDebt\\n        );\\n        safeSushiTransfer(msg.sender, pending);\\n        user.amount = user.amount.sub(_amount);\\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n    }\\n\\n    // Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.\\n    function safeSushiTransfer(address _to, uint256 _amount) internal {\\n        uint256 sushiBal = museToken.balanceOf(address(this));\\n        if (_amount > sushiBal) {\\n            museToken.transfer(_to, sushiBal);\\n        } else {\\n            museToken.transfer(_to, _amount);\\n        }\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n}\\n\"",
          "pattern": "function\\s+emergencyWithdraw"
        }
      ]
    }
  }
}