{
  "total_matches": 37,
  "patterns_found": {
    "minting_mechanics": {
      "count": 36,
      "snippets": [
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/ISigsVerifier.sol\\\";\\nimport \\\"../interfaces/IPeggedToken.sol\\\";\\nimport \\\"../interfaces/IPeggedTokenBurnFrom.sol\\\";\\nimport \\\"../libraries/PbPegged.sol\\\";\\nimport \\\"../safeguard/Pauser.sol\\\";\\nimport \\\"../safeguard/VolumeControl.sol\\\";\\nimport \\\"../safeguard/DelayedTransfer.sol\\\";\\n\\n/**\\n * @title The bridge contract to mint and burn pegged tokens\\n * @dev Work together with OriginalTokenVault deployed at remote chains.\\n */\\ncontract PeggedTokenBridgeV2 is Pauser, VolumeControl, DelayedTransfer {\\n    ISigsVerifier public immutable sigsVerifier;\\n\\n    mapping(bytes32 => bool) public records;\\n    mapping(address => uint256) public supplies;\\n\\n    mapping(address => uint256) public minBurn;\\n    mapping(address => uint256) public maxBurn;\\n\\n    event Mint(\\n        bytes32 mintId,\\n        address token,\\n        address account,\\n        uint256 amount,\\n        // ref_chain_id defines the reference chain ID, taking values of:\\n        // 1. The common case: the chain ID on which the remote corresponding deposit or burn happened;\\n        // 2. Refund for wrong burn: this chain ID on which the burn happened\\n        uint64 refChainId,\\n        // ref_id defines a unique reference ID, taking values of:\\n        // 1. The common case of deposit/burn-mint: the deposit or burn ID on the remote chain;\\n        // 2. Refund for wrong burn: the burn ID on this chain\\n        bytes32 refId,\\n        address depositor\\n    );\\n    event Burn(\\n        bytes32 burnId,\\n        address token,\\n        address account,\\n        uint256 amount,\\n        uint64 toChainId,\\n        address toAccount,\\n        uint64 nonce\\n    );\\n    event MinBurnUpdated(address token, uint256 amount);\\n    event MaxBurnUpdated(address token, uint256 amount);\\n    event SupplyUpdated(address token, uint256 supply);\\n\\n    constructor(ISigsVerifier _sigsVerifier) {\\n        sigsVerifier = _sigsVerifier;\\n    }\\n\\n    /**\\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\\n     * @param _request The serialized Mint protobuf.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function mint(\\n        bytes calldata _request,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external whenNotPaused returns (bytes32) {\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"Mint\\\"));\\n        sigsVerifier.verifySigs(abi.encodePacked(domain, _request), _sigs, _signers, _powers);\\n        PbPegged.Mint memory request = PbPegged.decMint(_request);\\n        bytes32 mintId = keccak256(\\n            // len = 20 + 20 + 32 + 20 + 8 + 32 + 20 = 152\\n            abi.encodePacked(\\n                request.account,\\n                request.token,\\n                request.amount,\\n                request.depositor,\\n                request.refChainId,\\n                request.refId,\\n                address(this)\\n            )\\n        );\\n        require(records[mintId] == false, \\\"record exists\\\");\\n        records[mintId] = true;\\n        _updateVolume(request.token, request.amount);\\n        uint256 delayThreshold = delayThresholds[request.token];\\n        if (delayThreshold > 0 && request.amount > delayThreshold) {\\n            _addDelayedTransfer(mintId, request.account, request.token, request.amount);\\n        } else {\\n            IPeggedToken(request.token).mint(request.account, request.amount);\\n        }\\n        supplies[request.token] += request.amount;\\n        emit Mint(\\n            mintId,\\n            request.token,\\n            request.account,\\n            request.amount,\\n            request.refChainId,\\n            request.refId,\\n            request.depositor\\n        );\\n        return mintId;\\n    }\\n\\n    /**\\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\\n     * OriginalTokenVault, or mint at another remote chain\\n     * NOTE: This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\\n     * @param _token The pegged token address.\\n     * @param _amount The amount to burn.\\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\\n     * @param _toAccount The account to receive tokens on the remote chain\\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\\n     */\\n    function burn(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) external whenNotPaused returns (bytes32) {\\n        bytes32 burnId = _burn(_token, _amount, _toChainId, _toAccount, _nonce);\\n        IPeggedToken(_token).burn(msg.sender, _amount);\\n        return burnId;\\n    }\\n\\n    // same with `burn` above, use openzeppelin ERC20Burnable interface\\n    function burnFrom(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) external whenNotPaused returns (bytes32) {\\n        bytes32 burnId = _burn(_token, _amount, _toChainId, _toAccount, _nonce);\\n        IPeggedTokenBurnFrom(_token).burnFrom(msg.sender, _amount);\\n        return burnId;\\n    }\\n\\n    function _burn(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) private returns (bytes32) {\\n        require(_amount > minBurn[_token], \\\"amount too small\\\");\\n        require(maxBurn[_token] == 0 || _amount <= maxBurn[_token], \\\"amount too large\\\");\\n        supplies[_token] -= _amount;\\n        bytes32 burnId = keccak256(\\n            // len = 20 + 20 + 32 + 8 + 20 + 8 + 8 + 20 = 136\\n            abi.encodePacked(\\n                msg.sender,\\n                _token,\\n                _amount,\\n                _toChainId,\\n                _toAccount,\\n                _nonce,\\n                uint64(block.chainid),\\n                address(this)\\n            )\\n        );\\n        require(records[burnId] == false, \\\"record exists\\\");\\n        records[burnId] = true;\\n        emit Burn(burnId, _token, msg.sender, _amount, _toChainId, _toAccount, _nonce);\\n        return burnId;\\n    }\\n\\n    function executeDelayedTransfer(bytes32 id) external whenNotPaused {\\n        delayedTransfer memory transfer = _executeDelayedTransfer(id);\\n        IPeggedToken(transfer.token).mint(transfer.receiver, transfer.amount);\\n    }\\n\\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyGovernor {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            minBurn[_tokens[i]] = _amounts[i];\\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n\\n    function setMaxBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyGovernor {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            maxBurn[_tokens[i]] = _amounts[i];\\n            emit MaxBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n\\n    function setSupply(address _token, uint256 _supply) external onlyOwner {\\n        supplies[_token] = _supply;\\n        emit SupplyUpdated(_token, _supply);\\n    }\\n\\n    function increaseSupply(address _token, uint256 _delta) external onlyOwner {\\n        supplies[_token] += _delta;\\n        emit SupplyUpdated(_token, supplies[_token]);\\n    }\\n\\n    function decreaseSupply(address _token, uint256 _delta) external onlyOwner {\\n        supplies[_token] -= _delta;\\n        emit SupplyUpdated(_token, supplies[_token]);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/ISigsVerifier.sol\\\";\\nimport \\\"../interfaces/IPeggedToken.sol\\\";\\nimport \\\"../libraries/PbPegged.sol\\\";\\nimport \\\"../safeguard/Pauser.sol\\\";\\nimport \\\"../safeguard/VolumeControl.sol\\\";\\nimport \\\"../safeguard/DelayedTransfer.sol\\\";\\n\\n/**\\n * @title The bridge contract to mint and burn pegged tokens\\n * @dev Work together with OriginalTokenVault deployed at remote chains.\\n */\\ncontract PeggedTokenBridge is Pauser, VolumeControl, DelayedTransfer {\\n    ISigsVerifier public immutable sigsVerifier;\\n\\n    mapping(bytes32 => bool) public records;\\n\\n    mapping(address => uint256) public minBurn;\\n    mapping(address => uint256) public maxBurn;\\n\\n    event Mint(\\n        bytes32 mintId,\\n        address token,\\n        address account,\\n        uint256 amount,\\n        // ref_chain_id defines the reference chain ID, taking values of:\\n        // 1. The common case: the chain ID on which the remote corresponding deposit or burn happened;\\n        // 2. Refund for wrong burn: this chain ID on which the burn happened\\n        uint64 refChainId,\\n        // ref_id defines a unique reference ID, taking values of:\\n        // 1. The common case of deposit/burn-mint: the deposit or burn ID on the remote chain;\\n        // 2. Refund for wrong burn: the burn ID on this chain\\n        bytes32 refId,\\n        address depositor\\n    );\\n    event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount);\\n    event MinBurnUpdated(address token, uint256 amount);\\n    event MaxBurnUpdated(address token, uint256 amount);\\n\\n    constructor(ISigsVerifier _sigsVerifier) {\\n        sigsVerifier = _sigsVerifier;\\n    }\\n\\n    /**\\n     * @notice Mint tokens triggered by deposit at a remote chain's OriginalTokenVault.\\n     * @param _request The serialized Mint protobuf.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function mint(\\n        bytes calldata _request,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external whenNotPaused {\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"Mint\\\"));\\n        sigsVerifier.verifySigs(abi.encodePacked(domain, _request), _sigs, _signers, _powers);\\n        PbPegged.Mint memory request = PbPegged.decMint(_request);\\n        bytes32 mintId = keccak256(\\n            // len = 20 + 20 + 32 + 20 + 8 + 32 = 132\\n            abi.encodePacked(\\n                request.account,\\n                request.token,\\n                request.amount,\\n                request.depositor,\\n                request.refChainId,\\n                request.refId\\n            )\\n        );\\n        require(records[mintId] == false, \\\"record exists\\\");\\n        records[mintId] = true;\\n        _updateVolume(request.token, request.amount);\\n        uint256 delayThreshold = delayThresholds[request.token];\\n        if (delayThreshold > 0 && request.amount > delayThreshold) {\\n            _addDelayedTransfer(mintId, request.account, request.token, request.amount);\\n        } else {\\n            IPeggedToken(request.token).mint(request.account, request.amount);\\n        }\\n        emit Mint(\\n            mintId,\\n            request.token,\\n            request.account,\\n            request.amount,\\n            request.refChainId,\\n            request.refId,\\n            request.depositor\\n        );\\n    }\\n\\n    /**\\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\\n     * OriginalTokenVault.\\n     * NOTE: This function DOES NOT SUPPORT fee-on-transfer / rebasing tokens.\\n     * @param _token The pegged token address.\\n     * @param _amount The amount to burn.\\n     * @param _withdrawAccount The account to receive the original tokens withdrawn on the remote chain.\\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\\n     */\\n    function burn(\\n        address _token,\\n        uint256 _amount,\\n        address _withdrawAccount,\\n        uint64 _nonce\\n    ) external whenNotPaused {\\n        require(_amount > minBurn[_token], \\\"amount too small\\\");\\n        require(maxBurn[_token] == 0 || _amount <= maxBurn[_token], \\\"amount too large\\\");\\n        bytes32 burnId = keccak256(\\n            // len = 20 + 20 + 32 + 20 + 8 + 8 = 108\\n            abi.encodePacked(msg.sender, _token, _amount, _withdrawAccount, _nonce, uint64(block.chainid))\\n        );\\n        require(records[burnId] == false, \\\"record exists\\\");\\n        records[burnId] = true;\\n        IPeggedToken(_token).burn(msg.sender, _amount);\\n        emit Burn(burnId, _token, msg.sender, _amount, _withdrawAccount);\\n    }\\n\\n    function executeDelayedTransfer(bytes32 id) external whenNotPaused {\\n        delayedTransfer memory transfer = _executeDelayedTransfer(id);\\n        IPeggedToken(transfer.token).mint(transfer.receiver, transfer.amount);\\n    }\\n\\n    function setMinBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyGovernor {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            minBurn[_tokens[i]] = _amounts[i];\\n            emit MinBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n\\n    function setMaxBurn(address[] calldata _tokens, uint256[] calldata _amounts) external onlyGovernor {\\n        require(_tokens.length == _amounts.length, \\\"length mismatch\\\");\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            maxBurn[_tokens[i]] = _amounts[i];\\n            emit MaxBurnUpdated(_tokens[i], _amounts[i]);\\n        }\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../../safeguard/Ownable.sol\\\";\\n\\n/**\\n * @title Example Multi-Bridge Pegged ERC20 token\\n */\\ncontract MultiBridgeToken is ERC20, Ownable {\\n    struct Supply {\\n        uint256 cap;\\n        uint256 total;\\n    }\\n    mapping(address => Supply) public bridges; // bridge address -> supply\\n\\n    uint8 private immutable _decimals;\\n\\n    event BridgeSupplyCapUpdated(address bridge, uint256 supplyCap);\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @notice Mints tokens to an address. Increases total amount minted by the calling bridge.\\n     * @param _to The address to mint tokens to.\\n     * @param _amount The amount to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external returns (bool) {\\n        Supply storage b = bridges[msg.sender];\\n        require(b.cap > 0, \\\"invalid caller\\\");\\n        b.total += _amount;\\n        require(b.total <= b.cap, \\\"exceeds bridge supply cap\\\");\\n        _mint(_to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens for msg.sender.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(uint256 _amount) external returns (bool) {\\n        _burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address. Decreases total amount minted if called by a bridge.\\n     * Alternative to {burnFrom} for compatibility with some bridge implementations.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address. Decreases total amount minted if called by a bridge.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burnFrom(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @dev Burns tokens from an address, deducting from the caller's allowance.\\n     *      Decreases total amount minted if called by a bridge.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function _burnFrom(address _from, uint256 _amount) internal returns (bool) {\\n        Supply storage b = bridges[msg.sender];\\n        if (b.cap > 0 || b.total > 0) {\\n            // set cap to 1 would effectively disable a deprecated bridge's ability to burn\\n            require(b.total >= _amount, \\\"exceeds bridge minted amount\\\");\\n            unchecked {\\n                b.total -= _amount;\\n            }\\n        }\\n        _spendAllowance(_from, msg.sender, _amount);\\n        _burn(_from, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns the decimals of the token.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @notice Updates the supply cap for a bridge.\\n     * @param _bridge The bridge address.\\n     * @param _cap The new supply cap.\\n     */\\n    function updateBridgeSupplyCap(address _bridge, uint256 _cap) external onlyOwner {\\n        // cap == 0 means revoking bridge role\\n        bridges[_bridge].cap = _cap;\\n        emit BridgeSupplyCapUpdated(_bridge, _cap);\\n    }\\n\\n    /**\\n     * @notice Returns the owner address. Required by BEP20.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Example Pegged ERC20 token\\n */\\ncontract SingleBridgeToken is ERC20, Ownable {\\n    address public bridge;\\n\\n    uint8 private immutable _decimals;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address bridge_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n        bridge = bridge_;\\n    }\\n\\n    /**\\n     * @notice Mints tokens to an address.\\n     * @param _to The address to mint tokens to.\\n     * @param _amount The amount to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(_to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens for msg.sender.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(uint256 _amount) external returns (bool) {\\n        _burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * Alternative to {burnFrom} for compatibility with some bridge implementations.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burnFrom(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @dev Burns tokens from an address, deducting from the caller's allowance.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function _burnFrom(address _from, uint256 _amount) internal returns (bool) {\\n        _spendAllowance(_from, msg.sender, _amount);\\n        _burn(_from, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns the decimals of the token.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @notice Updates the bridge address.\\n     * @param _bridge The bridge address.\\n     */\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    /**\\n     * @notice Returns the owner address. Required by BEP20.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// Use pegged model to support no-slippage liquidity pool\\ncontract WrappedBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // The canonical\\n    address public immutable canonical;\\n\\n    mapping(address => uint256) public liquidity;\\n\\n    event BridgeUpdated(address bridge);\\n    event LiquidityAdded(address provider, uint256 amount);\\n    event LiquidityRemoved(address provider, uint256 amount);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount);\\n        IERC20(canonical).safeTransfer(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        return true;\\n    }\\n\\n    function addLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] += _amount;\\n        IERC20(canonical).safeTransferFrom(msg.sender, address(this), _amount);\\n        emit LiquidityAdded(msg.sender, _amount);\\n    }\\n\\n    function removeLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] -= _amount;\\n        IERC20(canonical).safeTransfer(msg.sender, _amount);\\n        emit LiquidityRemoved(msg.sender, _amount);\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface ISwapCanoToken {\\n    function swapBridgeForCanonical(address, uint256) external returns (uint256);\\n\\n    function swapCanonicalForBridge(address, uint256) external returns (uint256);\\n}\\n\\n/**\\n * @title Per bridge intermediary token that supports swapping with a canonical token.\\n */\\ncontract SwapBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public bridge;\\n    address public immutable canonical; // canonical token that support swap\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so swapBridgeForCanonical can transfer amount\\n        uint256 got = ISwapCanoToken(canonical).swapBridgeForCanonical(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(canonical).safeTransfer(_to, got);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        uint256 got = ISwapCanoToken(canonical).swapCanonicalForBridge(address(this), _amount);\\n        _burn(address(this), got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    // approve canonical token so swapBridgeForCanonical can work. or we approve before call it in mint w/ added gas\\n    function approveCanonical() external onlyOwner {\\n        _approve(address(this), canonical, type(uint256).max);\\n    }\\n\\n    function revokeCanonical() external onlyOwner {\\n        _approve(address(this), canonical, 0);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IERC20MintableBurnable is IERC20 {\\n    function mint(address receiver, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\\n/**\\n * @title Per bridge intermediary token that delegates to a canonical token.\\n * Useful for canonical tokens that don't support the burn / burnFrom function signature required by\\n * PeggedTokenBridge.\\n */\\ncontract IntermediaryBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public bridge;\\n    address public immutable canonical; // canonical token that support swap\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // totalSupply == bridge liquidity\\n        IERC20MintableBurnable(canonical).mint(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        IERC20MintableBurnable(canonical).burn(_amount);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IERC20MintableBurnable is IERC20 {\\n    function mint(address receiver, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\\n/**\\n * @title Per bridge intermediary token that delegates to a canonical token.\\n * Useful for canonical tokens that don't support the burn / burnFrom function signature required by\\n * PeggedTokenBridge.\\n */\\ncontract IntermediaryBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public bridge;\\n    address public immutable canonical; // canonical token that support swap\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // totalSupply == bridge liquidity\\n        IERC20MintableBurnable(canonical).mint(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        IERC20MintableBurnable(canonical).burn(_amount);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IOntologyBridgeTokenWrapper {\\n    function swapBridgeForCanonical(\\n        address bridgeToken,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (uint256);\\n\\n    function swapCanonicalForBridge(\\n        address bridgeToken,\\n        address _to,\\n        uint256 _amount\\n    ) external payable returns (uint256);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the Ontology bridge token wrapper.\\n * NOTE: The bridge wrapper is NOT the canonical token itself.\\n */\\ncontract OntologyBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // Bridge token wrapper for swapping\\n    address public immutable wrapper;\\n    // The canonical token\\n    address public immutable canonical;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address wrapper_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        wrapper = wrapper_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount);\\n        _approve(address(this), wrapper, _amount);\\n        // NOTE: swapBridgeForCanonical automatically transfers canonical token to _to.\\n        IOntologyBridgeTokenWrapper(wrapper).swapBridgeForCanonical(address(this), _to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        IERC20(canonical).safeIncreaseAllowance(address(wrapper), _amount);\\n        // NOTE: swapCanonicalForBridge automatically transfers bridge token to _from.\\n        uint256 got = IOntologyBridgeTokenWrapper(wrapper).swapCanonicalForBridge(address(this), _from, _amount);\\n        _burn(_from, got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IMaiBridgeHub {\\n    // send bridge token, get asset\\n    function swapIn(address, uint256) external;\\n\\n    // send asset, get bridge token back\\n    function swapOut(address, uint256) external;\\n\\n    // asset address\\n    function asset() external view returns (address);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the Mai hub.\\n * NOTE: Mai hub is NOT the canonical token itself. The asset is set in the hub constructor.\\n */\\ncontract MaiBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // Mai hub for swapping\\n    address public immutable maihub;\\n    // The canonical Mai token\\n    address public immutable asset;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address maihub_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        maihub = maihub_;\\n        asset = IMaiBridgeHub(maihub_).asset();\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so swapIn can transfer amount to hub\\n        _approve(address(this), maihub, _amount);\\n        IMaiBridgeHub(maihub).swapIn(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(asset).safeTransfer(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(asset).safeTransferFrom(_from, address(this), _amount);\\n        IERC20(asset).safeIncreaseAllowance(address(maihub), _amount);\\n        IMaiBridgeHub(maihub).swapOut(address(this), _amount);\\n        _burn(address(this), _amount);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(asset).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IFraxCanoToken {\\n    function exchangeOldForCanonical(address, uint256) external returns (uint256);\\n\\n    function exchangeCanonicalForOld(address, uint256) external returns (uint256);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the canonical Frax token.\\n */\\ncontract FraxBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // The canonical Frax token that supports swapping\\n    address public immutable canonical;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so exchangeOldForCanonical can transfer amount\\n        _approve(address(this), canonical, _amount);\\n        uint256 got = IFraxCanoToken(canonical).exchangeOldForCanonical(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(canonical).safeTransfer(_to, got);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        uint256 got = IFraxCanoToken(canonical).exchangeCanonicalForOld(address(this), _amount);\\n        _burn(address(this), got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"../../safeguard/Ownable.sol\\\";\\n\\ncontract OrigNFT is ERC721URIStorage, Ownable {\\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyOwner {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"../../safeguard/Pauser.sol\\\";\\n\\ninterface INFTBridge {\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        address _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        bytes calldata _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function totalFee(\\n        uint64 _dstChid,\\n        address _nft,\\n        uint256 _id\\n    ) external view returns (uint256);\\n}\\n\\n// Multi-Chain Native NFT, same contract on all chains. User interacts with this directly.\\ncontract MCNNFT is ERC721URIStorage, Pauser {\\n    event NFTBridgeUpdated(address);\\n    address public nftBridge;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _nftBridge\\n    ) ERC721(name_, symbol_) {\\n        nftBridge = _nftBridge;\\n    }\\n\\n    modifier onlyNftBridge() {\\n        require(msg.sender == nftBridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    function bridgeMint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyNftBridge {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    // calls nft bridge to get total fee for crossChain msg.Value\\n    function totalFee(uint64 _dstChid, uint256 _id) external view returns (uint256) {\\n        return INFTBridge(nftBridge).totalFee(_dstChid, address(this), _id);\\n    }\\n\\n    // called by user, burn token on this chain and mint same id/uri on dest chain\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        address _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // support chains using bytes for address\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        bytes calldata _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // ===== only Owner\\n    function mint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyOwner {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    function setNFTBridge(address _newBridge) public onlyOwner {\\n        nftBridge = _newBridge;\\n        emit NFTBridgeUpdated(_newBridge);\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "function mint(",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\n/**\\n * @title A mintable {ERC20} token.\\n */\\ncontract MintableERC20 is ERC20Burnable, Ownable {\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Constructor that gives msg.sender an initial supply of tokens.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 initialSupply_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n        _mint(msg.sender, initialSupply_);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     */\\n    function mint(address to, uint256 amount) public onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"",
          "pattern": "function\\s+mint\\s*\\("
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../../safeguard/Ownable.sol\\\";\\n\\n/**\\n * @title Example Multi-Bridge Pegged ERC20 token\\n */\\ncontract MultiBridgeToken is ERC20, Ownable {\\n    struct Supply {\\n        uint256 cap;\\n        uint256 total;\\n    }\\n    mapping(address => Supply) public bridges; // bridge address -> supply\\n\\n    uint8 private immutable _decimals;\\n\\n    event BridgeSupplyCapUpdated(address bridge, uint256 supplyCap);\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @notice Mints tokens to an address. Increases total amount minted by the calling bridge.\\n     * @param _to The address to mint tokens to.\\n     * @param _amount The amount to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external returns (bool) {\\n        Supply storage b = bridges[msg.sender];\\n        require(b.cap > 0, \\\"invalid caller\\\");\\n        b.total += _amount;\\n        require(b.total <= b.cap, \\\"exceeds bridge supply cap\\\");\\n        _mint(_to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens for msg.sender.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(uint256 _amount) external returns (bool) {\\n        _burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address. Decreases total amount minted if called by a bridge.\\n     * Alternative to {burnFrom} for compatibility with some bridge implementations.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address. Decreases total amount minted if called by a bridge.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burnFrom(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @dev Burns tokens from an address, deducting from the caller's allowance.\\n     *      Decreases total amount minted if called by a bridge.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function _burnFrom(address _from, uint256 _amount) internal returns (bool) {\\n        Supply storage b = bridges[msg.sender];\\n        if (b.cap > 0 || b.total > 0) {\\n            // set cap to 1 would effectively disable a deprecated bridge's ability to burn\\n            require(b.total >= _amount, \\\"exceeds bridge minted amount\\\");\\n            unchecked {\\n                b.total -= _amount;\\n            }\\n        }\\n        _spendAllowance(_from, msg.sender, _amount);\\n        _burn(_from, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns the decimals of the token.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @notice Updates the supply cap for a bridge.\\n     * @param _bridge The bridge address.\\n     * @param _cap The new supply cap.\\n     */\\n    function updateBridgeSupplyCap(address _bridge, uint256 _cap) external onlyOwner {\\n        // cap == 0 means revoking bridge role\\n        bridges[_bridge].cap = _cap;\\n        emit BridgeSupplyCapUpdated(_bridge, _cap);\\n    }\\n\\n    /**\\n     * @notice Returns the owner address. Required by BEP20.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_to, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Example Pegged ERC20 token\\n */\\ncontract SingleBridgeToken is ERC20, Ownable {\\n    address public bridge;\\n\\n    uint8 private immutable _decimals;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        address bridge_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n        bridge = bridge_;\\n    }\\n\\n    /**\\n     * @notice Mints tokens to an address.\\n     * @param _to The address to mint tokens to.\\n     * @param _amount The amount to mint.\\n     */\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(_to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens for msg.sender.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(uint256 _amount) external returns (bool) {\\n        _burn(msg.sender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * Alternative to {burnFrom} for compatibility with some bridge implementations.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burn(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @notice Burns tokens from an address.\\n     * See {_burnFrom}.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function burnFrom(address _from, uint256 _amount) external returns (bool) {\\n        return _burnFrom(_from, _amount);\\n    }\\n\\n    /**\\n     * @dev Burns tokens from an address, deducting from the caller's allowance.\\n     * @param _from The address to burn tokens from.\\n     * @param _amount The amount to burn.\\n     */\\n    function _burnFrom(address _from, uint256 _amount) internal returns (bool) {\\n        _spendAllowance(_from, msg.sender, _amount);\\n        _burn(_from, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Returns the decimals of the token.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @notice Updates the bridge address.\\n     * @param _bridge The bridge address.\\n     */\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    /**\\n     * @notice Returns the owner address. Required by BEP20.\\n     */\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// Use pegged model to support no-slippage liquidity pool\\ncontract WrappedBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // The canonical\\n    address public immutable canonical;\\n\\n    mapping(address => uint256) public liquidity;\\n\\n    event BridgeUpdated(address bridge);\\n    event LiquidityAdded(address provider, uint256 amount);\\n    event LiquidityRemoved(address provider, uint256 amount);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount);\\n        IERC20(canonical).safeTransfer(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        return true;\\n    }\\n\\n    function addLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] += _amount;\\n        IERC20(canonical).safeTransferFrom(msg.sender, address(this), _amount);\\n        emit LiquidityAdded(msg.sender, _amount);\\n    }\\n\\n    function removeLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] -= _amount;\\n        IERC20(canonical).safeTransfer(msg.sender, _amount);\\n        emit LiquidityRemoved(msg.sender, _amount);\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, msg.value)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract WETH is ERC20 {\\n    constructor() ERC20(\\\"WETH\\\", \\\"WETH\\\") {}\\n\\n    function deposit() external payable {\\n        _mint(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n        (bool sent, ) = msg.sender.call{value: _amount, gas: 50000}(\\\"\\\");\\n        require(sent, \\\"failed to send\\\");\\n    }\\n\\n    receive() external payable {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface ISwapCanoToken {\\n    function swapBridgeForCanonical(address, uint256) external returns (uint256);\\n\\n    function swapCanonicalForBridge(address, uint256) external returns (uint256);\\n}\\n\\n/**\\n * @title Per bridge intermediary token that supports swapping with a canonical token.\\n */\\ncontract SwapBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public bridge;\\n    address public immutable canonical; // canonical token that support swap\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so swapBridgeForCanonical can transfer amount\\n        uint256 got = ISwapCanoToken(canonical).swapBridgeForCanonical(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(canonical).safeTransfer(_to, got);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        uint256 got = ISwapCanoToken(canonical).swapCanonicalForBridge(address(this), _amount);\\n        _burn(address(this), got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    // approve canonical token so swapBridgeForCanonical can work. or we approve before call it in mint w/ added gas\\n    function approveCanonical() external onlyOwner {\\n        _approve(address(this), canonical, type(uint256).max);\\n    }\\n\\n    function revokeCanonical() external onlyOwner {\\n        _approve(address(this), canonical, 0);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(_from, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Intermediary token that automatically transfers the canonical token when interacting with approved bridges.\\n */\\ncontract IntermediaryOriginalToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    mapping(address => bool) public bridges;\\n    address public immutable canonical; // canonical token\\n\\n    event BridgeUpdated(address bridge, bool enable);\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address[] memory bridges_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        for (uint256 i = 0; i < bridges_.length; i++) {\\n            bridges[bridges_[i]] = true;\\n        }\\n        canonical = canonical_;\\n    }\\n\\n    function transfer(address _to, uint256 _amount) public virtual override returns (bool) {\\n        bool success = super.transfer(_to, _amount);\\n        if (bridges[msg.sender]) {\\n            _burn(_to, _amount);\\n            IERC20(canonical).safeTransfer(_to, _amount);\\n        }\\n        return success;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) public virtual override returns (bool) {\\n        if (bridges[msg.sender]) {\\n            _mint(_from, _amount);\\n            IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        }\\n        return super.transferFrom(_from, _to, _amount);\\n    }\\n\\n    function updateBridge(address _bridge, bool _enable) external onlyOwner {\\n        bridges[_bridge] = _enable;\\n        emit BridgeUpdated(_bridge, _enable);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IERC20MintableBurnable is IERC20 {\\n    function mint(address receiver, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n}\\n\\n/**\\n * @title Per bridge intermediary token that delegates to a canonical token.\\n * Useful for canonical tokens that don't support the burn / burnFrom function signature required by\\n * PeggedTokenBridge.\\n */\\ncontract IntermediaryBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    address public bridge;\\n    address public immutable canonical; // canonical token that support swap\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // totalSupply == bridge liquidity\\n        IERC20MintableBurnable(canonical).mint(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        IERC20MintableBurnable(canonical).burn(_amount);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IOntologyBridgeTokenWrapper {\\n    function swapBridgeForCanonical(\\n        address bridgeToken,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (uint256);\\n\\n    function swapCanonicalForBridge(\\n        address bridgeToken,\\n        address _to,\\n        uint256 _amount\\n    ) external payable returns (uint256);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the Ontology bridge token wrapper.\\n * NOTE: The bridge wrapper is NOT the canonical token itself.\\n */\\ncontract OntologyBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // Bridge token wrapper for swapping\\n    address public immutable wrapper;\\n    // The canonical token\\n    address public immutable canonical;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address wrapper_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        wrapper = wrapper_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount);\\n        _approve(address(this), wrapper, _amount);\\n        // NOTE: swapBridgeForCanonical automatically transfers canonical token to _to.\\n        IOntologyBridgeTokenWrapper(wrapper).swapBridgeForCanonical(address(this), _to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        IERC20(canonical).safeIncreaseAllowance(address(wrapper), _amount);\\n        // NOTE: swapCanonicalForBridge automatically transfers bridge token to _from.\\n        uint256 got = IOntologyBridgeTokenWrapper(wrapper).swapCanonicalForBridge(address(this), _from, _amount);\\n        _burn(_from, got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IMaiBridgeHub {\\n    // send bridge token, get asset\\n    function swapIn(address, uint256) external;\\n\\n    // send asset, get bridge token back\\n    function swapOut(address, uint256) external;\\n\\n    // asset address\\n    function asset() external view returns (address);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the Mai hub.\\n * NOTE: Mai hub is NOT the canonical token itself. The asset is set in the hub constructor.\\n */\\ncontract MaiBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // Mai hub for swapping\\n    address public immutable maihub;\\n    // The canonical Mai token\\n    address public immutable asset;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address maihub_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        maihub = maihub_;\\n        asset = IMaiBridgeHub(maihub_).asset();\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so swapIn can transfer amount to hub\\n        _approve(address(this), maihub, _amount);\\n        IMaiBridgeHub(maihub).swapIn(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(asset).safeTransfer(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(asset).safeTransferFrom(_from, address(this), _amount);\\n        IERC20(asset).safeIncreaseAllowance(address(maihub), _amount);\\n        IMaiBridgeHub(maihub).swapOut(address(this), _amount);\\n        _burn(address(this), _amount);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(asset).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address(this)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IFraxCanoToken {\\n    function exchangeOldForCanonical(address, uint256) external returns (uint256);\\n\\n    function exchangeCanonicalForOld(address, uint256) external returns (uint256);\\n}\\n\\n/**\\n * @title Intermediary bridge token that supports swapping with the canonical Frax token.\\n */\\ncontract FraxBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // The canonical Frax token that supports swapping\\n    address public immutable canonical;\\n\\n    event BridgeUpdated(address bridge);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount); // add amount to myself so exchangeOldForCanonical can transfer amount\\n        _approve(address(this), canonical, _amount);\\n        uint256 got = IFraxCanoToken(canonical).exchangeOldForCanonical(address(this), _amount);\\n        // now this has canonical token, next step is to transfer to user\\n        IERC20(canonical).safeTransfer(_to, got);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        uint256 got = IFraxCanoToken(canonical).exchangeCanonicalForOld(address(this), _amount);\\n        _burn(address(this), got);\\n        return true;\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, tokenid)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(address to, uint256 tokenid)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, id)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\n\\ncontract PegNFT is ERC721URIStorage {\\n    address public immutable nftBridge;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _nftBridge\\n    ) ERC721(name_, symbol_) {\\n        nftBridge = _nftBridge;\\n    }\\n\\n    modifier onlyNftBridge() {\\n        require(msg.sender == nftBridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    function bridgeMint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyNftBridge {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    function burn(uint256 id) external onlyNftBridge {\\n        _burn(id);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, id)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"../../safeguard/Ownable.sol\\\";\\n\\ncontract OrigNFT is ERC721URIStorage, Ownable {\\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyOwner {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, id)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"../../safeguard/Pauser.sol\\\";\\n\\ninterface INFTBridge {\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        address _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        bytes calldata _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function totalFee(\\n        uint64 _dstChid,\\n        address _nft,\\n        uint256 _id\\n    ) external view returns (uint256);\\n}\\n\\n// Multi-Chain Native NFT, same contract on all chains. User interacts with this directly.\\ncontract MCNNFT is ERC721URIStorage, Pauser {\\n    event NFTBridgeUpdated(address);\\n    address public nftBridge;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _nftBridge\\n    ) ERC721(name_, symbol_) {\\n        nftBridge = _nftBridge;\\n    }\\n\\n    modifier onlyNftBridge() {\\n        require(msg.sender == nftBridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    function bridgeMint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyNftBridge {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    // calls nft bridge to get total fee for crossChain msg.Value\\n    function totalFee(uint64 _dstChid, uint256 _id) external view returns (uint256) {\\n        return INFTBridge(nftBridge).totalFee(_dstChid, address(this), _id);\\n    }\\n\\n    // called by user, burn token on this chain and mint same id/uri on dest chain\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        address _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // support chains using bytes for address\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        bytes calldata _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // ===== only Owner\\n    function mint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyOwner {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    function setNFTBridge(address _newBridge) public onlyOwner {\\n        nftBridge = _newBridge;\\n        emit NFTBridgeUpdated(_newBridge);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, id)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\\\";\\nimport \\\"../../safeguard/Pauser.sol\\\";\\n\\ninterface INFTBridge {\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        address _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function sendMsg(\\n        uint64 _dstChid,\\n        address _sender,\\n        bytes calldata _receiver,\\n        uint256 _id,\\n        string calldata _uri\\n    ) external payable;\\n\\n    function totalFee(\\n        uint64 _dstChid,\\n        address _nft,\\n        uint256 _id\\n    ) external view returns (uint256);\\n}\\n\\n// Multi-Chain Native NFT, same contract on all chains. User interacts with this directly.\\ncontract MCNNFT is ERC721URIStorage, Pauser {\\n    event NFTBridgeUpdated(address);\\n    address public nftBridge;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address _nftBridge\\n    ) ERC721(name_, symbol_) {\\n        nftBridge = _nftBridge;\\n    }\\n\\n    modifier onlyNftBridge() {\\n        require(msg.sender == nftBridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    function bridgeMint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyNftBridge {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    // calls nft bridge to get total fee for crossChain msg.Value\\n    function totalFee(uint64 _dstChid, uint256 _id) external view returns (uint256) {\\n        return INFTBridge(nftBridge).totalFee(_dstChid, address(this), _id);\\n    }\\n\\n    // called by user, burn token on this chain and mint same id/uri on dest chain\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        address _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // support chains using bytes for address\\n    function crossChain(\\n        uint64 _dstChid,\\n        uint256 _id,\\n        bytes calldata _receiver\\n    ) external payable whenNotPaused {\\n        require(msg.sender == ownerOf(_id), \\\"not token owner\\\");\\n        string memory _uri = tokenURI(_id);\\n        _burn(_id);\\n        INFTBridge(nftBridge).sendMsg{value: msg.value}(_dstChid, msg.sender, _receiver, _id, _uri);\\n    }\\n\\n    // ===== only Owner\\n    function mint(\\n        address to,\\n        uint256 id,\\n        string memory uri\\n    ) external onlyOwner {\\n        _mint(to, id);\\n        _setTokenURI(id, uri);\\n    }\\n\\n    function setNFTBridge(address _newBridge) public onlyOwner {\\n        nftBridge = _newBridge;\\n        emit NFTBridgeUpdated(_newBridge);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, initialsupply_)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\n/**\\n * @title A mintable {ERC20} token.\\n */\\ncontract MintableERC20 is ERC20Burnable, Ownable {\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Constructor that gives msg.sender an initial supply of tokens.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 initialSupply_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n        _mint(msg.sender, initialSupply_);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     */\\n    function mint(address to, uint256 amount) public onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(to, amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\n\\n/**\\n * @title A mintable {ERC20} token.\\n */\\ncontract MintableERC20 is ERC20Burnable, Ownable {\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Constructor that gives msg.sender an initial supply of tokens.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 initialSupply_\\n    ) ERC20(name_, symbol_) {\\n        _decimals = decimals_;\\n        _mint(msg.sender, initialSupply_);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     */\\n    function mint(address to, uint256 amount) public onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(msg.sender, _amount)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./MultiBridgeToken.sol\\\";\\n\\n/**\\n * @title Canonical token that supports multi-bridge minter and multi-token swap\\n */\\ncontract MintSwapCanonicalToken is MultiBridgeToken {\\n    using SafeERC20 for IERC20;\\n\\n    // bridge token address -> minted amount and cap for each bridge\\n    mapping(address => Supply) public swapSupplies;\\n\\n    event TokenSwapCapUpdated(address token, uint256 cap);\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) MultiBridgeToken(name_, symbol_, decimals_) {}\\n\\n    /**\\n     * @notice msg.sender has bridge token and wants to get canonical token.\\n     * @param _bridgeToken The intermediary token address for a particular bridge.\\n     * @param _amount The amount.\\n     */\\n    function swapBridgeForCanonical(address _bridgeToken, uint256 _amount) external returns (uint256) {\\n        Supply storage supply = swapSupplies[_bridgeToken];\\n        require(supply.cap > 0, \\\"invalid bridge token\\\");\\n        require(supply.total + _amount <= supply.cap, \\\"exceed swap cap\\\");\\n\\n        supply.total += _amount;\\n        _mint(msg.sender, _amount);\\n\\n        // move bridge token from msg.sender to canonical token _amount\\n        IERC20(_bridgeToken).safeTransferFrom(msg.sender, address(this), _amount);\\n        return _amount;\\n    }\\n\\n    /**\\n     * @notice msg.sender has canonical token and wants to get bridge token (eg. for cross chain burn).\\n     * @param _bridgeToken The intermediary token address for a particular bridge.\\n     * @param _amount The amount.\\n     */\\n    function swapCanonicalForBridge(address _bridgeToken, uint256 _amount) external returns (uint256) {\\n        Supply storage supply = swapSupplies[_bridgeToken];\\n        require(supply.cap > 0, \\\"invalid bridge token\\\");\\n\\n        supply.total -= _amount;\\n        _burn(msg.sender, _amount);\\n\\n        IERC20(_bridgeToken).safeTransfer(msg.sender, _amount);\\n        return _amount;\\n    }\\n\\n    /**\\n     * @dev Update existing bridge token swap cap or add a new bridge token with swap cap.\\n     * Setting cap to 0 will disable the bridge token.\\n     * @param _bridgeToken The intermediary token address for a particular bridge.\\n     * @param _swapCap The new swap cap.\\n     */\\n    function setBridgeTokenSwapCap(address _bridgeToken, uint256 _swapCap) external onlyOwner {\\n        swapSupplies[_bridgeToken].cap = _swapCap;\\n        emit TokenSwapCapUpdated(_bridgeToken, _swapCap);\\n    }\\n}\\n\"",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    },
    "liquidity_manipulation": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "function removeliquidity(uint256 _amount) external {\\n        liquidity[msg.sender] -= _amount;\\n        ierc20(canonical).safetransfer(msg.sender, _amount);\\n        emit liquidityremoved(msg.sender, _amount);\\n    }\\n\\n    function updatebridge(address _bridge) external onlyowner",
          "function_context": "\"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n// Use pegged model to support no-slippage liquidity pool\\ncontract WrappedBridgeToken is ERC20, Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // The PeggedTokenBridge\\n    address public bridge;\\n    // The canonical\\n    address public immutable canonical;\\n\\n    mapping(address => uint256) public liquidity;\\n\\n    event BridgeUpdated(address bridge);\\n    event LiquidityAdded(address provider, uint256 amount);\\n    event LiquidityRemoved(address provider, uint256 amount);\\n\\n    modifier onlyBridge() {\\n        require(msg.sender == bridge, \\\"caller is not bridge\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address bridge_,\\n        address canonical_\\n    ) ERC20(name_, symbol_) {\\n        bridge = bridge_;\\n        canonical = canonical_;\\n    }\\n\\n    function mint(address _to, uint256 _amount) external onlyBridge returns (bool) {\\n        _mint(address(this), _amount);\\n        IERC20(canonical).safeTransfer(_to, _amount);\\n        return true;\\n    }\\n\\n    function burn(address _from, uint256 _amount) external onlyBridge returns (bool) {\\n        _burn(address(this), _amount);\\n        IERC20(canonical).safeTransferFrom(_from, address(this), _amount);\\n        return true;\\n    }\\n\\n    function addLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] += _amount;\\n        IERC20(canonical).safeTransferFrom(msg.sender, address(this), _amount);\\n        emit LiquidityAdded(msg.sender, _amount);\\n    }\\n\\n    function removeLiquidity(uint256 _amount) external {\\n        liquidity[msg.sender] -= _amount;\\n        IERC20(canonical).safeTransfer(msg.sender, _amount);\\n        emit LiquidityRemoved(msg.sender, _amount);\\n    }\\n\\n    function updateBridge(address _bridge) external onlyOwner {\\n        bridge = _bridge;\\n        emit BridgeUpdated(bridge);\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20(canonical).decimals();\\n    }\\n\\n    // to make compatible with BEP20\\n    function getOwner() external view returns (address) {\\n        return owner();\\n    }\\n}\\n\"",
          "pattern": "function\\s+removeLiquidity.*onlyOwner"
        }
      ]
    }
  }
}