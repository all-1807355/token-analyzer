{
  "total_matches": 1,
  "patterns_found": {
    "minting_mechanics": {
      "count": 1,
      "snippets": [
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "\"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./governance/IGovernanceToken.sol\\\";\\nimport \\\"./tax/ITaxHandler.sol\\\";\\nimport \\\"./treasury/ITreasuryHandler.sol\\\";\\n\\n/**\\n * @title Floki token contract\\n * @dev The Floki token has modular systems for tax and treasury handler as well as governance capabilities.\\n */\\ncontract FLOKI is IERC20, IGovernanceToken, Ownable {\\n    /// @dev Registry of user token balances.\\n    mapping(address => uint256) private _balances;\\n\\n    /// @dev Registry of addresses users have given allowances to.\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    /// @notice Registry of user delegates for governance.\\n    mapping(address => address) public delegates;\\n\\n    /// @notice Registry of nonces for vote delegation.\\n    mapping(address => uint256) public nonces;\\n\\n    /// @notice Registry of the number of balance checkpoints an account has.\\n    mapping(address => uint32) public numCheckpoints;\\n\\n    /// @notice Registry of balance checkpoints per account.\\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain.\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract.\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n        keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice The contract implementing tax calculations.\\n    ITaxHandler public taxHandler;\\n\\n    /// @notice The contract that performs treasury-related operations.\\n    ITreasuryHandler public treasuryHandler;\\n\\n    /// @notice Emitted when the tax handler contract is changed.\\n    event TaxHandlerChanged(address oldAddress, address newAddress);\\n\\n    /// @notice Emitted when the treasury handler contract is changed.\\n    event TreasuryHandlerChanged(address oldAddress, address newAddress);\\n\\n    /// @dev Name of the token.\\n    string private _name;\\n\\n    /// @dev Symbol of the token.\\n    string private _symbol;\\n\\n    /**\\n     * @param name_ Name of the token.\\n     * @param symbol_ Symbol of the token.\\n     * @param taxHandlerAddress Initial tax handler contract.\\n     * @param treasuryHandlerAddress Initial treasury handler contract.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address taxHandlerAddress,\\n        address treasuryHandlerAddress\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        taxHandler = ITaxHandler(taxHandlerAddress);\\n        treasuryHandler = ITreasuryHandler(treasuryHandlerAddress);\\n\\n        _balances[_msgSender()] = totalSupply();\\n\\n        emit Transfer(address(0), _msgSender(), totalSupply());\\n    }\\n\\n    /**\\n     * @notice Get token name.\\n     * @return Name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @notice Get token symbol.\\n     * @return Symbol of the token.\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @notice Get number of decimals used by the token.\\n     * @return Number of decimals used by the token.\\n     */\\n    function decimals() external pure returns (uint8) {\\n        return 9;\\n    }\\n\\n    /**\\n     * @notice Get the maximum number of tokens.\\n     * @return The maximum number of tokens that will ever be in existence.\\n     */\\n    function totalSupply() public pure override returns (uint256) {\\n        // Ten trillion, i.e., 10,000,000,000,000 tokens.\\n        return 1e13 * 1e9;\\n    }\\n\\n    /**\\n     * @notice Get token balance of given account.\\n     * @param account Address to retrieve balance for.\\n     * @return The number of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @notice Transfer tokens from caller's address to another.\\n     * @param recipient Address to send the caller's tokens to.\\n     * @param amount The number of tokens to transfer to recipient.\\n     * @return True if transfer succeeds, else an error is raised.\\n     */\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the allowance `owner` has given `spender`.\\n     * @param owner The address on behalf of whom tokens can be spent by `spender`.\\n     * @param spender The address authorized to spend tokens on behalf of `owner`.\\n     * @return The allowance `owner` has given `spender`.\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @notice Approve address to spend caller's tokens.\\n     * @dev This method can be exploited by malicious spenders if their allowance is already non-zero. See the following\\n     * document for details: https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit.\\n     * Ensure the spender can be trusted before calling this method if they've already been approved before. Otherwise\\n     * use either the `increaseAllowance`/`decreaseAllowance` functions, or first set their allowance to zero, before\\n     * setting a new allowance.\\n     * @param spender Address to authorize for token expenditure.\\n     * @param amount The number of tokens `spender` is allowed to spend.\\n     * @return True if the approval succeeds, else an error is raised.\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer tokens from one address to another.\\n     * @param sender Address to move tokens from.\\n     * @param recipient Address to send the caller's tokens to.\\n     * @param amount The number of tokens to transfer to recipient.\\n     * @return True if the transfer succeeds, else an error is raised.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance >= amount,\\n            \\\"FLOKI:transferFrom:ALLOWANCE_EXCEEDED: Transfer amount exceeds allowance.\\\"\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Increase spender's allowance.\\n     * @param spender Address of user authorized to spend caller's tokens.\\n     * @param addedValue The number of tokens to add to `spender`'s allowance.\\n     * @return True if the allowance is successfully increased, else an error is raised.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Decrease spender's allowance.\\n     * @param spender Address of user authorized to spend caller's tokens.\\n     * @param subtractedValue The number of tokens to remove from `spender`'s allowance.\\n     * @return True if the allowance is successfully decreased, else an error is raised.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"FLOKI:decreaseAllowance:ALLOWANCE_UNDERFLOW: Subtraction results in sub-zero allowance.\\\"\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes to given address.\\n     * @dev It should be noted that users that want to vote themselves, also need to call this method, albeit with their\\n     * own address.\\n     * @param delegatee Address to delegate votes to.\\n     */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegate votes from signatory to `delegatee`.\\n     * @param delegatee The address to delegate votes to.\\n     * @param nonce The contract state required to match the signature.\\n     * @param expiry The time at which to expire the signature.\\n     * @param v The recovery byte of the signature.\\n     * @param r Half of the ECDSA signature pair.\\n     * @param s Half of the ECDSA signature pair.\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), block.chainid, address(this))\\n        );\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n\\n        require(signatory != address(0), \\\"FLOKI:delegateBySig:INVALID_SIGNATURE: Received signature was invalid.\\\");\\n        require(block.timestamp <= expiry, \\\"FLOKI:delegateBySig:EXPIRED_SIGNATURE: Received signature has expired.\\\");\\n        require(nonce == nonces[signatory]++, \\\"FLOKI:delegateBySig:INVALID_NONCE: Received nonce was invalid.\\\");\\n\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Determine the number of votes for an account as of a block number.\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check.\\n     * @param blockNumber The block number to get the vote balance at.\\n     * @return The number of votes the account had as of the given block.\\n     */\\n    function getVotesAtBlock(address account, uint32 blockNumber) public view returns (uint224) {\\n        require(\\n            blockNumber < block.number,\\n            \\\"FLOKI:getVotesAtBlock:FUTURE_BLOCK: Cannot get votes at a block in the future.\\\"\\n        );\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance.\\n        if (checkpoints[account][nCheckpoints - 1].blockNumber <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance.\\n        if (checkpoints[account][0].blockNumber > blockNumber) {\\n            return 0;\\n        }\\n\\n        // Perform binary search.\\n        uint32 lowerBound = 0;\\n        uint32 upperBound = nCheckpoints - 1;\\n        while (upperBound > lowerBound) {\\n            uint32 center = upperBound - (upperBound - lowerBound) / 2;\\n            Checkpoint memory checkpoint = checkpoints[account][center];\\n\\n            if (checkpoint.blockNumber == blockNumber) {\\n                return checkpoint.votes;\\n            } else if (checkpoint.blockNumber < blockNumber) {\\n                lowerBound = center;\\n            } else {\\n                upperBound = center - 1;\\n            }\\n        }\\n\\n        // No exact block found. Use last known balance before that block number.\\n        return checkpoints[account][lowerBound].votes;\\n    }\\n\\n    /**\\n     * @notice Set new tax handler contract.\\n     * @param taxHandlerAddress Address of new tax handler contract.\\n     */\\n    function setTaxHandler(address taxHandlerAddress) external onlyOwner {\\n        address oldTaxHandlerAddress = address(taxHandler);\\n        taxHandler = ITaxHandler(taxHandlerAddress);\\n\\n        emit TaxHandlerChanged(oldTaxHandlerAddress, taxHandlerAddress);\\n    }\\n\\n    /**\\n     * @notice Set new treasury handler contract.\\n     * @param treasuryHandlerAddress Address of new treasury handler contract.\\n     */\\n    function setTreasuryHandler(address treasuryHandlerAddress) external onlyOwner {\\n        address oldTreasuryHandlerAddress = address(treasuryHandler);\\n        treasuryHandler = ITreasuryHandler(treasuryHandlerAddress);\\n\\n        emit TreasuryHandlerChanged(oldTreasuryHandlerAddress, treasuryHandlerAddress);\\n    }\\n\\n    /**\\n     * @notice Delegate votes from one address to another.\\n     * @param delegator Address from which to delegate votes for.\\n     * @param delegatee Address to delegate votes to.\\n     */\\n    function _delegate(address delegator, address delegatee) private {\\n        address currentDelegate = delegates[delegator];\\n        uint256 delegatorBalance = _balances[delegator];\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, uint224(delegatorBalance));\\n    }\\n\\n    /**\\n     * @notice Move delegates from one address to another.\\n     * @param from Representative to move delegates from.\\n     * @param to Representative to move delegates to.\\n     * @param amount Number of delegates to move.\\n     */\\n    function _moveDelegates(\\n        address from,\\n        address to,\\n        uint224 amount\\n    ) private {\\n        // No need to update checkpoints if the votes don't actually move between different delegates. This can be the\\n        // case where tokens are transferred between two parties that have delegated their votes to the same address.\\n        if (from == to) {\\n            return;\\n        }\\n\\n        // Some users preemptively delegate their votes (i.e. before they have any tokens). No need to perform an update\\n        // to the checkpoints in that case.\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (from != address(0)) {\\n            uint32 fromRepNum = numCheckpoints[from];\\n            uint224 fromRepOld = fromRepNum > 0 ? checkpoints[from][fromRepNum - 1].votes : 0;\\n            uint224 fromRepNew = fromRepOld - amount;\\n\\n            _writeCheckpoint(from, fromRepNum, fromRepOld, fromRepNew);\\n        }\\n\\n        if (to != address(0)) {\\n            uint32 toRepNum = numCheckpoints[to];\\n            uint224 toRepOld = toRepNum > 0 ? checkpoints[to][toRepNum - 1].votes : 0;\\n            uint224 toRepNew = toRepOld + amount;\\n\\n            _writeCheckpoint(to, toRepNum, toRepOld, toRepNew);\\n        }\\n    }\\n\\n    /**\\n     * @notice Write balance checkpoint to chain.\\n     * @param delegatee The address to write the checkpoint for.\\n     * @param nCheckpoints The number of checkpoints `delegatee` already has.\\n     * @param oldVotes Number of votes prior to this checkpoint.\\n     * @param newVotes Number of votes `delegatee` now has.\\n     */\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint224 oldVotes,\\n        uint224 newVotes\\n    ) private {\\n        uint32 blockNumber = uint32(block.number);\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].blockNumber == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    /**\\n     * @notice Approve spender on behalf of owner.\\n     * @param owner Address on behalf of whom tokens can be spent by `spender`.\\n     * @param spender Address to authorize for token expenditure.\\n     * @param amount The number of tokens `spender` is allowed to spend.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"FLOKI:_approve:OWNER_ZERO: Cannot approve for the zero address.\\\");\\n        require(spender != address(0), \\\"FLOKI:_approve:SPENDER_ZERO: Cannot approve to the zero address.\\\");\\n\\n        _allowances[owner][spender] = amount;\\n\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from account `from` to account `to`.\\n     * @param from Address the tokens are moved out of.\\n     * @param to Address the tokens are moved to.\\n     * @param amount The number of tokens to transfer.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        require(from != address(0), \\\"FLOKI:_transfer:FROM_ZERO: Cannot transfer from the zero address.\\\");\\n        require(to != address(0), \\\"FLOKI:_transfer:TO_ZERO: Cannot transfer to the zero address.\\\");\\n        require(amount > 0, \\\"FLOKI:_transfer:ZERO_AMOUNT: Transfer amount must be greater than zero.\\\");\\n        require(amount <= _balances[from], \\\"FLOKI:_transfer:INSUFFICIENT_BALANCE: Transfer amount exceeds balance.\\\");\\n\\n        treasuryHandler.beforeTransferHandler(from, to, amount);\\n\\n        uint256 tax = taxHandler.getTax(from, to, amount);\\n        uint256 taxedAmount = amount - tax;\\n\\n        _balances[from] -= amount;\\n        _balances[to] += taxedAmount;\\n        _moveDelegates(delegates[from], delegates[to], uint224(taxedAmount));\\n\\n        if (tax > 0) {\\n            _balances[address(treasuryHandler)] += tax;\\n\\n            _moveDelegates(delegates[from], delegates[address(treasuryHandler)], uint224(tax));\\n\\n            emit Transfer(from, address(treasuryHandler), tax);\\n        }\\n\\n        treasuryHandler.afterTransferHandler(from, to, amount);\\n\\n        emit Transfer(from, to, taxedAmount);\\n    }\\n}\\n\"",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}