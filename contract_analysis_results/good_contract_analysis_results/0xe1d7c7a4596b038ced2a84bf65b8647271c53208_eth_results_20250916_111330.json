{
  "total_matches": 6,
  "patterns_found": {
    "minting_mechanics": {
      "count": 6,
      "snippets": [
        {
          "matched_code": "_mint(address account, uint256 amount)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(w1, amount1)",
          "function_context": "function mineTo(address rewardTo) public {\n    if (miningPaused) {\n      return;\n    }\n    // only mine once per block, maximum.\n    // don't revert, in case called via some downstream contract\n    if (lastBlockMined >= block.number) {\n      emit AlreadyMined(block.number);\n      return;\n    }\n\n    // use getAmounts() to calculate splits\n    (uint256 amt2mine, uint256 amount1, uint256 amount2, uint256 amount3, uint256 amount4, uint256 amt2burn) = getAmounts();\n    if (amt2mine == 0) {\n      return;\n    }\n    lastBlockMined = block.number;\n\n    // transfer downstream if amount is not zero\n    if (amount1 != 0) { _mint(w1, amount1); }\n    if (amount2 != 0) { _mint(w2, amount2); }\n    if (amount3 != 0) { _mint(w3, amount3); }\n    if (amount4 != 0) { _mint(w4, amount4); }\n\n    // There are tokens to burn, so add them to amt2burn\n    // No point in burning then minting, so simply track these in global amountBurned variable\n    if (amt2burn != 0) {\n      amountBurned += amt2burn; \n    }\n    emit Mined(block.number, amt2mine, amt2burn, totalSupply(), amountBurned);\n\n    // Call auxiliary contract for reward, passing rewardTo address\n    AuxContract aux = auxContract;\n    if (address(aux) != address(0)) {\n        try aux.cron(rewardTo) {} catch {}\n    }\n  }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(w2, amount2)",
          "function_context": "function mineTo(address rewardTo) public {\n    if (miningPaused) {\n      return;\n    }\n    // only mine once per block, maximum.\n    // don't revert, in case called via some downstream contract\n    if (lastBlockMined >= block.number) {\n      emit AlreadyMined(block.number);\n      return;\n    }\n\n    // use getAmounts() to calculate splits\n    (uint256 amt2mine, uint256 amount1, uint256 amount2, uint256 amount3, uint256 amount4, uint256 amt2burn) = getAmounts();\n    if (amt2mine == 0) {\n      return;\n    }\n    lastBlockMined = block.number;\n\n    // transfer downstream if amount is not zero\n    if (amount1 != 0) { _mint(w1, amount1); }\n    if (amount2 != 0) { _mint(w2, amount2); }\n    if (amount3 != 0) { _mint(w3, amount3); }\n    if (amount4 != 0) { _mint(w4, amount4); }\n\n    // There are tokens to burn, so add them to amt2burn\n    // No point in burning then minting, so simply track these in global amountBurned variable\n    if (amt2burn != 0) {\n      amountBurned += amt2burn; \n    }\n    emit Mined(block.number, amt2mine, amt2burn, totalSupply(), amountBurned);\n\n    // Call auxiliary contract for reward, passing rewardTo address\n    AuxContract aux = auxContract;\n    if (address(aux) != address(0)) {\n        try aux.cron(rewardTo) {} catch {}\n    }\n  }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(w3, amount3)",
          "function_context": "function mineTo(address rewardTo) public {\n    if (miningPaused) {\n      return;\n    }\n    // only mine once per block, maximum.\n    // don't revert, in case called via some downstream contract\n    if (lastBlockMined >= block.number) {\n      emit AlreadyMined(block.number);\n      return;\n    }\n\n    // use getAmounts() to calculate splits\n    (uint256 amt2mine, uint256 amount1, uint256 amount2, uint256 amount3, uint256 amount4, uint256 amt2burn) = getAmounts();\n    if (amt2mine == 0) {\n      return;\n    }\n    lastBlockMined = block.number;\n\n    // transfer downstream if amount is not zero\n    if (amount1 != 0) { _mint(w1, amount1); }\n    if (amount2 != 0) { _mint(w2, amount2); }\n    if (amount3 != 0) { _mint(w3, amount3); }\n    if (amount4 != 0) { _mint(w4, amount4); }\n\n    // There are tokens to burn, so add them to amt2burn\n    // No point in burning then minting, so simply track these in global amountBurned variable\n    if (amt2burn != 0) {\n      amountBurned += amt2burn; \n    }\n    emit Mined(block.number, amt2mine, amt2burn, totalSupply(), amountBurned);\n\n    // Call auxiliary contract for reward, passing rewardTo address\n    AuxContract aux = auxContract;\n    if (address(aux) != address(0)) {\n        try aux.cron(rewardTo) {} catch {}\n    }\n  }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "_mint(w4, amount4)",
          "function_context": "function mineTo(address rewardTo) public {\n    if (miningPaused) {\n      return;\n    }\n    // only mine once per block, maximum.\n    // don't revert, in case called via some downstream contract\n    if (lastBlockMined >= block.number) {\n      emit AlreadyMined(block.number);\n      return;\n    }\n\n    // use getAmounts() to calculate splits\n    (uint256 amt2mine, uint256 amount1, uint256 amount2, uint256 amount3, uint256 amount4, uint256 amt2burn) = getAmounts();\n    if (amt2mine == 0) {\n      return;\n    }\n    lastBlockMined = block.number;\n\n    // transfer downstream if amount is not zero\n    if (amount1 != 0) { _mint(w1, amount1); }\n    if (amount2 != 0) { _mint(w2, amount2); }\n    if (amount3 != 0) { _mint(w3, amount3); }\n    if (amount4 != 0) { _mint(w4, amount4); }\n\n    // There are tokens to burn, so add them to amt2burn\n    // No point in burning then minting, so simply track these in global amountBurned variable\n    if (amt2burn != 0) {\n      amountBurned += amt2burn; \n    }\n    emit Mined(block.number, amt2mine, amt2burn, totalSupply(), amountBurned);\n\n    // Call auxiliary contract for reward, passing rewardTo address\n    AuxContract aux = auxContract;\n    if (address(aux) != address(0)) {\n        try aux.cron(rewardTo) {} catch {}\n    }\n  }",
          "pattern": "_mint\\s*\\(\\s*[^)]*\\)"
        },
        {
          "matched_code": "emit transfer(address(0)",
          "function_context": "function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }",
          "pattern": "emit\\s+Transfer\\s*\\(\\s*address\\(0\\)"
        }
      ]
    }
  }
}